
Base Template.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         0000ceb8  00080000  00080000  00008000  2**3
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .ARM.exidx    00000008  0008ceb8  0008ceb8  00014eb8  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  2 .relocate     00000ce0  20070000  0008cec0  00018000  2**3
                  CONTENTS, ALLOC, LOAD, CODE
  3 .bss          00004f80  20070ce0  0008dba0  00018ce0  2**3
                  ALLOC
  4 .stack        00002000  20075c60  00092b20  00018ce0  2**0
                  ALLOC
  5 .ARM.attributes 00000029  00000000  00000000  00018ce0  2**0
                  CONTENTS, READONLY
  6 .comment      0000005b  00000000  00000000  00018d09  2**0
                  CONTENTS, READONLY
  7 .debug_info   0001ab8b  00000000  00000000  00018d64  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_abbrev 00004de0  00000000  00000000  000338ef  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_loc    0000d514  00000000  00000000  000386cf  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_aranges 000013a0  00000000  00000000  00045be3  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_ranges 000012a8  00000000  00000000  00046f83  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_macro  0001ef65  00000000  00000000  0004822b  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_line   0001c520  00000000  00000000  00067190  2**0
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_str    00076dc0  00000000  00000000  000836b0  2**0
                  CONTENTS, READONLY, DEBUGGING
 15 .debug_frame  0000373c  00000000  00000000  000fa470  2**2
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00080000 <_sfixed>:
   80000:	20077c60 	.word	0x20077c60
   80004:	0008373d 	.word	0x0008373d
   80008:	00083739 	.word	0x00083739
   8000c:	00083739 	.word	0x00083739
   80010:	00083739 	.word	0x00083739
   80014:	00083739 	.word	0x00083739
   80018:	00083739 	.word	0x00083739
	...
   8002c:	000840f9 	.word	0x000840f9
   80030:	00083739 	.word	0x00083739
   80034:	00000000 	.word	0x00000000
   80038:	00084175 	.word	0x00084175
   8003c:	000841b1 	.word	0x000841b1
   80040:	00083739 	.word	0x00083739
   80044:	00083739 	.word	0x00083739
   80048:	00083739 	.word	0x00083739
   8004c:	00083739 	.word	0x00083739
   80050:	00083739 	.word	0x00083739
   80054:	00083739 	.word	0x00083739
   80058:	00083739 	.word	0x00083739
   8005c:	00083739 	.word	0x00083739
   80060:	00080775 	.word	0x00080775
   80064:	00083739 	.word	0x00083739
   80068:	00000000 	.word	0x00000000
   8006c:	000820b9 	.word	0x000820b9
   80070:	000820cd 	.word	0x000820cd
   80074:	000820e1 	.word	0x000820e1
   80078:	000820f5 	.word	0x000820f5
	...
   80084:	00080e41 	.word	0x00080e41
   80088:	00080e51 	.word	0x00080e51
   8008c:	00080e61 	.word	0x00080e61
   80090:	00080e71 	.word	0x00080e71
   80094:	00083739 	.word	0x00083739
   80098:	000806b9 	.word	0x000806b9
   8009c:	000806c9 	.word	0x000806c9
   800a0:	00083739 	.word	0x00083739
   800a4:	00000000 	.word	0x00000000
   800a8:	00083739 	.word	0x00083739
   800ac:	00083739 	.word	0x00083739
   800b0:	00083739 	.word	0x00083739
   800b4:	00083739 	.word	0x00083739
   800b8:	00083739 	.word	0x00083739
   800bc:	00083739 	.word	0x00083739
   800c0:	00083739 	.word	0x00083739
   800c4:	00083739 	.word	0x00083739
   800c8:	00083739 	.word	0x00083739
   800cc:	00083739 	.word	0x00083739
   800d0:	00083739 	.word	0x00083739
   800d4:	00083739 	.word	0x00083739
   800d8:	00083739 	.word	0x00083739
   800dc:	00083739 	.word	0x00083739
   800e0:	00082941 	.word	0x00082941
   800e4:	00083739 	.word	0x00083739
   800e8:	00083739 	.word	0x00083739
   800ec:	00083739 	.word	0x00083739
   800f0:	00083739 	.word	0x00083739

000800f4 <__do_global_dtors_aux>:
   800f4:	b510      	push	{r4, lr}
   800f6:	4c05      	ldr	r4, [pc, #20]	; (8010c <__do_global_dtors_aux+0x18>)
   800f8:	7823      	ldrb	r3, [r4, #0]
   800fa:	b933      	cbnz	r3, 8010a <__do_global_dtors_aux+0x16>
   800fc:	4b04      	ldr	r3, [pc, #16]	; (80110 <__do_global_dtors_aux+0x1c>)
   800fe:	b113      	cbz	r3, 80106 <__do_global_dtors_aux+0x12>
   80100:	4804      	ldr	r0, [pc, #16]	; (80114 <__do_global_dtors_aux+0x20>)
   80102:	f3af 8000 	nop.w
   80106:	2301      	movs	r3, #1
   80108:	7023      	strb	r3, [r4, #0]
   8010a:	bd10      	pop	{r4, pc}
   8010c:	20070ce0 	.word	0x20070ce0
   80110:	00000000 	.word	0x00000000
   80114:	0008cec0 	.word	0x0008cec0

00080118 <frame_dummy>:
   80118:	b508      	push	{r3, lr}
   8011a:	4b06      	ldr	r3, [pc, #24]	; (80134 <frame_dummy+0x1c>)
   8011c:	b11b      	cbz	r3, 80126 <frame_dummy+0xe>
   8011e:	4806      	ldr	r0, [pc, #24]	; (80138 <frame_dummy+0x20>)
   80120:	4906      	ldr	r1, [pc, #24]	; (8013c <frame_dummy+0x24>)
   80122:	f3af 8000 	nop.w
   80126:	4806      	ldr	r0, [pc, #24]	; (80140 <frame_dummy+0x28>)
   80128:	6803      	ldr	r3, [r0, #0]
   8012a:	b113      	cbz	r3, 80132 <frame_dummy+0x1a>
   8012c:	4b05      	ldr	r3, [pc, #20]	; (80144 <frame_dummy+0x2c>)
   8012e:	b103      	cbz	r3, 80132 <frame_dummy+0x1a>
   80130:	4798      	blx	r3
   80132:	bd08      	pop	{r3, pc}
   80134:	00000000 	.word	0x00000000
   80138:	0008cec0 	.word	0x0008cec0
   8013c:	20070ce4 	.word	0x20070ce4
   80140:	0008cec0 	.word	0x0008cec0
   80144:	00000000 	.word	0x00000000

00080148 <sysclk_enable_usb>:
 *
 * \param pll_id Source of the USB clock.
 * \param div Actual clock divisor. Must be superior to 0.
 */
void sysclk_enable_usb(void)
{
   80148:	b508      	push	{r3, lr}
	}
#endif

	if (CONFIG_USBCLK_SOURCE == USBCLK_SRC_UPLL) {

		pmc_enable_upll_clock();
   8014a:	4b04      	ldr	r3, [pc, #16]	; (8015c <sysclk_enable_usb+0x14>)
   8014c:	4798      	blx	r3
		pmc_switch_udpck_to_upllck(CONFIG_USBCLK_DIV - 1);
   8014e:	2000      	movs	r0, #0
   80150:	4b03      	ldr	r3, [pc, #12]	; (80160 <sysclk_enable_usb+0x18>)
   80152:	4798      	blx	r3
		pmc_enable_udpck();
   80154:	4b03      	ldr	r3, [pc, #12]	; (80164 <sysclk_enable_usb+0x1c>)
   80156:	4798      	blx	r3
   80158:	bd08      	pop	{r3, pc}
   8015a:	bf00      	nop
   8015c:	000821f1 	.word	0x000821f1
   80160:	00082261 	.word	0x00082261
   80164:	00082275 	.word	0x00082275

00080168 <sysclk_init>:
	pmc_disable_udpck();
}
#endif // CONFIG_USBCLK_SOURCE

void sysclk_init(void)
{
   80168:	b510      	push	{r4, lr}
	struct pll_config pllcfg;

	/* Set flash wait state to max in case the below clock switching. */
	system_init_flash(CHIP_FREQ_CPU_MAX);
   8016a:	480e      	ldr	r0, [pc, #56]	; (801a4 <sysclk_init+0x3c>)
   8016c:	4b0e      	ldr	r3, [pc, #56]	; (801a8 <sysclk_init+0x40>)
   8016e:	4798      	blx	r3
		pmc_switch_mainck_to_fastrc(CKGR_MOR_MOSCRCF_12_MHz);
		break;


	case OSC_MAINCK_XTAL:
		pmc_switch_mainck_to_xtal(PMC_OSC_XTAL,
   80170:	2000      	movs	r0, #0
   80172:	213e      	movs	r1, #62	; 0x3e
   80174:	4b0d      	ldr	r3, [pc, #52]	; (801ac <sysclk_init+0x44>)
   80176:	4798      	blx	r3
	case OSC_MAINCK_4M_RC:
	case OSC_MAINCK_8M_RC:
	case OSC_MAINCK_12M_RC:
	case OSC_MAINCK_XTAL:
	case OSC_MAINCK_BYPASS:
		return pmc_osc_is_ready_mainck();
   80178:	4c0d      	ldr	r4, [pc, #52]	; (801b0 <sysclk_init+0x48>)
   8017a:	47a0      	blx	r4
 *
 * \param id A number identifying the oscillator to wait for.
 */
static inline void osc_wait_ready(uint8_t id)
{
	while (!osc_is_ready(id)) {
   8017c:	2800      	cmp	r0, #0
   8017e:	d0fc      	beq.n	8017a <sysclk_init+0x12>
static inline void pll_enable(const struct pll_config *p_cfg, uint32_t ul_pll_id)
{
	Assert(ul_pll_id < NR_PLLS);

	if (ul_pll_id == PLLA_ID) {
		pmc_disable_pllack(); // Always stop PLL first!
   80180:	4b0c      	ldr	r3, [pc, #48]	; (801b4 <sysclk_init+0x4c>)
   80182:	4798      	blx	r3
		PMC->CKGR_PLLAR = CKGR_PLLAR_ONE | p_cfg->ctrl;
   80184:	4a0c      	ldr	r2, [pc, #48]	; (801b8 <sysclk_init+0x50>)
   80186:	4b0d      	ldr	r3, [pc, #52]	; (801bc <sysclk_init+0x54>)
   80188:	629a      	str	r2, [r3, #40]	; 0x28
static inline uint32_t pll_is_locked(uint32_t ul_pll_id)
{
	Assert(ul_pll_id < NR_PLLS);

	if (ul_pll_id == PLLA_ID) {
		return pmc_is_locked_pllack();
   8018a:	4c0d      	ldr	r4, [pc, #52]	; (801c0 <sysclk_init+0x58>)
   8018c:	47a0      	blx	r4
 */
static inline int pll_wait_for_lock(unsigned int pll_id)
{
	Assert(pll_id < NR_PLLS);

	while (!pll_is_locked(pll_id)) {
   8018e:	2800      	cmp	r0, #0
   80190:	d0fc      	beq.n	8018c <sysclk_init+0x24>
	else if (CONFIG_SYSCLK_SOURCE == SYSCLK_SRC_PLLACK) {
		pll_enable_source(CONFIG_PLL0_SOURCE);
		pll_config_defaults(&pllcfg, 0);
		pll_enable(&pllcfg, 0);
		pll_wait_for_lock(0);
		pmc_switch_mck_to_pllack(CONFIG_SYSCLK_PRES);
   80192:	2010      	movs	r0, #16
   80194:	4b0b      	ldr	r3, [pc, #44]	; (801c4 <sysclk_init+0x5c>)
   80196:	4798      	blx	r3
		pll_wait_for_lock(1);
		pmc_switch_mck_to_upllck(CONFIG_SYSCLK_PRES);
	}

	/* Update the SystemFrequency variable */
	SystemCoreClockUpdate();
   80198:	4b0b      	ldr	r3, [pc, #44]	; (801c8 <sysclk_init+0x60>)
   8019a:	4798      	blx	r3

	/* Set a flash wait state depending on the new cpu frequency */
	system_init_flash(sysclk_get_cpu_hz());
   8019c:	4801      	ldr	r0, [pc, #4]	; (801a4 <sysclk_init+0x3c>)
   8019e:	4b02      	ldr	r3, [pc, #8]	; (801a8 <sysclk_init+0x40>)
   801a0:	4798      	blx	r3
   801a2:	bd10      	pop	{r4, pc}
   801a4:	0501bd00 	.word	0x0501bd00
   801a8:	200700a5 	.word	0x200700a5
   801ac:	0008216d 	.word	0x0008216d
   801b0:	000821c1 	.word	0x000821c1
   801b4:	000821d1 	.word	0x000821d1
   801b8:	200d3f01 	.word	0x200d3f01
   801bc:	400e0600 	.word	0x400e0600
   801c0:	000821e1 	.word	0x000821e1
   801c4:	00082109 	.word	0x00082109
   801c8:	000837ed 	.word	0x000837ed

000801cc <get_pdc_peripheral_details>:
 * peripheral that has the start address specified by peripheral_to_find.
 */
portBASE_TYPE get_pdc_peripheral_details(
		const freertos_pdc_peripheral_parameters_t peripheral_array[],
		size_t array_size, void *peripheral_to_find)
{
   801cc:	b430      	push	{r4, r5}
	size_t x;

	for (x = 0; x < array_size; x++) {
   801ce:	460d      	mov	r5, r1
   801d0:	b169      	cbz	r1, 801ee <get_pdc_peripheral_details+0x22>
		if (peripheral_array[x].peripheral_base_address ==
   801d2:	6803      	ldr	r3, [r0, #0]
   801d4:	4293      	cmp	r3, r2
   801d6:	d00c      	beq.n	801f2 <get_pdc_peripheral_details+0x26>
   801d8:	4603      	mov	r3, r0
		const freertos_pdc_peripheral_parameters_t peripheral_array[],
		size_t array_size, void *peripheral_to_find)
{
	size_t x;

	for (x = 0; x < array_size; x++) {
   801da:	2000      	movs	r0, #0
   801dc:	e003      	b.n	801e6 <get_pdc_peripheral_details+0x1a>
		if (peripheral_array[x].peripheral_base_address ==
   801de:	f853 4f10 	ldr.w	r4, [r3, #16]!
   801e2:	4294      	cmp	r4, r2
   801e4:	d006      	beq.n	801f4 <get_pdc_peripheral_details+0x28>
		const freertos_pdc_peripheral_parameters_t peripheral_array[],
		size_t array_size, void *peripheral_to_find)
{
	size_t x;

	for (x = 0; x < array_size; x++) {
   801e6:	3001      	adds	r0, #1
   801e8:	42a8      	cmp	r0, r5
   801ea:	d1f8      	bne.n	801de <get_pdc_peripheral_details+0x12>
   801ec:	e002      	b.n	801f4 <get_pdc_peripheral_details+0x28>
   801ee:	2000      	movs	r0, #0
   801f0:	e000      	b.n	801f4 <get_pdc_peripheral_details+0x28>
   801f2:	2000      	movs	r0, #0
			break;
		}
	}

	return x;
}
   801f4:	bc30      	pop	{r4, r5}
   801f6:	4770      	bx	lr

000801f8 <check_requested_operating_mode>:
		portBASE_TYPE num_valid_operating_modes)
{
	bool return_value = false;
	portBASE_TYPE index_position;

	for (index_position = 0; index_position < num_valid_operating_modes;
   801f8:	2a00      	cmp	r2, #0
   801fa:	dd0e      	ble.n	8021a <check_requested_operating_mode+0x22>
			index_position++) {
		if (requested_operation_mode ==
   801fc:	780b      	ldrb	r3, [r1, #0]
   801fe:	4283      	cmp	r3, r0
   80200:	d00d      	beq.n	8021e <check_requested_operating_mode+0x26>
   80202:	460b      	mov	r3, r1
   80204:	3901      	subs	r1, #1
   80206:	4411      	add	r1, r2
   80208:	e003      	b.n	80212 <check_requested_operating_mode+0x1a>
   8020a:	f813 2f01 	ldrb.w	r2, [r3, #1]!
   8020e:	4282      	cmp	r2, r0
   80210:	d007      	beq.n	80222 <check_requested_operating_mode+0x2a>
		portBASE_TYPE num_valid_operating_modes)
{
	bool return_value = false;
	portBASE_TYPE index_position;

	for (index_position = 0; index_position < num_valid_operating_modes;
   80212:	428b      	cmp	r3, r1
   80214:	d1f9      	bne.n	8020a <check_requested_operating_mode+0x12>
bool check_requested_operating_mode(
		const enum peripheral_operation_mode requested_operation_mode,
		const enum peripheral_operation_mode valid_operating_modes[],
		portBASE_TYPE num_valid_operating_modes)
{
	bool return_value = false;
   80216:	2000      	movs	r0, #0
   80218:	4770      	bx	lr
   8021a:	2000      	movs	r0, #0
   8021c:	4770      	bx	lr

	for (index_position = 0; index_position < num_valid_operating_modes;
			index_position++) {
		if (requested_operation_mode ==
				valid_operating_modes[index_position]) {
			return_value = true;
   8021e:	2001      	movs	r0, #1
   80220:	4770      	bx	lr
   80222:	2001      	movs	r0, #1
			break;
		}
	}

	return return_value;
}
   80224:	4770      	bx	lr
   80226:	bf00      	nop

00080228 <create_peripheral_control_semaphores>:
 * with the bits set in the options_flags value.
 */
void create_peripheral_control_semaphores(const uint8_t options_flags,
		freertos_dma_event_control_t *tx_dma_control,
		freertos_dma_event_control_t *rx_dma_control)
{
   80228:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   8022a:	4604      	mov	r4, r0
   8022c:	460e      	mov	r6, r1
   8022e:	4615      	mov	r5, r2
	/* If the tx driver is to be thread aware then create an access control
	mutex.  An Rx access mutex is not created in this function as half duplex
	peripherals need only use a single access mutex, and the Tx mutex is used
	for the purpose.  Full duplex peripherals have extra configuration steps
	that are performed separately. */
	if ((options_flags & USE_TX_ACCESS_MUTEX) != 0) {
   80230:	f010 0f01 	tst.w	r0, #1
   80234:	d008      	beq.n	80248 <create_peripheral_control_semaphores+0x20>
		tx_dma_control->peripheral_access_mutex = xSemaphoreCreateMutex();
   80236:	2001      	movs	r0, #1
   80238:	4b22      	ldr	r3, [pc, #136]	; (802c4 <create_peripheral_control_semaphores+0x9c>)
   8023a:	4798      	blx	r3
   8023c:	6070      	str	r0, [r6, #4]
		configASSERT(tx_dma_control->peripheral_access_mutex);
   8023e:	b918      	cbnz	r0, 80248 <create_peripheral_control_semaphores+0x20>
   80240:	4821      	ldr	r0, [pc, #132]	; (802c8 <create_peripheral_control_semaphores+0xa0>)
   80242:	217a      	movs	r1, #122	; 0x7a
   80244:	4b21      	ldr	r3, [pc, #132]	; (802cc <create_peripheral_control_semaphores+0xa4>)
   80246:	4798      	blx	r3
	}

	/* If the transmit function is only going to return once the transmit is
	complete then create an internal notification semaphore. */
	if ((options_flags & WAIT_TX_COMPLETE) != 0) {
   80248:	f014 0f04 	tst.w	r4, #4
   8024c:	d018      	beq.n	80280 <create_peripheral_control_semaphores+0x58>
		vSemaphoreCreateBinary(
   8024e:	2001      	movs	r0, #1
   80250:	2100      	movs	r1, #0
   80252:	2203      	movs	r2, #3
   80254:	4b1e      	ldr	r3, [pc, #120]	; (802d0 <create_peripheral_control_semaphores+0xa8>)
   80256:	4798      	blx	r3
   80258:	6030      	str	r0, [r6, #0]
   8025a:	b130      	cbz	r0, 8026a <create_peripheral_control_semaphores+0x42>
   8025c:	2100      	movs	r1, #0
   8025e:	460a      	mov	r2, r1
   80260:	460b      	mov	r3, r1
   80262:	4f1c      	ldr	r7, [pc, #112]	; (802d4 <create_peripheral_control_semaphores+0xac>)
   80264:	47b8      	blx	r7
				tx_dma_control->transaction_complete_notification_semaphore);
		configASSERT(
   80266:	6833      	ldr	r3, [r6, #0]
   80268:	b91b      	cbnz	r3, 80272 <create_peripheral_control_semaphores+0x4a>
   8026a:	4817      	ldr	r0, [pc, #92]	; (802c8 <create_peripheral_control_semaphores+0xa0>)
   8026c:	2183      	movs	r1, #131	; 0x83
   8026e:	4b17      	ldr	r3, [pc, #92]	; (802cc <create_peripheral_control_semaphores+0xa4>)
   80270:	4798      	blx	r3
				tx_dma_control->transaction_complete_notification_semaphore);

		/* Ensure the semaphore starts in the expected state.  A block time
		of zero can be used here as the semaphore is guaranteed to be
		available (it has only just been created). */
		xSemaphoreTake(
   80272:	6830      	ldr	r0, [r6, #0]
   80274:	2100      	movs	r1, #0
   80276:	460a      	mov	r2, r1
   80278:	460b      	mov	r3, r1
   8027a:	4e17      	ldr	r6, [pc, #92]	; (802d8 <create_peripheral_control_semaphores+0xb0>)
   8027c:	47b0      	blx	r6
   8027e:	e001      	b.n	80284 <create_peripheral_control_semaphores+0x5c>
				tx_dma_control->transaction_complete_notification_semaphore,
				0);
	} else {
		tx_dma_control->transaction_complete_notification_semaphore = NULL;
   80280:	2300      	movs	r3, #0
   80282:	6033      	str	r3, [r6, #0]
	}

	/* If the receive function is only going to return once the receive
	is complete then create an internal notification semaphore. */
	if (((options_flags & WAIT_RX_COMPLETE) != 0) &&
   80284:	f014 0f08 	tst.w	r4, #8
   80288:	d019      	beq.n	802be <create_peripheral_control_semaphores+0x96>
   8028a:	b1c5      	cbz	r5, 802be <create_peripheral_control_semaphores+0x96>
			(rx_dma_control != NULL)) {
		vSemaphoreCreateBinary(
   8028c:	2001      	movs	r0, #1
   8028e:	2100      	movs	r1, #0
   80290:	2203      	movs	r2, #3
   80292:	4b0f      	ldr	r3, [pc, #60]	; (802d0 <create_peripheral_control_semaphores+0xa8>)
   80294:	4798      	blx	r3
   80296:	6028      	str	r0, [r5, #0]
   80298:	b130      	cbz	r0, 802a8 <create_peripheral_control_semaphores+0x80>
   8029a:	2100      	movs	r1, #0
   8029c:	460a      	mov	r2, r1
   8029e:	460b      	mov	r3, r1
   802a0:	4c0c      	ldr	r4, [pc, #48]	; (802d4 <create_peripheral_control_semaphores+0xac>)
   802a2:	47a0      	blx	r4
				rx_dma_control->transaction_complete_notification_semaphore);
		configASSERT(
   802a4:	682b      	ldr	r3, [r5, #0]
   802a6:	b91b      	cbnz	r3, 802b0 <create_peripheral_control_semaphores+0x88>
   802a8:	4807      	ldr	r0, [pc, #28]	; (802c8 <create_peripheral_control_semaphores+0xa0>)
   802aa:	2196      	movs	r1, #150	; 0x96
   802ac:	4b07      	ldr	r3, [pc, #28]	; (802cc <create_peripheral_control_semaphores+0xa4>)
   802ae:	4798      	blx	r3
				rx_dma_control->transaction_complete_notification_semaphore);

		/* Ensure the semaphore starts in the expected state.  A block time
		of zero can be used here as the semaphore is guaranteed to be
		available (it has only just been created. */
		xSemaphoreTake(
   802b0:	6828      	ldr	r0, [r5, #0]
   802b2:	2100      	movs	r1, #0
   802b4:	460a      	mov	r2, r1
   802b6:	460b      	mov	r3, r1
   802b8:	4c07      	ldr	r4, [pc, #28]	; (802d8 <create_peripheral_control_semaphores+0xb0>)
   802ba:	47a0      	blx	r4
   802bc:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
				rx_dma_control->transaction_complete_notification_semaphore,
				0);
	} else {
		rx_dma_control->transaction_complete_notification_semaphore = NULL;
   802be:	2300      	movs	r3, #0
   802c0:	602b      	str	r3, [r5, #0]
   802c2:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   802c4:	000846e1 	.word	0x000846e1
   802c8:	0008b368 	.word	0x0008b368
   802cc:	00085f89 	.word	0x00085f89
   802d0:	00084521 	.word	0x00084521
   802d4:	000845b1 	.word	0x000845b1
   802d8:	000847e9 	.word	0x000847e9

000802dc <configure_interrupt_controller>:
 * Configure the NVIC to enable, and set the priority of, the interrupt
 * specified by peripheral_irq.
 */
void configure_interrupt_controller(const enum IRQn peripheral_irq,
		uint32_t interrupt_priority)
{
   802dc:	b538      	push	{r3, r4, r5, lr}
   802de:	4604      	mov	r4, r0
   802e0:	460d      	mov	r5, r1
	configASSERT(interrupt_priority <=
   802e2:	290f      	cmp	r1, #15
   802e4:	d903      	bls.n	802ee <configure_interrupt_controller+0x12>
   802e6:	4815      	ldr	r0, [pc, #84]	; (8033c <configure_interrupt_controller+0x60>)
   802e8:	21ac      	movs	r1, #172	; 0xac
   802ea:	4b15      	ldr	r3, [pc, #84]	; (80340 <configure_interrupt_controller+0x64>)
   802ec:	4798      	blx	r3
            configLIBRARY_LOWEST_INTERRUPT_PRIORITY);
	configASSERT(interrupt_priority >=
   802ee:	2d09      	cmp	r5, #9
   802f0:	d803      	bhi.n	802fa <configure_interrupt_controller+0x1e>
   802f2:	4812      	ldr	r0, [pc, #72]	; (8033c <configure_interrupt_controller+0x60>)
   802f4:	21ae      	movs	r1, #174	; 0xae
   802f6:	4b12      	ldr	r3, [pc, #72]	; (80340 <configure_interrupt_controller+0x64>)
   802f8:	4798      	blx	r3

    \param [in]      IRQn  External interrupt number. Value cannot be negative.
 */
__STATIC_INLINE void NVIC_ClearPendingIRQ(IRQn_Type IRQn)
{
  NVIC->ICPR[((uint32_t)(IRQn) >> 5)] = (1 << ((uint32_t)(IRQn) & 0x1F)); /* Clear pending interrupt */
   802fa:	b2e1      	uxtb	r1, r4
   802fc:	f001 031f 	and.w	r3, r1, #31
   80300:	2201      	movs	r2, #1
   80302:	409a      	lsls	r2, r3
   80304:	0963      	lsrs	r3, r4, #5
   80306:	009b      	lsls	r3, r3, #2
   80308:	f103 4360 	add.w	r3, r3, #3758096384	; 0xe0000000
   8030c:	f503 4361 	add.w	r3, r3, #57600	; 0xe100
   80310:	f8c3 2180 	str.w	r2, [r3, #384]	; 0x180
    \param [in]      IRQn  Interrupt number.
    \param [in]  priority  Priority to set.
 */
__STATIC_INLINE void NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
  if(IRQn < 0) {
   80314:	2c00      	cmp	r4, #0
   80316:	da06      	bge.n	80326 <configure_interrupt_controller+0x4a>
    SCB->SHP[((uint32_t)(IRQn) & 0xF)-4] = ((priority << (8 - __NVIC_PRIO_BITS)) & 0xff); } /* set Priority for Cortex-M  System Interrupts */
   80318:	f001 010f 	and.w	r1, r1, #15
   8031c:	012d      	lsls	r5, r5, #4
   8031e:	b2ed      	uxtb	r5, r5
   80320:	4808      	ldr	r0, [pc, #32]	; (80344 <configure_interrupt_controller+0x68>)
   80322:	5445      	strb	r5, [r0, r1]
   80324:	e007      	b.n	80336 <configure_interrupt_controller+0x5a>
  else {
    NVIC->IP[(uint32_t)(IRQn)] = ((priority << (8 - __NVIC_PRIO_BITS)) & 0xff);    }        /* set Priority for device specific Interrupts  */
   80326:	012d      	lsls	r5, r5, #4
   80328:	b2ed      	uxtb	r5, r5
   8032a:	f104 4460 	add.w	r4, r4, #3758096384	; 0xe0000000
   8032e:	f504 4461 	add.w	r4, r4, #57600	; 0xe100
   80332:	f884 5300 	strb.w	r5, [r4, #768]	; 0x300

    \param [in]      IRQn  External interrupt number. Value cannot be negative.
 */
__STATIC_INLINE void NVIC_EnableIRQ(IRQn_Type IRQn)
{
  NVIC->ISER[((uint32_t)(IRQn) >> 5)] = (1 << ((uint32_t)(IRQn) & 0x1F)); /* enable interrupt */
   80336:	601a      	str	r2, [r3, #0]
   80338:	bd38      	pop	{r3, r4, r5, pc}
   8033a:	bf00      	nop
   8033c:	0008b368 	.word	0x0008b368
   80340:	00085f89 	.word	0x00085f89
   80344:	e000ed14 	.word	0xe000ed14

00080348 <freertos_copy_bytes_from_pdc_circular_buffer>:
 */
uint32_t freertos_copy_bytes_from_pdc_circular_buffer(
		freertos_pdc_rx_control_t *p_rx_buffer_details,
		uint32_t next_byte_to_be_written, uint8_t *buf,
		uint32_t bytes_to_read)
{
   80348:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   8034c:	4604      	mov	r4, r0
   8034e:	4690      	mov	r8, r2
   80350:	461f      	mov	r7, r3
	uint32_t number_of_bytes_available, next_byte_to_read;

	/* Locate the position that data will be read from next. */
	next_byte_to_read = (uint32_t) p_rx_buffer_details->next_byte_to_read;
   80352:	6986      	ldr	r6, [r0, #24]

	if (next_byte_to_be_written == next_byte_to_read) {
   80354:	42b1      	cmp	r1, r6
   80356:	d104      	bne.n	80362 <freertos_copy_bytes_from_pdc_circular_buffer+0x1a>
		if (p_rx_buffer_details->rx_pdc_parameters.ul_size == 0) {
   80358:	68c3      	ldr	r3, [r0, #12]
   8035a:	b953      	cbnz	r3, 80372 <freertos_copy_bytes_from_pdc_circular_buffer+0x2a>
			/* The read and write pointers are equal, but as the Rx DMA has been
			stopped, the buffer must be full, not empty.  Data from the read
			pointer up to the end of the buffer is available. */
			number_of_bytes_available =
   8035c:	6845      	ldr	r5, [r0, #4]
   8035e:	1a6d      	subs	r5, r5, r1
   80360:	e008      	b.n	80374 <freertos_copy_bytes_from_pdc_circular_buffer+0x2c>
		} else {
			/* The read and write pointers are equal, but the Rx DMA is still
			in operation, so the buffer must be empty. */
			number_of_bytes_available = 0;
		}
	} else if (next_byte_to_be_written > next_byte_to_read) {
   80362:	428e      	cmp	r6, r1
		/* The write pointer has not wrapped around from the read pointer, or
		the write and read pointer are the same indicating a buffer overflow.
		Calculate the bytes available between the write and read pointers. */
		number_of_bytes_available = next_byte_to_be_written -
   80364:	bf32      	itee	cc
   80366:	ebc6 0501 	rsbcc	r5, r6, r1
				next_byte_to_read;
	} else {
		/* The write pointer has wrapped around from the read pointer.
		Calculate the bytes available between the end of the buffer and the
		read pointer. */
		number_of_bytes_available =
   8036a:	6845      	ldrcs	r5, [r0, #4]
   8036c:	ebc6 0505 	rsbcs	r5, r6, r5
   80370:	e000      	b.n	80374 <freertos_copy_bytes_from_pdc_circular_buffer+0x2c>
					p_rx_buffer_details->past_rx_buffer_end_address
					- next_byte_to_read;
		} else {
			/* The read and write pointers are equal, but the Rx DMA is still
			in operation, so the buffer must be empty. */
			number_of_bytes_available = 0;
   80372:	2500      	movs	r5, #0
				p_rx_buffer_details->past_rx_buffer_end_address
				- next_byte_to_read;
	}

	/* Cap the number of requested bytes to those available. */
	if (bytes_to_read > number_of_bytes_available) {
   80374:	42bd      	cmp	r5, r7
   80376:	d30a      	bcc.n	8038e <freertos_copy_bytes_from_pdc_circular_buffer+0x46>
		bytes_to_read = number_of_bytes_available;
	} else if (bytes_to_read != number_of_bytes_available) {
   80378:	42af      	cmp	r7, r5
   8037a:	d007      	beq.n	8038c <freertos_copy_bytes_from_pdc_circular_buffer+0x44>
		/* There are more bytes available than being read now, so there is no
		need to wait for the interrupt to give the semaphore to indicate that
		new data is available. */
		xSemaphoreGive(p_rx_buffer_details->rx_event_semaphore);
   8037c:	6920      	ldr	r0, [r4, #16]
   8037e:	2100      	movs	r1, #0
   80380:	460a      	mov	r2, r1
   80382:	460b      	mov	r3, r1
   80384:	4d0e      	ldr	r5, [pc, #56]	; (803c0 <freertos_copy_bytes_from_pdc_circular_buffer+0x78>)
   80386:	47a8      	blx	r5
   80388:	463d      	mov	r5, r7
   8038a:	e000      	b.n	8038e <freertos_copy_bytes_from_pdc_circular_buffer+0x46>
   8038c:	463d      	mov	r5, r7
	}

	/* Copy the bytes into the user buffer. */
	memcpy(buf, (void *) p_rx_buffer_details->next_byte_to_read,
   8038e:	4640      	mov	r0, r8
   80390:	69a1      	ldr	r1, [r4, #24]
   80392:	462a      	mov	r2, r5
   80394:	4b0b      	ldr	r3, [pc, #44]	; (803c4 <freertos_copy_bytes_from_pdc_circular_buffer+0x7c>)
   80396:	4798      	blx	r3
			bytes_to_read);

	/* Move up the read buffer accordingly, wrapping around if it reaches the
	end of the buffer. */
	next_byte_to_read += bytes_to_read;
   80398:	442e      	add	r6, r5

	if (next_byte_to_read >=
   8039a:	6863      	ldr	r3, [r4, #4]
   8039c:	429e      	cmp	r6, r3
   8039e:	d306      	bcc.n	803ae <freertos_copy_bytes_from_pdc_circular_buffer+0x66>
			p_rx_buffer_details->past_rx_buffer_end_address) {
		/* The next_byte_to_read pointer is only read by the ISR, so the
		critical section is probably not needed on 32-bit machines. */
		taskENTER_CRITICAL();
   803a0:	4b09      	ldr	r3, [pc, #36]	; (803c8 <freertos_copy_bytes_from_pdc_circular_buffer+0x80>)
   803a2:	4798      	blx	r3
		{
			p_rx_buffer_details->next_byte_to_read =
   803a4:	6823      	ldr	r3, [r4, #0]
   803a6:	61a3      	str	r3, [r4, #24]
					(uint8_t *) p_rx_buffer_details->rx_buffer_start_address;
		}
		taskEXIT_CRITICAL();
   803a8:	4b08      	ldr	r3, [pc, #32]	; (803cc <freertos_copy_bytes_from_pdc_circular_buffer+0x84>)
   803aa:	4798      	blx	r3
   803ac:	e004      	b.n	803b8 <freertos_copy_bytes_from_pdc_circular_buffer+0x70>
	} else {
		/* The next_byte_to_read pointer is only read by the ISR, so the
		critical section is probably not needed on 32-bit machines. */
		taskENTER_CRITICAL();
   803ae:	4b06      	ldr	r3, [pc, #24]	; (803c8 <freertos_copy_bytes_from_pdc_circular_buffer+0x80>)
   803b0:	4798      	blx	r3
		{
			p_rx_buffer_details->next_byte_to_read =
   803b2:	61a6      	str	r6, [r4, #24]
					(uint8_t *) next_byte_to_read;
		}
		taskEXIT_CRITICAL();
   803b4:	4b05      	ldr	r3, [pc, #20]	; (803cc <freertos_copy_bytes_from_pdc_circular_buffer+0x84>)
   803b6:	4798      	blx	r3
	}

	/* Return the number of bytes actually read. */
	return bytes_to_read;
}
   803b8:	4628      	mov	r0, r5
   803ba:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   803be:	bf00      	nop
   803c0:	000845b1 	.word	0x000845b1
   803c4:	000862d5 	.word	0x000862d5
   803c8:	00084139 	.word	0x00084139
   803cc:	00084159 	.word	0x00084159

000803d0 <freertos_obtain_peripheral_access_mutex>:
 * did not become available within max_block_time_ticks tick periods.
 */
status_code_t freertos_obtain_peripheral_access_mutex(
		freertos_dma_event_control_t *dma_event_control,
		portTickType *max_block_time_ticks)
{
   803d0:	b530      	push	{r4, r5, lr}
   803d2:	b083      	sub	sp, #12
   803d4:	4604      	mov	r4, r0
   803d6:	460d      	mov	r5, r1
	status_code_t return_value = STATUS_OK;
	xTimeOutType time_out_definition;

	if (dma_event_control->peripheral_access_mutex != NULL) {
   803d8:	6843      	ldr	r3, [r0, #4]
   803da:	b193      	cbz	r3, 80402 <freertos_obtain_peripheral_access_mutex+0x32>
		/* Remember the time on entry. */
		vTaskSetTimeOutState(&time_out_definition);
   803dc:	4668      	mov	r0, sp
   803de:	4b0d      	ldr	r3, [pc, #52]	; (80414 <freertos_obtain_peripheral_access_mutex+0x44>)
   803e0:	4798      	blx	r3

		/* Wait to get exclusive access to the peripheral. */
		if (xSemaphoreTake(dma_event_control->peripheral_access_mutex,
   803e2:	6860      	ldr	r0, [r4, #4]
   803e4:	2100      	movs	r1, #0
   803e6:	682a      	ldr	r2, [r5, #0]
   803e8:	460b      	mov	r3, r1
   803ea:	4c0b      	ldr	r4, [pc, #44]	; (80418 <freertos_obtain_peripheral_access_mutex+0x48>)
   803ec:	47a0      	blx	r4
   803ee:	b150      	cbz	r0, 80406 <freertos_obtain_peripheral_access_mutex+0x36>
				*max_block_time_ticks) == pdFAIL) {
			return_value = ERR_TIMEOUT;
		} else {
			/* Adjust the time out value in case the task had to block to
			wait for the semaphore. */
			if (xTaskCheckForTimeOut(&time_out_definition,
   803f0:	4668      	mov	r0, sp
   803f2:	4629      	mov	r1, r5
   803f4:	4b09      	ldr	r3, [pc, #36]	; (8041c <freertos_obtain_peripheral_access_mutex+0x4c>)
   803f6:	4798      	blx	r3
   803f8:	2801      	cmp	r0, #1
   803fa:	d106      	bne.n	8040a <freertos_obtain_peripheral_access_mutex+0x3a>
					max_block_time_ticks) == pdTRUE) {
				*max_block_time_ticks = 0;
   803fc:	2000      	movs	r0, #0
   803fe:	6028      	str	r0, [r5, #0]
   80400:	e004      	b.n	8040c <freertos_obtain_peripheral_access_mutex+0x3c>
 */
status_code_t freertos_obtain_peripheral_access_mutex(
		freertos_dma_event_control_t *dma_event_control,
		portTickType *max_block_time_ticks)
{
	status_code_t return_value = STATUS_OK;
   80402:	2000      	movs	r0, #0
   80404:	e002      	b.n	8040c <freertos_obtain_peripheral_access_mutex+0x3c>
		vTaskSetTimeOutState(&time_out_definition);

		/* Wait to get exclusive access to the peripheral. */
		if (xSemaphoreTake(dma_event_control->peripheral_access_mutex,
				*max_block_time_ticks) == pdFAIL) {
			return_value = ERR_TIMEOUT;
   80406:	20fd      	movs	r0, #253	; 0xfd
   80408:	e000      	b.n	8040c <freertos_obtain_peripheral_access_mutex+0x3c>
 */
status_code_t freertos_obtain_peripheral_access_mutex(
		freertos_dma_event_control_t *dma_event_control,
		portTickType *max_block_time_ticks)
{
	status_code_t return_value = STATUS_OK;
   8040a:	2000      	movs	r0, #0
			}
		}
	}

	return return_value;
}
   8040c:	b240      	sxtb	r0, r0
   8040e:	b003      	add	sp, #12
   80410:	bd30      	pop	{r4, r5, pc}
   80412:	bf00      	nop
   80414:	000855dd 	.word	0x000855dd
   80418:	000847e9 	.word	0x000847e9
   8041c:	0008560d 	.word	0x0008560d

00080420 <freertos_start_pdc_transfer>:
 */
void freertos_start_pdc_transfer(
		freertos_dma_event_control_t *dma_event_control,
		const uint8_t *data, size_t len, void *pdc_base_address,
		xSemaphoreHandle notification_semaphore, bool is_transmitting)
{
   80420:	b5f0      	push	{r4, r5, r6, r7, lr}
   80422:	b083      	sub	sp, #12
   80424:	460e      	mov	r6, r1
   80426:	4615      	mov	r5, r2
   80428:	461c      	mov	r4, r3
   8042a:	9b08      	ldr	r3, [sp, #32]
	/* Remember which semaphore is to be used to indicate the end of
	transmission.  If notification_semaphore is NULL then either no
	semaphore is being used, or the driver is using an internal notification
	semaphore because it is configured to wait until the transmit has
	completed before returning. */
	if (notification_semaphore != NULL) {
   8042c:	b113      	cbz	r3, 80434 <freertos_start_pdc_transfer+0x14>
		dma_event_control->transaction_complete_notification_semaphore =
   8042e:	6003      	str	r3, [r0, #0]
				notification_semaphore;
	}

	/* Ensure the notification semaphore starts in the expected state in case
	the previous PDC transfer didn't complete for any reason. */
	if (dma_event_control->transaction_complete_notification_semaphore !=
   80430:	4618      	mov	r0, r3
   80432:	e001      	b.n	80438 <freertos_start_pdc_transfer+0x18>
   80434:	6800      	ldr	r0, [r0, #0]
   80436:	b120      	cbz	r0, 80442 <freertos_start_pdc_transfer+0x22>
			NULL) {
		xSemaphoreTake(
   80438:	2100      	movs	r1, #0
   8043a:	460a      	mov	r2, r1
   8043c:	460b      	mov	r3, r1
   8043e:	4f13      	ldr	r7, [pc, #76]	; (8048c <freertos_start_pdc_transfer+0x6c>)
   80440:	47b8      	blx	r7
				dma_event_control->transaction_complete_notification_semaphore,
				0);
	}

	/* Configure the PDC to transmit or receive parameters. */
	pdc_packet.ul_addr = (uint32_t) data;
   80442:	9600      	str	r6, [sp, #0]
	pdc_packet.ul_size = (uint32_t) len;
   80444:	9501      	str	r5, [sp, #4]

	if (is_transmitting == true) {
   80446:	f89d 3024 	ldrb.w	r3, [sp, #36]	; 0x24
   8044a:	b17b      	cbz	r3, 8046c <freertos_start_pdc_transfer+0x4c>
		pdc_disable_transfer(pdc_base_address, PERIPH_PTCR_TXTDIS);
   8044c:	4620      	mov	r0, r4
   8044e:	f44f 7100 	mov.w	r1, #512	; 0x200
   80452:	4b0f      	ldr	r3, [pc, #60]	; (80490 <freertos_start_pdc_transfer+0x70>)
   80454:	4798      	blx	r3
		pdc_tx_init(pdc_base_address, &pdc_packet, NULL);
   80456:	4620      	mov	r0, r4
   80458:	4669      	mov	r1, sp
   8045a:	2200      	movs	r2, #0
   8045c:	4b0d      	ldr	r3, [pc, #52]	; (80494 <freertos_start_pdc_transfer+0x74>)
   8045e:	4798      	blx	r3
		pdc_enable_transfer(pdc_base_address, PERIPH_PTCR_TXTEN);
   80460:	4620      	mov	r0, r4
   80462:	f44f 7180 	mov.w	r1, #256	; 0x100
   80466:	4b0c      	ldr	r3, [pc, #48]	; (80498 <freertos_start_pdc_transfer+0x78>)
   80468:	4798      	blx	r3
   8046a:	e00c      	b.n	80486 <freertos_start_pdc_transfer+0x66>
	} else {
		pdc_disable_transfer(pdc_base_address, PERIPH_PTCR_RXTDIS);
   8046c:	4620      	mov	r0, r4
   8046e:	2102      	movs	r1, #2
   80470:	4b07      	ldr	r3, [pc, #28]	; (80490 <freertos_start_pdc_transfer+0x70>)
   80472:	4798      	blx	r3
		pdc_rx_init(pdc_base_address, &pdc_packet, NULL);
   80474:	4620      	mov	r0, r4
   80476:	4669      	mov	r1, sp
   80478:	2200      	movs	r2, #0
   8047a:	4b08      	ldr	r3, [pc, #32]	; (8049c <freertos_start_pdc_transfer+0x7c>)
   8047c:	4798      	blx	r3
		pdc_enable_transfer(pdc_base_address, PERIPH_PTCR_RXTEN);
   8047e:	4620      	mov	r0, r4
   80480:	2101      	movs	r1, #1
   80482:	4b05      	ldr	r3, [pc, #20]	; (80498 <freertos_start_pdc_transfer+0x78>)
   80484:	4798      	blx	r3
	}
}
   80486:	b003      	add	sp, #12
   80488:	bdf0      	pop	{r4, r5, r6, r7, pc}
   8048a:	bf00      	nop
   8048c:	000847e9 	.word	0x000847e9
   80490:	00081ed9 	.word	0x00081ed9
   80494:	00081e9d 	.word	0x00081e9d
   80498:	00081ecd 	.word	0x00081ecd
   8049c:	00081eb5 	.word	0x00081eb5

000804a0 <freertos_optionally_wait_transfer_completion>:
 */
status_code_t freertos_optionally_wait_transfer_completion(
		freertos_dma_event_control_t *dma_event_control,
		xSemaphoreHandle notification_semaphore,
		portTickType max_block_time_ticks)
{
   804a0:	b510      	push	{r4, lr}
	status_code_t return_value = STATUS_OK;

	if (notification_semaphore == NULL) {
   804a2:	b949      	cbnz	r1, 804b8 <freertos_optionally_wait_transfer_completion+0x18>
		if (dma_event_control->transaction_complete_notification_semaphore !=
   804a4:	6800      	ldr	r0, [r0, #0]
   804a6:	b148      	cbz	r0, 804bc <freertos_optionally_wait_transfer_completion+0x1c>
				NULL) {
			/* Wait until notified by the ISR that transmission is
			complete. */
			if (xSemaphoreTake(dma_event_control->
   804a8:	460b      	mov	r3, r1
   804aa:	4c06      	ldr	r4, [pc, #24]	; (804c4 <freertos_optionally_wait_transfer_completion+0x24>)
   804ac:	47a0      	blx	r4
status_code_t freertos_optionally_wait_transfer_completion(
		freertos_dma_event_control_t *dma_event_control,
		xSemaphoreHandle notification_semaphore,
		portTickType max_block_time_ticks)
{
	status_code_t return_value = STATUS_OK;
   804ae:	2801      	cmp	r0, #1
   804b0:	bf14      	ite	ne
   804b2:	20fd      	movne	r0, #253	; 0xfd
   804b4:	2000      	moveq	r0, #0
   804b6:	e002      	b.n	804be <freertos_optionally_wait_transfer_completion+0x1e>
   804b8:	2000      	movs	r0, #0
   804ba:	e000      	b.n	804be <freertos_optionally_wait_transfer_completion+0x1e>
   804bc:	2000      	movs	r0, #0
			}
		}
	}

	return return_value;
}
   804be:	b240      	sxtb	r0, r0
   804c0:	bd10      	pop	{r4, pc}
   804c2:	bf00      	nop
   804c4:	000847e9 	.word	0x000847e9

000804c8 <local_twi_handler>:
/*
 * For internal use only.
 * A common TWI interrupt handler that is called for all TWI peripherals.
 */
static void local_twi_handler(const portBASE_TYPE twi_index)
{
   804c8:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   804cc:	b082      	sub	sp, #8
   804ce:	4606      	mov	r6, r0
	portBASE_TYPE higher_priority_task_woken = pdFALSE;
   804d0:	2300      	movs	r3, #0
   804d2:	9301      	str	r3, [sp, #4]
	uint32_t twi_status;
	Twi *twi_port;
	bool transfer_timeout = false;

	twi_port = all_twi_definitions[twi_index].peripheral_base_address;
   804d4:	0103      	lsls	r3, r0, #4
   804d6:	4a6e      	ldr	r2, [pc, #440]	; (80690 <local_twi_handler+0x1c8>)
   804d8:	58d5      	ldr	r5, [r2, r3]

	twi_status = twi_get_interrupt_status(twi_port);
   804da:	4628      	mov	r0, r5
   804dc:	4b6d      	ldr	r3, [pc, #436]	; (80694 <local_twi_handler+0x1cc>)
   804de:	4798      	blx	r3
   804e0:	4607      	mov	r7, r0
	twi_status &= twi_get_interrupt_mask(twi_port);
   804e2:	4628      	mov	r0, r5
   804e4:	4b6c      	ldr	r3, [pc, #432]	; (80698 <local_twi_handler+0x1d0>)
   804e6:	4798      	blx	r3
   804e8:	4007      	ands	r7, r0

	/* Has the PDC completed a transmission? */
	if ((twi_status & TWI_SR_ENDTX) != 0UL) {
   804ea:	f417 5f00 	tst.w	r7, #8192	; 0x2000
   804ee:	d049      	beq.n	80584 <local_twi_handler+0xbc>
		/* Disable PDC */
		pdc_disable_transfer(all_twi_definitions[twi_index].pdc_base_address, PERIPH_PTCR_TXTDIS);
   804f0:	4b67      	ldr	r3, [pc, #412]	; (80690 <local_twi_handler+0x1c8>)
   804f2:	eb03 1306 	add.w	r3, r3, r6, lsl #4
   804f6:	6858      	ldr	r0, [r3, #4]
   804f8:	f44f 7100 	mov.w	r1, #512	; 0x200
   804fc:	4b67      	ldr	r3, [pc, #412]	; (8069c <local_twi_handler+0x1d4>)
   804fe:	4798      	blx	r3
		twi_disable_interrupt(twi_port, TWI_IDR_ENDTX);
   80500:	4628      	mov	r0, r5
   80502:	f44f 5100 	mov.w	r1, #8192	; 0x2000
   80506:	4b66      	ldr	r3, [pc, #408]	; (806a0 <local_twi_handler+0x1d8>)
   80508:	4798      	blx	r3

		uint8_t status;
		uint32_t timeout_counter = 0;
   8050a:	2400      	movs	r4, #0

		/* Wait for TX ready flag */
		while (1) {
			status = twi_port->TWI_SR;
   8050c:	6a2b      	ldr	r3, [r5, #32]
			if (status & TWI_SR_TXRDY) {
   8050e:	f013 0f04 	tst.w	r3, #4
   80512:	d104      	bne.n	8051e <local_twi_handler+0x56>
				break;
			}
			/* Check timeout condition. */
			if (++timeout_counter >= TWI_TIMEOUT_COUNTER) {
   80514:	3401      	adds	r4, #1
   80516:	f1b4 3fff 	cmp.w	r4, #4294967295
   8051a:	d1f7      	bne.n	8050c <local_twi_handler+0x44>
   8051c:	e002      	b.n	80524 <local_twi_handler+0x5c>
static void local_twi_handler(const portBASE_TYPE twi_index)
{
	portBASE_TYPE higher_priority_task_woken = pdFALSE;
	uint32_t twi_status;
	Twi *twi_port;
	bool transfer_timeout = false;
   8051e:	f04f 0800 	mov.w	r8, #0
   80522:	e001      	b.n	80528 <local_twi_handler+0x60>
			if (status & TWI_SR_TXRDY) {
				break;
			}
			/* Check timeout condition. */
			if (++timeout_counter >= TWI_TIMEOUT_COUNTER) {
				transfer_timeout = true;
   80524:	f04f 0801 	mov.w	r8, #1
				break;
			}
		}
		/* Complete the transfer - stop and last byte */
		twi_port->TWI_CR = TWI_CR_STOP;
   80528:	2302      	movs	r3, #2
   8052a:	602b      	str	r3, [r5, #0]
		twi_port->TWI_THR = twis[twi_index].buffer[twis[twi_index].length-1];
   8052c:	4b5d      	ldr	r3, [pc, #372]	; (806a4 <local_twi_handler+0x1dc>)
   8052e:	f853 2036 	ldr.w	r2, [r3, r6, lsl #3]
   80532:	eb03 03c6 	add.w	r3, r3, r6, lsl #3
   80536:	685b      	ldr	r3, [r3, #4]
   80538:	4413      	add	r3, r2
   8053a:	f813 3c01 	ldrb.w	r3, [r3, #-1]
   8053e:	636b      	str	r3, [r5, #52]	; 0x34

		/* Wait for TX complete flag */
		while (1) {
			status = twi_port->TWI_SR;
   80540:	6a2b      	ldr	r3, [r5, #32]
			if (status & TWI_SR_TXCOMP) {
   80542:	f013 0f01 	tst.w	r3, #1
   80546:	d105      	bne.n	80554 <local_twi_handler+0x8c>
				break;
			}
			/* Check timeout condition. */
			if (++timeout_counter >= TWI_TIMEOUT_COUNTER) {
   80548:	3401      	adds	r4, #1
   8054a:	f1b4 3fff 	cmp.w	r4, #4294967295
   8054e:	d1f7      	bne.n	80540 <local_twi_handler+0x78>
				transfer_timeout = true;
   80550:	f04f 0801 	mov.w	r8, #1
				break;
			}
		}
		/* If the driver is supporting multi-threading, then return the access
		mutex. */
		if (tx_dma_control[twi_index].peripheral_access_mutex != NULL) {
   80554:	4b54      	ldr	r3, [pc, #336]	; (806a8 <local_twi_handler+0x1e0>)
   80556:	eb03 03c6 	add.w	r3, r3, r6, lsl #3
   8055a:	6858      	ldr	r0, [r3, #4]
   8055c:	b128      	cbz	r0, 8056a <local_twi_handler+0xa2>
			xSemaphoreGiveFromISR(
   8055e:	2100      	movs	r1, #0
   80560:	aa01      	add	r2, sp, #4
   80562:	460b      	mov	r3, r1
   80564:	f8df c144 	ldr.w	ip, [pc, #324]	; 806ac <local_twi_handler+0x1e4>
   80568:	47e0      	blx	ip
					&higher_priority_task_woken);
		}

		/* if the sending task supplied a notification semaphore, then
		notify the task that the transmission has completed. */
		if (!(timeout_counter >= TWI_TIMEOUT_COUNTER)) {
   8056a:	f1b4 3fff 	cmp.w	r4, #4294967295
   8056e:	d00b      	beq.n	80588 <local_twi_handler+0xc0>
			if (tx_dma_control[twi_index]. transaction_complete_notification_semaphore != NULL) {
   80570:	4b4d      	ldr	r3, [pc, #308]	; (806a8 <local_twi_handler+0x1e0>)
   80572:	f853 0036 	ldr.w	r0, [r3, r6, lsl #3]
   80576:	b138      	cbz	r0, 80588 <local_twi_handler+0xc0>
				xSemaphoreGiveFromISR(
   80578:	2100      	movs	r1, #0
   8057a:	aa01      	add	r2, sp, #4
   8057c:	460b      	mov	r3, r1
   8057e:	4c4b      	ldr	r4, [pc, #300]	; (806ac <local_twi_handler+0x1e4>)
   80580:	47a0      	blx	r4
   80582:	e001      	b.n	80588 <local_twi_handler+0xc0>
static void local_twi_handler(const portBASE_TYPE twi_index)
{
	portBASE_TYPE higher_priority_task_woken = pdFALSE;
	uint32_t twi_status;
	Twi *twi_port;
	bool transfer_timeout = false;
   80584:	f04f 0800 	mov.w	r8, #0
			}
		}
	}

	/* Has the PDC completed a reception? */
	if ((twi_status & TWI_SR_ENDRX) != 0UL) {
   80588:	f417 5f80 	tst.w	r7, #4096	; 0x1000
   8058c:	d052      	beq.n	80634 <local_twi_handler+0x16c>
		uint32_t timeout_counter = 0;
		uint32_t status;
		/* Must handle the two last bytes */
		/* Disable PDC */
		pdc_disable_transfer(all_twi_definitions[twi_index].pdc_base_address, PERIPH_PTCR_RXTDIS);
   8058e:	4b40      	ldr	r3, [pc, #256]	; (80690 <local_twi_handler+0x1c8>)
   80590:	eb03 1306 	add.w	r3, r3, r6, lsl #4
   80594:	6858      	ldr	r0, [r3, #4]
   80596:	2102      	movs	r1, #2
   80598:	4b40      	ldr	r3, [pc, #256]	; (8069c <local_twi_handler+0x1d4>)
   8059a:	4798      	blx	r3

		twi_disable_interrupt(twi_port, TWI_IDR_ENDRX);
   8059c:	4628      	mov	r0, r5
   8059e:	f44f 5180 	mov.w	r1, #4096	; 0x1000
   805a2:	4b3f      	ldr	r3, [pc, #252]	; (806a0 <local_twi_handler+0x1d8>)
   805a4:	4798      	blx	r3
		}
	}

	/* Has the PDC completed a reception? */
	if ((twi_status & TWI_SR_ENDRX) != 0UL) {
		uint32_t timeout_counter = 0;
   805a6:	2400      	movs	r4, #0

		twi_disable_interrupt(twi_port, TWI_IDR_ENDRX);

		/* Wait for RX ready flag */
		while (1) {
			status = twi_port->TWI_SR;
   805a8:	6a2b      	ldr	r3, [r5, #32]
			if (status & TWI_SR_RXRDY) {
   805aa:	f013 0f02 	tst.w	r3, #2
   805ae:	d103      	bne.n	805b8 <local_twi_handler+0xf0>
				break;
			}
			/* Check timeout condition. */
			if (++timeout_counter >= TWI_TIMEOUT_COUNTER) {
   805b0:	3401      	adds	r4, #1
   805b2:	f1b4 3fff 	cmp.w	r4, #4294967295
   805b6:	d1f7      	bne.n	805a8 <local_twi_handler+0xe0>
				break;
			}
		}
		/* Complete the transfer. */
		twi_port->TWI_CR = TWI_CR_STOP;
   805b8:	2302      	movs	r3, #2
   805ba:	602b      	str	r3, [r5, #0]
		/* Read second last data */
		twis[twi_index].buffer[(twis[twi_index].length)-2] = twi_port->TWI_RHR;
   805bc:	4b39      	ldr	r3, [pc, #228]	; (806a4 <local_twi_handler+0x1dc>)
   805be:	f853 1036 	ldr.w	r1, [r3, r6, lsl #3]
   805c2:	eb03 03c6 	add.w	r3, r3, r6, lsl #3
   805c6:	685a      	ldr	r2, [r3, #4]
   805c8:	6b28      	ldr	r0, [r5, #48]	; 0x30
   805ca:	188b      	adds	r3, r1, r2
   805cc:	f803 0c02 	strb.w	r0, [r3, #-2]

		/* Wait for RX ready flag */
		while (1) {
			status = twi_port->TWI_SR;
   805d0:	6a2b      	ldr	r3, [r5, #32]
			if (status & TWI_SR_RXRDY) {
   805d2:	f013 0f02 	tst.w	r3, #2
   805d6:	d104      	bne.n	805e2 <local_twi_handler+0x11a>
				break;
			}
			/* Check timeout condition. */
			if (++timeout_counter >= TWI_TIMEOUT_COUNTER) {
   805d8:	3401      	adds	r4, #1
   805da:	f1b4 3fff 	cmp.w	r4, #4294967295
   805de:	d1f7      	bne.n	805d0 <local_twi_handler+0x108>
   805e0:	e011      	b.n	80606 <local_twi_handler+0x13e>
				break;
			}
		}

		if (!(timeout_counter >= TWI_TIMEOUT_COUNTER)) {
   805e2:	f1b4 3fff 	cmp.w	r4, #4294967295
   805e6:	d00e      	beq.n	80606 <local_twi_handler+0x13e>
			/* Read last data */
			twis[twi_index].buffer[(twis[twi_index].length)-1] = twi_port->TWI_RHR;
   805e8:	6b2b      	ldr	r3, [r5, #48]	; 0x30
   805ea:	440a      	add	r2, r1
   805ec:	f802 3c01 	strb.w	r3, [r2, #-1]
			timeout_counter = 0;
   805f0:	2400      	movs	r4, #0
			/* Wait for TX complete flag before releasing semaphore */
			while (1) {
				status = twi_port->TWI_SR;
   805f2:	6a2b      	ldr	r3, [r5, #32]
				if (status & TWI_SR_TXCOMP) {
   805f4:	f013 0f01 	tst.w	r3, #1
   805f8:	d105      	bne.n	80606 <local_twi_handler+0x13e>
					break;
				}
				/* Check timeout condition. */
				if (++timeout_counter >= TWI_TIMEOUT_COUNTER) {
   805fa:	3401      	adds	r4, #1
   805fc:	f1b4 3fff 	cmp.w	r4, #4294967295
   80600:	d1f7      	bne.n	805f2 <local_twi_handler+0x12a>
					transfer_timeout = true;
   80602:	f04f 0801 	mov.w	r8, #1
		}

		/* If the driver is supporting multi-threading, then return the access
		mutex.  NOTE: As the peripheral is half duplex there is only one
		access mutex, and the reception uses the tx access muted. */
		if (tx_dma_control[twi_index].peripheral_access_mutex != NULL) {
   80606:	4b28      	ldr	r3, [pc, #160]	; (806a8 <local_twi_handler+0x1e0>)
   80608:	eb03 03c6 	add.w	r3, r3, r6, lsl #3
   8060c:	6858      	ldr	r0, [r3, #4]
   8060e:	b128      	cbz	r0, 8061c <local_twi_handler+0x154>
			xSemaphoreGiveFromISR(
   80610:	2100      	movs	r1, #0
   80612:	aa01      	add	r2, sp, #4
   80614:	460b      	mov	r3, r1
   80616:	f8df c094 	ldr.w	ip, [pc, #148]	; 806ac <local_twi_handler+0x1e4>
   8061a:	47e0      	blx	ip
					&higher_priority_task_woken);
		}

		/* if the receiving task supplied a notification semaphore, then
		notify the task that the transmission has completed. */
		if  (!(timeout_counter >= TWI_TIMEOUT_COUNTER)) {
   8061c:	f1b4 3fff 	cmp.w	r4, #4294967295
   80620:	d008      	beq.n	80634 <local_twi_handler+0x16c>
			if (rx_dma_control[twi_index].transaction_complete_notification_semaphore != NULL) {
   80622:	4b23      	ldr	r3, [pc, #140]	; (806b0 <local_twi_handler+0x1e8>)
   80624:	f853 0036 	ldr.w	r0, [r3, r6, lsl #3]
   80628:	b120      	cbz	r0, 80634 <local_twi_handler+0x16c>
				xSemaphoreGiveFromISR(
   8062a:	2100      	movs	r1, #0
   8062c:	aa01      	add	r2, sp, #4
   8062e:	460b      	mov	r3, r1
   80630:	4c1e      	ldr	r4, [pc, #120]	; (806ac <local_twi_handler+0x1e4>)
   80632:	47a0      	blx	r4
						&higher_priority_task_woken);
			}
		}
	}

	if (((twi_status & SR_ERROR_INTERRUPTS) != 0) || (transfer_timeout == true)) {
   80634:	f417 7f50 	tst.w	r7, #832	; 0x340
   80638:	d102      	bne.n	80640 <local_twi_handler+0x178>
   8063a:	f1b8 0f00 	cmp.w	r8, #0
   8063e:	d01f      	beq.n	80680 <local_twi_handler+0x1b8>
		Stop the transmission, disable interrupts used by the peripheral, and
		ensure the peripheral access mutex is made available to tasks.  As this
		peripheral is half duplex, only the Tx peripheral access mutex exits.*/

		/* Stop the PDC */
		pdc_disable_transfer(all_twi_definitions[twi_index].pdc_base_address, PERIPH_PTCR_TXTDIS | PERIPH_PTCR_RXTDIS);
   80640:	4b13      	ldr	r3, [pc, #76]	; (80690 <local_twi_handler+0x1c8>)
   80642:	eb03 1306 	add.w	r3, r3, r6, lsl #4
   80646:	6858      	ldr	r0, [r3, #4]
   80648:	f240 2102 	movw	r1, #514	; 0x202
   8064c:	4b13      	ldr	r3, [pc, #76]	; (8069c <local_twi_handler+0x1d4>)
   8064e:	4798      	blx	r3

		if (!(twi_status & TWI_SR_NACK)) {
   80650:	f417 7f80 	tst.w	r7, #256	; 0x100
			/* Do not send stop if NACK received. Handled by hardware */
			twi_port->TWI_CR = TWI_CR_STOP;
   80654:	bf04      	itt	eq
   80656:	2302      	moveq	r3, #2
   80658:	602b      	streq	r3, [r5, #0]
		}
		twi_disable_interrupt(twi_port, TWI_IDR_ENDTX);
   8065a:	4628      	mov	r0, r5
   8065c:	f44f 5100 	mov.w	r1, #8192	; 0x2000
   80660:	4c0f      	ldr	r4, [pc, #60]	; (806a0 <local_twi_handler+0x1d8>)
   80662:	47a0      	blx	r4
		twi_disable_interrupt(twi_port, TWI_IDR_ENDRX);
   80664:	4628      	mov	r0, r5
   80666:	f44f 5180 	mov.w	r1, #4096	; 0x1000
   8066a:	47a0      	blx	r4

		if (tx_dma_control[twi_index].peripheral_access_mutex != NULL) {
   8066c:	4b0e      	ldr	r3, [pc, #56]	; (806a8 <local_twi_handler+0x1e0>)
   8066e:	eb03 06c6 	add.w	r6, r3, r6, lsl #3
   80672:	6870      	ldr	r0, [r6, #4]
   80674:	b120      	cbz	r0, 80680 <local_twi_handler+0x1b8>
			xSemaphoreGiveFromISR(
   80676:	2100      	movs	r1, #0
   80678:	aa01      	add	r2, sp, #4
   8067a:	460b      	mov	r3, r1
   8067c:	4c0b      	ldr	r4, [pc, #44]	; (806ac <local_twi_handler+0x1e4>)
   8067e:	47a0      	blx	r4
	has a priority equal to or higher than the currently running task (the task
	this ISR interrupted), then higher_priority_task_woken will have
	automatically been set to pdTRUE within the semaphore function.
	portEND_SWITCHING_ISR() will then ensure that this ISR returns directly to
	the higher priority unblocked task. */
	portEND_SWITCHING_ISR(higher_priority_task_woken);
   80680:	9b01      	ldr	r3, [sp, #4]
   80682:	b10b      	cbz	r3, 80688 <local_twi_handler+0x1c0>
   80684:	4b0b      	ldr	r3, [pc, #44]	; (806b4 <local_twi_handler+0x1ec>)
   80686:	4798      	blx	r3
}
   80688:	b002      	add	sp, #8
   8068a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   8068e:	bf00      	nop
   80690:	0008b3b0 	.word	0x0008b3b0
   80694:	000822ad 	.word	0x000822ad
   80698:	000822b1 	.word	0x000822b1
   8069c:	00081ed9 	.word	0x00081ed9
   806a0:	000822a5 	.word	0x000822a5
   806a4:	20070d0c 	.word	0x20070d0c
   806a8:	20070d1c 	.word	0x20070d1c
   806ac:	00084749 	.word	0x00084749
   806b0:	20070cfc 	.word	0x20070cfc
   806b4:	00084119 	.word	0x00084119

000806b8 <TWI0_Handler>:
#endif /* TWI */

#ifdef TWI0

void TWI0_Handler(void)
{
   806b8:	b508      	push	{r3, lr}
	local_twi_handler(0);
   806ba:	2000      	movs	r0, #0
   806bc:	4b01      	ldr	r3, [pc, #4]	; (806c4 <TWI0_Handler+0xc>)
   806be:	4798      	blx	r3
   806c0:	bd08      	pop	{r3, pc}
   806c2:	bf00      	nop
   806c4:	000804c9 	.word	0x000804c9

000806c8 <TWI1_Handler>:
#endif

#ifdef TWI1

void TWI1_Handler(void)
{
   806c8:	b508      	push	{r3, lr}
	local_twi_handler(1);
   806ca:	2001      	movs	r0, #1
   806cc:	4b01      	ldr	r3, [pc, #4]	; (806d4 <TWI1_Handler+0xc>)
   806ce:	4798      	blx	r3
   806d0:	bd08      	pop	{r3, pc}
   806d2:	bf00      	nop
   806d4:	000804c9 	.word	0x000804c9

000806d8 <configure_rx_dma>:
 * For internal use only.
 * Configures the Rx DMA to receive data into free space within the Rx buffer.
 */
static void configure_rx_dma(uint32_t uart_index,
		enum buffer_operations operation_performed)
{
   806d8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   806da:	4605      	mov	r5, r0
	freertos_pdc_rx_control_t *rx_buffer_definition;

	rx_buffer_definition = &(rx_buffer_definitions[uart_index]);
   806dc:	ebc0 04c0 	rsb	r4, r0, r0, lsl #3
   806e0:	4b1c      	ldr	r3, [pc, #112]	; (80754 <configure_rx_dma+0x7c>)
   806e2:	eb03 0484 	add.w	r4, r3, r4, lsl #2

	/* How much space is there between the start of the DMA buffer and the
	current read pointer?  */

	if (((uint32_t)rx_buffer_definition->next_byte_to_read) ==
   806e6:	69a2      	ldr	r2, [r4, #24]
			rx_buffer_definition->rx_pdc_parameters.ul_addr) {
   806e8:	68a3      	ldr	r3, [r4, #8]
	rx_buffer_definition = &(rx_buffer_definitions[uart_index]);

	/* How much space is there between the start of the DMA buffer and the
	current read pointer?  */

	if (((uint32_t)rx_buffer_definition->next_byte_to_read) ==
   806ea:	429a      	cmp	r2, r3
   806ec:	d107      	bne.n	806fe <configure_rx_dma+0x26>
		/* The read pointer and the write pointer are equal.  If this function
		was called because data was added to the buffer, then there is no free
		space in the buffer remaining.  If this function was called because data
		was removed from the buffer, then the space remaining is from the write
		pointer up to the end of the buffer. */
		if (operation_performed == data_added) {
   806ee:	b911      	cbnz	r1, 806f6 <configure_rx_dma+0x1e>
			rx_buffer_definition->rx_pdc_parameters.ul_size = 0UL;
   806f0:	2200      	movs	r2, #0
   806f2:	60e2      	str	r2, [r4, #12]
   806f4:	e008      	b.n	80708 <configure_rx_dma+0x30>
		} else {
			rx_buffer_definition->rx_pdc_parameters.ul_size =
				rx_buffer_definition->past_rx_buffer_end_address - rx_buffer_definition->rx_pdc_parameters.ul_addr;
   806f6:	6861      	ldr	r1, [r4, #4]
   806f8:	1a8a      	subs	r2, r1, r2
		was removed from the buffer, then the space remaining is from the write
		pointer up to the end of the buffer. */
		if (operation_performed == data_added) {
			rx_buffer_definition->rx_pdc_parameters.ul_size = 0UL;
		} else {
			rx_buffer_definition->rx_pdc_parameters.ul_size =
   806fa:	60e2      	str	r2, [r4, #12]
   806fc:	e004      	b.n	80708 <configure_rx_dma+0x30>
				rx_buffer_definition->past_rx_buffer_end_address - rx_buffer_definition->rx_pdc_parameters.ul_addr;
		}
	} else if (((uint32_t)rx_buffer_definition->next_byte_to_read) >
   806fe:	429a      	cmp	r2, r3
			((uint32_t) rx_buffer_definition->next_byte_to_read) - rx_buffer_definition->rx_pdc_parameters.ul_addr;
	} else {
		/* The write pointer is ahead of the read pointer so the space
		available is up to the end of the buffer. */
		rx_buffer_definition->rx_pdc_parameters.ul_size =
			rx_buffer_definition->past_rx_buffer_end_address - rx_buffer_definition->rx_pdc_parameters.ul_addr;
   80700:	bf98      	it	ls
   80702:	6862      	ldrls	r2, [r4, #4]
   80704:	1ad2      	subs	r2, r2, r3
		rx_buffer_definition->rx_pdc_parameters.ul_size =
			((uint32_t) rx_buffer_definition->next_byte_to_read) - rx_buffer_definition->rx_pdc_parameters.ul_addr;
	} else {
		/* The write pointer is ahead of the read pointer so the space
		available is up to the end of the buffer. */
		rx_buffer_definition->rx_pdc_parameters.ul_size =
   80706:	60e2      	str	r2, [r4, #12]
			rx_buffer_definition->past_rx_buffer_end_address - rx_buffer_definition->rx_pdc_parameters.ul_addr;
	}

	configASSERT((rx_buffer_definition->rx_pdc_parameters.ul_addr+
   80708:	68e2      	ldr	r2, [r4, #12]
   8070a:	4413      	add	r3, r2
   8070c:	6862      	ldr	r2, [r4, #4]
   8070e:	4293      	cmp	r3, r2
   80710:	d904      	bls.n	8071c <configure_rx_dma+0x44>
   80712:	4811      	ldr	r0, [pc, #68]	; (80758 <configure_rx_dma+0x80>)
   80714:	f240 2156 	movw	r1, #598	; 0x256
   80718:	4b10      	ldr	r3, [pc, #64]	; (8075c <configure_rx_dma+0x84>)
   8071a:	4798      	blx	r3
			rx_buffer_definition->rx_pdc_parameters.ul_size) <=
			rx_buffer_definition->past_rx_buffer_end_address);

	if (rx_buffer_definition->rx_pdc_parameters.ul_size > 0) {
   8071c:	68e3      	ldr	r3, [r4, #12]
   8071e:	b193      	cbz	r3, 80746 <configure_rx_dma+0x6e>
		/* Restart the DMA to receive into whichever space was calculated
		as remaining.  First clear any characters that might already be in the
		registers. */
		pdc_rx_init(
   80720:	4e0f      	ldr	r6, [pc, #60]	; (80760 <configure_rx_dma+0x88>)
   80722:	012d      	lsls	r5, r5, #4
   80724:	1973      	adds	r3, r6, r5
   80726:	685f      	ldr	r7, [r3, #4]
   80728:	4638      	mov	r0, r7
   8072a:	f104 0108 	add.w	r1, r4, #8
   8072e:	2200      	movs	r2, #0
   80730:	4b0c      	ldr	r3, [pc, #48]	; (80764 <configure_rx_dma+0x8c>)
   80732:	4798      	blx	r3
				all_uart_definitions[uart_index].pdc_base_address, &rx_buffer_definition->rx_pdc_parameters,
				NULL);
		pdc_enable_transfer(
   80734:	4638      	mov	r0, r7
   80736:	2101      	movs	r1, #1
   80738:	4b0b      	ldr	r3, [pc, #44]	; (80768 <configure_rx_dma+0x90>)
   8073a:	4798      	blx	r3
				all_uart_definitions[uart_index].pdc_base_address,
				PERIPH_PTCR_RXTEN);
		uart_enable_interrupt(
   8073c:	5970      	ldr	r0, [r6, r5]
   8073e:	2109      	movs	r1, #9
   80740:	4b0a      	ldr	r3, [pc, #40]	; (8076c <configure_rx_dma+0x94>)
   80742:	4798      	blx	r3
   80744:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	} else {
		/* The write pointer has reached the read pointer.  There is no
		more room so the DMA is not re-enabled until a read has created
		space. */
		uart_disable_interrupt(
				all_uart_definitions[uart_index].peripheral_base_address,
   80746:	012d      	lsls	r5, r5, #4
				UART_IER_ENDRX | UART_IER_RXRDY);
	} else {
		/* The write pointer has reached the read pointer.  There is no
		more room so the DMA is not re-enabled until a read has created
		space. */
		uart_disable_interrupt(
   80748:	4b05      	ldr	r3, [pc, #20]	; (80760 <configure_rx_dma+0x88>)
   8074a:	5958      	ldr	r0, [r3, r5]
   8074c:	2109      	movs	r1, #9
   8074e:	4b08      	ldr	r3, [pc, #32]	; (80770 <configure_rx_dma+0x98>)
   80750:	4798      	blx	r3
   80752:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   80754:	20070d2c 	.word	0x20070d2c
   80758:	0008b3d0 	.word	0x0008b3d0
   8075c:	00085f89 	.word	0x00085f89
   80760:	0008b410 	.word	0x0008b410
   80764:	00081eb5 	.word	0x00081eb5
   80768:	00081ecd 	.word	0x00081ecd
   8076c:	000822b5 	.word	0x000822b5
   80770:	000822b9 	.word	0x000822b9

00080774 <UART_Handler>:
 */

#ifdef UART

void UART_Handler(void)
{
   80774:	b530      	push	{r4, r5, lr}
   80776:	b083      	sub	sp, #12
 * For internal use only.
 * A common UART interrupt handler that is called for all UART peripherals.
 */
static void local_uart_handler(const portBASE_TYPE uart_index)
{
	portBASE_TYPE higher_priority_task_woken = pdFALSE;
   80778:	2300      	movs	r3, #0
   8077a:	9301      	str	r3, [sp, #4]
	uint32_t uart_status;
	freertos_pdc_rx_control_t *rx_buffer_definition;

	uart_status = uart_get_status(
   8077c:	4d34      	ldr	r5, [pc, #208]	; (80850 <UART_Handler+0xdc>)
   8077e:	4628      	mov	r0, r5
   80780:	4b34      	ldr	r3, [pc, #208]	; (80854 <UART_Handler+0xe0>)
   80782:	4798      	blx	r3
   80784:	4604      	mov	r4, r0
			all_uart_definitions[uart_index].peripheral_base_address);
	uart_status &= uart_get_interrupt_mask(
   80786:	4628      	mov	r0, r5
   80788:	4b33      	ldr	r3, [pc, #204]	; (80858 <UART_Handler+0xe4>)
   8078a:	4798      	blx	r3
   8078c:	4004      	ands	r4, r0
			all_uart_definitions[uart_index].peripheral_base_address);

	rx_buffer_definition = &(rx_buffer_definitions[uart_index]);

	/* Has the PDC completed a transmission? */
	if ((uart_status & UART_SR_ENDTX) != 0UL) {
   8078e:	f014 0f10 	tst.w	r4, #16
   80792:	d013      	beq.n	807bc <UART_Handler+0x48>
		uart_disable_interrupt(
   80794:	4628      	mov	r0, r5
   80796:	2110      	movs	r1, #16
   80798:	4b30      	ldr	r3, [pc, #192]	; (8085c <UART_Handler+0xe8>)
   8079a:	4798      	blx	r3
				all_uart_definitions[uart_index].peripheral_base_address,
				UART_IDR_ENDTX);

		/* If the driver is supporting multi-threading, then return the access
		mutex. */
		if (tx_dma_control[uart_index].peripheral_access_mutex != NULL) {
   8079c:	4b30      	ldr	r3, [pc, #192]	; (80860 <UART_Handler+0xec>)
   8079e:	6858      	ldr	r0, [r3, #4]
   807a0:	b120      	cbz	r0, 807ac <UART_Handler+0x38>
			xSemaphoreGiveFromISR(
   807a2:	2100      	movs	r1, #0
   807a4:	aa01      	add	r2, sp, #4
   807a6:	460b      	mov	r3, r1
   807a8:	4d2e      	ldr	r5, [pc, #184]	; (80864 <UART_Handler+0xf0>)
   807aa:	47a8      	blx	r5
					&higher_priority_task_woken);
		}

		/* if the sending task supplied a notification semaphore, then
		notify the task that the transmission has completed. */
		if (tx_dma_control[uart_index].transaction_complete_notification_semaphore != NULL) {
   807ac:	4b2c      	ldr	r3, [pc, #176]	; (80860 <UART_Handler+0xec>)
   807ae:	6818      	ldr	r0, [r3, #0]
   807b0:	b120      	cbz	r0, 807bc <UART_Handler+0x48>
			xSemaphoreGiveFromISR(
   807b2:	2100      	movs	r1, #0
   807b4:	aa01      	add	r2, sp, #4
   807b6:	460b      	mov	r3, r1
   807b8:	4d2a      	ldr	r5, [pc, #168]	; (80864 <UART_Handler+0xf0>)
   807ba:	47a8      	blx	r5
					tx_dma_control[uart_index].transaction_complete_notification_semaphore,
					&higher_priority_task_woken);
		}
	}

	if ((uart_status & UART_SR_ENDRX) != 0UL) {
   807bc:	f014 0f08 	tst.w	r4, #8
   807c0:	d027      	beq.n	80812 <UART_Handler+0x9e>
		/* It is possible to initialise the peripheral to only use Tx and not Rx.
		Check that Rx has been initialised. */
		configASSERT(rx_buffer_definition->next_byte_to_read);
   807c2:	4b29      	ldr	r3, [pc, #164]	; (80868 <UART_Handler+0xf4>)
   807c4:	699b      	ldr	r3, [r3, #24]
   807c6:	b923      	cbnz	r3, 807d2 <UART_Handler+0x5e>
   807c8:	4828      	ldr	r0, [pc, #160]	; (8086c <UART_Handler+0xf8>)
   807ca:	f240 219a 	movw	r1, #666	; 0x29a
   807ce:	4b28      	ldr	r3, [pc, #160]	; (80870 <UART_Handler+0xfc>)
   807d0:	4798      	blx	r3
		configASSERT(rx_buffer_definition->next_byte_to_read !=
   807d2:	4b25      	ldr	r3, [pc, #148]	; (80868 <UART_Handler+0xf4>)
   807d4:	699b      	ldr	r3, [r3, #24]
   807d6:	2b01      	cmp	r3, #1
   807d8:	d104      	bne.n	807e4 <UART_Handler+0x70>
   807da:	4824      	ldr	r0, [pc, #144]	; (8086c <UART_Handler+0xf8>)
   807dc:	f44f 7127 	mov.w	r1, #668	; 0x29c
   807e0:	4b23      	ldr	r3, [pc, #140]	; (80870 <UART_Handler+0xfc>)
   807e2:	4798      	blx	r3

		/* Out of DMA buffer, configure the next buffer.  Start by moving
		the DMA buffer start address up to the end of the previously defined
		buffer. */
		rx_buffer_definition->rx_pdc_parameters.ul_addr +=
				rx_buffer_definition->rx_pdc_parameters.ul_size;
   807e4:	4b20      	ldr	r3, [pc, #128]	; (80868 <UART_Handler+0xf4>)
				RX_NOT_USED);

		/* Out of DMA buffer, configure the next buffer.  Start by moving
		the DMA buffer start address up to the end of the previously defined
		buffer. */
		rx_buffer_definition->rx_pdc_parameters.ul_addr +=
   807e6:	68d9      	ldr	r1, [r3, #12]
   807e8:	689a      	ldr	r2, [r3, #8]
   807ea:	440a      	add	r2, r1
   807ec:	609a      	str	r2, [r3, #8]
				rx_buffer_definition->rx_pdc_parameters.ul_size;

		/* If the end of the buffer has been reached, wrap back to the start. */
		if (rx_buffer_definition->rx_pdc_parameters.ul_addr >=
   807ee:	685b      	ldr	r3, [r3, #4]
   807f0:	429a      	cmp	r2, r3
   807f2:	d302      	bcc.n	807fa <UART_Handler+0x86>
				rx_buffer_definition->past_rx_buffer_end_address)
		{
			rx_buffer_definition->rx_pdc_parameters.ul_addr =
   807f4:	4b1c      	ldr	r3, [pc, #112]	; (80868 <UART_Handler+0xf4>)
   807f6:	681a      	ldr	r2, [r3, #0]
   807f8:	609a      	str	r2, [r3, #8]
					rx_buffer_definition->rx_buffer_start_address;
		}

		/* Reset the Rx DMA to receive data into whatever free space remains in
		the Rx buffer. */
		configure_rx_dma(uart_index, data_added);
   807fa:	2000      	movs	r0, #0
   807fc:	4601      	mov	r1, r0
   807fe:	4b1d      	ldr	r3, [pc, #116]	; (80874 <UART_Handler+0x100>)
   80800:	4798      	blx	r3

		if (rx_buffer_definition->rx_event_semaphore != NULL) {
   80802:	4b19      	ldr	r3, [pc, #100]	; (80868 <UART_Handler+0xf4>)
   80804:	6918      	ldr	r0, [r3, #16]
   80806:	b120      	cbz	r0, 80812 <UART_Handler+0x9e>
			/* Notify that new data is available. */
			xSemaphoreGiveFromISR(
   80808:	2100      	movs	r1, #0
   8080a:	aa01      	add	r2, sp, #4
   8080c:	460b      	mov	r3, r1
   8080e:	4d15      	ldr	r5, [pc, #84]	; (80864 <UART_Handler+0xf0>)
   80810:	47a8      	blx	r5
	 * It happened only when in PDC mode with TXRDY and RXRDY interrupts since
	 * the flags has been cleared by PDC.
	 * As the TXRDY is never enabled in this service, here we
	 * check the RXRDY interrupt case.
	 */
	if (uart_status == 0UL) {
   80812:	b944      	cbnz	r4, 80826 <UART_Handler+0xb2>
		/* Character has been placed into the Rx buffer. */
		if (rx_buffer_definition->rx_event_semaphore != NULL) {
   80814:	4b14      	ldr	r3, [pc, #80]	; (80868 <UART_Handler+0xf4>)
   80816:	6918      	ldr	r0, [r3, #16]
   80818:	b198      	cbz	r0, 80842 <UART_Handler+0xce>
			/* Notify that new data is available. */
			xSemaphoreGiveFromISR(
   8081a:	2100      	movs	r1, #0
   8081c:	aa01      	add	r2, sp, #4
   8081e:	460b      	mov	r3, r1
   80820:	4c10      	ldr	r4, [pc, #64]	; (80864 <UART_Handler+0xf0>)
   80822:	47a0      	blx	r4
   80824:	e00d      	b.n	80842 <UART_Handler+0xce>
					rx_buffer_definition->rx_event_semaphore,
					&higher_priority_task_woken);
		}
	}

	if ((uart_status & SR_ERROR_INTERRUPTS) != 0) {
   80826:	f014 0fe0 	tst.w	r4, #224	; 0xe0
   8082a:	d00a      	beq.n	80842 <UART_Handler+0xce>
		/* An error occurred in either a transmission or reception.  Abort, and
		ensure the peripheral access mutex is made available to tasks. */
		uart_reset_status(
   8082c:	4808      	ldr	r0, [pc, #32]	; (80850 <UART_Handler+0xdc>)
   8082e:	4b12      	ldr	r3, [pc, #72]	; (80878 <UART_Handler+0x104>)
   80830:	4798      	blx	r3
				all_uart_definitions[uart_index].peripheral_base_address);
		if (tx_dma_control[uart_index].peripheral_access_mutex != NULL) {
   80832:	4b0b      	ldr	r3, [pc, #44]	; (80860 <UART_Handler+0xec>)
   80834:	6858      	ldr	r0, [r3, #4]
   80836:	b120      	cbz	r0, 80842 <UART_Handler+0xce>
			xSemaphoreGiveFromISR(
   80838:	2100      	movs	r1, #0
   8083a:	aa01      	add	r2, sp, #4
   8083c:	460b      	mov	r3, r1
   8083e:	4c09      	ldr	r4, [pc, #36]	; (80864 <UART_Handler+0xf0>)
   80840:	47a0      	blx	r4
	has a priority equal to or higher than the currently running task (the task
	this ISR interrupted), then higher_priority_task_woken will have
	automatically been set to pdTRUE within the semaphore function.
	portEND_SWITCHING_ISR() will then ensure that this ISR returns directly to
	the higher priority unblocked task. */
	portEND_SWITCHING_ISR(higher_priority_task_woken);
   80842:	9b01      	ldr	r3, [sp, #4]
   80844:	b10b      	cbz	r3, 8084a <UART_Handler+0xd6>
   80846:	4b0d      	ldr	r3, [pc, #52]	; (8087c <UART_Handler+0x108>)
   80848:	4798      	blx	r3
#ifdef UART

void UART_Handler(void)
{
	local_uart_handler(0);
}
   8084a:	b003      	add	sp, #12
   8084c:	bd30      	pop	{r4, r5, pc}
   8084e:	bf00      	nop
   80850:	400e0800 	.word	0x400e0800
   80854:	000822c1 	.word	0x000822c1
   80858:	000822bd 	.word	0x000822bd
   8085c:	000822b9 	.word	0x000822b9
   80860:	20070d48 	.word	0x20070d48
   80864:	00084749 	.word	0x00084749
   80868:	20070d2c 	.word	0x20070d2c
   8086c:	0008b3d0 	.word	0x0008b3d0
   80870:	00085f89 	.word	0x00085f89
   80874:	000806d9 	.word	0x000806d9
   80878:	000822c5 	.word	0x000822c5
   8087c:	00084119 	.word	0x00084119

00080880 <configure_rx_dma>:
 * For internal use only.
 * Configures the Rx DMA to receive data into free space within the Rx buffer.
 */
static void configure_rx_dma(uint32_t usart_index,
		enum buffer_operations operation_performed)
{
   80880:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   80882:	4605      	mov	r5, r0
	freertos_pdc_rx_control_t *rx_buffer_definition;

	rx_buffer_definition = &(rx_buffer_definitions[usart_index]);
   80884:	ebc0 04c0 	rsb	r4, r0, r0, lsl #3
   80888:	4b1d      	ldr	r3, [pc, #116]	; (80900 <configure_rx_dma+0x80>)
   8088a:	eb03 0484 	add.w	r4, r3, r4, lsl #2

	/* How much space is there between the start of the DMA buffer and the
	current read pointer?  */

	if (((uint32_t)rx_buffer_definition->next_byte_to_read) ==
   8088e:	69a2      	ldr	r2, [r4, #24]
			rx_buffer_definition->rx_pdc_parameters.ul_addr) {
   80890:	68a3      	ldr	r3, [r4, #8]
	rx_buffer_definition = &(rx_buffer_definitions[usart_index]);

	/* How much space is there between the start of the DMA buffer and the
	current read pointer?  */

	if (((uint32_t)rx_buffer_definition->next_byte_to_read) ==
   80892:	429a      	cmp	r2, r3
   80894:	d107      	bne.n	808a6 <configure_rx_dma+0x26>
		/* The read pointer and the write pointer are equal.  If this function
		was called because data was added to the buffer, then there is no free
		space in the buffer remaining.  If this function was called because data
		was removed from the buffer, then the space remaining is from the write
		pointer up to the end of the buffer. */
		if (operation_performed == data_added) {
   80896:	b911      	cbnz	r1, 8089e <configure_rx_dma+0x1e>
			rx_buffer_definition->rx_pdc_parameters.ul_size = 0UL;
   80898:	2200      	movs	r2, #0
   8089a:	60e2      	str	r2, [r4, #12]
   8089c:	e008      	b.n	808b0 <configure_rx_dma+0x30>
		} else {
			rx_buffer_definition->rx_pdc_parameters.ul_size =
				rx_buffer_definition->past_rx_buffer_end_address - rx_buffer_definition->rx_pdc_parameters.ul_addr;
   8089e:	6861      	ldr	r1, [r4, #4]
   808a0:	1a8a      	subs	r2, r1, r2
		was removed from the buffer, then the space remaining is from the write
		pointer up to the end of the buffer. */
		if (operation_performed == data_added) {
			rx_buffer_definition->rx_pdc_parameters.ul_size = 0UL;
		} else {
			rx_buffer_definition->rx_pdc_parameters.ul_size =
   808a2:	60e2      	str	r2, [r4, #12]
   808a4:	e004      	b.n	808b0 <configure_rx_dma+0x30>
				rx_buffer_definition->past_rx_buffer_end_address - rx_buffer_definition->rx_pdc_parameters.ul_addr;
		}
	} else if (((uint32_t)rx_buffer_definition->next_byte_to_read) >
   808a6:	429a      	cmp	r2, r3
			((uint32_t) rx_buffer_definition->next_byte_to_read) - rx_buffer_definition->rx_pdc_parameters.ul_addr;
	} else {
		/* The write pointer is ahead of the read pointer so the space
		available is up to the end of the buffer. */
		rx_buffer_definition->rx_pdc_parameters.ul_size =
			rx_buffer_definition->past_rx_buffer_end_address - rx_buffer_definition->rx_pdc_parameters.ul_addr;
   808a8:	bf98      	it	ls
   808aa:	6862      	ldrls	r2, [r4, #4]
   808ac:	1ad2      	subs	r2, r2, r3
		rx_buffer_definition->rx_pdc_parameters.ul_size =
			((uint32_t) rx_buffer_definition->next_byte_to_read) - rx_buffer_definition->rx_pdc_parameters.ul_addr;
	} else {
		/* The write pointer is ahead of the read pointer so the space
		available is up to the end of the buffer. */
		rx_buffer_definition->rx_pdc_parameters.ul_size =
   808ae:	60e2      	str	r2, [r4, #12]
			rx_buffer_definition->past_rx_buffer_end_address - rx_buffer_definition->rx_pdc_parameters.ul_addr;
	}

	configASSERT((rx_buffer_definition->rx_pdc_parameters.ul_addr +
   808b0:	68e2      	ldr	r2, [r4, #12]
   808b2:	4413      	add	r3, r2
   808b4:	6862      	ldr	r2, [r4, #4]
   808b6:	4293      	cmp	r3, r2
   808b8:	d904      	bls.n	808c4 <configure_rx_dma+0x44>
   808ba:	4812      	ldr	r0, [pc, #72]	; (80904 <configure_rx_dma+0x84>)
   808bc:	f240 219b 	movw	r1, #667	; 0x29b
   808c0:	4b11      	ldr	r3, [pc, #68]	; (80908 <configure_rx_dma+0x88>)
   808c2:	4798      	blx	r3
			rx_buffer_definition->rx_pdc_parameters.ul_size) <=
			rx_buffer_definition->past_rx_buffer_end_address);

	if (rx_buffer_definition->rx_pdc_parameters.ul_size > 0) {
   808c4:	68e3      	ldr	r3, [r4, #12]
   808c6:	b19b      	cbz	r3, 808f0 <configure_rx_dma+0x70>
		/* Restart the DMA to receive into whichever space was calculated
		as remaining.  First clear any characters that might already be in the
		registers. */
		pdc_rx_init(
   808c8:	4e10      	ldr	r6, [pc, #64]	; (8090c <configure_rx_dma+0x8c>)
   808ca:	012d      	lsls	r5, r5, #4
   808cc:	1973      	adds	r3, r6, r5
   808ce:	685f      	ldr	r7, [r3, #4]
   808d0:	4638      	mov	r0, r7
   808d2:	f104 0108 	add.w	r1, r4, #8
   808d6:	2200      	movs	r2, #0
   808d8:	4b0d      	ldr	r3, [pc, #52]	; (80910 <configure_rx_dma+0x90>)
   808da:	4798      	blx	r3
				all_usart_definitions[usart_index].pdc_base_address, &rx_buffer_definition->rx_pdc_parameters,
				NULL);
		pdc_enable_transfer(
   808dc:	4638      	mov	r0, r7
   808de:	2101      	movs	r1, #1
   808e0:	4b0c      	ldr	r3, [pc, #48]	; (80914 <configure_rx_dma+0x94>)
   808e2:	4798      	blx	r3
				all_usart_definitions[usart_index].pdc_base_address,
				PERIPH_PTCR_RXTEN);
		usart_enable_interrupt(
   808e4:	5970      	ldr	r0, [r6, r5]
   808e6:	f44f 7184 	mov.w	r1, #264	; 0x108
   808ea:	4b0b      	ldr	r3, [pc, #44]	; (80918 <configure_rx_dma+0x98>)
   808ec:	4798      	blx	r3
   808ee:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	} else {
		/* The write pointer has reached the read pointer.  There is no
		more room so the DMA is not re-enabled until a read has created
		space. */
		usart_disable_interrupt(
				all_usart_definitions[usart_index].peripheral_base_address, US_IER_ENDRX |
   808f0:	012d      	lsls	r5, r5, #4
				US_IER_TIMEOUT);
	} else {
		/* The write pointer has reached the read pointer.  There is no
		more room so the DMA is not re-enabled until a read has created
		space. */
		usart_disable_interrupt(
   808f2:	4b06      	ldr	r3, [pc, #24]	; (8090c <configure_rx_dma+0x8c>)
   808f4:	5958      	ldr	r0, [r3, r5]
   808f6:	f44f 7184 	mov.w	r1, #264	; 0x108
   808fa:	4b08      	ldr	r3, [pc, #32]	; (8091c <configure_rx_dma+0x9c>)
   808fc:	4798      	blx	r3
   808fe:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   80900:	20070d50 	.word	0x20070d50
   80904:	0008b420 	.word	0x0008b420
   80908:	00085f89 	.word	0x00085f89
   8090c:	0008b460 	.word	0x0008b460
   80910:	00081eb5 	.word	0x00081eb5
   80914:	00081ecd 	.word	0x00081ecd
   80918:	00083719 	.word	0x00083719
   8091c:	0008371d 	.word	0x0008371d

00080920 <local_usart_handler>:
/*
 * For internal use only.
 * A common USART interrupt handler that is called for all USART peripherals.
 */
static void local_usart_handler(const portBASE_TYPE usart_index)
{
   80920:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
   80924:	b083      	sub	sp, #12
   80926:	4604      	mov	r4, r0
	portBASE_TYPE higher_priority_task_woken = pdFALSE;
   80928:	2300      	movs	r3, #0
   8092a:	9301      	str	r3, [sp, #4]
	uint32_t usart_status;
	freertos_pdc_rx_control_t *rx_buffer_definition;

	usart_status = usart_get_status(
			all_usart_definitions[usart_index].peripheral_base_address);
   8092c:	0103      	lsls	r3, r0, #4
   8092e:	4a3d      	ldr	r2, [pc, #244]	; (80a24 <local_usart_handler+0x104>)
   80930:	58d7      	ldr	r7, [r2, r3]
{
	portBASE_TYPE higher_priority_task_woken = pdFALSE;
	uint32_t usart_status;
	freertos_pdc_rx_control_t *rx_buffer_definition;

	usart_status = usart_get_status(
   80932:	4638      	mov	r0, r7
   80934:	4b3c      	ldr	r3, [pc, #240]	; (80a28 <local_usart_handler+0x108>)
   80936:	4798      	blx	r3
   80938:	4606      	mov	r6, r0
			all_usart_definitions[usart_index].peripheral_base_address);
	usart_status &= usart_get_interrupt_mask(
   8093a:	4638      	mov	r0, r7
   8093c:	4b3b      	ldr	r3, [pc, #236]	; (80a2c <local_usart_handler+0x10c>)
   8093e:	4798      	blx	r3
   80940:	4006      	ands	r6, r0
			all_usart_definitions[usart_index].peripheral_base_address);

	rx_buffer_definition = &(rx_buffer_definitions[usart_index]);
   80942:	f8df 9110 	ldr.w	r9, [pc, #272]	; 80a54 <local_usart_handler+0x134>
   80946:	ebc4 08c4 	rsb	r8, r4, r4, lsl #3
   8094a:	ea4f 0888 	mov.w	r8, r8, lsl #2
   8094e:	eb09 0508 	add.w	r5, r9, r8

	/* Has the PDC completed a transmission? */
	if ((usart_status & US_CSR_ENDTX) != 0UL) {
   80952:	f016 0f10 	tst.w	r6, #16
   80956:	d018      	beq.n	8098a <local_usart_handler+0x6a>
		usart_disable_interrupt(
   80958:	4638      	mov	r0, r7
   8095a:	2110      	movs	r1, #16
   8095c:	4b34      	ldr	r3, [pc, #208]	; (80a30 <local_usart_handler+0x110>)
   8095e:	4798      	blx	r3
				all_usart_definitions[usart_index].peripheral_base_address,
				US_IER_ENDTX);

		/* If the driver is supporting multi-threading, then return the access
		mutex. */
		if (tx_dma_control[usart_index].peripheral_access_mutex != NULL) {
   80960:	4b34      	ldr	r3, [pc, #208]	; (80a34 <local_usart_handler+0x114>)
   80962:	eb03 03c4 	add.w	r3, r3, r4, lsl #3
   80966:	6858      	ldr	r0, [r3, #4]
   80968:	b128      	cbz	r0, 80976 <local_usart_handler+0x56>
			xSemaphoreGiveFromISR(
   8096a:	2100      	movs	r1, #0
   8096c:	aa01      	add	r2, sp, #4
   8096e:	460b      	mov	r3, r1
   80970:	f8df c0d4 	ldr.w	ip, [pc, #212]	; 80a48 <local_usart_handler+0x128>
   80974:	47e0      	blx	ip
					&higher_priority_task_woken);
		}

		/* if the sending task supplied a notification semaphore, then
		notify the task that the transmission has completed. */
		if (tx_dma_control[usart_index].transaction_complete_notification_semaphore != NULL) {
   80976:	4b2f      	ldr	r3, [pc, #188]	; (80a34 <local_usart_handler+0x114>)
   80978:	f853 0034 	ldr.w	r0, [r3, r4, lsl #3]
   8097c:	b128      	cbz	r0, 8098a <local_usart_handler+0x6a>
			xSemaphoreGiveFromISR(
   8097e:	2100      	movs	r1, #0
   80980:	aa01      	add	r2, sp, #4
   80982:	460b      	mov	r3, r1
   80984:	f8df c0c0 	ldr.w	ip, [pc, #192]	; 80a48 <local_usart_handler+0x128>
   80988:	47e0      	blx	ip
					tx_dma_control[usart_index].transaction_complete_notification_semaphore,
					&higher_priority_task_woken);
		}
	}

	if ((usart_status & US_CSR_ENDRX) != 0UL) {
   8098a:	f016 0f08 	tst.w	r6, #8
   8098e:	d024      	beq.n	809da <local_usart_handler+0xba>
		/* It is possible to initialise the peripheral to only use Tx and not Rx.
		Check that Rx has been initialised. */
		configASSERT(rx_buffer_definition->next_byte_to_read);
   80990:	69ab      	ldr	r3, [r5, #24]
   80992:	b923      	cbnz	r3, 8099e <local_usart_handler+0x7e>
   80994:	4828      	ldr	r0, [pc, #160]	; (80a38 <local_usart_handler+0x118>)
   80996:	f240 21df 	movw	r1, #735	; 0x2df
   8099a:	4b28      	ldr	r3, [pc, #160]	; (80a3c <local_usart_handler+0x11c>)
   8099c:	4798      	blx	r3
		configASSERT(rx_buffer_definition->next_byte_to_read !=
   8099e:	69ab      	ldr	r3, [r5, #24]
   809a0:	2b01      	cmp	r3, #1
   809a2:	d104      	bne.n	809ae <local_usart_handler+0x8e>
   809a4:	4824      	ldr	r0, [pc, #144]	; (80a38 <local_usart_handler+0x118>)
   809a6:	f240 21e1 	movw	r1, #737	; 0x2e1
   809aa:	4b24      	ldr	r3, [pc, #144]	; (80a3c <local_usart_handler+0x11c>)
   809ac:	4798      	blx	r3
				RX_NOT_USED);

		/* Out of DMA buffer, configure the next buffer.  Start by moving
		the DMA buffer start address up to the end of the previously defined
		buffer. */
		rx_buffer_definition->rx_pdc_parameters.ul_addr +=
   809ae:	68ea      	ldr	r2, [r5, #12]
   809b0:	68ab      	ldr	r3, [r5, #8]
   809b2:	4413      	add	r3, r2
   809b4:	60ab      	str	r3, [r5, #8]
				rx_buffer_definition->rx_pdc_parameters.ul_size;

		/* If the end of the buffer has been reached, wrap back to the start. */
		if (rx_buffer_definition->rx_pdc_parameters.ul_addr >=
   809b6:	686a      	ldr	r2, [r5, #4]
   809b8:	4293      	cmp	r3, r2
				rx_buffer_definition->past_rx_buffer_end_address)
		{
			rx_buffer_definition->rx_pdc_parameters.ul_addr =
   809ba:	bf24      	itt	cs
   809bc:	f859 3008 	ldrcs.w	r3, [r9, r8]
   809c0:	60ab      	strcs	r3, [r5, #8]
					rx_buffer_definition->rx_buffer_start_address;
		}

		/* Reset the Rx DMA to receive data into whatever free space remains in
		the Rx buffer. */
		configure_rx_dma(usart_index, data_added);
   809c2:	4620      	mov	r0, r4
   809c4:	2100      	movs	r1, #0
   809c6:	4b1e      	ldr	r3, [pc, #120]	; (80a40 <local_usart_handler+0x120>)
   809c8:	4798      	blx	r3

		if (rx_buffer_definition->rx_event_semaphore != NULL) {
   809ca:	6928      	ldr	r0, [r5, #16]
   809cc:	b128      	cbz	r0, 809da <local_usart_handler+0xba>
			/* Notify that new data is available. */
			xSemaphoreGiveFromISR(
   809ce:	2100      	movs	r1, #0
   809d0:	aa01      	add	r2, sp, #4
   809d2:	460b      	mov	r3, r1
   809d4:	f8df c070 	ldr.w	ip, [pc, #112]	; 80a48 <local_usart_handler+0x128>
   809d8:	47e0      	blx	ip
					rx_buffer_definition->rx_event_semaphore,
					&higher_priority_task_woken);
		}
	}

	if ((usart_status & US_IER_TIMEOUT) != 0UL) {
   809da:	f416 7f80 	tst.w	r6, #256	; 0x100
   809de:	d009      	beq.n	809f4 <local_usart_handler+0xd4>
		/* More characters have been placed into the Rx buffer.

		Restart the timeout after more data has been received. */
		usart_start_rx_timeout(all_usart_definitions[usart_index].peripheral_base_address);
   809e0:	4638      	mov	r0, r7
   809e2:	4b18      	ldr	r3, [pc, #96]	; (80a44 <local_usart_handler+0x124>)
   809e4:	4798      	blx	r3

		if (rx_buffer_definition->rx_event_semaphore != NULL) {
   809e6:	6928      	ldr	r0, [r5, #16]
   809e8:	b120      	cbz	r0, 809f4 <local_usart_handler+0xd4>
			/* Notify that new data is available. */
			xSemaphoreGiveFromISR(
   809ea:	2100      	movs	r1, #0
   809ec:	aa01      	add	r2, sp, #4
   809ee:	460b      	mov	r3, r1
   809f0:	4d15      	ldr	r5, [pc, #84]	; (80a48 <local_usart_handler+0x128>)
   809f2:	47a8      	blx	r5
					rx_buffer_definition->rx_event_semaphore,
					&higher_priority_task_woken);
		}
	}

	if ((usart_status & SR_ERROR_INTERRUPTS) != 0) {
   809f4:	f016 0fe0 	tst.w	r6, #224	; 0xe0
   809f8:	d00c      	beq.n	80a14 <local_usart_handler+0xf4>
		/* An error occurred in either a transmission or reception.  Abort, and
		ensure the peripheral access mutex is made available to tasks. */
		usart_reset_status(
   809fa:	4638      	mov	r0, r7
   809fc:	4b13      	ldr	r3, [pc, #76]	; (80a4c <local_usart_handler+0x12c>)
   809fe:	4798      	blx	r3
				all_usart_definitions[usart_index].peripheral_base_address);
		if (tx_dma_control[usart_index].peripheral_access_mutex != NULL) {
   80a00:	4b0c      	ldr	r3, [pc, #48]	; (80a34 <local_usart_handler+0x114>)
   80a02:	eb03 04c4 	add.w	r4, r3, r4, lsl #3
   80a06:	6860      	ldr	r0, [r4, #4]
   80a08:	b120      	cbz	r0, 80a14 <local_usart_handler+0xf4>
			xSemaphoreGiveFromISR(
   80a0a:	2100      	movs	r1, #0
   80a0c:	aa01      	add	r2, sp, #4
   80a0e:	460b      	mov	r3, r1
   80a10:	4c0d      	ldr	r4, [pc, #52]	; (80a48 <local_usart_handler+0x128>)
   80a12:	47a0      	blx	r4
	has a priority equal to or higher than the currently running task (the task
	this ISR interrupted), then higher_priority_task_woken will have
	automatically been set to pdTRUE within the semaphore function.
	portEND_SWITCHING_ISR() will then ensure that this ISR returns directly to
	the higher priority unblocked task. */
	portEND_SWITCHING_ISR(higher_priority_task_woken);
   80a14:	9b01      	ldr	r3, [sp, #4]
   80a16:	b10b      	cbz	r3, 80a1c <local_usart_handler+0xfc>
   80a18:	4b0d      	ldr	r3, [pc, #52]	; (80a50 <local_usart_handler+0x130>)
   80a1a:	4798      	blx	r3
}
   80a1c:	b003      	add	sp, #12
   80a1e:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
   80a22:	bf00      	nop
   80a24:	0008b460 	.word	0x0008b460
   80a28:	00083725 	.word	0x00083725
   80a2c:	00083721 	.word	0x00083721
   80a30:	0008371d 	.word	0x0008371d
   80a34:	20070dc0 	.word	0x20070dc0
   80a38:	0008b420 	.word	0x0008b420
   80a3c:	00085f89 	.word	0x00085f89
   80a40:	00080881 	.word	0x00080881
   80a44:	00083731 	.word	0x00083731
   80a48:	00084749 	.word	0x00084749
   80a4c:	00083729 	.word	0x00083729
   80a50:	00084119 	.word	0x00084119
   80a54:	20070d50 	.word	0x20070d50

00080a58 <freertos_usart_serial_init>:
 *     the initialisation fails then NULL is returned.
 */
freertos_usart_if freertos_usart_serial_init(Usart *p_usart,
		const sam_usart_opt_t *const uart_parameters,
		const freertos_peripheral_options_t *const freertos_driver_parameters)
{
   80a58:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
   80a5c:	b082      	sub	sp, #8
   80a5e:	4605      	mov	r5, r0
   80a60:	4689      	mov	r9, r1
   80a62:	4616      	mov	r6, r2
	portBASE_TYPE usart_index;
	bool is_valid_operating_mode;
	freertos_usart_if return_value;
	const enum peripheral_operation_mode valid_operating_modes[] = {USART_RS232};
   80a64:	af02      	add	r7, sp, #8
   80a66:	2300      	movs	r3, #0
   80a68:	f807 3d04 	strb.w	r3, [r7, #-4]!

	/* Find the index into the all_usart_definitions array that holds details of
	the p_usart peripheral. */
	usart_index = get_pdc_peripheral_details(all_usart_definitions,
   80a6c:	485d      	ldr	r0, [pc, #372]	; (80be4 <freertos_usart_serial_init+0x18c>)
   80a6e:	2104      	movs	r1, #4
   80a70:	462a      	mov	r2, r5
   80a72:	4b5d      	ldr	r3, [pc, #372]	; (80be8 <freertos_usart_serial_init+0x190>)
   80a74:	4798      	blx	r3
   80a76:	4604      	mov	r4, r0
			MAX_USARTS,
			(void *) p_usart);

	/* Check the requested operating mode is valid for the peripheral. */
	is_valid_operating_mode = check_requested_operating_mode(
   80a78:	7b30      	ldrb	r0, [r6, #12]
   80a7a:	4639      	mov	r1, r7
   80a7c:	2201      	movs	r2, #1
   80a7e:	4b5b      	ldr	r3, [pc, #364]	; (80bec <freertos_usart_serial_init+0x194>)
   80a80:	4798      	blx	r3
			sizeof(valid_operating_modes) /
			sizeof(enum peripheral_operation_mode));

	/* Don't do anything unless a valid p_usart pointer was used, and a valid
	operating mode was requested. */
	if ((usart_index < MAX_USARTS) && (is_valid_operating_mode == true)) {
   80a82:	2c03      	cmp	r4, #3
   80a84:	f300 80a7 	bgt.w	80bd6 <freertos_usart_serial_init+0x17e>
   80a88:	2800      	cmp	r0, #0
   80a8a:	f000 80a6 	beq.w	80bda <freertos_usart_serial_init+0x182>
		/* This function must be called exactly once per supported USART.  Check it
		has not been called	before. */
		configASSERT(rx_buffer_definitions[usart_index].next_byte_to_read == NULL);
   80a8e:	ebc4 03c4 	rsb	r3, r4, r4, lsl #3
   80a92:	4a57      	ldr	r2, [pc, #348]	; (80bf0 <freertos_usart_serial_init+0x198>)
   80a94:	eb02 0383 	add.w	r3, r2, r3, lsl #2
   80a98:	699b      	ldr	r3, [r3, #24]
   80a9a:	b11b      	cbz	r3, 80aa4 <freertos_usart_serial_init+0x4c>
   80a9c:	4855      	ldr	r0, [pc, #340]	; (80bf4 <freertos_usart_serial_init+0x19c>)
   80a9e:	21e7      	movs	r1, #231	; 0xe7
   80aa0:	4b55      	ldr	r3, [pc, #340]	; (80bf8 <freertos_usart_serial_init+0x1a0>)
   80aa2:	4798      	blx	r3

		/* Disable everything before enabling the clock. */
		usart_disable_tx(p_usart);
   80aa4:	4628      	mov	r0, r5
   80aa6:	4b55      	ldr	r3, [pc, #340]	; (80bfc <freertos_usart_serial_init+0x1a4>)
   80aa8:	4798      	blx	r3
		usart_disable_rx(p_usart);
   80aaa:	4628      	mov	r0, r5
   80aac:	4b54      	ldr	r3, [pc, #336]	; (80c00 <freertos_usart_serial_init+0x1a8>)
   80aae:	4798      	blx	r3
		pdc_disable_transfer(all_usart_definitions[usart_index].pdc_base_address,
   80ab0:	4f4c      	ldr	r7, [pc, #304]	; (80be4 <freertos_usart_serial_init+0x18c>)
   80ab2:	eb07 1704 	add.w	r7, r7, r4, lsl #4
   80ab6:	f8d7 8004 	ldr.w	r8, [r7, #4]
   80aba:	4640      	mov	r0, r8
   80abc:	f240 2102 	movw	r1, #514	; 0x202
   80ac0:	4b50      	ldr	r3, [pc, #320]	; (80c04 <freertos_usart_serial_init+0x1ac>)
   80ac2:	4798      	blx	r3
		Flexcom *p_flexcom = (Flexcom *)temp;
		flexcom_enable(p_flexcom);
		flexcom_set_opmode(p_flexcom, FLEXCOM_USART);
#else
		/* Enable the peripheral clock in the PMC. */
		pmc_enable_periph_clk(
   80ac4:	68b8      	ldr	r0, [r7, #8]
   80ac6:	4b50      	ldr	r3, [pc, #320]	; (80c08 <freertos_usart_serial_init+0x1b0>)
   80ac8:	4798      	blx	r3
				all_usart_definitions[usart_index].peripheral_id);
#endif

		switch (freertos_driver_parameters->operation_mode) {
   80aca:	7b33      	ldrb	r3, [r6, #12]
   80acc:	b923      	cbnz	r3, 80ad8 <freertos_usart_serial_init+0x80>
		case USART_RS232:
			/* Call the standard ASF init function. */
			usart_init_rs232(p_usart, uart_parameters,
   80ace:	4628      	mov	r0, r5
   80ad0:	4649      	mov	r1, r9
   80ad2:	4a4e      	ldr	r2, [pc, #312]	; (80c0c <freertos_usart_serial_init+0x1b4>)
   80ad4:	4b4e      	ldr	r3, [pc, #312]	; (80c10 <freertos_usart_serial_init+0x1b8>)
   80ad6:	4798      	blx	r3
			/* Other modes are not currently supported. */
			break;
		}

		/* Disable all the interrupts. */
		usart_disable_interrupt(p_usart, MASK_ALL_INTERRUPTS);
   80ad8:	4628      	mov	r0, r5
   80ada:	f04f 31ff 	mov.w	r1, #4294967295
   80ade:	4b4d      	ldr	r3, [pc, #308]	; (80c14 <freertos_usart_serial_init+0x1bc>)
   80ae0:	4798      	blx	r3

		/* Create any required peripheral access mutexes and transaction complete
		semaphores.  This peripheral is full duplex so only the Tx semaphores
		are created in the following function.  The the Rx semaphores are
		created	separately. */
		create_peripheral_control_semaphores(
   80ae2:	7b70      	ldrb	r0, [r6, #13]
   80ae4:	494c      	ldr	r1, [pc, #304]	; (80c18 <freertos_usart_serial_init+0x1c0>)
   80ae6:	eb01 01c4 	add.w	r1, r1, r4, lsl #3
   80aea:	2200      	movs	r2, #0
   80aec:	4b4b      	ldr	r3, [pc, #300]	; (80c1c <freertos_usart_serial_init+0x1c4>)
   80aee:	4798      	blx	r3
				freertos_driver_parameters->options_flags,
				&(tx_dma_control[usart_index]),
				NULL /* The rx structures are not created in this function. */);

		/* Is the driver also going to receive? */
		if (freertos_driver_parameters->receive_buffer != NULL) {
   80af0:	6833      	ldr	r3, [r6, #0]
   80af2:	2b00      	cmp	r3, #0
   80af4:	d055      	beq.n	80ba2 <freertos_usart_serial_init+0x14a>
			capped to that available up to the end of the buffer only.  If this
			semaphore was a binary semaphore, it would then be 'taken' even
			though, unknown to the reading task, unread and therefore available
			data remained at the beginning of the buffer. */
			rx_buffer_definitions[usart_index].rx_event_semaphore =
					xSemaphoreCreateCounting(portMAX_DELAY, 0);
   80af6:	f04f 30ff 	mov.w	r0, #4294967295
   80afa:	2100      	movs	r1, #0
   80afc:	4b48      	ldr	r3, [pc, #288]	; (80c20 <freertos_usart_serial_init+0x1c8>)
   80afe:	4798      	blx	r3
			and the end of the buffer, the actual amount returned will be
			capped to that available up to the end of the buffer only.  If this
			semaphore was a binary semaphore, it would then be 'taken' even
			though, unknown to the reading task, unread and therefore available
			data remained at the beginning of the buffer. */
			rx_buffer_definitions[usart_index].rx_event_semaphore =
   80b00:	ebc4 03c4 	rsb	r3, r4, r4, lsl #3
   80b04:	4a3a      	ldr	r2, [pc, #232]	; (80bf0 <freertos_usart_serial_init+0x198>)
   80b06:	eb02 0383 	add.w	r3, r2, r3, lsl #2
   80b0a:	6118      	str	r0, [r3, #16]
					xSemaphoreCreateCounting(portMAX_DELAY, 0);
			configASSERT(rx_buffer_definitions[usart_index].rx_event_semaphore);
   80b0c:	b920      	cbnz	r0, 80b18 <freertos_usart_serial_init+0xc0>
   80b0e:	4839      	ldr	r0, [pc, #228]	; (80bf4 <freertos_usart_serial_init+0x19c>)
   80b10:	f44f 7192 	mov.w	r1, #292	; 0x124
   80b14:	4b38      	ldr	r3, [pc, #224]	; (80bf8 <freertos_usart_serial_init+0x1a0>)
   80b16:	4798      	blx	r3

			/* Set the timeout to 5ms, then start waiting for a character (the
			timeout is not started until characters have started to	be
			received). */
			usart_set_rx_timeout(p_usart,
   80b18:	f8d9 1000 	ldr.w	r1, [r9]
   80b1c:	4b41      	ldr	r3, [pc, #260]	; (80c24 <freertos_usart_serial_init+0x1cc>)
   80b1e:	fba3 2101 	umull	r2, r1, r3, r1
   80b22:	4628      	mov	r0, r5
   80b24:	0989      	lsrs	r1, r1, #6
   80b26:	4b40      	ldr	r3, [pc, #256]	; (80c28 <freertos_usart_serial_init+0x1d0>)
   80b28:	4798      	blx	r3
					(uart_parameters->baudrate / BITS_PER_5_MS));
			usart_start_rx_timeout(p_usart);
   80b2a:	4628      	mov	r0, r5
   80b2c:	4b3f      	ldr	r3, [pc, #252]	; (80c2c <freertos_usart_serial_init+0x1d4>)
   80b2e:	4798      	blx	r3

			/* The receive buffer is currently empty, so the DMA has control
			over the entire buffer. */
			rx_buffer_definitions[usart_index].rx_pdc_parameters.ul_addr =
   80b30:	f8df 90bc 	ldr.w	r9, [pc, #188]	; 80bf0 <freertos_usart_serial_init+0x198>
   80b34:	00e3      	lsls	r3, r4, #3
   80b36:	ebc4 0a03 	rsb	sl, r4, r3
   80b3a:	ea4f 0a8a 	mov.w	sl, sl, lsl #2
   80b3e:	eb09 070a 	add.w	r7, r9, sl
   80b42:	6832      	ldr	r2, [r6, #0]
   80b44:	60ba      	str	r2, [r7, #8]
					(uint32_t)freertos_driver_parameters->receive_buffer;
			rx_buffer_definitions[usart_index].rx_pdc_parameters.ul_size =
					freertos_driver_parameters->receive_buffer_size;
   80b46:	6872      	ldr	r2, [r6, #4]

			/* The receive buffer is currently empty, so the DMA has control
			over the entire buffer. */
			rx_buffer_definitions[usart_index].rx_pdc_parameters.ul_addr =
					(uint32_t)freertos_driver_parameters->receive_buffer;
			rx_buffer_definitions[usart_index].rx_pdc_parameters.ul_size =
   80b48:	60fa      	str	r2, [r7, #12]
					freertos_driver_parameters->receive_buffer_size;
			pdc_rx_init(
   80b4a:	1b1b      	subs	r3, r3, r4
   80b4c:	eb09 0183 	add.w	r1, r9, r3, lsl #2
   80b50:	4640      	mov	r0, r8
   80b52:	3108      	adds	r1, #8
   80b54:	2200      	movs	r2, #0
   80b56:	4b36      	ldr	r3, [pc, #216]	; (80c30 <freertos_usart_serial_init+0x1d8>)
   80b58:	4798      	blx	r3
					NULL);

			/* Set the next byte to read to the start of the buffer as no data
			has yet been read. */
			rx_buffer_definitions[usart_index].next_byte_to_read =
					freertos_driver_parameters->receive_buffer;
   80b5a:	6833      	ldr	r3, [r6, #0]
					&(rx_buffer_definitions[usart_index].rx_pdc_parameters),
					NULL);

			/* Set the next byte to read to the start of the buffer as no data
			has yet been read. */
			rx_buffer_definitions[usart_index].next_byte_to_read =
   80b5c:	61bb      	str	r3, [r7, #24]
					freertos_driver_parameters->receive_buffer;

			/* Remember the limits of entire buffer. */
			rx_buffer_definitions[usart_index].rx_buffer_start_address =
					rx_buffer_definitions[usart_index].rx_pdc_parameters.ul_addr;
   80b5e:	68bb      	ldr	r3, [r7, #8]
			has yet been read. */
			rx_buffer_definitions[usart_index].next_byte_to_read =
					freertos_driver_parameters->receive_buffer;

			/* Remember the limits of entire buffer. */
			rx_buffer_definitions[usart_index].rx_buffer_start_address =
   80b60:	f849 300a 	str.w	r3, [r9, sl]
					rx_buffer_definitions[usart_index].rx_pdc_parameters.ul_addr;
			rx_buffer_definitions[usart_index].past_rx_buffer_end_address =
					rx_buffer_definitions[usart_index].rx_buffer_start_address +
   80b64:	6872      	ldr	r2, [r6, #4]
   80b66:	4413      	add	r3, r2
					freertos_driver_parameters->receive_buffer;

			/* Remember the limits of entire buffer. */
			rx_buffer_definitions[usart_index].rx_buffer_start_address =
					rx_buffer_definitions[usart_index].rx_pdc_parameters.ul_addr;
			rx_buffer_definitions[usart_index].past_rx_buffer_end_address =
   80b68:	607b      	str	r3, [r7, #4]
					rx_buffer_definitions[usart_index].rx_buffer_start_address +
					freertos_driver_parameters->receive_buffer_size;

			/* If the rx driver is to be thread aware, create an access control
			mutex. */
			if ((freertos_driver_parameters->options_flags &
   80b6a:	7b73      	ldrb	r3, [r6, #13]
   80b6c:	f013 0f02 	tst.w	r3, #2
   80b70:	d00d      	beq.n	80b8e <freertos_usart_serial_init+0x136>
					USE_RX_ACCESS_MUTEX) != 0) {
				rx_buffer_definitions[usart_index].rx_access_mutex =
					xSemaphoreCreateMutex();
   80b72:	2001      	movs	r0, #1
   80b74:	4b2f      	ldr	r3, [pc, #188]	; (80c34 <freertos_usart_serial_init+0x1dc>)
   80b76:	4798      	blx	r3

			/* If the rx driver is to be thread aware, create an access control
			mutex. */
			if ((freertos_driver_parameters->options_flags &
					USE_RX_ACCESS_MUTEX) != 0) {
				rx_buffer_definitions[usart_index].rx_access_mutex =
   80b78:	ebc4 03c4 	rsb	r3, r4, r4, lsl #3
   80b7c:	eb09 0383 	add.w	r3, r9, r3, lsl #2
   80b80:	6158      	str	r0, [r3, #20]
					xSemaphoreCreateMutex();
				configASSERT(rx_buffer_definitions[usart_index].rx_access_mutex);
   80b82:	b920      	cbnz	r0, 80b8e <freertos_usart_serial_init+0x136>
   80b84:	481b      	ldr	r0, [pc, #108]	; (80bf4 <freertos_usart_serial_init+0x19c>)
   80b86:	f44f 71a5 	mov.w	r1, #330	; 0x14a
   80b8a:	4b1b      	ldr	r3, [pc, #108]	; (80bf8 <freertos_usart_serial_init+0x1a0>)
   80b8c:	4798      	blx	r3
			}

			/* Catch the DMA running out of Rx space, and gaps in the
			reception.  These events are both used to signal that there is
			data available in the Rx buffer. */
			usart_enable_interrupt(p_usart, US_IER_ENDRX | US_IER_TIMEOUT);
   80b8e:	4628      	mov	r0, r5
   80b90:	f44f 7184 	mov.w	r1, #264	; 0x108
   80b94:	4b28      	ldr	r3, [pc, #160]	; (80c38 <freertos_usart_serial_init+0x1e0>)
   80b96:	4798      	blx	r3

			/* The Rx DMA is running all the time, so enable it now. */
			pdc_enable_transfer(
   80b98:	4640      	mov	r0, r8
   80b9a:	2101      	movs	r1, #1
   80b9c:	4b27      	ldr	r3, [pc, #156]	; (80c3c <freertos_usart_serial_init+0x1e4>)
   80b9e:	4798      	blx	r3
   80ba0:	e006      	b.n	80bb0 <freertos_usart_serial_init+0x158>
		} else {
			/* next_byte_to_read is used to check to see if this function
			has been called before, so it must be set to something, even if
			it is not going to be used.  The value it is set to is not
			important, provided it is not zero (NULL). */
			rx_buffer_definitions[usart_index].next_byte_to_read = RX_NOT_USED;
   80ba2:	ebc4 03c4 	rsb	r3, r4, r4, lsl #3
   80ba6:	4a12      	ldr	r2, [pc, #72]	; (80bf0 <freertos_usart_serial_init+0x198>)
   80ba8:	eb02 0383 	add.w	r3, r2, r3, lsl #2
   80bac:	2201      	movs	r2, #1
   80bae:	619a      	str	r2, [r3, #24]
		}

		/* Configure and enable the USART interrupt in the interrupt controller. */
		configure_interrupt_controller(all_usart_definitions[usart_index].peripheral_irq,
   80bb0:	4f0c      	ldr	r7, [pc, #48]	; (80be4 <freertos_usart_serial_init+0x18c>)
   80bb2:	0124      	lsls	r4, r4, #4
   80bb4:	193b      	adds	r3, r7, r4
   80bb6:	f993 000c 	ldrsb.w	r0, [r3, #12]
   80bba:	68b1      	ldr	r1, [r6, #8]
   80bbc:	4b20      	ldr	r3, [pc, #128]	; (80c40 <freertos_usart_serial_init+0x1e8>)
   80bbe:	4798      	blx	r3
				freertos_driver_parameters->interrupt_priority);

		/* Error interrupts are always enabled. */
		usart_enable_interrupt(
   80bc0:	5938      	ldr	r0, [r7, r4]
   80bc2:	21e0      	movs	r1, #224	; 0xe0
   80bc4:	4b1c      	ldr	r3, [pc, #112]	; (80c38 <freertos_usart_serial_init+0x1e0>)
   80bc6:	4798      	blx	r3
				all_usart_definitions[usart_index].peripheral_base_address,
				IER_ERROR_INTERRUPTS);

		/* Finally, enable the receiver and transmitter. */
		usart_enable_tx(p_usart);
   80bc8:	4628      	mov	r0, r5
   80bca:	4b1e      	ldr	r3, [pc, #120]	; (80c44 <freertos_usart_serial_init+0x1ec>)
   80bcc:	4798      	blx	r3
		usart_enable_rx(p_usart);
   80bce:	4628      	mov	r0, r5
   80bd0:	4b1d      	ldr	r3, [pc, #116]	; (80c48 <freertos_usart_serial_init+0x1f0>)
   80bd2:	4798      	blx	r3

		return_value = (freertos_usart_if) p_usart;
   80bd4:	e002      	b.n	80bdc <freertos_usart_serial_init+0x184>
	} else {
		return_value = NULL;
   80bd6:	2500      	movs	r5, #0
   80bd8:	e000      	b.n	80bdc <freertos_usart_serial_init+0x184>
   80bda:	2500      	movs	r5, #0
	}

	return return_value;
}
   80bdc:	4628      	mov	r0, r5
   80bde:	b002      	add	sp, #8
   80be0:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
   80be4:	0008b460 	.word	0x0008b460
   80be8:	000801cd 	.word	0x000801cd
   80bec:	000801f9 	.word	0x000801f9
   80bf0:	20070d50 	.word	0x20070d50
   80bf4:	0008b420 	.word	0x0008b420
   80bf8:	00085f89 	.word	0x00085f89
   80bfc:	000836fd 	.word	0x000836fd
   80c00:	0008370d 	.word	0x0008370d
   80c04:	00081ed9 	.word	0x00081ed9
   80c08:	00082209 	.word	0x00082209
   80c0c:	0501bd00 	.word	0x0501bd00
   80c10:	000836a1 	.word	0x000836a1
   80c14:	0008371d 	.word	0x0008371d
   80c18:	20070dc0 	.word	0x20070dc0
   80c1c:	00080229 	.word	0x00080229
   80c20:	00084581 	.word	0x00084581
   80c24:	51eb851f 	.word	0x51eb851f
   80c28:	00083715 	.word	0x00083715
   80c2c:	00083731 	.word	0x00083731
   80c30:	00081eb5 	.word	0x00081eb5
   80c34:	000846e1 	.word	0x000846e1
   80c38:	00083719 	.word	0x00083719
   80c3c:	00081ecd 	.word	0x00081ecd
   80c40:	000802dd 	.word	0x000802dd
   80c44:	000836f5 	.word	0x000836f5
   80c48:	00083705 	.word	0x00083705

00080c4c <freertos_usart_write_packet_async>:
 *     operation.
 */
status_code_t freertos_usart_write_packet_async(freertos_usart_if p_usart,
		const uint8_t *data, size_t len, portTickType block_time_ticks,
		xSemaphoreHandle notification_semaphore)
{
   80c4c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   80c50:	b084      	sub	sp, #16
   80c52:	4606      	mov	r6, r0
   80c54:	4688      	mov	r8, r1
   80c56:	4617      	mov	r7, r2
   80c58:	9303      	str	r3, [sp, #12]
	status_code_t return_value;
	portBASE_TYPE usart_index;
	Usart *usart_base;

	usart_base = (Usart *) p_usart;
	usart_index = get_pdc_peripheral_details(all_usart_definitions,
   80c5a:	4817      	ldr	r0, [pc, #92]	; (80cb8 <freertos_usart_write_packet_async+0x6c>)
   80c5c:	2104      	movs	r1, #4
   80c5e:	4632      	mov	r2, r6
   80c60:	4b16      	ldr	r3, [pc, #88]	; (80cbc <freertos_usart_write_packet_async+0x70>)
   80c62:	4798      	blx	r3
   80c64:	4604      	mov	r4, r0
			MAX_USARTS,
			(void *) usart_base);

	/* Don't do anything unless a valid USART pointer was used. */
	if (usart_index < MAX_USARTS) {
   80c66:	2803      	cmp	r0, #3
   80c68:	dc20      	bgt.n	80cac <freertos_usart_write_packet_async+0x60>
		return_value = freertos_obtain_peripheral_access_mutex(
   80c6a:	4d15      	ldr	r5, [pc, #84]	; (80cc0 <freertos_usart_write_packet_async+0x74>)
   80c6c:	eb05 05c0 	add.w	r5, r5, r0, lsl #3
   80c70:	4628      	mov	r0, r5
   80c72:	a903      	add	r1, sp, #12
   80c74:	4b13      	ldr	r3, [pc, #76]	; (80cc4 <freertos_usart_write_packet_async+0x78>)
   80c76:	4798      	blx	r3
				&(tx_dma_control[usart_index]),
				&block_time_ticks);

		if (return_value == STATUS_OK) {
   80c78:	4603      	mov	r3, r0
   80c7a:	b9c0      	cbnz	r0, 80cae <freertos_usart_write_packet_async+0x62>
			freertos_start_pdc_tx(&(tx_dma_control[usart_index]),
   80c7c:	4b0e      	ldr	r3, [pc, #56]	; (80cb8 <freertos_usart_write_packet_async+0x6c>)
   80c7e:	eb03 1404 	add.w	r4, r3, r4, lsl #4
   80c82:	6863      	ldr	r3, [r4, #4]
   80c84:	9a0a      	ldr	r2, [sp, #40]	; 0x28
   80c86:	9200      	str	r2, [sp, #0]
   80c88:	2201      	movs	r2, #1
   80c8a:	9201      	str	r2, [sp, #4]
   80c8c:	4628      	mov	r0, r5
   80c8e:	4641      	mov	r1, r8
   80c90:	463a      	mov	r2, r7
   80c92:	4c0d      	ldr	r4, [pc, #52]	; (80cc8 <freertos_usart_write_packet_async+0x7c>)
   80c94:	47a0      	blx	r4
			/* Catch the end of transmission so the access mutex can be
			returned, and the task notified (if it supplied a notification
			semaphore).  The interrupt can be enabled here because the ENDTX
			signal from the PDC to the USART will have been de-asserted when
			the next transfer was configured. */
			usart_enable_interrupt(usart_base, US_IER_ENDTX);
   80c96:	4630      	mov	r0, r6
   80c98:	2110      	movs	r1, #16
   80c9a:	4b0c      	ldr	r3, [pc, #48]	; (80ccc <freertos_usart_write_packet_async+0x80>)
   80c9c:	4798      	blx	r3

			return_value = freertos_optionally_wait_transfer_completion(
   80c9e:	4628      	mov	r0, r5
   80ca0:	990a      	ldr	r1, [sp, #40]	; 0x28
   80ca2:	9a03      	ldr	r2, [sp, #12]
   80ca4:	4b0a      	ldr	r3, [pc, #40]	; (80cd0 <freertos_usart_write_packet_async+0x84>)
   80ca6:	4798      	blx	r3
   80ca8:	4603      	mov	r3, r0
   80caa:	e000      	b.n	80cae <freertos_usart_write_packet_async+0x62>
					&(tx_dma_control[usart_index]),
					notification_semaphore,
					block_time_ticks);
		}
	} else {
		return_value = ERR_INVALID_ARG;
   80cac:	23f8      	movs	r3, #248	; 0xf8
	}

	return return_value;
}
   80cae:	b258      	sxtb	r0, r3
   80cb0:	b004      	add	sp, #16
   80cb2:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   80cb6:	bf00      	nop
   80cb8:	0008b460 	.word	0x0008b460
   80cbc:	000801cd 	.word	0x000801cd
   80cc0:	20070dc0 	.word	0x20070dc0
   80cc4:	000803d1 	.word	0x000803d1
   80cc8:	00080421 	.word	0x00080421
   80ccc:	00083719 	.word	0x00083719
   80cd0:	000804a1 	.word	0x000804a1

00080cd4 <freertos_usart_serial_read_packet>:
 * \return     The number of bytes that were copied into data.  This will be
 *     less than the requested number of bytes if a time out occurred.
 */
uint32_t freertos_usart_serial_read_packet(freertos_usart_if p_usart,
		uint8_t *data, uint32_t len, portTickType block_time_ticks)
{
   80cd4:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   80cd8:	b085      	sub	sp, #20
   80cda:	4604      	mov	r4, r0
   80cdc:	4688      	mov	r8, r1
   80cde:	4616      	mov	r6, r2
   80ce0:	9301      	str	r3, [sp, #4]
	Usart *usart_base;
	xTimeOutType time_out_definition;
	uint32_t bytes_read = 0;

	usart_base = (Usart *) p_usart;
	usart_index = get_pdc_peripheral_details(all_usart_definitions,
   80ce2:	484a      	ldr	r0, [pc, #296]	; (80e0c <freertos_usart_serial_read_packet+0x138>)
   80ce4:	2104      	movs	r1, #4
   80ce6:	4622      	mov	r2, r4
   80ce8:	4b49      	ldr	r3, [pc, #292]	; (80e10 <freertos_usart_serial_read_packet+0x13c>)
   80cea:	4798      	blx	r3
   80cec:	4605      	mov	r5, r0
			MAX_USARTS,
			(void *) usart_base);

	/* It is possible to initialise the peripheral to only use Tx and not Rx.
	Check that Rx has been initialised. */
	configASSERT(rx_buffer_definitions[usart_index].next_byte_to_read);
   80cee:	ebc0 02c0 	rsb	r2, r0, r0, lsl #3
   80cf2:	4b48      	ldr	r3, [pc, #288]	; (80e14 <freertos_usart_serial_read_packet+0x140>)
   80cf4:	eb03 0382 	add.w	r3, r3, r2, lsl #2
   80cf8:	699b      	ldr	r3, [r3, #24]
   80cfa:	b923      	cbnz	r3, 80d06 <freertos_usart_serial_read_packet+0x32>
   80cfc:	4846      	ldr	r0, [pc, #280]	; (80e18 <freertos_usart_serial_read_packet+0x144>)
   80cfe:	f44f 7108 	mov.w	r1, #544	; 0x220
   80d02:	4b46      	ldr	r3, [pc, #280]	; (80e1c <freertos_usart_serial_read_packet+0x148>)
   80d04:	4798      	blx	r3
	configASSERT(rx_buffer_definitions[usart_index].next_byte_to_read !=
   80d06:	ebc5 03c5 	rsb	r3, r5, r5, lsl #3
   80d0a:	4a42      	ldr	r2, [pc, #264]	; (80e14 <freertos_usart_serial_read_packet+0x140>)
   80d0c:	eb02 0383 	add.w	r3, r2, r3, lsl #2
   80d10:	699b      	ldr	r3, [r3, #24]
   80d12:	2b01      	cmp	r3, #1
   80d14:	d104      	bne.n	80d20 <freertos_usart_serial_read_packet+0x4c>
   80d16:	4840      	ldr	r0, [pc, #256]	; (80e18 <freertos_usart_serial_read_packet+0x144>)
   80d18:	f240 2122 	movw	r1, #546	; 0x222
   80d1c:	4b3f      	ldr	r3, [pc, #252]	; (80e1c <freertos_usart_serial_read_packet+0x148>)
   80d1e:	4798      	blx	r3
			RX_NOT_USED);

	/* Only do anything if the USART is valid. */
	if (usart_index < MAX_USARTS) {
   80d20:	2d03      	cmp	r5, #3
   80d22:	dc5b      	bgt.n	80ddc <freertos_usart_serial_read_packet+0x108>
		/* Must not request more bytes than will fit in the buffer. */
		if (len <=
				(rx_buffer_definitions[usart_index].past_rx_buffer_end_address
   80d24:	4a3b      	ldr	r2, [pc, #236]	; (80e14 <freertos_usart_serial_read_packet+0x140>)
   80d26:	ebc5 03c5 	rsb	r3, r5, r5, lsl #3
   80d2a:	009b      	lsls	r3, r3, #2
   80d2c:	18d1      	adds	r1, r2, r3
				- rx_buffer_definitions[usart_index].rx_buffer_start_address)) {
   80d2e:	6849      	ldr	r1, [r1, #4]
   80d30:	58d3      	ldr	r3, [r2, r3]
   80d32:	1acb      	subs	r3, r1, r3
			RX_NOT_USED);

	/* Only do anything if the USART is valid. */
	if (usart_index < MAX_USARTS) {
		/* Must not request more bytes than will fit in the buffer. */
		if (len <=
   80d34:	42b3      	cmp	r3, r6
   80d36:	d353      	bcc.n	80de0 <freertos_usart_serial_read_packet+0x10c>
				(rx_buffer_definitions[usart_index].past_rx_buffer_end_address
				- rx_buffer_definitions[usart_index].rx_buffer_start_address)) {
			/* Remember the time on entry. */
			vTaskSetTimeOutState(&time_out_definition);
   80d38:	a802      	add	r0, sp, #8
   80d3a:	4b39      	ldr	r3, [pc, #228]	; (80e20 <freertos_usart_serial_read_packet+0x14c>)
   80d3c:	4798      	blx	r3

			/* If an Rx mutex is in use, attempt to obtain it. */
			if (rx_buffer_definitions[usart_index].rx_access_mutex != NULL) {
   80d3e:	ebc5 03c5 	rsb	r3, r5, r5, lsl #3
   80d42:	4a34      	ldr	r2, [pc, #208]	; (80e14 <freertos_usart_serial_read_packet+0x140>)
   80d44:	eb02 0383 	add.w	r3, r2, r3, lsl #2
   80d48:	6958      	ldr	r0, [r3, #20]
   80d4a:	2800      	cmp	r0, #0
   80d4c:	d04c      	beq.n	80de8 <freertos_usart_serial_read_packet+0x114>
				/* Attempt to obtain the mutex. */
				attempt_read = xSemaphoreTake(
   80d4e:	2100      	movs	r1, #0
   80d50:	9a01      	ldr	r2, [sp, #4]
   80d52:	460b      	mov	r3, r1
   80d54:	4c33      	ldr	r4, [pc, #204]	; (80e24 <freertos_usart_serial_read_packet+0x150>)
   80d56:	47a0      	blx	r4
						rx_buffer_definitions[usart_index].rx_access_mutex,
						block_time_ticks);

				if (attempt_read == pdTRUE) {
   80d58:	2801      	cmp	r0, #1
   80d5a:	d143      	bne.n	80de4 <freertos_usart_serial_read_packet+0x110>
					/* The semaphore was obtained, adjust the block_time_ticks to take
					into account the time taken to obtain the semaphore. */
					if (xTaskCheckForTimeOut(&time_out_definition,
   80d5c:	a802      	add	r0, sp, #8
   80d5e:	a901      	add	r1, sp, #4
   80d60:	4b31      	ldr	r3, [pc, #196]	; (80e28 <freertos_usart_serial_read_packet+0x154>)
   80d62:	4798      	blx	r3
   80d64:	2801      	cmp	r0, #1
   80d66:	d13f      	bne.n	80de8 <freertos_usart_serial_read_packet+0x114>
							&block_time_ticks) == pdTRUE) {
						attempt_read = pdFALSE;

						/* The port is not going to be used, so return the
						mutex now. */
						xSemaphoreGive(rx_buffer_definitions[usart_index].rx_access_mutex);
   80d68:	ebc5 05c5 	rsb	r5, r5, r5, lsl #3
   80d6c:	4b29      	ldr	r3, [pc, #164]	; (80e14 <freertos_usart_serial_read_packet+0x140>)
   80d6e:	eb03 0385 	add.w	r3, r3, r5, lsl #2
   80d72:	6958      	ldr	r0, [r3, #20]
   80d74:	2100      	movs	r1, #0
   80d76:	460a      	mov	r2, r1
   80d78:	460b      	mov	r3, r1
   80d7a:	4c2c      	ldr	r4, [pc, #176]	; (80e2c <freertos_usart_serial_read_packet+0x158>)
   80d7c:	47a0      	blx	r4
   80d7e:	e031      	b.n	80de4 <freertos_usart_serial_read_packet+0x110>
			}

			if (attempt_read == pdTRUE) {
				do {
					/* Wait until data is available. */
					xSemaphoreTake(rx_buffer_definitions[usart_index].rx_event_semaphore,
   80d80:	6938      	ldr	r0, [r7, #16]
   80d82:	2100      	movs	r1, #0
   80d84:	9a01      	ldr	r2, [sp, #4]
   80d86:	460b      	mov	r3, r1
   80d88:	47d8      	blx	fp

					/* Copy as much data as is available, up to however much
					a maximum of the total number of requested bytes. */
					bytes_read += freertos_copy_bytes_from_pdc_circular_buffer(
							&(rx_buffer_definitions[usart_index]),
							all_usart_definitions[usart_index].pdc_base_address->PERIPH_RPR,
   80d8a:	f8da 3004 	ldr.w	r3, [sl, #4]
					xSemaphoreTake(rx_buffer_definitions[usart_index].rx_event_semaphore,
							block_time_ticks);

					/* Copy as much data as is available, up to however much
					a maximum of the total number of requested bytes. */
					bytes_read += freertos_copy_bytes_from_pdc_circular_buffer(
   80d8e:	6819      	ldr	r1, [r3, #0]
   80d90:	4638      	mov	r0, r7
   80d92:	eb08 0204 	add.w	r2, r8, r4
   80d96:	1b33      	subs	r3, r6, r4
   80d98:	47c8      	blx	r9

					/* The Rx DMA will have stopped if the Rx buffer had become
					full before this read operation.  If bytes were removed by
					this read then there is guaranteed to be space in the Rx
					buffer and the Rx DMA can be restarted. */
					if (bytes_read > 0) {
   80d9a:	1824      	adds	r4, r4, r0
   80d9c:	d009      	beq.n	80db2 <freertos_usart_serial_read_packet+0xde>
						taskENTER_CRITICAL();
   80d9e:	4b24      	ldr	r3, [pc, #144]	; (80e30 <freertos_usart_serial_read_packet+0x15c>)
   80da0:	4798      	blx	r3
						{
							if(rx_buffer_definitions[usart_index].rx_pdc_parameters.ul_size == 0UL) {
   80da2:	68fb      	ldr	r3, [r7, #12]
   80da4:	b91b      	cbnz	r3, 80dae <freertos_usart_serial_read_packet+0xda>
								configure_rx_dma(usart_index, data_removed);
   80da6:	4628      	mov	r0, r5
   80da8:	2101      	movs	r1, #1
   80daa:	4b22      	ldr	r3, [pc, #136]	; (80e34 <freertos_usart_serial_read_packet+0x160>)
   80dac:	4798      	blx	r3
							}
						}
						taskEXIT_CRITICAL();
   80dae:	4b22      	ldr	r3, [pc, #136]	; (80e38 <freertos_usart_serial_read_packet+0x164>)
   80db0:	4798      	blx	r3

				  /* Until all the requested bytes are received, or the function
				  runs out of time. */
				} while ((bytes_read < len) && (xTaskCheckForTimeOut(
						&time_out_definition,
						&block_time_ticks) == pdFALSE));
   80db2:	42a6      	cmp	r6, r4
   80db4:	d905      	bls.n	80dc2 <freertos_usart_serial_read_packet+0xee>
						taskEXIT_CRITICAL();
					}

				  /* Until all the requested bytes are received, or the function
				  runs out of time. */
				} while ((bytes_read < len) && (xTaskCheckForTimeOut(
   80db6:	a802      	add	r0, sp, #8
   80db8:	a901      	add	r1, sp, #4
   80dba:	4b1b      	ldr	r3, [pc, #108]	; (80e28 <freertos_usart_serial_read_packet+0x154>)
   80dbc:	4798      	blx	r3
   80dbe:	2800      	cmp	r0, #0
   80dc0:	d0de      	beq.n	80d80 <freertos_usart_serial_read_packet+0xac>
						&time_out_definition,
						&block_time_ticks) == pdFALSE));

				if (rx_buffer_definitions[usart_index].rx_access_mutex != NULL) {
   80dc2:	ebc5 05c5 	rsb	r5, r5, r5, lsl #3
   80dc6:	4b13      	ldr	r3, [pc, #76]	; (80e14 <freertos_usart_serial_read_packet+0x140>)
   80dc8:	eb03 0585 	add.w	r5, r3, r5, lsl #2
   80dcc:	6968      	ldr	r0, [r5, #20]
   80dce:	b1c8      	cbz	r0, 80e04 <freertos_usart_serial_read_packet+0x130>
					/* Return the mutex. */
					xSemaphoreGive(rx_buffer_definitions[usart_index].rx_access_mutex);
   80dd0:	2100      	movs	r1, #0
   80dd2:	460a      	mov	r2, r1
   80dd4:	460b      	mov	r3, r1
   80dd6:	4d15      	ldr	r5, [pc, #84]	; (80e2c <freertos_usart_serial_read_packet+0x158>)
   80dd8:	47a8      	blx	r5
   80dda:	e013      	b.n	80e04 <freertos_usart_serial_read_packet+0x130>
		uint8_t *data, uint32_t len, portTickType block_time_ticks)
{
	portBASE_TYPE usart_index, attempt_read;
	Usart *usart_base;
	xTimeOutType time_out_definition;
	uint32_t bytes_read = 0;
   80ddc:	2400      	movs	r4, #0
   80dde:	e011      	b.n	80e04 <freertos_usart_serial_read_packet+0x130>
   80de0:	2400      	movs	r4, #0
   80de2:	e00f      	b.n	80e04 <freertos_usart_serial_read_packet+0x130>
   80de4:	2400      	movs	r4, #0
   80de6:	e00d      	b.n	80e04 <freertos_usart_serial_read_packet+0x130>
 * \return     The number of bytes that were copied into data.  This will be
 *     less than the requested number of bytes if a time out occurred.
 */
uint32_t freertos_usart_serial_read_packet(freertos_usart_if p_usart,
		uint8_t *data, uint32_t len, portTickType block_time_ticks)
{
   80de8:	2400      	movs	r4, #0
			}

			if (attempt_read == pdTRUE) {
				do {
					/* Wait until data is available. */
					xSemaphoreTake(rx_buffer_definitions[usart_index].rx_event_semaphore,
   80dea:	ebc5 07c5 	rsb	r7, r5, r5, lsl #3
   80dee:	4b09      	ldr	r3, [pc, #36]	; (80e14 <freertos_usart_serial_read_packet+0x140>)
   80df0:	eb03 0787 	add.w	r7, r3, r7, lsl #2
   80df4:	f8df b02c 	ldr.w	fp, [pc, #44]	; 80e24 <freertos_usart_serial_read_packet+0x150>

					/* Copy as much data as is available, up to however much
					a maximum of the total number of requested bytes. */
					bytes_read += freertos_copy_bytes_from_pdc_circular_buffer(
							&(rx_buffer_definitions[usart_index]),
							all_usart_definitions[usart_index].pdc_base_address->PERIPH_RPR,
   80df8:	4b04      	ldr	r3, [pc, #16]	; (80e0c <freertos_usart_serial_read_packet+0x138>)
   80dfa:	eb03 1a05 	add.w	sl, r3, r5, lsl #4
					xSemaphoreTake(rx_buffer_definitions[usart_index].rx_event_semaphore,
							block_time_ticks);

					/* Copy as much data as is available, up to however much
					a maximum of the total number of requested bytes. */
					bytes_read += freertos_copy_bytes_from_pdc_circular_buffer(
   80dfe:	f8df 903c 	ldr.w	r9, [pc, #60]	; 80e3c <freertos_usart_serial_read_packet+0x168>
   80e02:	e7bd      	b.n	80d80 <freertos_usart_serial_read_packet+0xac>
			}
		}
	}

	return bytes_read;
}
   80e04:	4620      	mov	r0, r4
   80e06:	b005      	add	sp, #20
   80e08:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   80e0c:	0008b460 	.word	0x0008b460
   80e10:	000801cd 	.word	0x000801cd
   80e14:	20070d50 	.word	0x20070d50
   80e18:	0008b420 	.word	0x0008b420
   80e1c:	00085f89 	.word	0x00085f89
   80e20:	000855dd 	.word	0x000855dd
   80e24:	000847e9 	.word	0x000847e9
   80e28:	0008560d 	.word	0x0008560d
   80e2c:	000845b1 	.word	0x000845b1
   80e30:	00084139 	.word	0x00084139
   80e34:	00080881 	.word	0x00080881
   80e38:	00084159 	.word	0x00084159
   80e3c:	00080349 	.word	0x00080349

00080e40 <USART0_Handler>:
#endif /* USART */

#ifdef USART0

void USART0_Handler(void)
{
   80e40:	b508      	push	{r3, lr}
	local_usart_handler(0);
   80e42:	2000      	movs	r0, #0
   80e44:	4b01      	ldr	r3, [pc, #4]	; (80e4c <USART0_Handler+0xc>)
   80e46:	4798      	blx	r3
   80e48:	bd08      	pop	{r3, pc}
   80e4a:	bf00      	nop
   80e4c:	00080921 	.word	0x00080921

00080e50 <USART1_Handler>:
#endif /* USART0 */

#ifdef USART1

void USART1_Handler(void)
{
   80e50:	b508      	push	{r3, lr}
	local_usart_handler(1);
   80e52:	2001      	movs	r0, #1
   80e54:	4b01      	ldr	r3, [pc, #4]	; (80e5c <USART1_Handler+0xc>)
   80e56:	4798      	blx	r3
   80e58:	bd08      	pop	{r3, pc}
   80e5a:	bf00      	nop
   80e5c:	00080921 	.word	0x00080921

00080e60 <USART2_Handler>:
#endif /* USART1 */

#ifdef USART2

void USART2_Handler(void)
{
   80e60:	b508      	push	{r3, lr}
	local_usart_handler(2);
   80e62:	2002      	movs	r0, #2
   80e64:	4b01      	ldr	r3, [pc, #4]	; (80e6c <USART2_Handler+0xc>)
   80e66:	4798      	blx	r3
   80e68:	bd08      	pop	{r3, pc}
   80e6a:	bf00      	nop
   80e6c:	00080921 	.word	0x00080921

00080e70 <USART3_Handler>:
#endif /* USART2 */

#ifdef USART3

void USART3_Handler(void)
{
   80e70:	b508      	push	{r3, lr}
	local_usart_handler(3);
   80e72:	2003      	movs	r0, #3
   80e74:	4b01      	ldr	r3, [pc, #4]	; (80e7c <USART3_Handler+0xc>)
   80e76:	4798      	blx	r3
   80e78:	bd08      	pop	{r3, pc}
   80e7a:	bf00      	nop
   80e7c:	00080921 	.word	0x00080921

00080e80 <udi_cdc_comm_disable>:
}

void udi_cdc_comm_disable(void)
{
	Assert(udi_cdc_nb_comm_enabled != 0);
	udi_cdc_nb_comm_enabled--;
   80e80:	4b02      	ldr	r3, [pc, #8]	; (80e8c <udi_cdc_comm_disable+0xc>)
   80e82:	781a      	ldrb	r2, [r3, #0]
   80e84:	3a01      	subs	r2, #1
   80e86:	b2d2      	uxtb	r2, r2
   80e88:	701a      	strb	r2, [r3, #0]
   80e8a:	4770      	bx	lr
   80e8c:	200711f8 	.word	0x200711f8

00080e90 <udi_cdc_data_setup>:
}

bool udi_cdc_data_setup(void)
{
	return false;  // request Not supported
}
   80e90:	2000      	movs	r0, #0
   80e92:	4770      	bx	lr

00080e94 <udi_cdc_getsetting>:

uint8_t udi_cdc_getsetting(void)
{
	return 0;      // CDC don't have multiple alternate setting
}
   80e94:	2000      	movs	r0, #0
   80e96:	4770      	bx	lr

00080e98 <udi_cdc_comm_setup>:

bool udi_cdc_comm_setup(void)
{
	uint8_t port = udi_cdc_setup_to_port();

	if (Udd_setup_is_in()) {
   80e98:	4b1d      	ldr	r3, [pc, #116]	; (80f10 <udi_cdc_comm_setup+0x78>)
   80e9a:	781b      	ldrb	r3, [r3, #0]
   80e9c:	f013 0f80 	tst.w	r3, #128	; 0x80
   80ea0:	d012      	beq.n	80ec8 <udi_cdc_comm_setup+0x30>
		// GET Interface Requests
		if (Udd_setup_type() == USB_REQ_TYPE_CLASS) {
   80ea2:	f003 0360 	and.w	r3, r3, #96	; 0x60
   80ea6:	2b20      	cmp	r3, #32
   80ea8:	d128      	bne.n	80efc <udi_cdc_comm_setup+0x64>
			// Requests Class Interface Get
			switch (udd_g_ctrlreq.req.bRequest) {
   80eaa:	4b19      	ldr	r3, [pc, #100]	; (80f10 <udi_cdc_comm_setup+0x78>)
   80eac:	785b      	ldrb	r3, [r3, #1]
   80eae:	2b21      	cmp	r3, #33	; 0x21
   80eb0:	d126      	bne.n	80f00 <udi_cdc_comm_setup+0x68>
			case USB_REQ_CDC_GET_LINE_CODING:
				// Get configuration of CDC line
				if (sizeof(usb_cdc_line_coding_t) !=
						udd_g_ctrlreq.req.wLength)
   80eb2:	4b17      	ldr	r3, [pc, #92]	; (80f10 <udi_cdc_comm_setup+0x78>)
		if (Udd_setup_type() == USB_REQ_TYPE_CLASS) {
			// Requests Class Interface Get
			switch (udd_g_ctrlreq.req.bRequest) {
			case USB_REQ_CDC_GET_LINE_CODING:
				// Get configuration of CDC line
				if (sizeof(usb_cdc_line_coding_t) !=
   80eb4:	88db      	ldrh	r3, [r3, #6]
   80eb6:	2b07      	cmp	r3, #7
   80eb8:	d124      	bne.n	80f04 <udi_cdc_comm_setup+0x6c>
						udd_g_ctrlreq.req.wLength)
					return false; // Error for USB host
				udd_g_ctrlreq.payload =
   80eba:	4b15      	ldr	r3, [pc, #84]	; (80f10 <udi_cdc_comm_setup+0x78>)
   80ebc:	4a15      	ldr	r2, [pc, #84]	; (80f14 <udi_cdc_comm_setup+0x7c>)
   80ebe:	609a      	str	r2, [r3, #8]
						(uint8_t *) &
						udi_cdc_line_coding[port];
				udd_g_ctrlreq.payload_size =
   80ec0:	2207      	movs	r2, #7
   80ec2:	819a      	strh	r2, [r3, #12]
						sizeof(usb_cdc_line_coding_t);
				return true;
   80ec4:	2001      	movs	r0, #1
   80ec6:	4770      	bx	lr
			}
		}
	}
	if (Udd_setup_is_out()) {
		// SET Interface Requests
		if (Udd_setup_type() == USB_REQ_TYPE_CLASS) {
   80ec8:	f003 0360 	and.w	r3, r3, #96	; 0x60
   80ecc:	2b20      	cmp	r3, #32
   80ece:	d11b      	bne.n	80f08 <udi_cdc_comm_setup+0x70>
			// Requests Class Interface Set
			switch (udd_g_ctrlreq.req.bRequest) {
   80ed0:	4b0f      	ldr	r3, [pc, #60]	; (80f10 <udi_cdc_comm_setup+0x78>)
   80ed2:	7858      	ldrb	r0, [r3, #1]
   80ed4:	2820      	cmp	r0, #32
   80ed6:	d004      	beq.n	80ee2 <udi_cdc_comm_setup+0x4a>
						 & CDC_CTRL_SIGNAL_ACTIVATE_CARRIER)));
				return true;
			}
		}
	}
	return false;  // request Not supported
   80ed8:	2822      	cmp	r0, #34	; 0x22
   80eda:	bf14      	ite	ne
   80edc:	2000      	movne	r0, #0
   80ede:	2001      	moveq	r0, #1
   80ee0:	4770      	bx	lr
			// Requests Class Interface Set
			switch (udd_g_ctrlreq.req.bRequest) {
			case USB_REQ_CDC_SET_LINE_CODING:
				// Change configuration of CDC line
				if (sizeof(usb_cdc_line_coding_t) !=
						udd_g_ctrlreq.req.wLength)
   80ee2:	4b0b      	ldr	r3, [pc, #44]	; (80f10 <udi_cdc_comm_setup+0x78>)
		if (Udd_setup_type() == USB_REQ_TYPE_CLASS) {
			// Requests Class Interface Set
			switch (udd_g_ctrlreq.req.bRequest) {
			case USB_REQ_CDC_SET_LINE_CODING:
				// Change configuration of CDC line
				if (sizeof(usb_cdc_line_coding_t) !=
   80ee4:	88db      	ldrh	r3, [r3, #6]
   80ee6:	2b07      	cmp	r3, #7
   80ee8:	d110      	bne.n	80f0c <udi_cdc_comm_setup+0x74>
						udd_g_ctrlreq.req.wLength)
					return false; // Error for USB host
				udd_g_ctrlreq.callback =
   80eea:	4b09      	ldr	r3, [pc, #36]	; (80f10 <udi_cdc_comm_setup+0x78>)
   80eec:	4a0a      	ldr	r2, [pc, #40]	; (80f18 <udi_cdc_comm_setup+0x80>)
   80eee:	611a      	str	r2, [r3, #16]
						udi_cdc_line_coding_received;
				udd_g_ctrlreq.payload =
   80ef0:	4a08      	ldr	r2, [pc, #32]	; (80f14 <udi_cdc_comm_setup+0x7c>)
   80ef2:	609a      	str	r2, [r3, #8]
						(uint8_t *) &
						udi_cdc_line_coding[port];
				udd_g_ctrlreq.payload_size =
   80ef4:	2207      	movs	r2, #7
   80ef6:	819a      	strh	r2, [r3, #12]
						sizeof(usb_cdc_line_coding_t);
				return true;
   80ef8:	2001      	movs	r0, #1
   80efa:	4770      	bx	lr
						 & CDC_CTRL_SIGNAL_ACTIVATE_CARRIER)));
				return true;
			}
		}
	}
	return false;  // request Not supported
   80efc:	2000      	movs	r0, #0
   80efe:	4770      	bx	lr
   80f00:	2000      	movs	r0, #0
   80f02:	4770      	bx	lr
			switch (udd_g_ctrlreq.req.bRequest) {
			case USB_REQ_CDC_GET_LINE_CODING:
				// Get configuration of CDC line
				if (sizeof(usb_cdc_line_coding_t) !=
						udd_g_ctrlreq.req.wLength)
					return false; // Error for USB host
   80f04:	2000      	movs	r0, #0
   80f06:	4770      	bx	lr
						 & CDC_CTRL_SIGNAL_ACTIVATE_CARRIER)));
				return true;
			}
		}
	}
	return false;  // request Not supported
   80f08:	2000      	movs	r0, #0
   80f0a:	4770      	bx	lr
			switch (udd_g_ctrlreq.req.bRequest) {
			case USB_REQ_CDC_SET_LINE_CODING:
				// Change configuration of CDC line
				if (sizeof(usb_cdc_line_coding_t) !=
						udd_g_ctrlreq.req.wLength)
					return false; // Error for USB host
   80f0c:	2000      	movs	r0, #0
				return true;
			}
		}
	}
	return false;  // request Not supported
}
   80f0e:	4770      	bx	lr
   80f10:	20075c44 	.word	0x20075c44
   80f14:	20070de0 	.word	0x20070de0
   80f18:	00080f1d 	.word	0x00080f1d

00080f1c <udi_cdc_line_coding_received>:
	}
	return port;
}

static void udi_cdc_line_coding_received(void)
{
   80f1c:	4770      	bx	lr
   80f1e:	bf00      	nop

00080f20 <udi_cdc_comm_enable>:
static volatile bool udi_cdc_tx_both_buf_to_send[UDI_CDC_PORT_NB];

//@}

bool udi_cdc_comm_enable(void)
{
   80f20:	b508      	push	{r3, lr}
	uint8_t port;
	uint8_t iface_comm_num;

#if UDI_CDC_PORT_NB == 1 // To optimize code
	port = 0;
	udi_cdc_nb_comm_enabled = 0;
   80f22:	2000      	movs	r0, #0
   80f24:	4b10      	ldr	r3, [pc, #64]	; (80f68 <udi_cdc_comm_enable+0x48>)
   80f26:	7018      	strb	r0, [r3, #0]
	}
	port = udi_cdc_nb_comm_enabled;
#endif

	// Initialize control signal management
	udi_cdc_state[port] = CPU_TO_LE16(0);
   80f28:	4b10      	ldr	r3, [pc, #64]	; (80f6c <udi_cdc_comm_enable+0x4c>)
   80f2a:	8018      	strh	r0, [r3, #0]

	uid_cdc_state_msg[port].header.bmRequestType =
   80f2c:	4b10      	ldr	r3, [pc, #64]	; (80f70 <udi_cdc_comm_enable+0x50>)
   80f2e:	22a1      	movs	r2, #161	; 0xa1
   80f30:	701a      	strb	r2, [r3, #0]
			USB_REQ_DIR_IN | USB_REQ_TYPE_CLASS |
			USB_REQ_RECIP_INTERFACE;
	uid_cdc_state_msg[port].header.bNotification = USB_REQ_CDC_NOTIFY_SERIAL_STATE;
   80f32:	2220      	movs	r2, #32
   80f34:	705a      	strb	r2, [r3, #1]
	uid_cdc_state_msg[port].header.wValue = LE16(0);
   80f36:	8058      	strh	r0, [r3, #2]
	default:
		iface_comm_num = UDI_CDC_COMM_IFACE_NUMBER_0;
		break;
	}

	uid_cdc_state_msg[port].header.wIndex = LE16(iface_comm_num);
   80f38:	8098      	strh	r0, [r3, #4]
	uid_cdc_state_msg[port].header.wLength = LE16(2);
   80f3a:	2202      	movs	r2, #2
   80f3c:	80da      	strh	r2, [r3, #6]
	uid_cdc_state_msg[port].value = CPU_TO_LE16(0);
   80f3e:	8118      	strh	r0, [r3, #8]

	udi_cdc_line_coding[port].dwDTERate = CPU_TO_LE32(UDI_CDC_DEFAULT_RATE);
   80f40:	4b0c      	ldr	r3, [pc, #48]	; (80f74 <udi_cdc_comm_enable+0x54>)
   80f42:	f44f 32e1 	mov.w	r2, #115200	; 0x1c200
   80f46:	601a      	str	r2, [r3, #0]
	udi_cdc_line_coding[port].bCharFormat = UDI_CDC_DEFAULT_STOPBITS;
   80f48:	7118      	strb	r0, [r3, #4]
	udi_cdc_line_coding[port].bParityType = UDI_CDC_DEFAULT_PARITY;
   80f4a:	7158      	strb	r0, [r3, #5]
	udi_cdc_line_coding[port].bDataBits = UDI_CDC_DEFAULT_DATABITS;
   80f4c:	2208      	movs	r2, #8
   80f4e:	719a      	strb	r2, [r3, #6]
	// Call application callback
	// to initialize memories or indicate that interface is enabled
	UDI_CDC_SET_CODING_EXT(port,(&udi_cdc_line_coding[port]));
	if (!UDI_CDC_ENABLE_EXT(port)) {
   80f50:	4b09      	ldr	r3, [pc, #36]	; (80f78 <udi_cdc_comm_enable+0x58>)
   80f52:	4798      	blx	r3
   80f54:	4603      	mov	r3, r0
   80f56:	b120      	cbz	r0, 80f62 <udi_cdc_comm_enable+0x42>
		return false;
	}
	udi_cdc_nb_comm_enabled++;
   80f58:	4a03      	ldr	r2, [pc, #12]	; (80f68 <udi_cdc_comm_enable+0x48>)
   80f5a:	7811      	ldrb	r1, [r2, #0]
   80f5c:	3101      	adds	r1, #1
   80f5e:	b2c9      	uxtb	r1, r1
   80f60:	7011      	strb	r1, [r2, #0]
	return true;
}
   80f62:	4618      	mov	r0, r3
   80f64:	bd08      	pop	{r3, pc}
   80f66:	bf00      	nop
   80f68:	200711f8 	.word	0x200711f8
   80f6c:	20071628 	.word	0x20071628
   80f70:	20071214 	.word	0x20071214
   80f74:	20070de0 	.word	0x20070de0
   80f78:	00083dc9 	.word	0x00083dc9

00080f7c <udi_cdc_tx_send>:
	udi_cdc_tx_send(port);
}


static void udi_cdc_tx_send(uint8_t port)
{
   80f7c:	b530      	push	{r4, r5, lr}
   80f7e:	b083      	sub	sp, #12

#if UDI_CDC_PORT_NB == 1 // To optimize code
	port = 0;
#endif

	if (udi_cdc_tx_trans_ongoing[port]) {
   80f80:	4b43      	ldr	r3, [pc, #268]	; (81090 <udi_cdc_tx_send+0x114>)
   80f82:	781b      	ldrb	r3, [r3, #0]
   80f84:	f013 0fff 	tst.w	r3, #255	; 0xff
   80f88:	d17f      	bne.n	8108a <udi_cdc_tx_send+0x10e>
		return; // Already on going or wait next SOF to send next data
	}
	if (udd_is_high_speed()) {
   80f8a:	4b42      	ldr	r3, [pc, #264]	; (81094 <udi_cdc_tx_send+0x118>)
   80f8c:	4798      	blx	r3
   80f8e:	b130      	cbz	r0, 80f9e <udi_cdc_tx_send+0x22>
		if (udi_cdc_tx_sof_num[port] == udd_get_micro_frame_number()) {
   80f90:	4b41      	ldr	r3, [pc, #260]	; (81098 <udi_cdc_tx_send+0x11c>)
   80f92:	881c      	ldrh	r4, [r3, #0]
   80f94:	4b41      	ldr	r3, [pc, #260]	; (8109c <udi_cdc_tx_send+0x120>)
   80f96:	4798      	blx	r3
   80f98:	4284      	cmp	r4, r0
   80f9a:	d106      	bne.n	80faa <udi_cdc_tx_send+0x2e>
   80f9c:	e075      	b.n	8108a <udi_cdc_tx_send+0x10e>
			return; // Wait next SOF to send next data
		}
	}else{
		if (udi_cdc_tx_sof_num[port] == udd_get_frame_number()) {
   80f9e:	4b3e      	ldr	r3, [pc, #248]	; (81098 <udi_cdc_tx_send+0x11c>)
   80fa0:	881c      	ldrh	r4, [r3, #0]
   80fa2:	4b3f      	ldr	r3, [pc, #252]	; (810a0 <udi_cdc_tx_send+0x124>)
   80fa4:	4798      	blx	r3
   80fa6:	4284      	cmp	r4, r0
   80fa8:	d06f      	beq.n	8108a <udi_cdc_tx_send+0x10e>
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_PRIMASK(void)
{
  uint32_t result;

  __ASM volatile ("MRS %0, primask" : "=r" (result) );
   80faa:	f3ef 8310 	mrs	r3, PRIMASK
static volatile uint32_t cpu_irq_critical_section_counter;
static volatile bool     cpu_irq_prev_interrupt_state;

static inline irqflags_t cpu_irq_save(void)
{
	irqflags_t flags = cpu_irq_is_enabled();
   80fae:	f1d3 0501 	rsbs	r5, r3, #1
   80fb2:	bf38      	it	cc
   80fb4:	2500      	movcc	r5, #0
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
   80fb6:	b672      	cpsid	i
    This function ensures the apparent order of the explicit memory operations before
    and after the instruction, without ensuring their completion.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __DMB(void)
{
  __ASM volatile ("dmb");
   80fb8:	f3bf 8f5f 	dmb	sy
	cpu_irq_disable();
   80fbc:	2200      	movs	r2, #0
   80fbe:	4b39      	ldr	r3, [pc, #228]	; (810a4 <udi_cdc_tx_send+0x128>)
   80fc0:	701a      	strb	r2, [r3, #0]
			return; // Wait next SOF to send next data
		}
	}

	flags = cpu_irq_save(); // to protect udi_cdc_tx_buf_sel
	buf_sel_trans = udi_cdc_tx_buf_sel[port];
   80fc2:	4b39      	ldr	r3, [pc, #228]	; (810a8 <udi_cdc_tx_send+0x12c>)
   80fc4:	781c      	ldrb	r4, [r3, #0]
   80fc6:	b2e4      	uxtb	r4, r4
	if (udi_cdc_tx_buf_nb[port][buf_sel_trans] == 0) {
   80fc8:	4b38      	ldr	r3, [pc, #224]	; (810ac <udi_cdc_tx_send+0x130>)
   80fca:	f833 3014 	ldrh.w	r3, [r3, r4, lsl #1]
   80fce:	b9db      	cbnz	r3, 81008 <udi_cdc_tx_send+0x8c>
		sof_zlp_counter++;
   80fd0:	4b37      	ldr	r3, [pc, #220]	; (810b0 <udi_cdc_tx_send+0x134>)
   80fd2:	881a      	ldrh	r2, [r3, #0]
   80fd4:	3201      	adds	r2, #1
   80fd6:	801a      	strh	r2, [r3, #0]
		if (((!udd_is_high_speed()) && (sof_zlp_counter < 100))
   80fd8:	4b2e      	ldr	r3, [pc, #184]	; (81094 <udi_cdc_tx_send+0x118>)
   80fda:	4798      	blx	r3
   80fdc:	b918      	cbnz	r0, 80fe6 <udi_cdc_tx_send+0x6a>
   80fde:	4b34      	ldr	r3, [pc, #208]	; (810b0 <udi_cdc_tx_send+0x134>)
   80fe0:	881b      	ldrh	r3, [r3, #0]
   80fe2:	2b63      	cmp	r3, #99	; 0x63
   80fe4:	d907      	bls.n	80ff6 <udi_cdc_tx_send+0x7a>
				|| (udd_is_high_speed() && (sof_zlp_counter < 800))) {
   80fe6:	4b2b      	ldr	r3, [pc, #172]	; (81094 <udi_cdc_tx_send+0x118>)
   80fe8:	4798      	blx	r3
   80fea:	b168      	cbz	r0, 81008 <udi_cdc_tx_send+0x8c>
   80fec:	4b30      	ldr	r3, [pc, #192]	; (810b0 <udi_cdc_tx_send+0x134>)
   80fee:	881b      	ldrh	r3, [r3, #0]
   80ff0:	f5b3 7f48 	cmp.w	r3, #800	; 0x320
   80ff4:	d208      	bcs.n	81008 <udi_cdc_tx_send+0x8c>
	return (flags);
}

static inline void cpu_irq_restore(irqflags_t flags)
{
	if (cpu_irq_is_enabled_flags(flags))
   80ff6:	2d00      	cmp	r5, #0
   80ff8:	d047      	beq.n	8108a <udi_cdc_tx_send+0x10e>
		cpu_irq_enable();
   80ffa:	2201      	movs	r2, #1
   80ffc:	4b29      	ldr	r3, [pc, #164]	; (810a4 <udi_cdc_tx_send+0x128>)
   80ffe:	701a      	strb	r2, [r3, #0]
   81000:	f3bf 8f5f 	dmb	sy
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
   81004:	b662      	cpsie	i
   81006:	e040      	b.n	8108a <udi_cdc_tx_send+0x10e>
			cpu_irq_restore(flags);
			return;
		}
	}
	sof_zlp_counter = 0;
   81008:	2200      	movs	r2, #0
   8100a:	4b29      	ldr	r3, [pc, #164]	; (810b0 <udi_cdc_tx_send+0x134>)
   8100c:	801a      	strh	r2, [r3, #0]

	if (!udi_cdc_tx_both_buf_to_send[port]) {
   8100e:	4b29      	ldr	r3, [pc, #164]	; (810b4 <udi_cdc_tx_send+0x138>)
   81010:	781b      	ldrb	r3, [r3, #0]
   81012:	f013 0fff 	tst.w	r3, #255	; 0xff
   81016:	d106      	bne.n	81026 <udi_cdc_tx_send+0xaa>
		// Send current Buffer
		// and switch the current buffer
		udi_cdc_tx_buf_sel[port] = (buf_sel_trans==0)?1:0;
   81018:	4294      	cmp	r4, r2
   8101a:	bf14      	ite	ne
   8101c:	2200      	movne	r2, #0
   8101e:	2201      	moveq	r2, #1
   81020:	4b21      	ldr	r3, [pc, #132]	; (810a8 <udi_cdc_tx_send+0x12c>)
   81022:	701a      	strb	r2, [r3, #0]
   81024:	e003      	b.n	8102e <udi_cdc_tx_send+0xb2>
	}else{
		// Send the other Buffer
		// and no switch the current buffer
		buf_sel_trans = (buf_sel_trans==0)?1:0;
   81026:	f1d4 0401 	rsbs	r4, r4, #1
   8102a:	bf38      	it	cc
   8102c:	2400      	movcc	r4, #0
	}
	udi_cdc_tx_trans_ongoing[port] = true;
   8102e:	2201      	movs	r2, #1
   81030:	4b17      	ldr	r3, [pc, #92]	; (81090 <udi_cdc_tx_send+0x114>)
   81032:	701a      	strb	r2, [r3, #0]
	return (flags);
}

static inline void cpu_irq_restore(irqflags_t flags)
{
	if (cpu_irq_is_enabled_flags(flags))
   81034:	b125      	cbz	r5, 81040 <udi_cdc_tx_send+0xc4>
		cpu_irq_enable();
   81036:	4b1b      	ldr	r3, [pc, #108]	; (810a4 <udi_cdc_tx_send+0x128>)
   81038:	701a      	strb	r2, [r3, #0]
   8103a:	f3bf 8f5f 	dmb	sy
   8103e:	b662      	cpsie	i
	cpu_irq_restore(flags);

	b_short_packet = (udi_cdc_tx_buf_nb[port][buf_sel_trans] != UDI_CDC_TX_BUFFERS);
   81040:	4625      	mov	r5, r4
   81042:	4b1a      	ldr	r3, [pc, #104]	; (810ac <udi_cdc_tx_send+0x130>)
   81044:	f833 4014 	ldrh.w	r4, [r3, r4, lsl #1]
   81048:	f5b4 7400 	subs.w	r4, r4, #512	; 0x200
   8104c:	bf18      	it	ne
   8104e:	2401      	movne	r4, #1
	if (b_short_packet) {
   81050:	b164      	cbz	r4, 8106c <udi_cdc_tx_send+0xf0>
		if (udd_is_high_speed()) {
   81052:	4b10      	ldr	r3, [pc, #64]	; (81094 <udi_cdc_tx_send+0x118>)
   81054:	4798      	blx	r3
   81056:	b120      	cbz	r0, 81062 <udi_cdc_tx_send+0xe6>
			udi_cdc_tx_sof_num[port] = udd_get_micro_frame_number();
   81058:	4b10      	ldr	r3, [pc, #64]	; (8109c <udi_cdc_tx_send+0x120>)
   8105a:	4798      	blx	r3
   8105c:	4b0e      	ldr	r3, [pc, #56]	; (81098 <udi_cdc_tx_send+0x11c>)
   8105e:	8018      	strh	r0, [r3, #0]
   81060:	e007      	b.n	81072 <udi_cdc_tx_send+0xf6>
		}else{
			udi_cdc_tx_sof_num[port] = udd_get_frame_number();
   81062:	4b0f      	ldr	r3, [pc, #60]	; (810a0 <udi_cdc_tx_send+0x124>)
   81064:	4798      	blx	r3
   81066:	4b0c      	ldr	r3, [pc, #48]	; (81098 <udi_cdc_tx_send+0x11c>)
   81068:	8018      	strh	r0, [r3, #0]
   8106a:	e002      	b.n	81072 <udi_cdc_tx_send+0xf6>
		}
	}else{
		udi_cdc_tx_sof_num[port] = 0; // Force next transfer without wait SOF
   8106c:	2200      	movs	r2, #0
   8106e:	4b0a      	ldr	r3, [pc, #40]	; (81098 <udi_cdc_tx_send+0x11c>)
   81070:	801a      	strh	r2, [r3, #0]
		break;
	}
	udd_ep_run( ep,
			b_short_packet,
			udi_cdc_tx_buf[port][buf_sel_trans],
			udi_cdc_tx_buf_nb[port][buf_sel_trans],
   81072:	4b0e      	ldr	r3, [pc, #56]	; (810ac <udi_cdc_tx_send+0x130>)
#undef UDI_CDC_PORT_TO_DATA_EP_IN
	default:
		ep = UDI_CDC_DATA_EP_IN_0;
		break;
	}
	udd_ep_run( ep,
   81074:	f833 3015 	ldrh.w	r3, [r3, r5, lsl #1]
   81078:	4a0f      	ldr	r2, [pc, #60]	; (810b8 <udi_cdc_tx_send+0x13c>)
   8107a:	9200      	str	r2, [sp, #0]
   8107c:	2081      	movs	r0, #129	; 0x81
   8107e:	4621      	mov	r1, r4
   81080:	4a0e      	ldr	r2, [pc, #56]	; (810bc <udi_cdc_tx_send+0x140>)
   81082:	eb02 2245 	add.w	r2, r2, r5, lsl #9
   81086:	4c0e      	ldr	r4, [pc, #56]	; (810c0 <udi_cdc_tx_send+0x144>)
   81088:	47a0      	blx	r4
			b_short_packet,
			udi_cdc_tx_buf[port][buf_sel_trans],
			udi_cdc_tx_buf_nb[port][buf_sel_trans],
			udi_cdc_data_sent);
}
   8108a:	b003      	add	sp, #12
   8108c:	bd30      	pop	{r4, r5, pc}
   8108e:	bf00      	nop
   81090:	20071210 	.word	0x20071210
   81094:	00082f4d 	.word	0x00082f4d
   81098:	20071200 	.word	0x20071200
   8109c:	00082fa9 	.word	0x00082fa9
   810a0:	00082f99 	.word	0x00082f99
   810a4:	20070270 	.word	0x20070270
   810a8:	20070dec 	.word	0x20070dec
   810ac:	20070df0 	.word	0x20070df0
   810b0:	20070de8 	.word	0x20070de8
   810b4:	20071624 	.word	0x20071624
   810b8:	000810c5 	.word	0x000810c5
   810bc:	20070df4 	.word	0x20070df4
   810c0:	000831d5 	.word	0x000831d5

000810c4 <udi_cdc_data_sent>:
	udi_cdc_rx_start(port);
}


static void udi_cdc_data_sent(udd_ep_status_t status, iram_size_t n, udd_ep_id_t ep)
{
   810c4:	b508      	push	{r3, lr}
	default:
		port = 0;
		break;
	}

	if (UDD_EP_TRANSFER_OK != status) {
   810c6:	b978      	cbnz	r0, 810e8 <udi_cdc_data_sent+0x24>
		// Abort transfer
		return;
	}
	udi_cdc_tx_buf_nb[port][(udi_cdc_tx_buf_sel[port]==0)?1:0] = 0;
   810c8:	4b08      	ldr	r3, [pc, #32]	; (810ec <udi_cdc_data_sent+0x28>)
   810ca:	781b      	ldrb	r3, [r3, #0]
   810cc:	f013 0fff 	tst.w	r3, #255	; 0xff
   810d0:	bf14      	ite	ne
   810d2:	2200      	movne	r2, #0
   810d4:	2201      	moveq	r2, #1
   810d6:	4b06      	ldr	r3, [pc, #24]	; (810f0 <udi_cdc_data_sent+0x2c>)
   810d8:	f823 0012 	strh.w	r0, [r3, r2, lsl #1]
	udi_cdc_tx_both_buf_to_send[port] = false;
   810dc:	4b05      	ldr	r3, [pc, #20]	; (810f4 <udi_cdc_data_sent+0x30>)
   810de:	7018      	strb	r0, [r3, #0]
	udi_cdc_tx_trans_ongoing[port] = false;
   810e0:	4b05      	ldr	r3, [pc, #20]	; (810f8 <udi_cdc_data_sent+0x34>)
   810e2:	7018      	strb	r0, [r3, #0]

	if (n != 0) {
		UDI_CDC_TX_EMPTY_NOTIFY(port);
	}
	udi_cdc_tx_send(port);
   810e4:	4b05      	ldr	r3, [pc, #20]	; (810fc <udi_cdc_data_sent+0x38>)
   810e6:	4798      	blx	r3
   810e8:	bd08      	pop	{r3, pc}
   810ea:	bf00      	nop
   810ec:	20070dec 	.word	0x20070dec
   810f0:	20070df0 	.word	0x20070df0
   810f4:	20071624 	.word	0x20071624
   810f8:	20071210 	.word	0x20071210
   810fc:	00080f7d 	.word	0x00080f7d

00081100 <udi_cdc_data_sof_notify>:
{
	return 0;      // CDC don't have multiple alternate setting
}

void udi_cdc_data_sof_notify(void)
{
   81100:	b508      	push	{r3, lr}
	static uint8_t port_notify = 0;

	// A call of udi_cdc_data_sof_notify() is done for each port
	udi_cdc_tx_send(port_notify);
   81102:	2000      	movs	r0, #0
   81104:	4b01      	ldr	r3, [pc, #4]	; (8110c <udi_cdc_data_sof_notify+0xc>)
   81106:	4798      	blx	r3
   81108:	bd08      	pop	{r3, pc}
   8110a:	bf00      	nop
   8110c:	00080f7d 	.word	0x00080f7d

00081110 <udi_cdc_data_disable>:
	Assert(udi_cdc_nb_comm_enabled != 0);
	udi_cdc_nb_comm_enabled--;
}

void udi_cdc_data_disable(void)
{
   81110:	b508      	push	{r3, lr}
	uint8_t port;

	Assert(udi_cdc_nb_data_enabled != 0);
	udi_cdc_nb_data_enabled--;
   81112:	4b06      	ldr	r3, [pc, #24]	; (8112c <udi_cdc_data_disable+0x1c>)
   81114:	781a      	ldrb	r2, [r3, #0]
   81116:	3a01      	subs	r2, #1
   81118:	b2d2      	uxtb	r2, r2
   8111a:	701a      	strb	r2, [r3, #0]
	port = udi_cdc_nb_data_enabled;
   8111c:	7818      	ldrb	r0, [r3, #0]
	UDI_CDC_DISABLE_EXT(port);
   8111e:	4b04      	ldr	r3, [pc, #16]	; (81130 <udi_cdc_data_disable+0x20>)
   81120:	4798      	blx	r3
	udi_cdc_data_running = false;
   81122:	2200      	movs	r2, #0
   81124:	4b03      	ldr	r3, [pc, #12]	; (81134 <udi_cdc_data_disable+0x24>)
   81126:	701a      	strb	r2, [r3, #0]
   81128:	bd08      	pop	{r3, pc}
   8112a:	bf00      	nop
   8112c:	2007120c 	.word	0x2007120c
   81130:	00083e1d 	.word	0x00083e1d
   81134:	20071204 	.word	0x20071204

00081138 <udi_cdc_multi_get_nb_received_data>:
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_PRIMASK(void)
{
  uint32_t result;

  __ASM volatile ("MRS %0, primask" : "=r" (result) );
   81138:	f3ef 8310 	mrs	r3, PRIMASK
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
   8113c:	b672      	cpsid	i
   8113e:	f3bf 8f5f 	dmb	sy
static volatile bool     cpu_irq_prev_interrupt_state;

static inline irqflags_t cpu_irq_save(void)
{
	irqflags_t flags = cpu_irq_is_enabled();
	cpu_irq_disable();
   81142:	2100      	movs	r1, #0
   81144:	4a0a      	ldr	r2, [pc, #40]	; (81170 <udi_cdc_multi_get_nb_received_data+0x38>)
   81146:	7011      	strb	r1, [r2, #0]

#if UDI_CDC_PORT_NB == 1 // To optimize code
	port = 0;
#endif
	flags = cpu_irq_save();
	pos = udi_cdc_rx_pos[port];
   81148:	4a0a      	ldr	r2, [pc, #40]	; (81174 <udi_cdc_multi_get_nb_received_data+0x3c>)
   8114a:	8812      	ldrh	r2, [r2, #0]
   8114c:	b292      	uxth	r2, r2
	nb_received = udi_cdc_rx_buf_nb[port][udi_cdc_rx_buf_sel[port]] - pos;
   8114e:	490a      	ldr	r1, [pc, #40]	; (81178 <udi_cdc_multi_get_nb_received_data+0x40>)
   81150:	7808      	ldrb	r0, [r1, #0]
   81152:	b2c0      	uxtb	r0, r0
   81154:	4909      	ldr	r1, [pc, #36]	; (8117c <udi_cdc_multi_get_nb_received_data+0x44>)
   81156:	f831 0010 	ldrh.w	r0, [r1, r0, lsl #1]
   8115a:	b280      	uxth	r0, r0
   8115c:	1a80      	subs	r0, r0, r2
	return (flags);
}

static inline void cpu_irq_restore(irqflags_t flags)
{
	if (cpu_irq_is_enabled_flags(flags))
   8115e:	b92b      	cbnz	r3, 8116c <udi_cdc_multi_get_nb_received_data+0x34>
		cpu_irq_enable();
   81160:	2201      	movs	r2, #1
   81162:	4b03      	ldr	r3, [pc, #12]	; (81170 <udi_cdc_multi_get_nb_received_data+0x38>)
   81164:	701a      	strb	r2, [r3, #0]
   81166:	f3bf 8f5f 	dmb	sy
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
   8116a:	b662      	cpsie	i
	cpu_irq_restore(flags);
	return nb_received;
}
   8116c:	4770      	bx	lr
   8116e:	bf00      	nop
   81170:	20070270 	.word	0x20070270
   81174:	200711fc 	.word	0x200711fc
   81178:	20071208 	.word	0x20071208
   8117c:	200711f4 	.word	0x200711f4

00081180 <udi_cdc_multi_is_rx_ready>:
{
	return udi_cdc_multi_get_nb_received_data(0);
}

bool udi_cdc_multi_is_rx_ready(uint8_t port)
{
   81180:	b508      	push	{r3, lr}
	return (udi_cdc_multi_get_nb_received_data(port) > 0);
   81182:	4b03      	ldr	r3, [pc, #12]	; (81190 <udi_cdc_multi_is_rx_ready+0x10>)
   81184:	4798      	blx	r3
}
   81186:	3000      	adds	r0, #0
   81188:	bf18      	it	ne
   8118a:	2001      	movne	r0, #1
   8118c:	bd08      	pop	{r3, pc}
   8118e:	bf00      	nop
   81190:	00081139 	.word	0x00081139

00081194 <udi_cdc_rx_start>:
//-------------------------------------------------
//------- Internal routines to process data transfer


static bool udi_cdc_rx_start(uint8_t port)
{
   81194:	b510      	push	{r4, lr}
   81196:	b082      	sub	sp, #8
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_PRIMASK(void)
{
  uint32_t result;

  __ASM volatile ("MRS %0, primask" : "=r" (result) );
   81198:	f3ef 8310 	mrs	r3, PRIMASK
static volatile uint32_t cpu_irq_critical_section_counter;
static volatile bool     cpu_irq_prev_interrupt_state;

static inline irqflags_t cpu_irq_save(void)
{
	irqflags_t flags = cpu_irq_is_enabled();
   8119c:	f1d3 0301 	rsbs	r3, r3, #1
   811a0:	bf38      	it	cc
   811a2:	2300      	movcc	r3, #0
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
   811a4:	b672      	cpsid	i
   811a6:	f3bf 8f5f 	dmb	sy
	cpu_irq_disable();
   811aa:	2100      	movs	r1, #0
   811ac:	4a22      	ldr	r2, [pc, #136]	; (81238 <udi_cdc_rx_start+0xa4>)
   811ae:	7011      	strb	r1, [r2, #0]
#if UDI_CDC_PORT_NB == 1 // To optimize code
	port = 0;
#endif

	flags = cpu_irq_save();
	buf_sel_trans = udi_cdc_rx_buf_sel[port];
   811b0:	4a22      	ldr	r2, [pc, #136]	; (8123c <udi_cdc_rx_start+0xa8>)
   811b2:	7814      	ldrb	r4, [r2, #0]
   811b4:	b2e4      	uxtb	r4, r4
	if (udi_cdc_rx_trans_ongoing[port] ||
   811b6:	4a22      	ldr	r2, [pc, #136]	; (81240 <udi_cdc_rx_start+0xac>)
   811b8:	7812      	ldrb	r2, [r2, #0]
   811ba:	f012 0fff 	tst.w	r2, #255	; 0xff
   811be:	d108      	bne.n	811d2 <udi_cdc_rx_start+0x3e>
		(udi_cdc_rx_pos[port] < udi_cdc_rx_buf_nb[port][buf_sel_trans])) {
   811c0:	4a20      	ldr	r2, [pc, #128]	; (81244 <udi_cdc_rx_start+0xb0>)
   811c2:	8811      	ldrh	r1, [r2, #0]
   811c4:	b289      	uxth	r1, r1
   811c6:	4a20      	ldr	r2, [pc, #128]	; (81248 <udi_cdc_rx_start+0xb4>)
   811c8:	f832 2014 	ldrh.w	r2, [r2, r4, lsl #1]
   811cc:	b292      	uxth	r2, r2
	port = 0;
#endif

	flags = cpu_irq_save();
	buf_sel_trans = udi_cdc_rx_buf_sel[port];
	if (udi_cdc_rx_trans_ongoing[port] ||
   811ce:	4291      	cmp	r1, r2
   811d0:	d209      	bcs.n	811e6 <udi_cdc_rx_start+0x52>
	return (flags);
}

static inline void cpu_irq_restore(irqflags_t flags)
{
	if (cpu_irq_is_enabled_flags(flags))
   811d2:	2b00      	cmp	r3, #0
   811d4:	d02c      	beq.n	81230 <udi_cdc_rx_start+0x9c>
		cpu_irq_enable();
   811d6:	2201      	movs	r2, #1
   811d8:	4b17      	ldr	r3, [pc, #92]	; (81238 <udi_cdc_rx_start+0xa4>)
   811da:	701a      	strb	r2, [r3, #0]
   811dc:	f3bf 8f5f 	dmb	sy
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
   811e0:	b662      	cpsie	i
		(udi_cdc_rx_pos[port] < udi_cdc_rx_buf_nb[port][buf_sel_trans])) {
		// Transfer already on-going or current buffer no empty
		cpu_irq_restore(flags);
		return false;
   811e2:	2000      	movs	r0, #0
   811e4:	e025      	b.n	81232 <udi_cdc_rx_start+0x9e>
	}

	// Change current buffer
	udi_cdc_rx_pos[port] = 0;
   811e6:	2100      	movs	r1, #0
   811e8:	4a16      	ldr	r2, [pc, #88]	; (81244 <udi_cdc_rx_start+0xb0>)
   811ea:	8011      	strh	r1, [r2, #0]
	udi_cdc_rx_buf_sel[port] = (buf_sel_trans==0)?1:0;
   811ec:	428c      	cmp	r4, r1
   811ee:	bf14      	ite	ne
   811f0:	2100      	movne	r1, #0
   811f2:	2101      	moveq	r1, #1
   811f4:	4a11      	ldr	r2, [pc, #68]	; (8123c <udi_cdc_rx_start+0xa8>)
   811f6:	7011      	strb	r1, [r2, #0]

	// Start transfer on RX
	udi_cdc_rx_trans_ongoing[port] = true;
   811f8:	2101      	movs	r1, #1
   811fa:	4a11      	ldr	r2, [pc, #68]	; (81240 <udi_cdc_rx_start+0xac>)
   811fc:	7011      	strb	r1, [r2, #0]
	return (flags);
}

static inline void cpu_irq_restore(irqflags_t flags)
{
	if (cpu_irq_is_enabled_flags(flags))
   811fe:	b123      	cbz	r3, 8120a <udi_cdc_rx_start+0x76>
		cpu_irq_enable();
   81200:	4b0d      	ldr	r3, [pc, #52]	; (81238 <udi_cdc_rx_start+0xa4>)
   81202:	7019      	strb	r1, [r3, #0]
   81204:	f3bf 8f5f 	dmb	sy
   81208:	b662      	cpsie	i
	cpu_irq_restore(flags);

	if (udi_cdc_multi_is_rx_ready(port)) {
   8120a:	2000      	movs	r0, #0
   8120c:	4b0f      	ldr	r3, [pc, #60]	; (8124c <udi_cdc_rx_start+0xb8>)
   8120e:	4798      	blx	r3
   81210:	b110      	cbz	r0, 81218 <udi_cdc_rx_start+0x84>
		UDI_CDC_RX_NOTIFY(port);
   81212:	2000      	movs	r0, #0
   81214:	4b0e      	ldr	r3, [pc, #56]	; (81250 <udi_cdc_rx_start+0xbc>)
   81216:	4798      	blx	r3
#undef UDI_CDC_PORT_TO_DATA_EP_OUT
	default:
		ep = UDI_CDC_DATA_EP_OUT_0;
		break;
	}
	return udd_ep_run(ep,
   81218:	4b0e      	ldr	r3, [pc, #56]	; (81254 <udi_cdc_rx_start+0xc0>)
   8121a:	9300      	str	r3, [sp, #0]
   8121c:	2002      	movs	r0, #2
   8121e:	2101      	movs	r1, #1
   81220:	4a0d      	ldr	r2, [pc, #52]	; (81258 <udi_cdc_rx_start+0xc4>)
   81222:	eb02 2244 	add.w	r2, r2, r4, lsl #9
   81226:	f44f 7300 	mov.w	r3, #512	; 0x200
   8122a:	4c0c      	ldr	r4, [pc, #48]	; (8125c <udi_cdc_rx_start+0xc8>)
   8122c:	47a0      	blx	r4
   8122e:	e000      	b.n	81232 <udi_cdc_rx_start+0x9e>
	buf_sel_trans = udi_cdc_rx_buf_sel[port];
	if (udi_cdc_rx_trans_ongoing[port] ||
		(udi_cdc_rx_pos[port] < udi_cdc_rx_buf_nb[port][buf_sel_trans])) {
		// Transfer already on-going or current buffer no empty
		cpu_irq_restore(flags);
		return false;
   81230:	2000      	movs	r0, #0
	return udd_ep_run(ep,
			true,
			udi_cdc_rx_buf[port][buf_sel_trans],
			UDI_CDC_RX_BUFFERS,
			udi_cdc_data_received);
}
   81232:	b002      	add	sp, #8
   81234:	bd10      	pop	{r4, pc}
   81236:	bf00      	nop
   81238:	20070270 	.word	0x20070270
   8123c:	20071208 	.word	0x20071208
   81240:	20071620 	.word	0x20071620
   81244:	200711fc 	.word	0x200711fc
   81248:	200711f4 	.word	0x200711f4
   8124c:	00081181 	.word	0x00081181
   81250:	00083dd5 	.word	0x00083dd5
   81254:	000812f1 	.word	0x000812f1
   81258:	20071220 	.word	0x20071220
   8125c:	000831d5 	.word	0x000831d5

00081260 <udi_cdc_data_enable>:
	udi_cdc_nb_comm_enabled++;
	return true;
}

bool udi_cdc_data_enable(void)
{
   81260:	b510      	push	{r4, lr}
	uint8_t port;

#if UDI_CDC_PORT_NB == 1 // To optimize code
	port = 0;
	udi_cdc_nb_data_enabled = 0;
   81262:	2400      	movs	r4, #0
   81264:	4b15      	ldr	r3, [pc, #84]	; (812bc <udi_cdc_data_enable+0x5c>)
   81266:	701c      	strb	r4, [r3, #0]
	}
	port = udi_cdc_nb_data_enabled;
#endif

	// Initialize TX management
	udi_cdc_tx_trans_ongoing[port] = false;
   81268:	4b15      	ldr	r3, [pc, #84]	; (812c0 <udi_cdc_data_enable+0x60>)
   8126a:	701c      	strb	r4, [r3, #0]
	udi_cdc_tx_both_buf_to_send[port] = false;
   8126c:	4b15      	ldr	r3, [pc, #84]	; (812c4 <udi_cdc_data_enable+0x64>)
   8126e:	701c      	strb	r4, [r3, #0]
	udi_cdc_tx_buf_sel[port] = 0;
   81270:	4b15      	ldr	r3, [pc, #84]	; (812c8 <udi_cdc_data_enable+0x68>)
   81272:	701c      	strb	r4, [r3, #0]
	udi_cdc_tx_buf_nb[port][0] = 0;
   81274:	4b15      	ldr	r3, [pc, #84]	; (812cc <udi_cdc_data_enable+0x6c>)
   81276:	801c      	strh	r4, [r3, #0]
	udi_cdc_tx_buf_nb[port][1] = 0;
   81278:	805c      	strh	r4, [r3, #2]
	udi_cdc_tx_sof_num[port] = 0;
   8127a:	4b15      	ldr	r3, [pc, #84]	; (812d0 <udi_cdc_data_enable+0x70>)
   8127c:	801c      	strh	r4, [r3, #0]
	udi_cdc_tx_send(port);
   8127e:	4620      	mov	r0, r4
   81280:	4b14      	ldr	r3, [pc, #80]	; (812d4 <udi_cdc_data_enable+0x74>)
   81282:	4798      	blx	r3

	// Initialize RX management
	udi_cdc_rx_trans_ongoing[port] = false;
   81284:	4b14      	ldr	r3, [pc, #80]	; (812d8 <udi_cdc_data_enable+0x78>)
   81286:	701c      	strb	r4, [r3, #0]
	udi_cdc_rx_buf_sel[port] = 0;
   81288:	4b14      	ldr	r3, [pc, #80]	; (812dc <udi_cdc_data_enable+0x7c>)
   8128a:	701c      	strb	r4, [r3, #0]
	udi_cdc_rx_buf_nb[port][0] = 0;
   8128c:	4b14      	ldr	r3, [pc, #80]	; (812e0 <udi_cdc_data_enable+0x80>)
   8128e:	801c      	strh	r4, [r3, #0]
	udi_cdc_rx_buf_nb[port][1] = 0;
   81290:	805c      	strh	r4, [r3, #2]
	udi_cdc_rx_pos[port] = 0;
   81292:	4b14      	ldr	r3, [pc, #80]	; (812e4 <udi_cdc_data_enable+0x84>)
   81294:	801c      	strh	r4, [r3, #0]
	if (!udi_cdc_rx_start(port)) {
   81296:	4620      	mov	r0, r4
   81298:	4b13      	ldr	r3, [pc, #76]	; (812e8 <udi_cdc_data_enable+0x88>)
   8129a:	4798      	blx	r3
   8129c:	4602      	mov	r2, r0
   8129e:	b158      	cbz	r0, 812b8 <udi_cdc_data_enable+0x58>
		return false;
	}
	udi_cdc_nb_data_enabled++;
   812a0:	4b06      	ldr	r3, [pc, #24]	; (812bc <udi_cdc_data_enable+0x5c>)
   812a2:	7819      	ldrb	r1, [r3, #0]
   812a4:	3101      	adds	r1, #1
   812a6:	b2c9      	uxtb	r1, r1
   812a8:	7019      	strb	r1, [r3, #0]
	if (udi_cdc_nb_data_enabled == UDI_CDC_PORT_NB) {
   812aa:	781b      	ldrb	r3, [r3, #0]
   812ac:	b2db      	uxtb	r3, r3
   812ae:	2b01      	cmp	r3, #1
   812b0:	d102      	bne.n	812b8 <udi_cdc_data_enable+0x58>
		udi_cdc_data_running = true;
   812b2:	2101      	movs	r1, #1
   812b4:	4b0d      	ldr	r3, [pc, #52]	; (812ec <udi_cdc_data_enable+0x8c>)
   812b6:	7019      	strb	r1, [r3, #0]
	}
	return true;
}
   812b8:	4610      	mov	r0, r2
   812ba:	bd10      	pop	{r4, pc}
   812bc:	2007120c 	.word	0x2007120c
   812c0:	20071210 	.word	0x20071210
   812c4:	20071624 	.word	0x20071624
   812c8:	20070dec 	.word	0x20070dec
   812cc:	20070df0 	.word	0x20070df0
   812d0:	20071200 	.word	0x20071200
   812d4:	00080f7d 	.word	0x00080f7d
   812d8:	20071620 	.word	0x20071620
   812dc:	20071208 	.word	0x20071208
   812e0:	200711f4 	.word	0x200711f4
   812e4:	200711fc 	.word	0x200711fc
   812e8:	00081195 	.word	0x00081195
   812ec:	20071204 	.word	0x20071204

000812f0 <udi_cdc_data_received>:
			udi_cdc_data_received);
}


static void udi_cdc_data_received(udd_ep_status_t status, iram_size_t n, udd_ep_id_t ep)
{
   812f0:	b510      	push	{r4, lr}
   812f2:	b082      	sub	sp, #8
	default:
		port = 0;
		break;
	}

	if (UDD_EP_TRANSFER_OK != status) {
   812f4:	b9e0      	cbnz	r0, 81330 <udi_cdc_data_received+0x40>
		// Abort reception
		return;
	}
	buf_sel_trans = (udi_cdc_rx_buf_sel[port]==0)?1:0;
   812f6:	4b0f      	ldr	r3, [pc, #60]	; (81334 <udi_cdc_data_received+0x44>)
   812f8:	781b      	ldrb	r3, [r3, #0]
   812fa:	f013 0fff 	tst.w	r3, #255	; 0xff
   812fe:	bf14      	ite	ne
   81300:	2300      	movne	r3, #0
   81302:	2301      	moveq	r3, #1
	if (!n) {
   81304:	b959      	cbnz	r1, 8131e <udi_cdc_data_received+0x2e>
		udd_ep_run( ep,
   81306:	490c      	ldr	r1, [pc, #48]	; (81338 <udi_cdc_data_received+0x48>)
   81308:	9100      	str	r1, [sp, #0]
   8130a:	4610      	mov	r0, r2
   8130c:	2101      	movs	r1, #1
   8130e:	4a0b      	ldr	r2, [pc, #44]	; (8133c <udi_cdc_data_received+0x4c>)
   81310:	eb02 2243 	add.w	r2, r2, r3, lsl #9
   81314:	f44f 7300 	mov.w	r3, #512	; 0x200
   81318:	4c09      	ldr	r4, [pc, #36]	; (81340 <udi_cdc_data_received+0x50>)
   8131a:	47a0      	blx	r4
				true,
				udi_cdc_rx_buf[port][buf_sel_trans],
				UDI_CDC_RX_BUFFERS,
				udi_cdc_data_received);
		return;
   8131c:	e008      	b.n	81330 <udi_cdc_data_received+0x40>
	}
	udi_cdc_rx_buf_nb[port][buf_sel_trans] = n;
   8131e:	b289      	uxth	r1, r1
   81320:	4a08      	ldr	r2, [pc, #32]	; (81344 <udi_cdc_data_received+0x54>)
   81322:	f822 1013 	strh.w	r1, [r2, r3, lsl #1]
	udi_cdc_rx_trans_ongoing[port] = false;
   81326:	2000      	movs	r0, #0
   81328:	4b07      	ldr	r3, [pc, #28]	; (81348 <udi_cdc_data_received+0x58>)
   8132a:	7018      	strb	r0, [r3, #0]
	udi_cdc_rx_start(port);
   8132c:	4b07      	ldr	r3, [pc, #28]	; (8134c <udi_cdc_data_received+0x5c>)
   8132e:	4798      	blx	r3
}
   81330:	b002      	add	sp, #8
   81332:	bd10      	pop	{r4, pc}
   81334:	20071208 	.word	0x20071208
   81338:	000812f1 	.word	0x000812f1
   8133c:	20071220 	.word	0x20071220
   81340:	000831d5 	.word	0x000831d5
   81344:	200711f4 	.word	0x200711f4
   81348:	20071620 	.word	0x20071620
   8134c:	00081195 	.word	0x00081195

00081350 <udi_cdc_is_rx_ready>:
{
	return (udi_cdc_multi_get_nb_received_data(port) > 0);
}

bool udi_cdc_is_rx_ready(void)
{
   81350:	b508      	push	{r3, lr}
	return udi_cdc_multi_is_rx_ready(0);
   81352:	2000      	movs	r0, #0
   81354:	4b01      	ldr	r3, [pc, #4]	; (8135c <udi_cdc_is_rx_ready+0xc>)
   81356:	4798      	blx	r3
}
   81358:	bd08      	pop	{r3, pc}
   8135a:	bf00      	nop
   8135c:	00081181 	.word	0x00081181

00081360 <udi_cdc_multi_getc>:

int udi_cdc_multi_getc(uint8_t port)
{
   81360:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}

#if UDI_CDC_PORT_NB == 1 // To optimize code
	port = 0;
#endif

	b_databit_9 = (9 == udi_cdc_line_coding[port].bDataBits);
   81364:	4b22      	ldr	r3, [pc, #136]	; (813f0 <udi_cdc_multi_getc+0x90>)
   81366:	f893 9006 	ldrb.w	r9, [r3, #6]
   8136a:	f1b9 0f09 	cmp.w	r9, #9
   8136e:	bf14      	ite	ne
   81370:	f04f 0900 	movne.w	r9, #0
   81374:	f04f 0901 	moveq.w	r9, #1
}

int udi_cdc_multi_getc(uint8_t port)
{
	irqflags_t flags;
	int rx_data = 0;
   81378:	f04f 0c00 	mov.w	ip, #0
static volatile bool     cpu_irq_prev_interrupt_state;

static inline irqflags_t cpu_irq_save(void)
{
	irqflags_t flags = cpu_irq_is_enabled();
	cpu_irq_disable();
   8137c:	4c1d      	ldr	r4, [pc, #116]	; (813f4 <udi_cdc_multi_getc+0x94>)
   8137e:	46e0      	mov	r8, ip
   81380:	4667      	mov	r7, ip
	b_databit_9 = (9 == udi_cdc_line_coding[port].bDataBits);

udi_cdc_getc_process_one_byte:
	// Check available data
	flags = cpu_irq_save();
	pos = udi_cdc_rx_pos[port];
   81382:	4d1d      	ldr	r5, [pc, #116]	; (813f8 <udi_cdc_multi_getc+0x98>)
	buf_sel = udi_cdc_rx_buf_sel[port];
   81384:	4e1d      	ldr	r6, [pc, #116]	; (813fc <udi_cdc_multi_getc+0x9c>)
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_PRIMASK(void)
{
  uint32_t result;

  __ASM volatile ("MRS %0, primask" : "=r" (result) );
   81386:	f3ef 8010 	mrs	r0, PRIMASK
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
   8138a:	b672      	cpsid	i
   8138c:	f3bf 8f5f 	dmb	sy
   81390:	7027      	strb	r7, [r4, #0]
	b_databit_9 = (9 == udi_cdc_line_coding[port].bDataBits);

udi_cdc_getc_process_one_byte:
	// Check available data
	flags = cpu_irq_save();
	pos = udi_cdc_rx_pos[port];
   81392:	882b      	ldrh	r3, [r5, #0]
   81394:	b29b      	uxth	r3, r3
	buf_sel = udi_cdc_rx_buf_sel[port];
   81396:	7832      	ldrb	r2, [r6, #0]
   81398:	b2d2      	uxtb	r2, r2
	again = pos >= udi_cdc_rx_buf_nb[port][buf_sel];
   8139a:	4919      	ldr	r1, [pc, #100]	; (81400 <udi_cdc_multi_getc+0xa0>)
   8139c:	f831 1012 	ldrh.w	r1, [r1, r2, lsl #1]
   813a0:	b289      	uxth	r1, r1
	return (flags);
}

static inline void cpu_irq_restore(irqflags_t flags)
{
	if (cpu_irq_is_enabled_flags(flags))
   813a2:	b920      	cbnz	r0, 813ae <udi_cdc_multi_getc+0x4e>
		cpu_irq_enable();
   813a4:	2001      	movs	r0, #1
   813a6:	7020      	strb	r0, [r4, #0]
   813a8:	f3bf 8f5f 	dmb	sy
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
   813ac:	b662      	cpsie	i
	cpu_irq_restore(flags);
	while (again) {
   813ae:	428b      	cmp	r3, r1
   813b0:	d307      	bcc.n	813c2 <udi_cdc_multi_getc+0x62>
		if (!udi_cdc_data_running) {
   813b2:	4b14      	ldr	r3, [pc, #80]	; (81404 <udi_cdc_multi_getc+0xa4>)
   813b4:	781b      	ldrb	r3, [r3, #0]
   813b6:	f013 0fff 	tst.w	r3, #255	; 0xff
   813ba:	d1e4      	bne.n	81386 <udi_cdc_multi_getc+0x26>
			return 0;
   813bc:	2000      	movs	r0, #0
   813be:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
		}
		goto udi_cdc_getc_process_one_byte;
	}

	// Read data
	rx_data |= udi_cdc_rx_buf[port][buf_sel][pos];
   813c2:	eb03 2242 	add.w	r2, r3, r2, lsl #9
   813c6:	4910      	ldr	r1, [pc, #64]	; (81408 <udi_cdc_multi_getc+0xa8>)
   813c8:	f811 a002 	ldrb.w	sl, [r1, r2]
   813cc:	ea4c 0a0a 	orr.w	sl, ip, sl
	udi_cdc_rx_pos[port] = pos+1;
   813d0:	3301      	adds	r3, #1
   813d2:	b29b      	uxth	r3, r3
   813d4:	802b      	strh	r3, [r5, #0]

	udi_cdc_rx_start(port);
   813d6:	4640      	mov	r0, r8
   813d8:	4b0c      	ldr	r3, [pc, #48]	; (8140c <udi_cdc_multi_getc+0xac>)
   813da:	4798      	blx	r3

	if (b_databit_9) {
   813dc:	f1b9 0f00 	cmp.w	r9, #0
   813e0:	d003      	beq.n	813ea <udi_cdc_multi_getc+0x8a>
		// Receive MSB
		b_databit_9 = false;
		rx_data = rx_data << 8;
   813e2:	ea4f 2c0a 	mov.w	ip, sl, lsl #8

	udi_cdc_rx_start(port);

	if (b_databit_9) {
		// Receive MSB
		b_databit_9 = false;
   813e6:	46c1      	mov	r9, r8
		rx_data = rx_data << 8;
		goto udi_cdc_getc_process_one_byte;
   813e8:	e7cd      	b.n	81386 <udi_cdc_multi_getc+0x26>
		}
		goto udi_cdc_getc_process_one_byte;
	}

	// Read data
	rx_data |= udi_cdc_rx_buf[port][buf_sel][pos];
   813ea:	4650      	mov	r0, sl
		b_databit_9 = false;
		rx_data = rx_data << 8;
		goto udi_cdc_getc_process_one_byte;
	}
	return rx_data;
}
   813ec:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
   813f0:	20070de0 	.word	0x20070de0
   813f4:	20070270 	.word	0x20070270
   813f8:	200711fc 	.word	0x200711fc
   813fc:	20071208 	.word	0x20071208
   81400:	200711f4 	.word	0x200711f4
   81404:	20071204 	.word	0x20071204
   81408:	20071220 	.word	0x20071220
   8140c:	00081195 	.word	0x00081195

00081410 <udi_cdc_getc>:

int udi_cdc_getc(void)
{
   81410:	b508      	push	{r3, lr}
	return udi_cdc_multi_getc(0);
   81412:	2000      	movs	r0, #0
   81414:	4b01      	ldr	r3, [pc, #4]	; (8141c <udi_cdc_getc+0xc>)
   81416:	4798      	blx	r3
}
   81418:	bd08      	pop	{r3, pc}
   8141a:	bf00      	nop
   8141c:	00081361 	.word	0x00081361

00081420 <udi_cdc_multi_get_free_tx_buffer>:
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_PRIMASK(void)
{
  uint32_t result;

  __ASM volatile ("MRS %0, primask" : "=r" (result) );
   81420:	f3ef 8210 	mrs	r2, PRIMASK
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
   81424:	b672      	cpsid	i
   81426:	f3bf 8f5f 	dmb	sy
static volatile bool     cpu_irq_prev_interrupt_state;

static inline irqflags_t cpu_irq_save(void)
{
	irqflags_t flags = cpu_irq_is_enabled();
	cpu_irq_disable();
   8142a:	2100      	movs	r1, #0
   8142c:	4b14      	ldr	r3, [pc, #80]	; (81480 <udi_cdc_multi_get_free_tx_buffer+0x60>)
   8142e:	7019      	strb	r1, [r3, #0]
#if UDI_CDC_PORT_NB == 1 // To optimize code
	port = 0;
#endif

	flags = cpu_irq_save();
	buf_sel = udi_cdc_tx_buf_sel[port];
   81430:	4b14      	ldr	r3, [pc, #80]	; (81484 <udi_cdc_multi_get_free_tx_buffer+0x64>)
   81432:	781b      	ldrb	r3, [r3, #0]
   81434:	b2db      	uxtb	r3, r3
	buf_sel_nb = udi_cdc_tx_buf_nb[port][buf_sel];
   81436:	4914      	ldr	r1, [pc, #80]	; (81488 <udi_cdc_multi_get_free_tx_buffer+0x68>)
   81438:	f831 0013 	ldrh.w	r0, [r1, r3, lsl #1]
	if (buf_sel_nb == UDI_CDC_TX_BUFFERS) {
   8143c:	f5b0 7f00 	cmp.w	r0, #512	; 0x200
   81440:	d113      	bne.n	8146a <udi_cdc_multi_get_free_tx_buffer+0x4a>
		if ((!udi_cdc_tx_trans_ongoing[port])
   81442:	4912      	ldr	r1, [pc, #72]	; (8148c <udi_cdc_multi_get_free_tx_buffer+0x6c>)
   81444:	7809      	ldrb	r1, [r1, #0]
   81446:	f011 0fff 	tst.w	r1, #255	; 0xff
   8144a:	d10e      	bne.n	8146a <udi_cdc_multi_get_free_tx_buffer+0x4a>
			&& (!udi_cdc_tx_both_buf_to_send[port])) {
   8144c:	4910      	ldr	r1, [pc, #64]	; (81490 <udi_cdc_multi_get_free_tx_buffer+0x70>)
   8144e:	7809      	ldrb	r1, [r1, #0]
   81450:	f011 0fff 	tst.w	r1, #255	; 0xff
   81454:	d109      	bne.n	8146a <udi_cdc_multi_get_free_tx_buffer+0x4a>
			/* One buffer is full, but the other buffer is not used.
			 * (not used = transfer on-going)
			 * then move to the other buffer to store data */
			udi_cdc_tx_both_buf_to_send[port] = true;
   81456:	2001      	movs	r0, #1
   81458:	490d      	ldr	r1, [pc, #52]	; (81490 <udi_cdc_multi_get_free_tx_buffer+0x70>)
   8145a:	7008      	strb	r0, [r1, #0]
			udi_cdc_tx_buf_sel[port] = (buf_sel == 0)? 1 : 0;
   8145c:	f1d3 0301 	rsbs	r3, r3, #1
   81460:	bf38      	it	cc
   81462:	2300      	movcc	r3, #0
   81464:	4907      	ldr	r1, [pc, #28]	; (81484 <udi_cdc_multi_get_free_tx_buffer+0x64>)
   81466:	700b      	strb	r3, [r1, #0]
			buf_sel_nb = 0;
   81468:	2000      	movs	r0, #0
		}
	}
	retval = UDI_CDC_TX_BUFFERS - buf_sel_nb;  
   8146a:	f5c0 7000 	rsb	r0, r0, #512	; 0x200
	return (flags);
}

static inline void cpu_irq_restore(irqflags_t flags)
{
	if (cpu_irq_is_enabled_flags(flags))
   8146e:	b92a      	cbnz	r2, 8147c <udi_cdc_multi_get_free_tx_buffer+0x5c>
		cpu_irq_enable();
   81470:	2201      	movs	r2, #1
   81472:	4b03      	ldr	r3, [pc, #12]	; (81480 <udi_cdc_multi_get_free_tx_buffer+0x60>)
   81474:	701a      	strb	r2, [r3, #0]
   81476:	f3bf 8f5f 	dmb	sy
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
   8147a:	b662      	cpsie	i
	cpu_irq_restore(flags);
	return retval;
}
   8147c:	4770      	bx	lr
   8147e:	bf00      	nop
   81480:	20070270 	.word	0x20070270
   81484:	20070dec 	.word	0x20070dec
   81488:	20070df0 	.word	0x20070df0
   8148c:	20071210 	.word	0x20071210
   81490:	20071624 	.word	0x20071624

00081494 <udi_cdc_multi_is_tx_ready>:
{
	return udi_cdc_multi_get_free_tx_buffer(0);
}

bool udi_cdc_multi_is_tx_ready(uint8_t port)
{
   81494:	b508      	push	{r3, lr}
	return (udi_cdc_multi_get_free_tx_buffer(port) != 0);
   81496:	4b03      	ldr	r3, [pc, #12]	; (814a4 <udi_cdc_multi_is_tx_ready+0x10>)
   81498:	4798      	blx	r3
}
   8149a:	3000      	adds	r0, #0
   8149c:	bf18      	it	ne
   8149e:	2001      	movne	r0, #1
   814a0:	bd08      	pop	{r3, pc}
   814a2:	bf00      	nop
   814a4:	00081421 	.word	0x00081421

000814a8 <udi_cdc_multi_putc>:
{
	return udi_cdc_multi_is_tx_ready(0);
}

int udi_cdc_multi_putc(uint8_t port, int value)
{
   814a8:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   814ac:	460c      	mov	r4, r1

#if UDI_CDC_PORT_NB == 1 // To optimize code
	port = 0;
#endif

	b_databit_9 = (9 == udi_cdc_line_coding[port].bDataBits);
   814ae:	4b1b      	ldr	r3, [pc, #108]	; (8151c <udi_cdc_multi_putc+0x74>)
   814b0:	799e      	ldrb	r6, [r3, #6]
   814b2:	2e09      	cmp	r6, #9
   814b4:	bf14      	ite	ne
   814b6:	2600      	movne	r6, #0
   814b8:	2601      	moveq	r6, #1

udi_cdc_putc_process_one_byte:
	// Check available space
	if (!udi_cdc_multi_is_tx_ready(port)) {
   814ba:	4d19      	ldr	r5, [pc, #100]	; (81520 <udi_cdc_multi_putc+0x78>)
static volatile bool     cpu_irq_prev_interrupt_state;

static inline irqflags_t cpu_irq_save(void)
{
	irqflags_t flags = cpu_irq_is_enabled();
	cpu_irq_disable();
   814bc:	4f19      	ldr	r7, [pc, #100]	; (81524 <udi_cdc_multi_putc+0x7c>)
		goto udi_cdc_putc_process_one_byte;
	}

	// Write value
	flags = cpu_irq_save();
	buf_sel = udi_cdc_tx_buf_sel[port];
   814be:	f8df 8074 	ldr.w	r8, [pc, #116]	; 81534 <udi_cdc_multi_putc+0x8c>

	b_databit_9 = (9 == udi_cdc_line_coding[port].bDataBits);

udi_cdc_putc_process_one_byte:
	// Check available space
	if (!udi_cdc_multi_is_tx_ready(port)) {
   814c2:	2000      	movs	r0, #0
   814c4:	47a8      	blx	r5
   814c6:	b930      	cbnz	r0, 814d6 <udi_cdc_multi_putc+0x2e>
		if (!udi_cdc_data_running) {
   814c8:	4b17      	ldr	r3, [pc, #92]	; (81528 <udi_cdc_multi_putc+0x80>)
   814ca:	781b      	ldrb	r3, [r3, #0]
   814cc:	f013 0fff 	tst.w	r3, #255	; 0xff
   814d0:	d1f7      	bne.n	814c2 <udi_cdc_multi_putc+0x1a>
   814d2:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_PRIMASK(void)
{
  uint32_t result;

  __ASM volatile ("MRS %0, primask" : "=r" (result) );
   814d6:	f3ef 8110 	mrs	r1, PRIMASK
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
   814da:	b672      	cpsid	i
   814dc:	f3bf 8f5f 	dmb	sy
   814e0:	2300      	movs	r3, #0
   814e2:	703b      	strb	r3, [r7, #0]
		goto udi_cdc_putc_process_one_byte;
	}

	// Write value
	flags = cpu_irq_save();
	buf_sel = udi_cdc_tx_buf_sel[port];
   814e4:	f898 3000 	ldrb.w	r3, [r8]
   814e8:	b2db      	uxtb	r3, r3
	udi_cdc_tx_buf[port][buf_sel][udi_cdc_tx_buf_nb[port][buf_sel]++] = value;
   814ea:	4810      	ldr	r0, [pc, #64]	; (8152c <udi_cdc_multi_putc+0x84>)
   814ec:	f830 2013 	ldrh.w	r2, [r0, r3, lsl #1]
   814f0:	f102 0c01 	add.w	ip, r2, #1
   814f4:	f820 c013 	strh.w	ip, [r0, r3, lsl #1]
   814f8:	eb02 2343 	add.w	r3, r2, r3, lsl #9
   814fc:	4a0c      	ldr	r2, [pc, #48]	; (81530 <udi_cdc_multi_putc+0x88>)
   814fe:	54d4      	strb	r4, [r2, r3]
	return (flags);
}

static inline void cpu_irq_restore(irqflags_t flags)
{
	if (cpu_irq_is_enabled_flags(flags))
   81500:	b921      	cbnz	r1, 8150c <udi_cdc_multi_putc+0x64>
		cpu_irq_enable();
   81502:	2301      	movs	r3, #1
   81504:	703b      	strb	r3, [r7, #0]
   81506:	f3bf 8f5f 	dmb	sy
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
   8150a:	b662      	cpsie	i
	cpu_irq_restore(flags);

	if (b_databit_9) {
   8150c:	b116      	cbz	r6, 81514 <udi_cdc_multi_putc+0x6c>
		// Send MSB
		b_databit_9 = false;
		value = value >> 8;
   8150e:	1224      	asrs	r4, r4, #8
	udi_cdc_tx_buf[port][buf_sel][udi_cdc_tx_buf_nb[port][buf_sel]++] = value;
	cpu_irq_restore(flags);

	if (b_databit_9) {
		// Send MSB
		b_databit_9 = false;
   81510:	2600      	movs	r6, #0
		value = value >> 8;
		goto udi_cdc_putc_process_one_byte;
   81512:	e7d6      	b.n	814c2 <udi_cdc_multi_putc+0x1a>
	}
	return true;
   81514:	2001      	movs	r0, #1
}
   81516:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   8151a:	bf00      	nop
   8151c:	20070de0 	.word	0x20070de0
   81520:	00081495 	.word	0x00081495
   81524:	20070270 	.word	0x20070270
   81528:	20071204 	.word	0x20071204
   8152c:	20070df0 	.word	0x20070df0
   81530:	20070df4 	.word	0x20070df4
   81534:	20070dec 	.word	0x20070dec

00081538 <udi_cdc_putc>:

int udi_cdc_putc(int value)
{
   81538:	b508      	push	{r3, lr}
   8153a:	4601      	mov	r1, r0
	return udi_cdc_multi_putc(0, value);
   8153c:	2000      	movs	r0, #0
   8153e:	4b01      	ldr	r3, [pc, #4]	; (81544 <udi_cdc_putc+0xc>)
   81540:	4798      	blx	r3
}
   81542:	bd08      	pop	{r3, pc}
   81544:	000814a9 	.word	0x000814a9

00081548 <udi_cdc_multi_write_buf>:

iram_size_t udi_cdc_multi_write_buf(uint8_t port, const void* buf, iram_size_t size)
{
   81548:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
   8154c:	4688      	mov	r8, r1
   8154e:	4615      	mov	r5, r2

#if UDI_CDC_PORT_NB == 1 // To optimize code
	port = 0;
#endif

	if (9 == udi_cdc_line_coding[port].bDataBits) {
   81550:	4b1f      	ldr	r3, [pc, #124]	; (815d0 <udi_cdc_multi_write_buf+0x88>)
   81552:	799b      	ldrb	r3, [r3, #6]
   81554:	2b09      	cmp	r3, #9
		size *=2;
   81556:	bf08      	it	eq
   81558:	0055      	lsleq	r5, r2, #1
	}

udi_cdc_write_buf_loop_wait:
	// Check available space
	if (!udi_cdc_multi_is_tx_ready(port)) {
   8155a:	f8df a08c 	ldr.w	sl, [pc, #140]	; 815e8 <udi_cdc_multi_write_buf+0xa0>
   8155e:	2000      	movs	r0, #0
   81560:	47d0      	blx	sl
   81562:	b938      	cbnz	r0, 81574 <udi_cdc_multi_write_buf+0x2c>
		if (!udi_cdc_data_running) {
   81564:	4b1b      	ldr	r3, [pc, #108]	; (815d4 <udi_cdc_multi_write_buf+0x8c>)
   81566:	781b      	ldrb	r3, [r3, #0]
   81568:	f013 0fff 	tst.w	r3, #255	; 0xff
   8156c:	d1f7      	bne.n	8155e <udi_cdc_multi_write_buf+0x16>
   8156e:	4628      	mov	r0, r5
   81570:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_PRIMASK(void)
{
  uint32_t result;

  __ASM volatile ("MRS %0, primask" : "=r" (result) );
   81574:	f3ef 8b10 	mrs	fp, PRIMASK
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
   81578:	b672      	cpsid	i
   8157a:	f3bf 8f5f 	dmb	sy
static volatile bool     cpu_irq_prev_interrupt_state;

static inline irqflags_t cpu_irq_save(void)
{
	irqflags_t flags = cpu_irq_is_enabled();
	cpu_irq_disable();
   8157e:	2300      	movs	r3, #0
   81580:	4a15      	ldr	r2, [pc, #84]	; (815d8 <udi_cdc_multi_write_buf+0x90>)
   81582:	7013      	strb	r3, [r2, #0]
		goto udi_cdc_write_buf_loop_wait;
	}

	// Write values
	flags = cpu_irq_save();
	buf_sel = udi_cdc_tx_buf_sel[port];
   81584:	4b15      	ldr	r3, [pc, #84]	; (815dc <udi_cdc_multi_write_buf+0x94>)
   81586:	781e      	ldrb	r6, [r3, #0]
   81588:	b2f6      	uxtb	r6, r6
	buf_nb = udi_cdc_tx_buf_nb[port][buf_sel];
   8158a:	f8df 9060 	ldr.w	r9, [pc, #96]	; 815ec <udi_cdc_multi_write_buf+0xa4>
   8158e:	f839 7016 	ldrh.w	r7, [r9, r6, lsl #1]
	copy_nb = UDI_CDC_TX_BUFFERS - buf_nb;
   81592:	f5c7 7400 	rsb	r4, r7, #512	; 0x200
   81596:	42a5      	cmp	r5, r4
   81598:	bf38      	it	cc
   8159a:	462c      	movcc	r4, r5
	if (copy_nb > size) {
		copy_nb = size;
	}
	memcpy(&udi_cdc_tx_buf[port][buf_sel][buf_nb], ptr_buf, copy_nb);
   8159c:	eb07 2346 	add.w	r3, r7, r6, lsl #9
   815a0:	480f      	ldr	r0, [pc, #60]	; (815e0 <udi_cdc_multi_write_buf+0x98>)
   815a2:	4418      	add	r0, r3
   815a4:	4641      	mov	r1, r8
   815a6:	4622      	mov	r2, r4
   815a8:	4b0e      	ldr	r3, [pc, #56]	; (815e4 <udi_cdc_multi_write_buf+0x9c>)
   815aa:	4798      	blx	r3
	udi_cdc_tx_buf_nb[port][buf_sel] = buf_nb + copy_nb;
   815ac:	4427      	add	r7, r4
   815ae:	f829 7016 	strh.w	r7, [r9, r6, lsl #1]
	return (flags);
}

static inline void cpu_irq_restore(irqflags_t flags)
{
	if (cpu_irq_is_enabled_flags(flags))
   815b2:	465b      	mov	r3, fp
   815b4:	b92b      	cbnz	r3, 815c2 <udi_cdc_multi_write_buf+0x7a>
		cpu_irq_enable();
   815b6:	2301      	movs	r3, #1
   815b8:	4a07      	ldr	r2, [pc, #28]	; (815d8 <udi_cdc_multi_write_buf+0x90>)
   815ba:	7013      	strb	r3, [r2, #0]
   815bc:	f3bf 8f5f 	dmb	sy
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
   815c0:	b662      	cpsie	i
	cpu_irq_restore(flags);

	// Update buffer pointer
	ptr_buf = ptr_buf + copy_nb;
   815c2:	44a0      	add	r8, r4
	size -= copy_nb;

	if (size) {
   815c4:	1b2d      	subs	r5, r5, r4
   815c6:	d1ca      	bne.n	8155e <udi_cdc_multi_write_buf+0x16>
		goto udi_cdc_write_buf_loop_wait;
	}

	return 0;
   815c8:	2000      	movs	r0, #0
}
   815ca:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
   815ce:	bf00      	nop
   815d0:	20070de0 	.word	0x20070de0
   815d4:	20071204 	.word	0x20071204
   815d8:	20070270 	.word	0x20070270
   815dc:	20070dec 	.word	0x20070dec
   815e0:	20070df4 	.word	0x20070df4
   815e4:	000862d5 	.word	0x000862d5
   815e8:	00081495 	.word	0x00081495
   815ec:	20070df0 	.word	0x20070df0

000815f0 <udi_cdc_write_buf>:

iram_size_t udi_cdc_write_buf(const void* buf, iram_size_t size)
{
   815f0:	b508      	push	{r3, lr}
   815f2:	4603      	mov	r3, r0
   815f4:	460a      	mov	r2, r1
	return udi_cdc_multi_write_buf(0, buf, size);
   815f6:	2000      	movs	r0, #0
   815f8:	4619      	mov	r1, r3
   815fa:	4b01      	ldr	r3, [pc, #4]	; (81600 <udi_cdc_write_buf+0x10>)
   815fc:	4798      	blx	r3
}
   815fe:	bd08      	pop	{r3, pc}
   81600:	00081549 	.word	0x00081549

00081604 <udc_next_desc_in_iface>:
 */
static usb_conf_desc_t UDC_DESC_STORAGE *udc_get_eof_conf(void)
{
	return (UDC_DESC_STORAGE usb_conf_desc_t *) ((uint8_t *)
			udc_ptr_conf->desc +
			le16_to_cpu(udc_ptr_conf->desc->wTotalLength));
   81604:	4b0f      	ldr	r3, [pc, #60]	; (81644 <udc_next_desc_in_iface+0x40>)
   81606:	681b      	ldr	r3, [r3, #0]
   81608:	681b      	ldr	r3, [r3, #0]
 *
 * \return address after the last byte of USB Configuration descriptor
 */
static usb_conf_desc_t UDC_DESC_STORAGE *udc_get_eof_conf(void)
{
	return (UDC_DESC_STORAGE usb_conf_desc_t *) ((uint8_t *)
   8160a:	885a      	ldrh	r2, [r3, #2]
   8160c:	441a      	add	r2, r3
{
	usb_conf_desc_t UDC_DESC_STORAGE *ptr_eof_desc;

	ptr_eof_desc = udc_get_eof_conf();
	// Go to next descriptor
	desc = (UDC_DESC_STORAGE usb_conf_desc_t *) ((uint8_t *) desc +
   8160e:	7803      	ldrb	r3, [r0, #0]
   81610:	4418      	add	r0, r3
			desc->bLength);
	// Check the end of configuration descriptor
	while (ptr_eof_desc > desc) {
   81612:	4290      	cmp	r0, r2
   81614:	d210      	bcs.n	81638 <udc_next_desc_in_iface+0x34>
		// If new interface descriptor is found,
		// then it is the end of the current global interface descriptor
		if (USB_DT_INTERFACE == desc->bDescriptorType) {
   81616:	7843      	ldrb	r3, [r0, #1]
   81618:	2b04      	cmp	r3, #4
   8161a:	d00f      	beq.n	8163c <udc_next_desc_in_iface+0x38>
			break; // End of global interface descriptor
		}
		if (desc_id == desc->bDescriptorType) {
   8161c:	428b      	cmp	r3, r1
   8161e:	d105      	bne.n	8162c <udc_next_desc_in_iface+0x28>
   81620:	4770      	bx	lr
			desc->bLength);
	// Check the end of configuration descriptor
	while (ptr_eof_desc > desc) {
		// If new interface descriptor is found,
		// then it is the end of the current global interface descriptor
		if (USB_DT_INTERFACE == desc->bDescriptorType) {
   81622:	7843      	ldrb	r3, [r0, #1]
   81624:	2b04      	cmp	r3, #4
   81626:	d00b      	beq.n	81640 <udc_next_desc_in_iface+0x3c>
			break; // End of global interface descriptor
		}
		if (desc_id == desc->bDescriptorType) {
   81628:	428b      	cmp	r3, r1
   8162a:	d00a      	beq.n	81642 <udc_next_desc_in_iface+0x3e>
			return desc; // Specific descriptor found
		}
		// Go to next descriptor
		desc = (UDC_DESC_STORAGE usb_conf_desc_t *) ((uint8_t *) desc +
   8162c:	7803      	ldrb	r3, [r0, #0]
   8162e:	4418      	add	r0, r3
	ptr_eof_desc = udc_get_eof_conf();
	// Go to next descriptor
	desc = (UDC_DESC_STORAGE usb_conf_desc_t *) ((uint8_t *) desc +
			desc->bLength);
	// Check the end of configuration descriptor
	while (ptr_eof_desc > desc) {
   81630:	4290      	cmp	r0, r2
   81632:	d3f6      	bcc.n	81622 <udc_next_desc_in_iface+0x1e>
		}
		// Go to next descriptor
		desc = (UDC_DESC_STORAGE usb_conf_desc_t *) ((uint8_t *) desc +
				desc->bLength);
	}
	return NULL; // No specific descriptor found
   81634:	2000      	movs	r0, #0
   81636:	4770      	bx	lr
   81638:	2000      	movs	r0, #0
   8163a:	4770      	bx	lr
   8163c:	2000      	movs	r0, #0
   8163e:	4770      	bx	lr
   81640:	2000      	movs	r0, #0
}
   81642:	4770      	bx	lr
   81644:	2007162c 	.word	0x2007162c

00081648 <udc_valid_address>:
/**
 * \brief Change the address of device
 * Callback called at the end of request set address
 */
static void udc_valid_address(void)
{
   81648:	b508      	push	{r3, lr}
	udd_set_address(udd_g_ctrlreq.req.wValue & 0x7F);
   8164a:	4b03      	ldr	r3, [pc, #12]	; (81658 <udc_valid_address+0x10>)
   8164c:	7898      	ldrb	r0, [r3, #2]
   8164e:	f000 007f 	and.w	r0, r0, #127	; 0x7f
   81652:	4b02      	ldr	r3, [pc, #8]	; (8165c <udc_valid_address+0x14>)
   81654:	4798      	blx	r3
   81656:	bd08      	pop	{r3, pc}
   81658:	20075c44 	.word	0x20075c44
   8165c:	00082f61 	.word	0x00082f61

00081660 <udc_update_iface_desc>:
 * \param setting_num   Setting number of interface to find
 *
 * \return 1 if found or 0 if not found
 */
static bool udc_update_iface_desc(uint8_t iface_num, uint8_t setting_num)
{
   81660:	b410      	push	{r4}
	usb_conf_desc_t UDC_DESC_STORAGE *ptr_end_desc;

	if (0 == udc_num_configuration) {
   81662:	4b16      	ldr	r3, [pc, #88]	; (816bc <udc_update_iface_desc+0x5c>)
   81664:	781b      	ldrb	r3, [r3, #0]
   81666:	b303      	cbz	r3, 816aa <udc_update_iface_desc+0x4a>
		return false;
	}

	if (iface_num >= udc_ptr_conf->desc->bNumInterfaces) {
   81668:	4b15      	ldr	r3, [pc, #84]	; (816c0 <udc_update_iface_desc+0x60>)
   8166a:	681b      	ldr	r3, [r3, #0]
   8166c:	681b      	ldr	r3, [r3, #0]
   8166e:	791a      	ldrb	r2, [r3, #4]
   81670:	4282      	cmp	r2, r0
   81672:	d91c      	bls.n	816ae <udc_update_iface_desc+0x4e>
		return false;
	}

	// Start at the beginning of configuration descriptor
	udc_ptr_iface = (UDC_DESC_STORAGE usb_iface_desc_t *)
   81674:	4a13      	ldr	r2, [pc, #76]	; (816c4 <udc_update_iface_desc+0x64>)
   81676:	6013      	str	r3, [r2, #0]
 *
 * \return address after the last byte of USB Configuration descriptor
 */
static usb_conf_desc_t UDC_DESC_STORAGE *udc_get_eof_conf(void)
{
	return (UDC_DESC_STORAGE usb_conf_desc_t *) ((uint8_t *)
   81678:	885c      	ldrh	r4, [r3, #2]
   8167a:	441c      	add	r4, r3
	udc_ptr_iface = (UDC_DESC_STORAGE usb_iface_desc_t *)
			udc_ptr_conf->desc;

	// Check the end of configuration descriptor
	ptr_end_desc = udc_get_eof_conf();
	while (ptr_end_desc >
   8167c:	42a3      	cmp	r3, r4
   8167e:	d218      	bcs.n	816b2 <udc_update_iface_desc+0x52>
			(UDC_DESC_STORAGE usb_conf_desc_t *) udc_ptr_iface) {
		if (USB_DT_INTERFACE == udc_ptr_iface->bDescriptorType) {
   81680:	785a      	ldrb	r2, [r3, #1]
   81682:	2a04      	cmp	r2, #4
   81684:	d109      	bne.n	8169a <udc_update_iface_desc+0x3a>
			// A interface descriptor is found
			// Check interface and alternate setting number
			if ((iface_num == udc_ptr_iface->bInterfaceNumber) &&
   81686:	789a      	ldrb	r2, [r3, #2]
   81688:	4282      	cmp	r2, r0
   8168a:	d106      	bne.n	8169a <udc_update_iface_desc+0x3a>
   8168c:	78da      	ldrb	r2, [r3, #3]
   8168e:	428a      	cmp	r2, r1
   81690:	d103      	bne.n	8169a <udc_update_iface_desc+0x3a>
   81692:	4a0c      	ldr	r2, [pc, #48]	; (816c4 <udc_update_iface_desc+0x64>)
   81694:	6013      	str	r3, [r2, #0]
					(setting_num ==
					udc_ptr_iface->bAlternateSetting)) {
				return true; // Interface found
   81696:	2001      	movs	r0, #1
   81698:	e00c      	b.n	816b4 <udc_update_iface_desc+0x54>
			}
		}
		// Go to next descriptor
		udc_ptr_iface = (UDC_DESC_STORAGE usb_iface_desc_t *) (
   8169a:	781a      	ldrb	r2, [r3, #0]
   8169c:	4413      	add	r3, r2
	udc_ptr_iface = (UDC_DESC_STORAGE usb_iface_desc_t *)
			udc_ptr_conf->desc;

	// Check the end of configuration descriptor
	ptr_end_desc = udc_get_eof_conf();
	while (ptr_end_desc >
   8169e:	42a3      	cmp	r3, r4
   816a0:	d3ee      	bcc.n	81680 <udc_update_iface_desc+0x20>
   816a2:	4a08      	ldr	r2, [pc, #32]	; (816c4 <udc_update_iface_desc+0x64>)
   816a4:	6013      	str	r3, [r2, #0]
		// Go to next descriptor
		udc_ptr_iface = (UDC_DESC_STORAGE usb_iface_desc_t *) (
				(uint8_t *) udc_ptr_iface +
				udc_ptr_iface->bLength);
	}
	return false; // Interface not found
   816a6:	2000      	movs	r0, #0
   816a8:	e004      	b.n	816b4 <udc_update_iface_desc+0x54>
static bool udc_update_iface_desc(uint8_t iface_num, uint8_t setting_num)
{
	usb_conf_desc_t UDC_DESC_STORAGE *ptr_end_desc;

	if (0 == udc_num_configuration) {
		return false;
   816aa:	2000      	movs	r0, #0
   816ac:	e002      	b.n	816b4 <udc_update_iface_desc+0x54>
	}

	if (iface_num >= udc_ptr_conf->desc->bNumInterfaces) {
		return false;
   816ae:	2000      	movs	r0, #0
   816b0:	e000      	b.n	816b4 <udc_update_iface_desc+0x54>
		// Go to next descriptor
		udc_ptr_iface = (UDC_DESC_STORAGE usb_iface_desc_t *) (
				(uint8_t *) udc_ptr_iface +
				udc_ptr_iface->bLength);
	}
	return false; // Interface not found
   816b2:	2000      	movs	r0, #0
}
   816b4:	f85d 4b04 	ldr.w	r4, [sp], #4
   816b8:	4770      	bx	lr
   816ba:	bf00      	nop
   816bc:	20071638 	.word	0x20071638
   816c0:	2007162c 	.word	0x2007162c
   816c4:	2007163c 	.word	0x2007163c

000816c8 <udc_iface_disable>:
 * \param iface_num     Interface number to disable
 *
 * \return 1 if it is done or 0 if interface is not found
 */
static bool udc_iface_disable(uint8_t iface_num)
{
   816c8:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
   816cc:	4604      	mov	r4, r0
	udi_api_t UDC_DESC_STORAGE *udi_api;

	// Select first alternate setting of the interface
	// to update udc_ptr_iface before call iface->getsetting()
	if (!udc_update_iface_desc(iface_num, 0)) {
   816ce:	2100      	movs	r1, #0
   816d0:	4b12      	ldr	r3, [pc, #72]	; (8171c <udc_iface_disable+0x54>)
   816d2:	4798      	blx	r3
   816d4:	4680      	mov	r8, r0
   816d6:	b1e8      	cbz	r0, 81714 <udc_iface_disable+0x4c>
		return false;
	}

	// Select the interface with the current alternate setting
	udi_api = udc_ptr_conf->udi_apis[iface_num];
   816d8:	4b11      	ldr	r3, [pc, #68]	; (81720 <udc_iface_disable+0x58>)
   816da:	681b      	ldr	r3, [r3, #0]
   816dc:	685b      	ldr	r3, [r3, #4]
   816de:	f853 9024 	ldr.w	r9, [r3, r4, lsl #2]

#if (0!=USB_DEVICE_MAX_EP)
	if (!udc_update_iface_desc(iface_num, udi_api->getsetting())) {
   816e2:	f8d9 300c 	ldr.w	r3, [r9, #12]
   816e6:	4798      	blx	r3
   816e8:	4601      	mov	r1, r0
   816ea:	4620      	mov	r0, r4
   816ec:	4b0b      	ldr	r3, [pc, #44]	; (8171c <udc_iface_disable+0x54>)
   816ee:	4798      	blx	r3
   816f0:	4680      	mov	r8, r0
   816f2:	b178      	cbz	r0, 81714 <udc_iface_disable+0x4c>
	}

	// Start at the beginning of interface descriptor
	{
		usb_ep_desc_t UDC_DESC_STORAGE *ep_desc;
		ep_desc = (UDC_DESC_STORAGE usb_ep_desc_t *) udc_ptr_iface;
   816f4:	4b0b      	ldr	r3, [pc, #44]	; (81724 <udc_iface_disable+0x5c>)
   816f6:	681c      	ldr	r4, [r3, #0]
		while (1) {
			// Search Endpoint descriptor included in global interface descriptor
			ep_desc = (UDC_DESC_STORAGE usb_ep_desc_t *)
   816f8:	2605      	movs	r6, #5
   816fa:	4d0b      	ldr	r5, [pc, #44]	; (81728 <udc_iface_disable+0x60>)
					ep_desc, USB_DT_ENDPOINT);
			if (NULL == ep_desc) {
				break;
			}
			// Free the endpoint used by the interface
			udd_ep_free(ep_desc->bEndpointAddress);
   816fc:	4f0b      	ldr	r7, [pc, #44]	; (8172c <udc_iface_disable+0x64>)
	{
		usb_ep_desc_t UDC_DESC_STORAGE *ep_desc;
		ep_desc = (UDC_DESC_STORAGE usb_ep_desc_t *) udc_ptr_iface;
		while (1) {
			// Search Endpoint descriptor included in global interface descriptor
			ep_desc = (UDC_DESC_STORAGE usb_ep_desc_t *)
   816fe:	4620      	mov	r0, r4
   81700:	4631      	mov	r1, r6
   81702:	47a8      	blx	r5
					udc_next_desc_in_iface((UDC_DESC_STORAGE
					usb_conf_desc_t *)
					ep_desc, USB_DT_ENDPOINT);
			if (NULL == ep_desc) {
   81704:	4604      	mov	r4, r0
   81706:	b110      	cbz	r0, 8170e <udc_iface_disable+0x46>
				break;
			}
			// Free the endpoint used by the interface
			udd_ep_free(ep_desc->bEndpointAddress);
   81708:	7880      	ldrb	r0, [r0, #2]
   8170a:	47b8      	blx	r7
		}
   8170c:	e7f7      	b.n	816fe <udc_iface_disable+0x36>
	}
#endif

	// Disable interface
	udi_api->disable();
   8170e:	f8d9 3004 	ldr.w	r3, [r9, #4]
   81712:	4798      	blx	r3
	return true;
}
   81714:	4640      	mov	r0, r8
   81716:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
   8171a:	bf00      	nop
   8171c:	00081661 	.word	0x00081661
   81720:	2007162c 	.word	0x2007162c
   81724:	2007163c 	.word	0x2007163c
   81728:	00081605 	.word	0x00081605
   8172c:	00082fc5 	.word	0x00082fc5

00081730 <udc_iface_enable>:
 * \param setting_num   Setting number to enable
 *
 * \return 1 if it is done or 0 if interface is not found
 */
static bool udc_iface_enable(uint8_t iface_num, uint8_t setting_num)
{
   81730:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   81734:	4680      	mov	r8, r0
	// Select the interface descriptor
	if (!udc_update_iface_desc(iface_num, setting_num)) {
   81736:	4b10      	ldr	r3, [pc, #64]	; (81778 <udc_iface_enable+0x48>)
   81738:	4798      	blx	r3
   8173a:	4603      	mov	r3, r0
   8173c:	b1c8      	cbz	r0, 81772 <udc_iface_enable+0x42>

#if (0!=USB_DEVICE_MAX_EP)
	usb_ep_desc_t UDC_DESC_STORAGE *ep_desc;

	// Start at the beginning of the global interface descriptor
	ep_desc = (UDC_DESC_STORAGE usb_ep_desc_t *) udc_ptr_iface;
   8173e:	4b0f      	ldr	r3, [pc, #60]	; (8177c <udc_iface_enable+0x4c>)
   81740:	681c      	ldr	r4, [r3, #0]
	while (1) {
		// Search Endpoint descriptor included in the global interface descriptor
		ep_desc = (UDC_DESC_STORAGE usb_ep_desc_t *)
   81742:	2605      	movs	r6, #5
   81744:	4d0e      	ldr	r5, [pc, #56]	; (81780 <udc_iface_enable+0x50>)
						usb_conf_desc_t *) ep_desc,
				USB_DT_ENDPOINT);
		if (NULL == ep_desc)
			break;
		// Alloc the endpoint used by the interface
		if (!udd_ep_alloc(ep_desc->bEndpointAddress,
   81746:	4f0f      	ldr	r7, [pc, #60]	; (81784 <udc_iface_enable+0x54>)

	// Start at the beginning of the global interface descriptor
	ep_desc = (UDC_DESC_STORAGE usb_ep_desc_t *) udc_ptr_iface;
	while (1) {
		// Search Endpoint descriptor included in the global interface descriptor
		ep_desc = (UDC_DESC_STORAGE usb_ep_desc_t *)
   81748:	4620      	mov	r0, r4
   8174a:	4631      	mov	r1, r6
   8174c:	47a8      	blx	r5
				udc_next_desc_in_iface((UDC_DESC_STORAGE
						usb_conf_desc_t *) ep_desc,
				USB_DT_ENDPOINT);
		if (NULL == ep_desc)
   8174e:	4604      	mov	r4, r0
   81750:	b138      	cbz	r0, 81762 <udc_iface_enable+0x32>
			break;
		// Alloc the endpoint used by the interface
		if (!udd_ep_alloc(ep_desc->bEndpointAddress,
   81752:	7880      	ldrb	r0, [r0, #2]
   81754:	78e1      	ldrb	r1, [r4, #3]
   81756:	88a2      	ldrh	r2, [r4, #4]
   81758:	47b8      	blx	r7
   8175a:	4603      	mov	r3, r0
   8175c:	2800      	cmp	r0, #0
   8175e:	d1f3      	bne.n	81748 <udc_iface_enable+0x18>
   81760:	e007      	b.n	81772 <udc_iface_enable+0x42>
			return false;
		}
	}
#endif
	// Enable the interface
	return udc_ptr_conf->udi_apis[iface_num]->enable();
   81762:	4b09      	ldr	r3, [pc, #36]	; (81788 <udc_iface_enable+0x58>)
   81764:	681b      	ldr	r3, [r3, #0]
   81766:	685b      	ldr	r3, [r3, #4]
   81768:	f853 3028 	ldr.w	r3, [r3, r8, lsl #2]
   8176c:	681b      	ldr	r3, [r3, #0]
   8176e:	4798      	blx	r3
   81770:	4603      	mov	r3, r0
}
   81772:	4618      	mov	r0, r3
   81774:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   81778:	00081661 	.word	0x00081661
   8177c:	2007163c 	.word	0x2007163c
   81780:	00081605 	.word	0x00081605
   81784:	000832c9 	.word	0x000832c9
   81788:	2007162c 	.word	0x2007162c

0008178c <udc_start>:

/*! \brief Start the USB Device stack
 */
void udc_start(void)
{
   8178c:	b508      	push	{r3, lr}
	udd_enable();
   8178e:	4b01      	ldr	r3, [pc, #4]	; (81794 <udc_start+0x8>)
   81790:	4798      	blx	r3
   81792:	bd08      	pop	{r3, pc}
   81794:	0008270d 	.word	0x0008270d

00081798 <udc_reset>:
/**
 * \brief Reset the current configuration of the USB device,
 * This routines can be called by UDD when a RESET on the USB line occurs.
 */
void udc_reset(void)
{
   81798:	b570      	push	{r4, r5, r6, lr}
	uint8_t iface_num;

	if (udc_num_configuration) {
   8179a:	4b0d      	ldr	r3, [pc, #52]	; (817d0 <udc_reset+0x38>)
   8179c:	781b      	ldrb	r3, [r3, #0]
   8179e:	b183      	cbz	r3, 817c2 <udc_reset+0x2a>
		for (iface_num = 0;
				iface_num < udc_ptr_conf->desc->bNumInterfaces;
   817a0:	4b0c      	ldr	r3, [pc, #48]	; (817d4 <udc_reset+0x3c>)
   817a2:	681b      	ldr	r3, [r3, #0]
   817a4:	681b      	ldr	r3, [r3, #0]
void udc_reset(void)
{
	uint8_t iface_num;

	if (udc_num_configuration) {
		for (iface_num = 0;
   817a6:	791b      	ldrb	r3, [r3, #4]
   817a8:	b15b      	cbz	r3, 817c2 <udc_reset+0x2a>
   817aa:	2400      	movs	r4, #0
				iface_num < udc_ptr_conf->desc->bNumInterfaces;
				iface_num++) {
			udc_iface_disable(iface_num);
   817ac:	4e0a      	ldr	r6, [pc, #40]	; (817d8 <udc_reset+0x40>)
{
	uint8_t iface_num;

	if (udc_num_configuration) {
		for (iface_num = 0;
				iface_num < udc_ptr_conf->desc->bNumInterfaces;
   817ae:	4d09      	ldr	r5, [pc, #36]	; (817d4 <udc_reset+0x3c>)
				iface_num++) {
			udc_iface_disable(iface_num);
   817b0:	4620      	mov	r0, r4
   817b2:	47b0      	blx	r6
	uint8_t iface_num;

	if (udc_num_configuration) {
		for (iface_num = 0;
				iface_num < udc_ptr_conf->desc->bNumInterfaces;
				iface_num++) {
   817b4:	3401      	adds	r4, #1
   817b6:	b2e4      	uxtb	r4, r4
{
	uint8_t iface_num;

	if (udc_num_configuration) {
		for (iface_num = 0;
				iface_num < udc_ptr_conf->desc->bNumInterfaces;
   817b8:	682b      	ldr	r3, [r5, #0]
   817ba:	681b      	ldr	r3, [r3, #0]
void udc_reset(void)
{
	uint8_t iface_num;

	if (udc_num_configuration) {
		for (iface_num = 0;
   817bc:	791b      	ldrb	r3, [r3, #4]
   817be:	42a3      	cmp	r3, r4
   817c0:	d8f6      	bhi.n	817b0 <udc_reset+0x18>
				iface_num < udc_ptr_conf->desc->bNumInterfaces;
				iface_num++) {
			udc_iface_disable(iface_num);
		}
	}
	udc_num_configuration = 0;
   817c2:	2200      	movs	r2, #0
   817c4:	4b02      	ldr	r3, [pc, #8]	; (817d0 <udc_reset+0x38>)
   817c6:	701a      	strb	r2, [r3, #0]
	if (CPU_TO_LE16(USB_DEV_STATUS_REMOTEWAKEUP) & udc_device_status) {
		// Remote wakeup is enabled then disable it
		UDC_REMOTEWAKEUP_DISABLE();
	}
#endif
	udc_device_status =
   817c8:	2201      	movs	r2, #1
   817ca:	4b04      	ldr	r3, [pc, #16]	; (817dc <udc_reset+0x44>)
   817cc:	801a      	strh	r2, [r3, #0]
   817ce:	bd70      	pop	{r4, r5, r6, pc}
   817d0:	20071638 	.word	0x20071638
   817d4:	2007162c 	.word	0x2007162c
   817d8:	000816c9 	.word	0x000816c9
   817dc:	20071634 	.word	0x20071634

000817e0 <udc_sof_notify>:
			CPU_TO_LE16(USB_DEV_STATUS_BUS_POWERED);
#endif
}

void udc_sof_notify(void)
{
   817e0:	b538      	push	{r3, r4, r5, lr}
	uint8_t iface_num;

	if (udc_num_configuration) {
   817e2:	4b0c      	ldr	r3, [pc, #48]	; (81814 <udc_sof_notify+0x34>)
   817e4:	781b      	ldrb	r3, [r3, #0]
   817e6:	b19b      	cbz	r3, 81810 <udc_sof_notify+0x30>
		for (iface_num = 0;
				iface_num < udc_ptr_conf->desc->bNumInterfaces;
   817e8:	4b0b      	ldr	r3, [pc, #44]	; (81818 <udc_sof_notify+0x38>)
   817ea:	681b      	ldr	r3, [r3, #0]
   817ec:	681a      	ldr	r2, [r3, #0]
void udc_sof_notify(void)
{
	uint8_t iface_num;

	if (udc_num_configuration) {
		for (iface_num = 0;
   817ee:	7912      	ldrb	r2, [r2, #4]
   817f0:	b172      	cbz	r2, 81810 <udc_sof_notify+0x30>
   817f2:	2400      	movs	r4, #0
				iface_num < udc_ptr_conf->desc->bNumInterfaces;
   817f4:	4d08      	ldr	r5, [pc, #32]	; (81818 <udc_sof_notify+0x38>)
				iface_num++) {
			if (udc_ptr_conf->udi_apis[iface_num]->sof_notify != NULL) {
   817f6:	685b      	ldr	r3, [r3, #4]
   817f8:	f853 3024 	ldr.w	r3, [r3, r4, lsl #2]
   817fc:	691b      	ldr	r3, [r3, #16]
   817fe:	b103      	cbz	r3, 81802 <udc_sof_notify+0x22>
				udc_ptr_conf->udi_apis[iface_num]->sof_notify();
   81800:	4798      	blx	r3
	uint8_t iface_num;

	if (udc_num_configuration) {
		for (iface_num = 0;
				iface_num < udc_ptr_conf->desc->bNumInterfaces;
				iface_num++) {
   81802:	3401      	adds	r4, #1
   81804:	b2e4      	uxtb	r4, r4
{
	uint8_t iface_num;

	if (udc_num_configuration) {
		for (iface_num = 0;
				iface_num < udc_ptr_conf->desc->bNumInterfaces;
   81806:	682b      	ldr	r3, [r5, #0]
   81808:	681a      	ldr	r2, [r3, #0]
void udc_sof_notify(void)
{
	uint8_t iface_num;

	if (udc_num_configuration) {
		for (iface_num = 0;
   8180a:	7912      	ldrb	r2, [r2, #4]
   8180c:	42a2      	cmp	r2, r4
   8180e:	d8f2      	bhi.n	817f6 <udc_sof_notify+0x16>
   81810:	bd38      	pop	{r3, r4, r5, pc}
   81812:	bf00      	nop
   81814:	20071638 	.word	0x20071638
   81818:	2007162c 	.word	0x2007162c

0008181c <udc_process_setup>:
 * sent to a specific application callback.
 *
 * \return true if the request is supported, else the request is stalled by UDD
 */
bool udc_process_setup(void)
{
   8181c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	// By default no data (receive/send) and no callbacks registered
	udd_g_ctrlreq.payload_size = 0;
   81820:	4b88      	ldr	r3, [pc, #544]	; (81a44 <udc_process_setup+0x228>)
   81822:	2200      	movs	r2, #0
   81824:	819a      	strh	r2, [r3, #12]
	udd_g_ctrlreq.callback = NULL;
   81826:	611a      	str	r2, [r3, #16]
	udd_g_ctrlreq.over_under_run = NULL;
   81828:	615a      	str	r2, [r3, #20]

	if (Udd_setup_is_in()) {
   8182a:	781b      	ldrb	r3, [r3, #0]
   8182c:	f013 0f80 	tst.w	r3, #128	; 0x80
   81830:	f000 82d0 	beq.w	81dd4 <udc_process_setup+0x5b8>
		if (udd_g_ctrlreq.req.wLength == 0) {
   81834:	4a83      	ldr	r2, [pc, #524]	; (81a44 <udc_process_setup+0x228>)
   81836:	88d2      	ldrh	r2, [r2, #6]
   81838:	2a00      	cmp	r2, #0
   8183a:	f040 82cf 	bne.w	81ddc <udc_process_setup+0x5c0>
   8183e:	e2c5      	b.n	81dcc <udc_process_setup+0x5b0>
		// GET Standard Requests
		if (udd_g_ctrlreq.req.wLength == 0) {
			return false; // Error for USB host
		}

		if (USB_REQ_RECIP_DEVICE == Udd_setup_recipient()) {
   81840:	f013 031f 	ands.w	r3, r3, #31
   81844:	f040 80d0 	bne.w	819e8 <udc_process_setup+0x1cc>
			// Standard Get Device request
			switch (udd_g_ctrlreq.req.bRequest) {
   81848:	497e      	ldr	r1, [pc, #504]	; (81a44 <udc_process_setup+0x228>)
   8184a:	7849      	ldrb	r1, [r1, #1]
   8184c:	2906      	cmp	r1, #6
   8184e:	d00f      	beq.n	81870 <udc_process_setup+0x54>
   81850:	2908      	cmp	r1, #8
   81852:	f000 80bf 	beq.w	819d4 <udc_process_setup+0x1b8>
   81856:	2900      	cmp	r1, #0
   81858:	f040 80c6 	bne.w	819e8 <udc_process_setup+0x1cc>
 *
 * \return true if success
 */
static bool udc_req_std_dev_get_status(void)
{
	if (udd_g_ctrlreq.req.wLength != sizeof(udc_device_status)) {
   8185c:	2a02      	cmp	r2, #2
   8185e:	d105      	bne.n	8186c <udc_process_setup+0x50>
		return false;
	}

	udd_set_setup_payload( (uint8_t *) & udc_device_status,
   81860:	4879      	ldr	r0, [pc, #484]	; (81a48 <udc_process_setup+0x22c>)
   81862:	2102      	movs	r1, #2
   81864:	4b79      	ldr	r3, [pc, #484]	; (81a4c <udc_process_setup+0x230>)
   81866:	4798      	blx	r3
			sizeof(udc_device_status));
	return true;
   81868:	2401      	movs	r4, #1
   8186a:	e25b      	b.n	81d24 <udc_process_setup+0x508>
 * \return true if success
 */
static bool udc_req_std_dev_get_status(void)
{
	if (udd_g_ctrlreq.req.wLength != sizeof(udc_device_status)) {
		return false;
   8186c:	2400      	movs	r4, #0
   8186e:	e259      	b.n	81d24 <udc_process_setup+0x508>
 */
static bool udc_req_std_dev_get_descriptor(void)
{
	uint8_t conf_num;

	conf_num = udd_g_ctrlreq.req.wValue & 0xff;
   81870:	4b74      	ldr	r3, [pc, #464]	; (81a44 <udc_process_setup+0x228>)
   81872:	885b      	ldrh	r3, [r3, #2]
   81874:	b2dd      	uxtb	r5, r3

	// Check descriptor ID
	switch ((uint8_t) (udd_g_ctrlreq.req.wValue >> 8)) {
   81876:	0a1a      	lsrs	r2, r3, #8
   81878:	3a01      	subs	r2, #1
   8187a:	2a0e      	cmp	r2, #14
   8187c:	f200 809e 	bhi.w	819bc <udc_process_setup+0x1a0>
   81880:	e8df f002 	tbb	[pc, r2]
   81884:	9c731908 	.word	0x9c731908
   81888:	9c453e9c 	.word	0x9c453e9c
   8188c:	9c9c9c9c 	.word	0x9c9c9c9c
   81890:	9c9c      	.short	0x9c9c
   81892:	6a          	.byte	0x6a
   81893:	00          	.byte	0x00
	case USB_DT_DEVICE:
		// Device descriptor requested
#ifdef USB_DEVICE_HS_SUPPORT
		if (!udd_is_high_speed()) {
   81894:	4b6e      	ldr	r3, [pc, #440]	; (81a50 <udc_process_setup+0x234>)
   81896:	4798      	blx	r3
   81898:	b930      	cbnz	r0, 818a8 <udc_process_setup+0x8c>
			udd_set_setup_payload(
				(uint8_t *) udc_config.confdev_hs,
				udc_config.confdev_hs->bLength);
   8189a:	4b6e      	ldr	r3, [pc, #440]	; (81a54 <udc_process_setup+0x238>)
   8189c:	689b      	ldr	r3, [r3, #8]
	switch ((uint8_t) (udd_g_ctrlreq.req.wValue >> 8)) {
	case USB_DT_DEVICE:
		// Device descriptor requested
#ifdef USB_DEVICE_HS_SUPPORT
		if (!udd_is_high_speed()) {
			udd_set_setup_payload(
   8189e:	4618      	mov	r0, r3
   818a0:	7819      	ldrb	r1, [r3, #0]
   818a2:	4b6a      	ldr	r3, [pc, #424]	; (81a4c <udc_process_setup+0x230>)
   818a4:	4798      	blx	r3
   818a6:	e080      	b.n	819aa <udc_process_setup+0x18e>
		} else
#endif
		{
			udd_set_setup_payload(
				(uint8_t *) udc_config.confdev_lsfs,
				udc_config.confdev_lsfs->bLength);
   818a8:	4b6a      	ldr	r3, [pc, #424]	; (81a54 <udc_process_setup+0x238>)
   818aa:	681b      	ldr	r3, [r3, #0]
				(uint8_t *) udc_config.confdev_hs,
				udc_config.confdev_hs->bLength);
		} else
#endif
		{
			udd_set_setup_payload(
   818ac:	4618      	mov	r0, r3
   818ae:	7819      	ldrb	r1, [r3, #0]
   818b0:	4b66      	ldr	r3, [pc, #408]	; (81a4c <udc_process_setup+0x230>)
   818b2:	4798      	blx	r3
   818b4:	e079      	b.n	819aa <udc_process_setup+0x18e>
		break;

	case USB_DT_CONFIGURATION:
		// Configuration descriptor requested
#ifdef USB_DEVICE_HS_SUPPORT
		if (udd_is_high_speed()) {
   818b6:	4b66      	ldr	r3, [pc, #408]	; (81a50 <udc_process_setup+0x234>)
   818b8:	4798      	blx	r3
   818ba:	4604      	mov	r4, r0
   818bc:	b168      	cbz	r0, 818da <udc_process_setup+0xbe>
			// HS descriptor
			if (conf_num >= udc_config.confdev_hs->
   818be:	4b65      	ldr	r3, [pc, #404]	; (81a54 <udc_process_setup+0x238>)
   818c0:	689b      	ldr	r3, [r3, #8]
   818c2:	7c5b      	ldrb	r3, [r3, #17]
   818c4:	42ab      	cmp	r3, r5
   818c6:	d97b      	bls.n	819c0 <udc_process_setup+0x1a4>
					bNumConfigurations) {
				return false;
			}
			udd_set_setup_payload(
				(uint8_t *)udc_config.conf_hs[conf_num].desc,
				le16_to_cpu(udc_config.conf_hs[conf_num].desc->wTotalLength));
   818c8:	4b62      	ldr	r3, [pc, #392]	; (81a54 <udc_process_setup+0x238>)
   818ca:	691b      	ldr	r3, [r3, #16]
   818cc:	f853 3035 	ldr.w	r3, [r3, r5, lsl #3]
			// HS descriptor
			if (conf_num >= udc_config.confdev_hs->
					bNumConfigurations) {
				return false;
			}
			udd_set_setup_payload(
   818d0:	4618      	mov	r0, r3
   818d2:	8859      	ldrh	r1, [r3, #2]
   818d4:	4b5d      	ldr	r3, [pc, #372]	; (81a4c <udc_process_setup+0x230>)
   818d6:	4798      	blx	r3
   818d8:	e00d      	b.n	818f6 <udc_process_setup+0xda>
				le16_to_cpu(udc_config.conf_hs[conf_num].desc->wTotalLength));
		} else
#endif
		{
			// FS descriptor
			if (conf_num >= udc_config.confdev_lsfs->
   818da:	4b5e      	ldr	r3, [pc, #376]	; (81a54 <udc_process_setup+0x238>)
   818dc:	681b      	ldr	r3, [r3, #0]
   818de:	7c5b      	ldrb	r3, [r3, #17]
   818e0:	42ab      	cmp	r3, r5
   818e2:	f240 821f 	bls.w	81d24 <udc_process_setup+0x508>
					bNumConfigurations) {
				return false;
			}
			udd_set_setup_payload(
				(uint8_t *)udc_config.conf_lsfs[conf_num].desc,
				le16_to_cpu(udc_config.conf_lsfs[conf_num].desc->wTotalLength));
   818e6:	4b5b      	ldr	r3, [pc, #364]	; (81a54 <udc_process_setup+0x238>)
   818e8:	685b      	ldr	r3, [r3, #4]
   818ea:	f853 3035 	ldr.w	r3, [r3, r5, lsl #3]
			// FS descriptor
			if (conf_num >= udc_config.confdev_lsfs->
					bNumConfigurations) {
				return false;
			}
			udd_set_setup_payload(
   818ee:	4618      	mov	r0, r3
   818f0:	8859      	ldrh	r1, [r3, #2]
   818f2:	4b56      	ldr	r3, [pc, #344]	; (81a4c <udc_process_setup+0x230>)
   818f4:	4798      	blx	r3
				(uint8_t *)udc_config.conf_lsfs[conf_num].desc,
				le16_to_cpu(udc_config.conf_lsfs[conf_num].desc->wTotalLength));
		}
		((usb_conf_desc_t *) udd_g_ctrlreq.payload)->bDescriptorType =
   818f6:	4b53      	ldr	r3, [pc, #332]	; (81a44 <udc_process_setup+0x228>)
   818f8:	689b      	ldr	r3, [r3, #8]
   818fa:	2202      	movs	r2, #2
   818fc:	705a      	strb	r2, [r3, #1]
   818fe:	e054      	b.n	819aa <udc_process_setup+0x18e>

#ifdef USB_DEVICE_HS_SUPPORT
	case USB_DT_DEVICE_QUALIFIER:
		// Device qualifier descriptor requested
		udd_set_setup_payload( (uint8_t *) udc_config.qualifier,
				udc_config.qualifier->bLength);
   81900:	4b54      	ldr	r3, [pc, #336]	; (81a54 <udc_process_setup+0x238>)
   81902:	68db      	ldr	r3, [r3, #12]
		break;

#ifdef USB_DEVICE_HS_SUPPORT
	case USB_DT_DEVICE_QUALIFIER:
		// Device qualifier descriptor requested
		udd_set_setup_payload( (uint8_t *) udc_config.qualifier,
   81904:	4618      	mov	r0, r3
   81906:	7819      	ldrb	r1, [r3, #0]
   81908:	4b50      	ldr	r3, [pc, #320]	; (81a4c <udc_process_setup+0x230>)
   8190a:	4798      	blx	r3
   8190c:	e04d      	b.n	819aa <udc_process_setup+0x18e>
				udc_config.qualifier->bLength);
		break;

	case USB_DT_OTHER_SPEED_CONFIGURATION:
		// Other configuration descriptor requested
		if (!udd_is_high_speed()) {
   8190e:	4b50      	ldr	r3, [pc, #320]	; (81a50 <udc_process_setup+0x234>)
   81910:	4798      	blx	r3
   81912:	4604      	mov	r4, r0
   81914:	b970      	cbnz	r0, 81934 <udc_process_setup+0x118>
			// HS descriptor
			if (conf_num >= udc_config.confdev_hs->
   81916:	4b4f      	ldr	r3, [pc, #316]	; (81a54 <udc_process_setup+0x238>)
   81918:	689b      	ldr	r3, [r3, #8]
   8191a:	7c5b      	ldrb	r3, [r3, #17]
   8191c:	42ab      	cmp	r3, r5
   8191e:	f240 8201 	bls.w	81d24 <udc_process_setup+0x508>
					bNumConfigurations) {
				return false;
			}
			udd_set_setup_payload(
				(uint8_t *)udc_config.conf_hs[conf_num].desc,
				le16_to_cpu(udc_config.conf_hs[conf_num].desc->wTotalLength));
   81922:	4b4c      	ldr	r3, [pc, #304]	; (81a54 <udc_process_setup+0x238>)
   81924:	691b      	ldr	r3, [r3, #16]
   81926:	f853 3035 	ldr.w	r3, [r3, r5, lsl #3]
			// HS descriptor
			if (conf_num >= udc_config.confdev_hs->
					bNumConfigurations) {
				return false;
			}
			udd_set_setup_payload(
   8192a:	4618      	mov	r0, r3
   8192c:	8859      	ldrh	r1, [r3, #2]
   8192e:	4b47      	ldr	r3, [pc, #284]	; (81a4c <udc_process_setup+0x230>)
   81930:	4798      	blx	r3
   81932:	e00c      	b.n	8194e <udc_process_setup+0x132>
				(uint8_t *)udc_config.conf_hs[conf_num].desc,
				le16_to_cpu(udc_config.conf_hs[conf_num].desc->wTotalLength));
		} else {
			// FS descriptor
			if (conf_num >= udc_config.confdev_lsfs->
   81934:	4b47      	ldr	r3, [pc, #284]	; (81a54 <udc_process_setup+0x238>)
   81936:	681b      	ldr	r3, [r3, #0]
   81938:	7c5b      	ldrb	r3, [r3, #17]
   8193a:	42ab      	cmp	r3, r5
   8193c:	d942      	bls.n	819c4 <udc_process_setup+0x1a8>
					bNumConfigurations) {
				return false;
			}
			udd_set_setup_payload(
				(uint8_t *)udc_config.conf_lsfs[conf_num].desc,
				le16_to_cpu(udc_config.conf_lsfs[conf_num].desc->wTotalLength));
   8193e:	4b45      	ldr	r3, [pc, #276]	; (81a54 <udc_process_setup+0x238>)
   81940:	685b      	ldr	r3, [r3, #4]
   81942:	f853 3035 	ldr.w	r3, [r3, r5, lsl #3]
			// FS descriptor
			if (conf_num >= udc_config.confdev_lsfs->
					bNumConfigurations) {
				return false;
			}
			udd_set_setup_payload(
   81946:	4618      	mov	r0, r3
   81948:	8859      	ldrh	r1, [r3, #2]
   8194a:	4b40      	ldr	r3, [pc, #256]	; (81a4c <udc_process_setup+0x230>)
   8194c:	4798      	blx	r3
				(uint8_t *)udc_config.conf_lsfs[conf_num].desc,
				le16_to_cpu(udc_config.conf_lsfs[conf_num].desc->wTotalLength));
		}
		((usb_conf_desc_t *) udd_g_ctrlreq.payload)->bDescriptorType =
   8194e:	4b3d      	ldr	r3, [pc, #244]	; (81a44 <udc_process_setup+0x228>)
   81950:	689b      	ldr	r3, [r3, #8]
   81952:	2207      	movs	r2, #7
   81954:	705a      	strb	r2, [r3, #1]
   81956:	e028      	b.n	819aa <udc_process_setup+0x18e>
		break;
#endif

	case USB_DT_BOS:
		// Device BOS descriptor requested
		if (udc_config.conf_bos == NULL) {
   81958:	4b3e      	ldr	r3, [pc, #248]	; (81a54 <udc_process_setup+0x238>)
   8195a:	695b      	ldr	r3, [r3, #20]
   8195c:	2b00      	cmp	r3, #0
   8195e:	d033      	beq.n	819c8 <udc_process_setup+0x1ac>
			return false;
		}
		udd_set_setup_payload( (uint8_t *) udc_config.conf_bos,
   81960:	4618      	mov	r0, r3
   81962:	8859      	ldrh	r1, [r3, #2]
   81964:	4b39      	ldr	r3, [pc, #228]	; (81a4c <udc_process_setup+0x230>)
   81966:	4798      	blx	r3
   81968:	e01f      	b.n	819aa <udc_process_setup+0x18e>
	uint8_t i;
	const uint8_t *str;
	uint8_t str_length = 0;

	// Link payload pointer to the string corresponding at request
	switch (udd_g_ctrlreq.req.wValue & 0xff) {
   8196a:	b2db      	uxtb	r3, r3
   8196c:	2b01      	cmp	r3, #1
   8196e:	d008      	beq.n	81982 <udc_process_setup+0x166>
   81970:	b113      	cbz	r3, 81978 <udc_process_setup+0x15c>
   81972:	2b02      	cmp	r3, #2
   81974:	d008      	beq.n	81988 <udc_process_setup+0x16c>
   81976:	e029      	b.n	819cc <udc_process_setup+0x1b0>
	case 0:
		udd_set_setup_payload((uint8_t *) &udc_string_desc_languageid,
   81978:	4837      	ldr	r0, [pc, #220]	; (81a58 <udc_process_setup+0x23c>)
   8197a:	2104      	movs	r1, #4
   8197c:	4b33      	ldr	r3, [pc, #204]	; (81a4c <udc_process_setup+0x230>)
   8197e:	4798      	blx	r3
   81980:	e013      	b.n	819aa <udc_process_setup+0x18e>
		break;

#ifdef USB_DEVICE_MANUFACTURE_NAME
	case 1:
		str_length = USB_DEVICE_MANUFACTURE_NAME_SIZE;
		str = udc_string_manufacturer_name;
   81982:	4c36      	ldr	r4, [pc, #216]	; (81a5c <udc_process_setup+0x240>)
				sizeof(udc_string_desc_languageid));
		break;

#ifdef USB_DEVICE_MANUFACTURE_NAME
	case 1:
		str_length = USB_DEVICE_MANUFACTURE_NAME_SIZE;
   81984:	2005      	movs	r0, #5
   81986:	e001      	b.n	8198c <udc_process_setup+0x170>
		break;
#endif
#ifdef USB_DEVICE_PRODUCT_NAME
	case 2:
		str_length = USB_DEVICE_PRODUCT_NAME_SIZE;
		str = udc_string_product_name;
   81988:	4c35      	ldr	r4, [pc, #212]	; (81a60 <udc_process_setup+0x244>)
		str = udc_string_manufacturer_name;
		break;
#endif
#ifdef USB_DEVICE_PRODUCT_NAME
	case 2:
		str_length = USB_DEVICE_PRODUCT_NAME_SIZE;
   8198a:	2011      	movs	r0, #17
   8198c:	4a35      	ldr	r2, [pc, #212]	; (81a64 <udc_process_setup+0x248>)
   8198e:	2300      	movs	r3, #0
		return false;
	}

	if (str_length) {
		for(i = 0; i < str_length; i++) {
			udc_string_desc.string[i] = cpu_to_le16((le16_t)str[i]);
   81990:	5ce1      	ldrb	r1, [r4, r3]
   81992:	f822 1f02 	strh.w	r1, [r2, #2]!
   81996:	3301      	adds	r3, #1
#endif
		return false;
	}

	if (str_length) {
		for(i = 0; i < str_length; i++) {
   81998:	b2d9      	uxtb	r1, r3
   8199a:	4281      	cmp	r1, r0
   8199c:	d3f8      	bcc.n	81990 <udc_process_setup+0x174>
			udc_string_desc.string[i] = cpu_to_le16((le16_t)str[i]);
		}

		udc_string_desc.header.bLength = 2 + (str_length) * 2;
   8199e:	0041      	lsls	r1, r0, #1
   819a0:	3102      	adds	r1, #2
   819a2:	4830      	ldr	r0, [pc, #192]	; (81a64 <udc_process_setup+0x248>)
   819a4:	7001      	strb	r1, [r0, #0]
		udd_set_setup_payload(
   819a6:	4b29      	ldr	r3, [pc, #164]	; (81a4c <udc_process_setup+0x230>)
   819a8:	4798      	blx	r3
	default:
		// Unknown descriptor requested
		return false;
	}
	// if the descriptor is larger than length requested, then reduce it
	if (udd_g_ctrlreq.req.wLength < udd_g_ctrlreq.payload_size) {
   819aa:	4b26      	ldr	r3, [pc, #152]	; (81a44 <udc_process_setup+0x228>)
   819ac:	88da      	ldrh	r2, [r3, #6]
   819ae:	899b      	ldrh	r3, [r3, #12]
   819b0:	4293      	cmp	r3, r2
   819b2:	d90d      	bls.n	819d0 <udc_process_setup+0x1b4>
		udd_g_ctrlreq.payload_size = udd_g_ctrlreq.req.wLength;
   819b4:	4b23      	ldr	r3, [pc, #140]	; (81a44 <udc_process_setup+0x228>)
   819b6:	819a      	strh	r2, [r3, #12]
	}
	return true;
   819b8:	2401      	movs	r4, #1
   819ba:	e1b3      	b.n	81d24 <udc_process_setup+0x508>
		}
		break;

	default:
		// Unknown descriptor requested
		return false;
   819bc:	2400      	movs	r4, #0
   819be:	e1b1      	b.n	81d24 <udc_process_setup+0x508>
#ifdef USB_DEVICE_HS_SUPPORT
		if (udd_is_high_speed()) {
			// HS descriptor
			if (conf_num >= udc_config.confdev_hs->
					bNumConfigurations) {
				return false;
   819c0:	2400      	movs	r4, #0
   819c2:	e1af      	b.n	81d24 <udc_process_setup+0x508>
				le16_to_cpu(udc_config.conf_hs[conf_num].desc->wTotalLength));
		} else {
			// FS descriptor
			if (conf_num >= udc_config.confdev_lsfs->
					bNumConfigurations) {
				return false;
   819c4:	2400      	movs	r4, #0
   819c6:	e1ad      	b.n	81d24 <udc_process_setup+0x508>
#endif

	case USB_DT_BOS:
		// Device BOS descriptor requested
		if (udc_config.conf_bos == NULL) {
			return false;
   819c8:	2400      	movs	r4, #0
   819ca:	e1ab      	b.n	81d24 <udc_process_setup+0x508>
		break;

	case USB_DT_STRING:
		// String descriptor requested
		if (!udc_req_std_dev_get_str_desc()) {
			return false;
   819cc:	2400      	movs	r4, #0
   819ce:	e1a9      	b.n	81d24 <udc_process_setup+0x508>
	}
	// if the descriptor is larger than length requested, then reduce it
	if (udd_g_ctrlreq.req.wLength < udd_g_ctrlreq.payload_size) {
		udd_g_ctrlreq.payload_size = udd_g_ctrlreq.req.wLength;
	}
	return true;
   819d0:	2401      	movs	r4, #1
   819d2:	e1a7      	b.n	81d24 <udc_process_setup+0x508>
 *
 * \return true if success
 */
static bool udc_req_std_dev_get_configuration(void)
{
	if (udd_g_ctrlreq.req.wLength != 1) {
   819d4:	2a01      	cmp	r2, #1
   819d6:	d105      	bne.n	819e4 <udc_process_setup+0x1c8>
		return false;
	}

	udd_set_setup_payload(&udc_num_configuration,1);
   819d8:	4823      	ldr	r0, [pc, #140]	; (81a68 <udc_process_setup+0x24c>)
   819da:	2101      	movs	r1, #1
   819dc:	4b1b      	ldr	r3, [pc, #108]	; (81a4c <udc_process_setup+0x230>)
   819de:	4798      	blx	r3
	return true;
   819e0:	2401      	movs	r4, #1
   819e2:	e19f      	b.n	81d24 <udc_process_setup+0x508>
 * \return true if success
 */
static bool udc_req_std_dev_get_configuration(void)
{
	if (udd_g_ctrlreq.req.wLength != 1) {
		return false;
   819e4:	2400      	movs	r4, #0
   819e6:	e19d      	b.n	81d24 <udc_process_setup+0x508>
			default:
				break;
			}
		}

		if (USB_REQ_RECIP_INTERFACE == Udd_setup_recipient()) {
   819e8:	2b01      	cmp	r3, #1
   819ea:	d145      	bne.n	81a78 <udc_process_setup+0x25c>
			// Standard Get Interface request
			switch (udd_g_ctrlreq.req.bRequest) {
   819ec:	4915      	ldr	r1, [pc, #84]	; (81a44 <udc_process_setup+0x228>)
   819ee:	7849      	ldrb	r1, [r1, #1]
   819f0:	290a      	cmp	r1, #10
   819f2:	d141      	bne.n	81a78 <udc_process_setup+0x25c>
static bool udc_req_std_iface_get_setting(void)
{
	uint8_t iface_num;
	udi_api_t UDC_DESC_STORAGE *udi_api;

	if (udd_g_ctrlreq.req.wLength != 1) {
   819f4:	2a01      	cmp	r2, #1
   819f6:	d11e      	bne.n	81a36 <udc_process_setup+0x21a>
		return false; // Error in request
	}
	if (!udc_num_configuration) {
   819f8:	4b1b      	ldr	r3, [pc, #108]	; (81a68 <udc_process_setup+0x24c>)
   819fa:	781b      	ldrb	r3, [r3, #0]
   819fc:	b1eb      	cbz	r3, 81a3a <udc_process_setup+0x21e>
		return false; // The device is not is configured state yet
	}

	// Check the interface number included in the request
	iface_num = udd_g_ctrlreq.req.wIndex & 0xFF;
   819fe:	4b11      	ldr	r3, [pc, #68]	; (81a44 <udc_process_setup+0x228>)
   81a00:	791d      	ldrb	r5, [r3, #4]
	if (iface_num >= udc_ptr_conf->desc->bNumInterfaces) {
   81a02:	4b1a      	ldr	r3, [pc, #104]	; (81a6c <udc_process_setup+0x250>)
   81a04:	681e      	ldr	r6, [r3, #0]
   81a06:	6833      	ldr	r3, [r6, #0]
   81a08:	791b      	ldrb	r3, [r3, #4]
   81a0a:	42ab      	cmp	r3, r5
   81a0c:	d917      	bls.n	81a3e <udc_process_setup+0x222>
		return false;
	}

	// Select first alternate setting of the interface to update udc_ptr_iface
	// before call iface->getsetting()
	if (!udc_update_iface_desc(iface_num, 0)) {
   81a0e:	4628      	mov	r0, r5
   81a10:	2100      	movs	r1, #0
   81a12:	4b17      	ldr	r3, [pc, #92]	; (81a70 <udc_process_setup+0x254>)
   81a14:	4798      	blx	r3
   81a16:	4604      	mov	r4, r0
   81a18:	2800      	cmp	r0, #0
   81a1a:	f000 8183 	beq.w	81d24 <udc_process_setup+0x508>
		return false;
	}
	// Get alternate setting from UDI
	udi_api = udc_ptr_conf->udi_apis[iface_num];
   81a1e:	6873      	ldr	r3, [r6, #4]
	udc_iface_setting = udi_api->getsetting();
   81a20:	f853 3025 	ldr.w	r3, [r3, r5, lsl #2]
   81a24:	68db      	ldr	r3, [r3, #12]
   81a26:	4798      	blx	r3
   81a28:	4b12      	ldr	r3, [pc, #72]	; (81a74 <udc_process_setup+0x258>)
   81a2a:	7018      	strb	r0, [r3, #0]

	// Link value to payload pointer of request
	udd_set_setup_payload(&udc_iface_setting,1);
   81a2c:	4618      	mov	r0, r3
   81a2e:	2101      	movs	r1, #1
   81a30:	4b06      	ldr	r3, [pc, #24]	; (81a4c <udc_process_setup+0x230>)
   81a32:	4798      	blx	r3
   81a34:	e176      	b.n	81d24 <udc_process_setup+0x508>
{
	uint8_t iface_num;
	udi_api_t UDC_DESC_STORAGE *udi_api;

	if (udd_g_ctrlreq.req.wLength != 1) {
		return false; // Error in request
   81a36:	2400      	movs	r4, #0
   81a38:	e174      	b.n	81d24 <udc_process_setup+0x508>
	}
	if (!udc_num_configuration) {
		return false; // The device is not is configured state yet
   81a3a:	2400      	movs	r4, #0
   81a3c:	e172      	b.n	81d24 <udc_process_setup+0x508>
	}

	// Check the interface number included in the request
	iface_num = udd_g_ctrlreq.req.wIndex & 0xFF;
	if (iface_num >= udc_ptr_conf->desc->bNumInterfaces) {
		return false;
   81a3e:	2400      	movs	r4, #0
   81a40:	e170      	b.n	81d24 <udc_process_setup+0x508>
   81a42:	bf00      	nop
   81a44:	20075c44 	.word	0x20075c44
   81a48:	20071634 	.word	0x20071634
   81a4c:	00082fb9 	.word	0x00082fb9
   81a50:	00082f4d 	.word	0x00082f4d
   81a54:	200701a0 	.word	0x200701a0
   81a58:	2007026c 	.word	0x2007026c
   81a5c:	20070240 	.word	0x20070240
   81a60:	2007022c 	.word	0x2007022c
   81a64:	20070248 	.word	0x20070248
   81a68:	20071638 	.word	0x20071638
   81a6c:	2007162c 	.word	0x2007162c
   81a70:	00081661 	.word	0x00081661
   81a74:	20071630 	.word	0x20071630
			default:
				break;
			}
		}
#if (0!=USB_DEVICE_MAX_EP)
		if (USB_REQ_RECIP_ENDPOINT == Udd_setup_recipient()) {
   81a78:	2b02      	cmp	r3, #2
   81a7a:	f040 8155 	bne.w	81d28 <udc_process_setup+0x50c>
			// Standard Get Endpoint request
			switch (udd_g_ctrlreq.req.bRequest) {
   81a7e:	4b89      	ldr	r3, [pc, #548]	; (81ca4 <udc_process_setup+0x488>)
   81a80:	785b      	ldrb	r3, [r3, #1]
   81a82:	2b00      	cmp	r3, #0
   81a84:	f040 814b 	bne.w	81d1e <udc_process_setup+0x502>
 */
static bool udc_req_std_ep_get_status(void)
{
	static le16_t udc_ep_status;

	if (udd_g_ctrlreq.req.wLength != sizeof(udc_ep_status)) {
   81a88:	2a02      	cmp	r2, #2
   81a8a:	d10b      	bne.n	81aa4 <udc_process_setup+0x288>
		return false;
	}

	udc_ep_status = udd_ep_is_halted(udd_g_ctrlreq.req.
   81a8c:	4b85      	ldr	r3, [pc, #532]	; (81ca4 <udc_process_setup+0x488>)
   81a8e:	7918      	ldrb	r0, [r3, #4]
   81a90:	4b85      	ldr	r3, [pc, #532]	; (81ca8 <udc_process_setup+0x48c>)
   81a92:	4798      	blx	r3
   81a94:	4b85      	ldr	r3, [pc, #532]	; (81cac <udc_process_setup+0x490>)
   81a96:	8018      	strh	r0, [r3, #0]
			wIndex & 0xFF) ? CPU_TO_LE16(USB_EP_STATUS_HALTED) : 0;

	udd_set_setup_payload( (uint8_t *) & udc_ep_status,
   81a98:	4618      	mov	r0, r3
   81a9a:	2102      	movs	r1, #2
   81a9c:	4b84      	ldr	r3, [pc, #528]	; (81cb0 <udc_process_setup+0x494>)
   81a9e:	4798      	blx	r3
			sizeof(udc_ep_status));
	return true;
   81aa0:	2401      	movs	r4, #1
   81aa2:	e13f      	b.n	81d24 <udc_process_setup+0x508>
static bool udc_req_std_ep_get_status(void)
{
	static le16_t udc_ep_status;

	if (udd_g_ctrlreq.req.wLength != sizeof(udc_ep_status)) {
		return false;
   81aa4:	2400      	movs	r4, #0
   81aa6:	e13d      	b.n	81d24 <udc_process_setup+0x508>
			}
		}
#endif
	} else {
		// SET Standard Requests
		if (USB_REQ_RECIP_DEVICE == Udd_setup_recipient()) {
   81aa8:	f013 031f 	ands.w	r3, r3, #31
   81aac:	f040 80c6 	bne.w	81c3c <udc_process_setup+0x420>
			// Standard Set Device request
			switch (udd_g_ctrlreq.req.bRequest) {
   81ab0:	4a7c      	ldr	r2, [pc, #496]	; (81ca4 <udc_process_setup+0x488>)
   81ab2:	7852      	ldrb	r2, [r2, #1]
   81ab4:	3a01      	subs	r2, #1
   81ab6:	2a08      	cmp	r2, #8
   81ab8:	f200 80c0 	bhi.w	81c3c <udc_process_setup+0x420>
   81abc:	e8df f012 	tbh	[pc, r2, lsl #1]
   81ac0:	00be0013 	.word	0x00be0013
   81ac4:	00be0025 	.word	0x00be0025
   81ac8:	00be0009 	.word	0x00be0009
   81acc:	00be00be 	.word	0x00be00be
   81ad0:	005a      	.short	0x005a
 *
 * \return true if success
 */
static bool udc_req_std_dev_set_address(void)
{
	if (udd_g_ctrlreq.req.wLength) {
   81ad2:	4b74      	ldr	r3, [pc, #464]	; (81ca4 <udc_process_setup+0x488>)
   81ad4:	88db      	ldrh	r3, [r3, #6]
   81ad6:	b923      	cbnz	r3, 81ae2 <udc_process_setup+0x2c6>
		return false;
	}

	// The address must be changed at the end of setup request after the handshake
	// then we use a callback to change address
	udd_g_ctrlreq.callback = udc_valid_address;
   81ad8:	4a76      	ldr	r2, [pc, #472]	; (81cb4 <udc_process_setup+0x498>)
   81ada:	4b72      	ldr	r3, [pc, #456]	; (81ca4 <udc_process_setup+0x488>)
   81adc:	611a      	str	r2, [r3, #16]
	return true;
   81ade:	2401      	movs	r4, #1
   81ae0:	e120      	b.n	81d24 <udc_process_setup+0x508>
 * \return true if success
 */
static bool udc_req_std_dev_set_address(void)
{
	if (udd_g_ctrlreq.req.wLength) {
		return false;
   81ae2:	2400      	movs	r4, #0
   81ae4:	e11e      	b.n	81d24 <udc_process_setup+0x508>
 *
 * \return true if success
 */
static bool udc_req_std_dev_clear_feature(void)
{
	if (udd_g_ctrlreq.req.wLength) {
   81ae6:	4b6f      	ldr	r3, [pc, #444]	; (81ca4 <udc_process_setup+0x488>)
   81ae8:	88db      	ldrh	r3, [r3, #6]
   81aea:	b953      	cbnz	r3, 81b02 <udc_process_setup+0x2e6>
		return false;
	}

	if (udd_g_ctrlreq.req.wValue == USB_DEV_FEATURE_REMOTE_WAKEUP) {
   81aec:	4b6d      	ldr	r3, [pc, #436]	; (81ca4 <udc_process_setup+0x488>)
   81aee:	885b      	ldrh	r3, [r3, #2]
   81af0:	2b01      	cmp	r3, #1
   81af2:	d108      	bne.n	81b06 <udc_process_setup+0x2ea>
		udc_device_status &= CPU_TO_LE16(~(uint32_t)USB_DEV_STATUS_REMOTEWAKEUP);
   81af4:	4b70      	ldr	r3, [pc, #448]	; (81cb8 <udc_process_setup+0x49c>)
   81af6:	881a      	ldrh	r2, [r3, #0]
   81af8:	f022 0202 	bic.w	r2, r2, #2
   81afc:	801a      	strh	r2, [r3, #0]
#if (USB_CONFIG_ATTR_REMOTE_WAKEUP \
	== (USB_DEVICE_ATTR & USB_CONFIG_ATTR_REMOTE_WAKEUP))
		UDC_REMOTEWAKEUP_DISABLE();
#endif
		return true;
   81afe:	2401      	movs	r4, #1
   81b00:	e110      	b.n	81d24 <udc_process_setup+0x508>
 * \return true if success
 */
static bool udc_req_std_dev_clear_feature(void)
{
	if (udd_g_ctrlreq.req.wLength) {
		return false;
   81b02:	2400      	movs	r4, #0
   81b04:	e10e      	b.n	81d24 <udc_process_setup+0x508>
	== (USB_DEVICE_ATTR & USB_CONFIG_ATTR_REMOTE_WAKEUP))
		UDC_REMOTEWAKEUP_DISABLE();
#endif
		return true;
	}
	return false;
   81b06:	2400      	movs	r4, #0
   81b08:	e10c      	b.n	81d24 <udc_process_setup+0x508>
 *
 * \return true if success
 */
static bool udc_req_std_dev_set_feature(void)
{
	if (udd_g_ctrlreq.req.wLength) {
   81b0a:	4b66      	ldr	r3, [pc, #408]	; (81ca4 <udc_process_setup+0x488>)
   81b0c:	88db      	ldrh	r3, [r3, #6]
   81b0e:	2b00      	cmp	r3, #0
   81b10:	d128      	bne.n	81b64 <udc_process_setup+0x348>
		return false;
	}

	switch (udd_g_ctrlreq.req.wValue) {
   81b12:	4b64      	ldr	r3, [pc, #400]	; (81ca4 <udc_process_setup+0x488>)
   81b14:	885b      	ldrh	r3, [r3, #2]
   81b16:	2b02      	cmp	r3, #2
   81b18:	d126      	bne.n	81b68 <udc_process_setup+0x34c>
		return false;
#endif

#ifdef USB_DEVICE_HS_SUPPORT
	case USB_DEV_FEATURE_TEST_MODE:
		if (!udd_is_high_speed()) {
   81b1a:	4b68      	ldr	r3, [pc, #416]	; (81cbc <udc_process_setup+0x4a0>)
   81b1c:	4798      	blx	r3
   81b1e:	4604      	mov	r4, r0
   81b20:	2800      	cmp	r0, #0
   81b22:	f000 80ff 	beq.w	81d24 <udc_process_setup+0x508>
			break;
		}
		if (udd_g_ctrlreq.req.wIndex & 0xff) {
   81b26:	4b5f      	ldr	r3, [pc, #380]	; (81ca4 <udc_process_setup+0x488>)
   81b28:	791b      	ldrb	r3, [r3, #4]
   81b2a:	b9fb      	cbnz	r3, 81b6c <udc_process_setup+0x350>
			break;
		}
		// Unconfigure the device, terminating all ongoing requests
		udc_reset();
   81b2c:	4b64      	ldr	r3, [pc, #400]	; (81cc0 <udc_process_setup+0x4a4>)
   81b2e:	4798      	blx	r3
		switch ((udd_g_ctrlreq.req.wIndex >> 8) & 0xFF) {
   81b30:	4b5c      	ldr	r3, [pc, #368]	; (81ca4 <udc_process_setup+0x488>)
   81b32:	889b      	ldrh	r3, [r3, #4]
   81b34:	0a1b      	lsrs	r3, r3, #8
   81b36:	3b01      	subs	r3, #1
   81b38:	2b03      	cmp	r3, #3
   81b3a:	d819      	bhi.n	81b70 <udc_process_setup+0x354>
   81b3c:	e8df f003 	tbb	[pc, r3]
   81b40:	0e0a0602 	.word	0x0e0a0602
		case USB_DEV_TEST_MODE_J:
			udd_g_ctrlreq.callback = udd_test_mode_j;
   81b44:	4a5f      	ldr	r2, [pc, #380]	; (81cc4 <udc_process_setup+0x4a8>)
   81b46:	4b57      	ldr	r3, [pc, #348]	; (81ca4 <udc_process_setup+0x488>)
   81b48:	611a      	str	r2, [r3, #16]
   81b4a:	e0eb      	b.n	81d24 <udc_process_setup+0x508>
			return true;

		case USB_DEV_TEST_MODE_K:
			udd_g_ctrlreq.callback = udd_test_mode_k;
   81b4c:	4a5e      	ldr	r2, [pc, #376]	; (81cc8 <udc_process_setup+0x4ac>)
   81b4e:	4b55      	ldr	r3, [pc, #340]	; (81ca4 <udc_process_setup+0x488>)
   81b50:	611a      	str	r2, [r3, #16]
   81b52:	e0e7      	b.n	81d24 <udc_process_setup+0x508>
			return true;

		case USB_DEV_TEST_MODE_SE0_NAK:
			udd_g_ctrlreq.callback = udd_test_mode_se0_nak;
   81b54:	4a5d      	ldr	r2, [pc, #372]	; (81ccc <udc_process_setup+0x4b0>)
   81b56:	4b53      	ldr	r3, [pc, #332]	; (81ca4 <udc_process_setup+0x488>)
   81b58:	611a      	str	r2, [r3, #16]
   81b5a:	e0e3      	b.n	81d24 <udc_process_setup+0x508>
			return true;

		case USB_DEV_TEST_MODE_PACKET:
			udd_g_ctrlreq.callback = udd_test_mode_packet;
   81b5c:	4a5c      	ldr	r2, [pc, #368]	; (81cd0 <udc_process_setup+0x4b4>)
   81b5e:	4b51      	ldr	r3, [pc, #324]	; (81ca4 <udc_process_setup+0x488>)
   81b60:	611a      	str	r2, [r3, #16]
   81b62:	e0df      	b.n	81d24 <udc_process_setup+0x508>
 * \return true if success
 */
static bool udc_req_std_dev_set_feature(void)
{
	if (udd_g_ctrlreq.req.wLength) {
		return false;
   81b64:	2400      	movs	r4, #0
   81b66:	e0dd      	b.n	81d24 <udc_process_setup+0x508>
	== (USB_DEVICE_ATTR & USB_CONFIG_ATTR_REMOTE_WAKEUP))
		udc_device_status |= CPU_TO_LE16(USB_DEV_STATUS_REMOTEWAKEUP);
		UDC_REMOTEWAKEUP_ENABLE();
		return true;
#else
		return false;
   81b68:	2400      	movs	r4, #0
   81b6a:	e0db      	b.n	81d24 <udc_process_setup+0x508>
		break;
#endif
	default:
		break;
	}
	return false;
   81b6c:	2400      	movs	r4, #0
   81b6e:	e0d9      	b.n	81d24 <udc_process_setup+0x508>
   81b70:	2400      	movs	r4, #0
   81b72:	e0d7      	b.n	81d24 <udc_process_setup+0x508>
static bool udc_req_std_dev_set_configuration(void)
{
	uint8_t iface_num;

	// Check request length
	if (udd_g_ctrlreq.req.wLength) {
   81b74:	4b4b      	ldr	r3, [pc, #300]	; (81ca4 <udc_process_setup+0x488>)
   81b76:	88db      	ldrh	r3, [r3, #6]
   81b78:	2b00      	cmp	r3, #0
   81b7a:	d157      	bne.n	81c2c <udc_process_setup+0x410>
		return false;
	}
	// Authorize configuration only if the address is valid
	if (!udd_getaddress()) {
   81b7c:	4b55      	ldr	r3, [pc, #340]	; (81cd4 <udc_process_setup+0x4b8>)
   81b7e:	4798      	blx	r3
   81b80:	2800      	cmp	r0, #0
   81b82:	d055      	beq.n	81c30 <udc_process_setup+0x414>
		return false;
	}
	// Check the configuration number requested
#ifdef USB_DEVICE_HS_SUPPORT
	if (udd_is_high_speed()) {
   81b84:	4b4d      	ldr	r3, [pc, #308]	; (81cbc <udc_process_setup+0x4a0>)
   81b86:	4798      	blx	r3
   81b88:	4604      	mov	r4, r0
   81b8a:	b138      	cbz	r0, 81b9c <udc_process_setup+0x380>
		// HS descriptor
		if ((udd_g_ctrlreq.req.wValue & 0xFF) >
   81b8c:	4b45      	ldr	r3, [pc, #276]	; (81ca4 <udc_process_setup+0x488>)
   81b8e:	789a      	ldrb	r2, [r3, #2]
				udc_config.confdev_hs->bNumConfigurations) {
   81b90:	4b51      	ldr	r3, [pc, #324]	; (81cd8 <udc_process_setup+0x4bc>)
   81b92:	689b      	ldr	r3, [r3, #8]
	}
	// Check the configuration number requested
#ifdef USB_DEVICE_HS_SUPPORT
	if (udd_is_high_speed()) {
		// HS descriptor
		if ((udd_g_ctrlreq.req.wValue & 0xFF) >
   81b94:	7c5b      	ldrb	r3, [r3, #17]
   81b96:	429a      	cmp	r2, r3
   81b98:	dd08      	ble.n	81bac <udc_process_setup+0x390>
   81b9a:	e04b      	b.n	81c34 <udc_process_setup+0x418>
		}
	} else
#endif
	{
		// FS descriptor
		if ((udd_g_ctrlreq.req.wValue & 0xFF) >
   81b9c:	4b41      	ldr	r3, [pc, #260]	; (81ca4 <udc_process_setup+0x488>)
   81b9e:	789a      	ldrb	r2, [r3, #2]
				udc_config.confdev_lsfs->bNumConfigurations) {
   81ba0:	4b4d      	ldr	r3, [pc, #308]	; (81cd8 <udc_process_setup+0x4bc>)
   81ba2:	681b      	ldr	r3, [r3, #0]
		}
	} else
#endif
	{
		// FS descriptor
		if ((udd_g_ctrlreq.req.wValue & 0xFF) >
   81ba4:	7c5b      	ldrb	r3, [r3, #17]
   81ba6:	429a      	cmp	r2, r3
   81ba8:	f300 80bc 	bgt.w	81d24 <udc_process_setup+0x508>
			return false;
		}
	}

	// Reset current configuration
	udc_reset();
   81bac:	4b44      	ldr	r3, [pc, #272]	; (81cc0 <udc_process_setup+0x4a4>)
   81bae:	4798      	blx	r3

	// Enable new configuration
	udc_num_configuration = udd_g_ctrlreq.req.wValue & 0xFF;
   81bb0:	4b3c      	ldr	r3, [pc, #240]	; (81ca4 <udc_process_setup+0x488>)
   81bb2:	789b      	ldrb	r3, [r3, #2]
   81bb4:	4a49      	ldr	r2, [pc, #292]	; (81cdc <udc_process_setup+0x4c0>)
   81bb6:	7013      	strb	r3, [r2, #0]
	if (udc_num_configuration == 0) {
   81bb8:	2b00      	cmp	r3, #0
   81bba:	d03d      	beq.n	81c38 <udc_process_setup+0x41c>
		return true; // Default empty configuration requested
	}
	// Update pointer of the configuration descriptor
#ifdef USB_DEVICE_HS_SUPPORT
	if (udd_is_high_speed()) {
   81bbc:	4b3f      	ldr	r3, [pc, #252]	; (81cbc <udc_process_setup+0x4a0>)
   81bbe:	4798      	blx	r3
   81bc0:	b198      	cbz	r0, 81bea <udc_process_setup+0x3ce>
		// HS descriptor
		udc_ptr_conf = &udc_config.conf_hs[udc_num_configuration - 1];
   81bc2:	4b46      	ldr	r3, [pc, #280]	; (81cdc <udc_process_setup+0x4c0>)
   81bc4:	781b      	ldrb	r3, [r3, #0]
   81bc6:	f103 5300 	add.w	r3, r3, #536870912	; 0x20000000
   81bca:	3b01      	subs	r3, #1
   81bcc:	4a42      	ldr	r2, [pc, #264]	; (81cd8 <udc_process_setup+0x4bc>)
   81bce:	6912      	ldr	r2, [r2, #16]
   81bd0:	eb02 03c3 	add.w	r3, r2, r3, lsl #3
   81bd4:	4a42      	ldr	r2, [pc, #264]	; (81ce0 <udc_process_setup+0x4c4>)
   81bd6:	6013      	str	r3, [r2, #0]
	{
		// FS descriptor
		udc_ptr_conf = &udc_config.conf_lsfs[udc_num_configuration - 1];
	}
	// Enable all interfaces of the selected configuration
	for (iface_num = 0; iface_num < udc_ptr_conf->desc->bNumInterfaces;
   81bd8:	4b41      	ldr	r3, [pc, #260]	; (81ce0 <udc_process_setup+0x4c4>)
   81bda:	681b      	ldr	r3, [r3, #0]
   81bdc:	681b      	ldr	r3, [r3, #0]
   81bde:	791b      	ldrb	r3, [r3, #4]
			iface_num++) {
		if (!udc_iface_enable(iface_num, 0)) {
			return false;
		}
	}
	return true;
   81be0:	2401      	movs	r4, #1
	{
		// FS descriptor
		udc_ptr_conf = &udc_config.conf_lsfs[udc_num_configuration - 1];
	}
	// Enable all interfaces of the selected configuration
	for (iface_num = 0; iface_num < udc_ptr_conf->desc->bNumInterfaces;
   81be2:	2b00      	cmp	r3, #0
   81be4:	f000 809e 	beq.w	81d24 <udc_process_setup+0x508>
   81be8:	e00b      	b.n	81c02 <udc_process_setup+0x3e6>
		udc_ptr_conf = &udc_config.conf_hs[udc_num_configuration - 1];
	} else
#endif
	{
		// FS descriptor
		udc_ptr_conf = &udc_config.conf_lsfs[udc_num_configuration - 1];
   81bea:	4b3c      	ldr	r3, [pc, #240]	; (81cdc <udc_process_setup+0x4c0>)
   81bec:	781b      	ldrb	r3, [r3, #0]
   81bee:	f103 5300 	add.w	r3, r3, #536870912	; 0x20000000
   81bf2:	3b01      	subs	r3, #1
   81bf4:	4a38      	ldr	r2, [pc, #224]	; (81cd8 <udc_process_setup+0x4bc>)
   81bf6:	6852      	ldr	r2, [r2, #4]
   81bf8:	eb02 03c3 	add.w	r3, r2, r3, lsl #3
   81bfc:	4a38      	ldr	r2, [pc, #224]	; (81ce0 <udc_process_setup+0x4c4>)
   81bfe:	6013      	str	r3, [r2, #0]
   81c00:	e7ea      	b.n	81bd8 <udc_process_setup+0x3bc>
	}
	// Enable all interfaces of the selected configuration
	for (iface_num = 0; iface_num < udc_ptr_conf->desc->bNumInterfaces;
   81c02:	2500      	movs	r5, #0
			iface_num++) {
		if (!udc_iface_enable(iface_num, 0)) {
   81c04:	462f      	mov	r7, r5
   81c06:	4e37      	ldr	r6, [pc, #220]	; (81ce4 <udc_process_setup+0x4c8>)
	{
		// FS descriptor
		udc_ptr_conf = &udc_config.conf_lsfs[udc_num_configuration - 1];
	}
	// Enable all interfaces of the selected configuration
	for (iface_num = 0; iface_num < udc_ptr_conf->desc->bNumInterfaces;
   81c08:	f8df 80d4 	ldr.w	r8, [pc, #212]	; 81ce0 <udc_process_setup+0x4c4>
			iface_num++) {
		if (!udc_iface_enable(iface_num, 0)) {
   81c0c:	4628      	mov	r0, r5
   81c0e:	4639      	mov	r1, r7
   81c10:	47b0      	blx	r6
   81c12:	4604      	mov	r4, r0
   81c14:	2800      	cmp	r0, #0
   81c16:	f000 8085 	beq.w	81d24 <udc_process_setup+0x508>
		// FS descriptor
		udc_ptr_conf = &udc_config.conf_lsfs[udc_num_configuration - 1];
	}
	// Enable all interfaces of the selected configuration
	for (iface_num = 0; iface_num < udc_ptr_conf->desc->bNumInterfaces;
			iface_num++) {
   81c1a:	3501      	adds	r5, #1
   81c1c:	b2ed      	uxtb	r5, r5
	{
		// FS descriptor
		udc_ptr_conf = &udc_config.conf_lsfs[udc_num_configuration - 1];
	}
	// Enable all interfaces of the selected configuration
	for (iface_num = 0; iface_num < udc_ptr_conf->desc->bNumInterfaces;
   81c1e:	f8d8 3000 	ldr.w	r3, [r8]
   81c22:	681b      	ldr	r3, [r3, #0]
   81c24:	791b      	ldrb	r3, [r3, #4]
   81c26:	42ab      	cmp	r3, r5
   81c28:	d8f0      	bhi.n	81c0c <udc_process_setup+0x3f0>
   81c2a:	e07b      	b.n	81d24 <udc_process_setup+0x508>
{
	uint8_t iface_num;

	// Check request length
	if (udd_g_ctrlreq.req.wLength) {
		return false;
   81c2c:	2400      	movs	r4, #0
   81c2e:	e079      	b.n	81d24 <udc_process_setup+0x508>
	}
	// Authorize configuration only if the address is valid
	if (!udd_getaddress()) {
		return false;
   81c30:	2400      	movs	r4, #0
   81c32:	e077      	b.n	81d24 <udc_process_setup+0x508>
#ifdef USB_DEVICE_HS_SUPPORT
	if (udd_is_high_speed()) {
		// HS descriptor
		if ((udd_g_ctrlreq.req.wValue & 0xFF) >
				udc_config.confdev_hs->bNumConfigurations) {
			return false;
   81c34:	2400      	movs	r4, #0
   81c36:	e075      	b.n	81d24 <udc_process_setup+0x508>
	udc_reset();

	// Enable new configuration
	udc_num_configuration = udd_g_ctrlreq.req.wValue & 0xFF;
	if (udc_num_configuration == 0) {
		return true; // Default empty configuration requested
   81c38:	2401      	movs	r4, #1
   81c3a:	e073      	b.n	81d24 <udc_process_setup+0x508>
			default:
				break;
			}
		}

		if (USB_REQ_RECIP_INTERFACE == Udd_setup_recipient()) {
   81c3c:	2b01      	cmp	r3, #1
   81c3e:	d11c      	bne.n	81c7a <udc_process_setup+0x45e>
			// Standard Set Interface request
			switch (udd_g_ctrlreq.req.bRequest) {
   81c40:	4a18      	ldr	r2, [pc, #96]	; (81ca4 <udc_process_setup+0x488>)
   81c42:	7852      	ldrb	r2, [r2, #1]
   81c44:	2a0b      	cmp	r2, #11
   81c46:	d118      	bne.n	81c7a <udc_process_setup+0x45e>
 */
static bool udc_req_std_iface_set_setting(void)
{
	uint8_t iface_num, setting_num;

	if (udd_g_ctrlreq.req.wLength) {
   81c48:	4b16      	ldr	r3, [pc, #88]	; (81ca4 <udc_process_setup+0x488>)
   81c4a:	88db      	ldrh	r3, [r3, #6]
   81c4c:	b98b      	cbnz	r3, 81c72 <udc_process_setup+0x456>
		return false; // Error in request
	}
	if (!udc_num_configuration) {
   81c4e:	4b23      	ldr	r3, [pc, #140]	; (81cdc <udc_process_setup+0x4c0>)
   81c50:	781b      	ldrb	r3, [r3, #0]
   81c52:	b183      	cbz	r3, 81c76 <udc_process_setup+0x45a>
		return false; // The device is not is configured state yet
	}

	iface_num = udd_g_ctrlreq.req.wIndex & 0xFF;
   81c54:	4b13      	ldr	r3, [pc, #76]	; (81ca4 <udc_process_setup+0x488>)
   81c56:	791d      	ldrb	r5, [r3, #4]
	setting_num = udd_g_ctrlreq.req.wValue & 0xFF;
   81c58:	885e      	ldrh	r6, [r3, #2]

	// Disable current setting
	if (!udc_iface_disable(iface_num)) {
   81c5a:	4628      	mov	r0, r5
   81c5c:	4b22      	ldr	r3, [pc, #136]	; (81ce8 <udc_process_setup+0x4cc>)
   81c5e:	4798      	blx	r3
   81c60:	4604      	mov	r4, r0
   81c62:	2800      	cmp	r0, #0
   81c64:	d05e      	beq.n	81d24 <udc_process_setup+0x508>
		return false;
	}

	// Enable new setting
	return udc_iface_enable(iface_num, setting_num);
   81c66:	4628      	mov	r0, r5
   81c68:	b2f1      	uxtb	r1, r6
   81c6a:	4b1e      	ldr	r3, [pc, #120]	; (81ce4 <udc_process_setup+0x4c8>)
   81c6c:	4798      	blx	r3
   81c6e:	4604      	mov	r4, r0
   81c70:	e058      	b.n	81d24 <udc_process_setup+0x508>
static bool udc_req_std_iface_set_setting(void)
{
	uint8_t iface_num, setting_num;

	if (udd_g_ctrlreq.req.wLength) {
		return false; // Error in request
   81c72:	2400      	movs	r4, #0
   81c74:	e056      	b.n	81d24 <udc_process_setup+0x508>
	}
	if (!udc_num_configuration) {
		return false; // The device is not is configured state yet
   81c76:	2400      	movs	r4, #0
   81c78:	e054      	b.n	81d24 <udc_process_setup+0x508>
			default:
				break;
			}
		}
#if (0!=USB_DEVICE_MAX_EP)
		if (USB_REQ_RECIP_ENDPOINT == Udd_setup_recipient()) {
   81c7a:	2b02      	cmp	r3, #2
   81c7c:	d154      	bne.n	81d28 <udc_process_setup+0x50c>
			// Standard Set Endpoint request
			switch (udd_g_ctrlreq.req.bRequest) {
   81c7e:	4b09      	ldr	r3, [pc, #36]	; (81ca4 <udc_process_setup+0x488>)
   81c80:	785b      	ldrb	r3, [r3, #1]
   81c82:	2b01      	cmp	r3, #1
   81c84:	d002      	beq.n	81c8c <udc_process_setup+0x470>
   81c86:	2b03      	cmp	r3, #3
   81c88:	d036      	beq.n	81cf8 <udc_process_setup+0x4dc>
   81c8a:	e04a      	b.n	81d22 <udc_process_setup+0x506>
 *
 * \return true if success
 */
static bool udc_req_std_ep_clear_feature(void)
{
	if (udd_g_ctrlreq.req.wLength) {
   81c8c:	4b05      	ldr	r3, [pc, #20]	; (81ca4 <udc_process_setup+0x488>)
   81c8e:	88db      	ldrh	r3, [r3, #6]
   81c90:	bb73      	cbnz	r3, 81cf0 <udc_process_setup+0x4d4>
		return false;
	}

	if (udd_g_ctrlreq.req.wValue == USB_EP_FEATURE_HALT) {
   81c92:	4b04      	ldr	r3, [pc, #16]	; (81ca4 <udc_process_setup+0x488>)
   81c94:	885b      	ldrh	r3, [r3, #2]
   81c96:	bb6b      	cbnz	r3, 81cf4 <udc_process_setup+0x4d8>
		return udd_ep_clear_halt(udd_g_ctrlreq.req.wIndex & 0xFF);
   81c98:	4b02      	ldr	r3, [pc, #8]	; (81ca4 <udc_process_setup+0x488>)
   81c9a:	7918      	ldrb	r0, [r3, #4]
   81c9c:	4b13      	ldr	r3, [pc, #76]	; (81cec <udc_process_setup+0x4d0>)
   81c9e:	4798      	blx	r3
   81ca0:	4604      	mov	r4, r0
   81ca2:	e03f      	b.n	81d24 <udc_process_setup+0x508>
   81ca4:	20075c44 	.word	0x20075c44
   81ca8:	0008301d 	.word	0x0008301d
   81cac:	20071640 	.word	0x20071640
   81cb0:	00082fb9 	.word	0x00082fb9
   81cb4:	00081649 	.word	0x00081649
   81cb8:	20071634 	.word	0x20071634
   81cbc:	00082f4d 	.word	0x00082f4d
   81cc0:	00081799 	.word	0x00081799
   81cc4:	00083525 	.word	0x00083525
   81cc8:	00083541 	.word	0x00083541
   81ccc:	0008355d 	.word	0x0008355d
   81cd0:	00083571 	.word	0x00083571
   81cd4:	00082f89 	.word	0x00082f89
   81cd8:	200701a0 	.word	0x200701a0
   81cdc:	20071638 	.word	0x20071638
   81ce0:	2007162c 	.word	0x2007162c
   81ce4:	00081731 	.word	0x00081731
   81ce8:	000816c9 	.word	0x000816c9
   81cec:	00083119 	.word	0x00083119
 * \return true if success
 */
static bool udc_req_std_ep_clear_feature(void)
{
	if (udd_g_ctrlreq.req.wLength) {
		return false;
   81cf0:	2400      	movs	r4, #0
   81cf2:	e017      	b.n	81d24 <udc_process_setup+0x508>
	}

	if (udd_g_ctrlreq.req.wValue == USB_EP_FEATURE_HALT) {
		return udd_ep_clear_halt(udd_g_ctrlreq.req.wIndex & 0xFF);
	}
	return false;
   81cf4:	2400      	movs	r4, #0
   81cf6:	e015      	b.n	81d24 <udc_process_setup+0x508>
 * \return true if success
 */
#if (0!=USB_DEVICE_MAX_EP)
static bool udc_req_std_ep_set_feature(void)
{
	if (udd_g_ctrlreq.req.wLength) {
   81cf8:	4b3c      	ldr	r3, [pc, #240]	; (81dec <udc_process_setup+0x5d0>)
   81cfa:	88db      	ldrh	r3, [r3, #6]
   81cfc:	b95b      	cbnz	r3, 81d16 <udc_process_setup+0x4fa>
		return false;
	}
	if (udd_g_ctrlreq.req.wValue == USB_EP_FEATURE_HALT) {
   81cfe:	4b3b      	ldr	r3, [pc, #236]	; (81dec <udc_process_setup+0x5d0>)
   81d00:	885b      	ldrh	r3, [r3, #2]
   81d02:	b953      	cbnz	r3, 81d1a <udc_process_setup+0x4fe>
		udd_ep_abort(udd_g_ctrlreq.req.wIndex & 0xFF);
   81d04:	4c39      	ldr	r4, [pc, #228]	; (81dec <udc_process_setup+0x5d0>)
   81d06:	7920      	ldrb	r0, [r4, #4]
   81d08:	4b39      	ldr	r3, [pc, #228]	; (81df0 <udc_process_setup+0x5d4>)
   81d0a:	4798      	blx	r3
		return udd_ep_set_halt(udd_g_ctrlreq.req.wIndex & 0xFF);
   81d0c:	7920      	ldrb	r0, [r4, #4]
   81d0e:	4b39      	ldr	r3, [pc, #228]	; (81df4 <udc_process_setup+0x5d8>)
   81d10:	4798      	blx	r3
   81d12:	4604      	mov	r4, r0
   81d14:	e006      	b.n	81d24 <udc_process_setup+0x508>
 */
#if (0!=USB_DEVICE_MAX_EP)
static bool udc_req_std_ep_set_feature(void)
{
	if (udd_g_ctrlreq.req.wLength) {
		return false;
   81d16:	2400      	movs	r4, #0
   81d18:	e004      	b.n	81d24 <udc_process_setup+0x508>
	}
	if (udd_g_ctrlreq.req.wValue == USB_EP_FEATURE_HALT) {
		udd_ep_abort(udd_g_ctrlreq.req.wIndex & 0xFF);
		return udd_ep_set_halt(udd_g_ctrlreq.req.wIndex & 0xFF);
	}
	return false;
   81d1a:	2400      	movs	r4, #0
   81d1c:	e002      	b.n	81d24 <udc_process_setup+0x508>
				break;
			}
		}
#endif
	}
	return false;
   81d1e:	2400      	movs	r4, #0
   81d20:	e000      	b.n	81d24 <udc_process_setup+0x508>
   81d22:	2400      	movs	r4, #0
		}
	}

	// If standard request then try to decode it in UDC
	if (Udd_setup_type() == USB_REQ_TYPE_STANDARD) {
		if (udc_reqstd()) {
   81d24:	2c00      	cmp	r4, #0
   81d26:	d15d      	bne.n	81de4 <udc_process_setup+0x5c8>
			return true;
		}
	}

	// If interface request then try to decode it in UDI
	if (Udd_setup_recipient() == USB_REQ_RECIP_INTERFACE) {
   81d28:	4b30      	ldr	r3, [pc, #192]	; (81dec <udc_process_setup+0x5d0>)
   81d2a:	781b      	ldrb	r3, [r3, #0]
   81d2c:	f003 031f 	and.w	r3, r3, #31
   81d30:	2b01      	cmp	r3, #1
   81d32:	d11e      	bne.n	81d72 <udc_process_setup+0x556>
static bool udc_req_iface(void)
{
	uint8_t iface_num;
	udi_api_t UDC_DESC_STORAGE *udi_api;

	if (0 == udc_num_configuration) {
   81d34:	4b30      	ldr	r3, [pc, #192]	; (81df8 <udc_process_setup+0x5dc>)
   81d36:	781b      	ldrb	r3, [r3, #0]
   81d38:	b1db      	cbz	r3, 81d72 <udc_process_setup+0x556>
		return false; // The device is not is configured state yet
	}
	// Check interface number
	iface_num = udd_g_ctrlreq.req.wIndex & 0xFF;
   81d3a:	4b2c      	ldr	r3, [pc, #176]	; (81dec <udc_process_setup+0x5d0>)
   81d3c:	791c      	ldrb	r4, [r3, #4]
	if (iface_num >= udc_ptr_conf->desc->bNumInterfaces) {
   81d3e:	4b2f      	ldr	r3, [pc, #188]	; (81dfc <udc_process_setup+0x5e0>)
   81d40:	681d      	ldr	r5, [r3, #0]
   81d42:	682b      	ldr	r3, [r5, #0]
   81d44:	791b      	ldrb	r3, [r3, #4]
   81d46:	42a3      	cmp	r3, r4
   81d48:	d913      	bls.n	81d72 <udc_process_setup+0x556>
	}

	//* To update udc_ptr_iface with the selected interface in request
	// Select first alternate setting of interface to update udc_ptr_iface
	// before calling udi_api->getsetting()
	if (!udc_update_iface_desc(iface_num, 0)) {
   81d4a:	4620      	mov	r0, r4
   81d4c:	2100      	movs	r1, #0
   81d4e:	4b2c      	ldr	r3, [pc, #176]	; (81e00 <udc_process_setup+0x5e4>)
   81d50:	4798      	blx	r3
   81d52:	b170      	cbz	r0, 81d72 <udc_process_setup+0x556>
		return false;
	}
	// Select the interface with the current alternate setting
	udi_api = udc_ptr_conf->udi_apis[iface_num];
   81d54:	686b      	ldr	r3, [r5, #4]
   81d56:	f853 5024 	ldr.w	r5, [r3, r4, lsl #2]
	if (!udc_update_iface_desc(iface_num, udi_api->getsetting())) {
   81d5a:	68eb      	ldr	r3, [r5, #12]
   81d5c:	4798      	blx	r3
   81d5e:	4601      	mov	r1, r0
   81d60:	4620      	mov	r0, r4
   81d62:	4b27      	ldr	r3, [pc, #156]	; (81e00 <udc_process_setup+0x5e4>)
   81d64:	4798      	blx	r3
   81d66:	b120      	cbz	r0, 81d72 <udc_process_setup+0x556>
		return false;
	}

	// Send the SETUP request to the UDI corresponding to the interface number
	return udi_api->setup();
   81d68:	68ab      	ldr	r3, [r5, #8]
   81d6a:	4798      	blx	r3
		}
	}

	// If interface request then try to decode it in UDI
	if (Udd_setup_recipient() == USB_REQ_RECIP_INTERFACE) {
		if (udc_req_iface()) {
   81d6c:	4604      	mov	r4, r0
   81d6e:	2800      	cmp	r0, #0
   81d70:	d138      	bne.n	81de4 <udc_process_setup+0x5c8>
			return true;
		}
	}

	// If endpoint request then try to decode it in UDI
	if (Udd_setup_recipient() == USB_REQ_RECIP_ENDPOINT) {
   81d72:	4b1e      	ldr	r3, [pc, #120]	; (81dec <udc_process_setup+0x5d0>)
   81d74:	781b      	ldrb	r3, [r3, #0]
   81d76:	f003 031f 	and.w	r3, r3, #31
   81d7a:	2b02      	cmp	r3, #2
   81d7c:	d128      	bne.n	81dd0 <udc_process_setup+0x5b4>
static bool udc_req_ep(void)
{
	uint8_t iface_num;
	udi_api_t UDC_DESC_STORAGE *udi_api;

	if (0 == udc_num_configuration) {
   81d7e:	4b1e      	ldr	r3, [pc, #120]	; (81df8 <udc_process_setup+0x5dc>)
   81d80:	781b      	ldrb	r3, [r3, #0]
   81d82:	b1fb      	cbz	r3, 81dc4 <udc_process_setup+0x5a8>
		return false; // The device is not is configured state yet
	}
	// Send this request on all enabled interfaces
	iface_num = udd_g_ctrlreq.req.wIndex & 0xFF;
	for (iface_num = 0; iface_num < udc_ptr_conf->desc->bNumInterfaces;
   81d84:	4b1d      	ldr	r3, [pc, #116]	; (81dfc <udc_process_setup+0x5e0>)
   81d86:	681b      	ldr	r3, [r3, #0]
   81d88:	681a      	ldr	r2, [r3, #0]
   81d8a:	7912      	ldrb	r2, [r2, #4]
   81d8c:	b1e2      	cbz	r2, 81dc8 <udc_process_setup+0x5ac>
   81d8e:	2500      	movs	r5, #0
			iface_num++) {
		// Select the interface with the current alternate setting
		udi_api = udc_ptr_conf->udi_apis[iface_num];
		if (!udc_update_iface_desc(iface_num, udi_api->getsetting())) {
   81d90:	4f1b      	ldr	r7, [pc, #108]	; (81e00 <udc_process_setup+0x5e4>)
	if (0 == udc_num_configuration) {
		return false; // The device is not is configured state yet
	}
	// Send this request on all enabled interfaces
	iface_num = udd_g_ctrlreq.req.wIndex & 0xFF;
	for (iface_num = 0; iface_num < udc_ptr_conf->desc->bNumInterfaces;
   81d92:	f8df 8068 	ldr.w	r8, [pc, #104]	; 81dfc <udc_process_setup+0x5e0>
			iface_num++) {
		// Select the interface with the current alternate setting
		udi_api = udc_ptr_conf->udi_apis[iface_num];
   81d96:	685b      	ldr	r3, [r3, #4]
   81d98:	f853 6025 	ldr.w	r6, [r3, r5, lsl #2]
		if (!udc_update_iface_desc(iface_num, udi_api->getsetting())) {
   81d9c:	68f3      	ldr	r3, [r6, #12]
   81d9e:	4798      	blx	r3
   81da0:	4601      	mov	r1, r0
   81da2:	4628      	mov	r0, r5
   81da4:	47b8      	blx	r7
   81da6:	4604      	mov	r4, r0
   81da8:	b1e0      	cbz	r0, 81de4 <udc_process_setup+0x5c8>
			return false;
		}

		// Send the SETUP request to the UDI
		if (udi_api->setup()) {
   81daa:	68b3      	ldr	r3, [r6, #8]
   81dac:	4798      	blx	r3
   81dae:	4604      	mov	r4, r0
   81db0:	b9c0      	cbnz	r0, 81de4 <udc_process_setup+0x5c8>
		return false; // The device is not is configured state yet
	}
	// Send this request on all enabled interfaces
	iface_num = udd_g_ctrlreq.req.wIndex & 0xFF;
	for (iface_num = 0; iface_num < udc_ptr_conf->desc->bNumInterfaces;
			iface_num++) {
   81db2:	3501      	adds	r5, #1
   81db4:	b2ed      	uxtb	r5, r5
	if (0 == udc_num_configuration) {
		return false; // The device is not is configured state yet
	}
	// Send this request on all enabled interfaces
	iface_num = udd_g_ctrlreq.req.wIndex & 0xFF;
	for (iface_num = 0; iface_num < udc_ptr_conf->desc->bNumInterfaces;
   81db6:	f8d8 3000 	ldr.w	r3, [r8]
   81dba:	681a      	ldr	r2, [r3, #0]
   81dbc:	7912      	ldrb	r2, [r2, #4]
   81dbe:	42aa      	cmp	r2, r5
   81dc0:	d8e9      	bhi.n	81d96 <udc_process_setup+0x57a>
   81dc2:	e00f      	b.n	81de4 <udc_process_setup+0x5c8>
{
	uint8_t iface_num;
	udi_api_t UDC_DESC_STORAGE *udi_api;

	if (0 == udc_num_configuration) {
		return false; // The device is not is configured state yet
   81dc4:	2400      	movs	r4, #0
   81dc6:	e00d      	b.n	81de4 <udc_process_setup+0x5c8>
		// Send the SETUP request to the UDI
		if (udi_api->setup()) {
			return true;
		}
	}
	return false;
   81dc8:	2400      	movs	r4, #0
   81dca:	e00b      	b.n	81de4 <udc_process_setup+0x5c8>
	udd_g_ctrlreq.callback = NULL;
	udd_g_ctrlreq.over_under_run = NULL;

	if (Udd_setup_is_in()) {
		if (udd_g_ctrlreq.req.wLength == 0) {
			return false; // Error from USB host
   81dcc:	2400      	movs	r4, #0
   81dce:	e009      	b.n	81de4 <udc_process_setup+0x5c8>
	// Here SETUP request unknown by UDC and UDIs
#ifdef USB_DEVICE_SPECIFIC_REQUEST
	// Try to decode it in specific callback
	return USB_DEVICE_SPECIFIC_REQUEST(); // Ex: Vendor request,...
#else
	return false;
   81dd0:	2400      	movs	r4, #0
   81dd2:	e007      	b.n	81de4 <udc_process_setup+0x5c8>
			return false; // Error from USB host
		}
	}

	// If standard request then try to decode it in UDC
	if (Udd_setup_type() == USB_REQ_TYPE_STANDARD) {
   81dd4:	f013 0f60 	tst.w	r3, #96	; 0x60
   81dd8:	d1a6      	bne.n	81d28 <udc_process_setup+0x50c>
   81dda:	e665      	b.n	81aa8 <udc_process_setup+0x28c>
   81ddc:	f013 0f60 	tst.w	r3, #96	; 0x60
   81de0:	d1a2      	bne.n	81d28 <udc_process_setup+0x50c>
   81de2:	e52d      	b.n	81840 <udc_process_setup+0x24>
	// Try to decode it in specific callback
	return USB_DEVICE_SPECIFIC_REQUEST(); // Ex: Vendor request,...
#else
	return false;
#endif
}
   81de4:	4620      	mov	r0, r4
   81de6:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   81dea:	bf00      	nop
   81dec:	20075c44 	.word	0x20075c44
   81df0:	000834a5 	.word	0x000834a5
   81df4:	00083031 	.word	0x00083031
   81df8:	20071638 	.word	0x20071638
   81dfc:	2007162c 	.word	0x2007162c
   81e00:	00081661 	.word	0x00081661

00081e04 <board_init>:
#include "conf_board.h"
#include "gpio.h"
#include "ioport.h"

void board_init(void)
{
   81e04:	b510      	push	{r4, lr}
#ifndef CONF_BOARD_KEEP_WATCHDOG_AT_INIT
	/* Disable the watchdog */
	WDT->WDT_MR = WDT_MR_WDDIS;
   81e06:	f44f 4200 	mov.w	r2, #32768	; 0x8000
   81e0a:	4b1f      	ldr	r3, [pc, #124]	; (81e88 <board_init+0x84>)
   81e0c:	605a      	str	r2, [r3, #4]
 *
 * \param ul_id Id (number) of the peripheral clock.
 */
static inline void sysclk_enable_peripheral_clock(uint32_t ul_id)
{
	pmc_enable_periph_clk(ul_id);
   81e0e:	200b      	movs	r0, #11
   81e10:	4c1e      	ldr	r4, [pc, #120]	; (81e8c <board_init+0x88>)
   81e12:	47a0      	blx	r4
   81e14:	200c      	movs	r0, #12
   81e16:	47a0      	blx	r4
   81e18:	200d      	movs	r0, #13
   81e1a:	47a0      	blx	r4
   81e1c:	200e      	movs	r0, #14
   81e1e:	47a0      	blx	r4
	 * In new designs IOPORT is used instead.
	 * Here IOPORT must be initialized for others to use before setting up IO.
	 */
	ioport_init();
	/* Configure LED pins */
	gpio_configure_pin(LED0_GPIO, LED0_FLAGS);
   81e20:	203b      	movs	r0, #59	; 0x3b
   81e22:	f04f 5160 	mov.w	r1, #939524096	; 0x38000000
   81e26:	4c1a      	ldr	r4, [pc, #104]	; (81e90 <board_init+0x8c>)
   81e28:	47a0      	blx	r4
	gpio_configure_pin(LED1_GPIO, LED1_FLAGS);
   81e2a:	2055      	movs	r0, #85	; 0x55
   81e2c:	f04f 5160 	mov.w	r1, #939524096	; 0x38000000
   81e30:	47a0      	blx	r4
	gpio_configure_pin(LED2_GPIO, LED2_FLAGS);
   81e32:	2056      	movs	r0, #86	; 0x56
   81e34:	f04f 5160 	mov.w	r1, #939524096	; 0x38000000
   81e38:	47a0      	blx	r4

	/* Configure Push Button pins */
	gpio_configure_pin(GPIO_PUSH_BUTTON_1, GPIO_PUSH_BUTTON_1_FLAGS);
   81e3a:	2068      	movs	r0, #104	; 0x68
   81e3c:	4915      	ldr	r1, [pc, #84]	; (81e94 <board_init+0x90>)
   81e3e:	47a0      	blx	r4
	gpio_configure_pin(GPIO_PUSH_BUTTON_2, GPIO_PUSH_BUTTON_2_FLAGS);
   81e40:	205c      	movs	r0, #92	; 0x5c
   81e42:	4915      	ldr	r1, [pc, #84]	; (81e98 <board_init+0x94>)
   81e44:	47a0      	blx	r4
	gpio_configure_pin(PIN_PWM_LED2_GPIO, PIN_PWM_LED2_FLAGS);
#endif

	/* Configure SPI0 pins */
#ifdef CONF_BOARD_SPI0
	gpio_configure_pin(SPI0_MISO_GPIO, SPI0_MISO_FLAGS);
   81e46:	2019      	movs	r0, #25
   81e48:	f04f 6100 	mov.w	r1, #134217728	; 0x8000000
   81e4c:	47a0      	blx	r4
	gpio_configure_pin(SPI0_MOSI_GPIO, SPI0_MOSI_FLAGS);
   81e4e:	201a      	movs	r0, #26
   81e50:	f04f 6100 	mov.w	r1, #134217728	; 0x8000000
   81e54:	47a0      	blx	r4
	gpio_configure_pin(SPI0_SPCK_GPIO, SPI0_SPCK_FLAGS);
   81e56:	201b      	movs	r0, #27
   81e58:	f04f 6100 	mov.w	r1, #134217728	; 0x8000000
   81e5c:	47a0      	blx	r4
	 * CONF_BOARD_SPI_NPCS_GPIO and
	 * CONF_BOARD_SPI_NPCS_FLAGS macros.
	 */

#   ifdef CONF_BOARD_SPI0_NPCS0
		gpio_configure_pin(SPI0_NPCS0_GPIO, SPI0_NPCS0_FLAGS);
   81e5e:	201c      	movs	r0, #28
   81e60:	f04f 6100 	mov.w	r1, #134217728	; 0x8000000
   81e64:	47a0      	blx	r4
		gpio_configure_pin(SPI1_NPCS3_GPIO, SPI1_NPCS3_FLAGS);
#   endif
#endif

#ifdef CONF_BOARD_TWI0
	gpio_configure_pin(TWI0_DATA_GPIO, TWI0_DATA_FLAGS);
   81e66:	2011      	movs	r0, #17
   81e68:	f04f 6100 	mov.w	r1, #134217728	; 0x8000000
   81e6c:	47a0      	blx	r4
	gpio_configure_pin(TWI0_CLK_GPIO, TWI0_CLK_FLAGS);
   81e6e:	2012      	movs	r0, #18
   81e70:	f04f 6100 	mov.w	r1, #134217728	; 0x8000000
   81e74:	47a0      	blx	r4
	gpio_configure_pin(TWI1_CLK_GPIO, TWI1_CLK_FLAGS);
#endif

#ifdef CONF_BOARD_USART_RXD
	/* Configure USART RXD pin */
	gpio_configure_pin(PIN_USART0_RXD_IDX, PIN_USART0_RXD_FLAGS);
   81e76:	200a      	movs	r0, #10
   81e78:	f04f 6100 	mov.w	r1, #134217728	; 0x8000000
   81e7c:	47a0      	blx	r4
#endif

#ifdef CONF_BOARD_USART_TXD
	/* Configure USART TXD pin */
	gpio_configure_pin(PIN_USART0_TXD_IDX, PIN_USART0_TXD_FLAGS);
   81e7e:	200b      	movs	r0, #11
   81e80:	f04f 6100 	mov.w	r1, #134217728	; 0x8000000
   81e84:	47a0      	blx	r4
   81e86:	bd10      	pop	{r4, pc}
   81e88:	400e1a50 	.word	0x400e1a50
   81e8c:	00082209 	.word	0x00082209
   81e90:	00081f8d 	.word	0x00081f8d
   81e94:	28000079 	.word	0x28000079
   81e98:	28000001 	.word	0x28000001

00081e9c <pdc_tx_init>:
		pdc_packet_t *p_next_packet)
{
	/* Validate inputs. */
	Assert(p_pdc);
	
	if (p_packet) {
   81e9c:	460b      	mov	r3, r1
   81e9e:	b119      	cbz	r1, 81ea8 <pdc_tx_init+0xc>
		p_pdc->PERIPH_TPR = p_packet->ul_addr;
   81ea0:	6809      	ldr	r1, [r1, #0]
   81ea2:	6081      	str	r1, [r0, #8]
		p_pdc->PERIPH_TCR = p_packet->ul_size;
   81ea4:	685b      	ldr	r3, [r3, #4]
   81ea6:	60c3      	str	r3, [r0, #12]
	}
	if (p_next_packet) {
   81ea8:	b11a      	cbz	r2, 81eb2 <pdc_tx_init+0x16>
		p_pdc->PERIPH_TNPR = p_next_packet->ul_addr;
   81eaa:	6813      	ldr	r3, [r2, #0]
   81eac:	6183      	str	r3, [r0, #24]
		p_pdc->PERIPH_TNCR = p_next_packet->ul_size;
   81eae:	6853      	ldr	r3, [r2, #4]
   81eb0:	61c3      	str	r3, [r0, #28]
   81eb2:	4770      	bx	lr

00081eb4 <pdc_rx_init>:
		pdc_packet_t *p_next_packet)
{
	/* Validate inputs. */
	Assert(p_pdc);
	
	if (p_packet) {
   81eb4:	460b      	mov	r3, r1
   81eb6:	b119      	cbz	r1, 81ec0 <pdc_rx_init+0xc>
		p_pdc->PERIPH_RPR = p_packet->ul_addr;
   81eb8:	6809      	ldr	r1, [r1, #0]
   81eba:	6001      	str	r1, [r0, #0]
		p_pdc->PERIPH_RCR = p_packet->ul_size;
   81ebc:	685b      	ldr	r3, [r3, #4]
   81ebe:	6043      	str	r3, [r0, #4]
	}
	if (p_next_packet) {
   81ec0:	b11a      	cbz	r2, 81eca <pdc_rx_init+0x16>
		p_pdc->PERIPH_RNPR = p_next_packet->ul_addr;
   81ec2:	6813      	ldr	r3, [r2, #0]
   81ec4:	6103      	str	r3, [r0, #16]
		p_pdc->PERIPH_RNCR = p_next_packet->ul_size;
   81ec6:	6853      	ldr	r3, [r2, #4]
   81ec8:	6143      	str	r3, [r0, #20]
   81eca:	4770      	bx	lr

00081ecc <pdc_enable_transfer>:
{
	/* Validate inputs. */
	Assert(p_pdc);
	
	p_pdc->PERIPH_PTCR =
			ul_controls & (PERIPH_PTCR_RXTEN | PERIPH_PTCR_TXTEN);
   81ecc:	f021 01fe 	bic.w	r1, r1, #254	; 0xfe
   81ed0:	05c9      	lsls	r1, r1, #23
   81ed2:	0dc9      	lsrs	r1, r1, #23
		uint32_t ul_controls)
{
	/* Validate inputs. */
	Assert(p_pdc);
	
	p_pdc->PERIPH_PTCR =
   81ed4:	6201      	str	r1, [r0, #32]
   81ed6:	4770      	bx	lr

00081ed8 <pdc_disable_transfer>:
{
	/* Validate inputs. */
	Assert(p_pdc);
	
	p_pdc->PERIPH_PTCR =
			ul_controls & (PERIPH_PTCR_RXTDIS | PERIPH_PTCR_TXTDIS);
   81ed8:	f421 71fe 	bic.w	r1, r1, #508	; 0x1fc
   81edc:	f021 0101 	bic.w	r1, r1, #1
   81ee0:	0589      	lsls	r1, r1, #22
   81ee2:	0d89      	lsrs	r1, r1, #22
		uint32_t ul_controls)
{
	/* Validate inputs. */
	Assert(p_pdc);
	
	p_pdc->PERIPH_PTCR =
   81ee4:	6201      	str	r1, [r0, #32]
   81ee6:	4770      	bx	lr

00081ee8 <pio_set_peripheral>:
		const uint32_t ul_mask)
{
	uint32_t ul_sr;

	/* Disable interrupts on the pin(s) */
	p_pio->PIO_IDR = ul_mask;
   81ee8:	6442      	str	r2, [r0, #68]	; 0x44
	case PIO_OUTPUT_1:
	case PIO_NOT_A_PIN:
		return;
	}
#elif (SAM3XA|| SAM3U)
	switch (ul_type) {
   81eea:	f1b1 5f80 	cmp.w	r1, #268435456	; 0x10000000
   81eee:	d016      	beq.n	81f1e <pio_set_peripheral+0x36>
   81ef0:	d804      	bhi.n	81efc <pio_set_peripheral+0x14>
   81ef2:	b1c1      	cbz	r1, 81f26 <pio_set_peripheral+0x3e>
   81ef4:	f1b1 6f00 	cmp.w	r1, #134217728	; 0x8000000
   81ef8:	d00a      	beq.n	81f10 <pio_set_peripheral+0x28>
   81efa:	e013      	b.n	81f24 <pio_set_peripheral+0x3c>
   81efc:	f1b1 5f40 	cmp.w	r1, #805306368	; 0x30000000
   81f00:	d011      	beq.n	81f26 <pio_set_peripheral+0x3e>
   81f02:	f1b1 5f60 	cmp.w	r1, #939524096	; 0x38000000
   81f06:	d00e      	beq.n	81f26 <pio_set_peripheral+0x3e>
   81f08:	f1b1 5f20 	cmp.w	r1, #671088640	; 0x28000000
   81f0c:	d10a      	bne.n	81f24 <pio_set_peripheral+0x3c>
   81f0e:	4770      	bx	lr
	case PIO_PERIPH_A:
		ul_sr = p_pio->PIO_ABSR;
   81f10:	6f03      	ldr	r3, [r0, #112]	; 0x70
		p_pio->PIO_ABSR &= (~ul_mask & ul_sr);
   81f12:	6f01      	ldr	r1, [r0, #112]	; 0x70
   81f14:	400b      	ands	r3, r1
   81f16:	ea23 0302 	bic.w	r3, r3, r2
   81f1a:	6703      	str	r3, [r0, #112]	; 0x70
		break;
   81f1c:	e002      	b.n	81f24 <pio_set_peripheral+0x3c>

	case PIO_PERIPH_B:
		ul_sr = p_pio->PIO_ABSR;
   81f1e:	6f03      	ldr	r3, [r0, #112]	; 0x70
		p_pio->PIO_ABSR = (ul_mask | ul_sr);
   81f20:	4313      	orrs	r3, r2
   81f22:	6703      	str	r3, [r0, #112]	; 0x70
#else
#error "Unsupported device"
#endif

	/* Remove the pins from under the control of PIO */
	p_pio->PIO_PDR = ul_mask;
   81f24:	6042      	str	r2, [r0, #4]
   81f26:	4770      	bx	lr

00081f28 <pio_set_input>:
 * \param p_pio Pointer to a PIO instance.
 * \param ul_mask Interrupt sources bit map.
 */
void pio_disable_interrupt(Pio *p_pio, const uint32_t ul_mask)
{
	p_pio->PIO_IDR = ul_mask;
   81f28:	6441      	str	r1, [r0, #68]	; 0x44
 */
void pio_pull_up(Pio *p_pio, const uint32_t ul_mask,
		const uint32_t ul_pull_up_enable)
{
	/* Enable the pull-up(s) if necessary */
	if (ul_pull_up_enable) {
   81f2a:	f012 0f01 	tst.w	r2, #1
		p_pio->PIO_PUER = ul_mask;
   81f2e:	bf14      	ite	ne
   81f30:	6641      	strne	r1, [r0, #100]	; 0x64
	} else {
		p_pio->PIO_PUDR = ul_mask;
   81f32:	6601      	streq	r1, [r0, #96]	; 0x60
{
	pio_disable_interrupt(p_pio, ul_mask);
	pio_pull_up(p_pio, ul_mask, ul_attribute & PIO_PULLUP);

	/* Enable Input Filter if necessary */
	if (ul_attribute & (PIO_DEGLITCH | PIO_DEBOUNCE)) {
   81f34:	f012 0f0a 	tst.w	r2, #10
		p_pio->PIO_IFER = ul_mask;
   81f38:	bf14      	ite	ne
   81f3a:	6201      	strne	r1, [r0, #32]
	} else {
		p_pio->PIO_IFDR = ul_mask;
   81f3c:	6241      	streq	r1, [r0, #36]	; 0x24
			p_pio->PIO_IFSCER = ul_mask;
		}
	}
#elif (SAM3XA|| SAM3U)
	/* Enable de-glitch or de-bounce if necessary */
	if (ul_attribute & PIO_DEGLITCH) {
   81f3e:	f012 0f02 	tst.w	r2, #2
   81f42:	d002      	beq.n	81f4a <pio_set_input+0x22>
		p_pio->PIO_SCIFSR = ul_mask;
   81f44:	f8c0 1080 	str.w	r1, [r0, #128]	; 0x80
   81f48:	e004      	b.n	81f54 <pio_set_input+0x2c>
	} else {
		if (ul_attribute & PIO_DEBOUNCE) {
   81f4a:	f012 0f08 	tst.w	r2, #8
			p_pio->PIO_DIFSR = ul_mask;
   81f4e:	bf18      	it	ne
   81f50:	f8c0 1084 	strne.w	r1, [r0, #132]	; 0x84
#else
#error "Unsupported device"
#endif

	/* Configure pin as input */
	p_pio->PIO_ODR = ul_mask;
   81f54:	6141      	str	r1, [r0, #20]
	p_pio->PIO_PER = ul_mask;
   81f56:	6001      	str	r1, [r0, #0]
   81f58:	4770      	bx	lr
   81f5a:	bf00      	nop

00081f5c <pio_set_output>:
 */
void pio_set_output(Pio *p_pio, const uint32_t ul_mask,
		const uint32_t ul_default_level,
		const uint32_t ul_multidrive_enable,
		const uint32_t ul_pull_up_enable)
{
   81f5c:	b410      	push	{r4}
 * \param p_pio Pointer to a PIO instance.
 * \param ul_mask Interrupt sources bit map.
 */
void pio_disable_interrupt(Pio *p_pio, const uint32_t ul_mask)
{
	p_pio->PIO_IDR = ul_mask;
   81f5e:	6441      	str	r1, [r0, #68]	; 0x44
 */
void pio_pull_up(Pio *p_pio, const uint32_t ul_mask,
		const uint32_t ul_pull_up_enable)
{
	/* Enable the pull-up(s) if necessary */
	if (ul_pull_up_enable) {
   81f60:	9c01      	ldr	r4, [sp, #4]
   81f62:	b10c      	cbz	r4, 81f68 <pio_set_output+0xc>
		p_pio->PIO_PUER = ul_mask;
   81f64:	6641      	str	r1, [r0, #100]	; 0x64
   81f66:	e000      	b.n	81f6a <pio_set_output+0xe>
	} else {
		p_pio->PIO_PUDR = ul_mask;
   81f68:	6601      	str	r1, [r0, #96]	; 0x60
{
	pio_disable_interrupt(p_pio, ul_mask);
	pio_pull_up(p_pio, ul_mask, ul_pull_up_enable);

	/* Enable multi-drive if necessary */
	if (ul_multidrive_enable) {
   81f6a:	b10b      	cbz	r3, 81f70 <pio_set_output+0x14>
		p_pio->PIO_MDER = ul_mask;
   81f6c:	6501      	str	r1, [r0, #80]	; 0x50
   81f6e:	e000      	b.n	81f72 <pio_set_output+0x16>
	} else {
		p_pio->PIO_MDDR = ul_mask;
   81f70:	6541      	str	r1, [r0, #84]	; 0x54
	}

	/* Set default value */
	if (ul_default_level) {
   81f72:	b10a      	cbz	r2, 81f78 <pio_set_output+0x1c>
		p_pio->PIO_SODR = ul_mask;
   81f74:	6301      	str	r1, [r0, #48]	; 0x30
   81f76:	e000      	b.n	81f7a <pio_set_output+0x1e>
	} else {
		p_pio->PIO_CODR = ul_mask;
   81f78:	6341      	str	r1, [r0, #52]	; 0x34
	}

	/* Configure pin(s) as output(s) */
	p_pio->PIO_OER = ul_mask;
   81f7a:	6101      	str	r1, [r0, #16]
	p_pio->PIO_PER = ul_mask;
   81f7c:	6001      	str	r1, [r0, #0]
}
   81f7e:	f85d 4b04 	ldr.w	r4, [sp], #4
   81f82:	4770      	bx	lr

00081f84 <pio_get_interrupt_status>:
 *
 * \return The interrupt status mask value.
 */
uint32_t pio_get_interrupt_status(const Pio *p_pio)
{
	return p_pio->PIO_ISR;
   81f84:	6cc0      	ldr	r0, [r0, #76]	; 0x4c
}
   81f86:	4770      	bx	lr

00081f88 <pio_get_interrupt_mask>:
 *
 * \return The interrupt mask value.
 */
uint32_t pio_get_interrupt_mask(const Pio *p_pio)
{
	return p_pio->PIO_IMR;
   81f88:	6c80      	ldr	r0, [r0, #72]	; 0x48
}
   81f8a:	4770      	bx	lr

00081f8c <pio_configure_pin>:
 * \param ul_flags Pins attributes.
 *
 * \return Whether the pin(s) have been configured properly.
 */
uint32_t pio_configure_pin(uint32_t ul_pin, const uint32_t ul_flags)
{
   81f8c:	b570      	push	{r4, r5, r6, lr}
   81f8e:	b082      	sub	sp, #8
   81f90:	460d      	mov	r5, r1
		p_pio = PIOC;
	} else {
		p_pio = (Pio *)((uint32_t)PIOA + (PIO_DELTA * (ul_pin >> 5)));
	}
#else
	p_pio = (Pio *)((uint32_t)PIOA + (PIO_DELTA * (ul_pin >> 5)));
   81f92:	0944      	lsrs	r4, r0, #5
   81f94:	f504 1400 	add.w	r4, r4, #2097152	; 0x200000
   81f98:	f204 7407 	addw	r4, r4, #1799	; 0x707
   81f9c:	0266      	lsls	r6, r4, #9
uint32_t pio_configure_pin(uint32_t ul_pin, const uint32_t ul_flags)
{
	Pio *p_pio = pio_get_pin_group(ul_pin);

	/* Configure pins */
	switch (ul_flags & PIO_TYPE_Msk) {
   81f9e:	f001 44f0 	and.w	r4, r1, #2013265920	; 0x78000000
   81fa2:	f1b4 5f20 	cmp.w	r4, #671088640	; 0x28000000
   81fa6:	d030      	beq.n	8200a <pio_configure_pin+0x7e>
   81fa8:	d806      	bhi.n	81fb8 <pio_configure_pin+0x2c>
   81faa:	f1b4 6f00 	cmp.w	r4, #134217728	; 0x8000000
   81fae:	d00a      	beq.n	81fc6 <pio_configure_pin+0x3a>
   81fb0:	f1b4 5f80 	cmp.w	r4, #268435456	; 0x10000000
   81fb4:	d018      	beq.n	81fe8 <pio_configure_pin+0x5c>
   81fb6:	e049      	b.n	8204c <pio_configure_pin+0xc0>
   81fb8:	f1b4 5f40 	cmp.w	r4, #805306368	; 0x30000000
   81fbc:	d030      	beq.n	82020 <pio_configure_pin+0x94>
   81fbe:	f1b4 5f60 	cmp.w	r4, #939524096	; 0x38000000
   81fc2:	d02d      	beq.n	82020 <pio_configure_pin+0x94>
   81fc4:	e042      	b.n	8204c <pio_configure_pin+0xc0>
	case PIO_TYPE_PIO_PERIPH_A:
		pio_set_peripheral(p_pio, PIO_PERIPH_A, (1 << (ul_pin & 0x1F)));
   81fc6:	f000 001f 	and.w	r0, r0, #31
   81fca:	2401      	movs	r4, #1
   81fcc:	4084      	lsls	r4, r0
   81fce:	4630      	mov	r0, r6
   81fd0:	f04f 6100 	mov.w	r1, #134217728	; 0x8000000
   81fd4:	4622      	mov	r2, r4
   81fd6:	4b1f      	ldr	r3, [pc, #124]	; (82054 <pio_configure_pin+0xc8>)
   81fd8:	4798      	blx	r3
 */
void pio_pull_up(Pio *p_pio, const uint32_t ul_mask,
		const uint32_t ul_pull_up_enable)
{
	/* Enable the pull-up(s) if necessary */
	if (ul_pull_up_enable) {
   81fda:	f015 0f01 	tst.w	r5, #1
		p_pio->PIO_PUER = ul_mask;
   81fde:	bf14      	ite	ne
   81fe0:	6674      	strne	r4, [r6, #100]	; 0x64
	} else {
		p_pio->PIO_PUDR = ul_mask;
   81fe2:	6634      	streq	r4, [r6, #96]	; 0x60

	default:
		return 0;
	}

	return 1;
   81fe4:	2001      	movs	r0, #1
   81fe6:	e032      	b.n	8204e <pio_configure_pin+0xc2>
		pio_set_peripheral(p_pio, PIO_PERIPH_A, (1 << (ul_pin & 0x1F)));
		pio_pull_up(p_pio, (1 << (ul_pin & 0x1F)),
				(ul_flags & PIO_PULLUP));
		break;
	case PIO_TYPE_PIO_PERIPH_B:
		pio_set_peripheral(p_pio, PIO_PERIPH_B, (1 << (ul_pin & 0x1F)));
   81fe8:	f000 001f 	and.w	r0, r0, #31
   81fec:	2401      	movs	r4, #1
   81fee:	4084      	lsls	r4, r0
   81ff0:	4630      	mov	r0, r6
   81ff2:	f04f 5180 	mov.w	r1, #268435456	; 0x10000000
   81ff6:	4622      	mov	r2, r4
   81ff8:	4b16      	ldr	r3, [pc, #88]	; (82054 <pio_configure_pin+0xc8>)
   81ffa:	4798      	blx	r3
 */
void pio_pull_up(Pio *p_pio, const uint32_t ul_mask,
		const uint32_t ul_pull_up_enable)
{
	/* Enable the pull-up(s) if necessary */
	if (ul_pull_up_enable) {
   81ffc:	f015 0f01 	tst.w	r5, #1
		p_pio->PIO_PUER = ul_mask;
   82000:	bf14      	ite	ne
   82002:	6674      	strne	r4, [r6, #100]	; 0x64
	} else {
		p_pio->PIO_PUDR = ul_mask;
   82004:	6634      	streq	r4, [r6, #96]	; 0x60

	default:
		return 0;
	}

	return 1;
   82006:	2001      	movs	r0, #1
   82008:	e021      	b.n	8204e <pio_configure_pin+0xc2>
				(ul_flags & PIO_PULLUP));
		break;
#endif

	case PIO_TYPE_PIO_INPUT:
		pio_set_input(p_pio, (1 << (ul_pin & 0x1F)), ul_flags);
   8200a:	f000 011f 	and.w	r1, r0, #31
   8200e:	2401      	movs	r4, #1
   82010:	4630      	mov	r0, r6
   82012:	fa04 f101 	lsl.w	r1, r4, r1
   82016:	462a      	mov	r2, r5
   82018:	4b0f      	ldr	r3, [pc, #60]	; (82058 <pio_configure_pin+0xcc>)
   8201a:	4798      	blx	r3

	default:
		return 0;
	}

	return 1;
   8201c:	4620      	mov	r0, r4
		break;
#endif

	case PIO_TYPE_PIO_INPUT:
		pio_set_input(p_pio, (1 << (ul_pin & 0x1F)), ul_flags);
		break;
   8201e:	e016      	b.n	8204e <pio_configure_pin+0xc2>

	case PIO_TYPE_PIO_OUTPUT_0:
	case PIO_TYPE_PIO_OUTPUT_1:
		pio_set_output(p_pio, (1 << (ul_pin & 0x1F)),
   82020:	f000 011f 	and.w	r1, r0, #31
   82024:	2401      	movs	r4, #1
				((ul_flags & PIO_TYPE_PIO_OUTPUT_1)
   82026:	f005 5260 	and.w	r2, r5, #939524096	; 0x38000000
		pio_set_input(p_pio, (1 << (ul_pin & 0x1F)), ul_flags);
		break;

	case PIO_TYPE_PIO_OUTPUT_0:
	case PIO_TYPE_PIO_OUTPUT_1:
		pio_set_output(p_pio, (1 << (ul_pin & 0x1F)),
   8202a:	ea05 0304 	and.w	r3, r5, r4
   8202e:	9300      	str	r3, [sp, #0]
   82030:	4630      	mov	r0, r6
   82032:	fa04 f101 	lsl.w	r1, r4, r1
   82036:	f1b2 5f60 	cmp.w	r2, #939524096	; 0x38000000
   8203a:	bf14      	ite	ne
   8203c:	2200      	movne	r2, #0
   8203e:	2201      	moveq	r2, #1
   82040:	f3c5 0380 	ubfx	r3, r5, #2, #1
   82044:	4d05      	ldr	r5, [pc, #20]	; (8205c <pio_configure_pin+0xd0>)
   82046:	47a8      	blx	r5

	default:
		return 0;
	}

	return 1;
   82048:	4620      	mov	r0, r4
		pio_set_output(p_pio, (1 << (ul_pin & 0x1F)),
				((ul_flags & PIO_TYPE_PIO_OUTPUT_1)
				== PIO_TYPE_PIO_OUTPUT_1) ? 1 : 0,
				(ul_flags & PIO_OPENDRAIN) ? 1 : 0,
				(ul_flags & PIO_PULLUP) ? 1 : 0);
		break;
   8204a:	e000      	b.n	8204e <pio_configure_pin+0xc2>

	default:
		return 0;
   8204c:	2000      	movs	r0, #0
	}

	return 1;
}
   8204e:	b002      	add	sp, #8
   82050:	bd70      	pop	{r4, r5, r6, pc}
   82052:	bf00      	nop
   82054:	00081ee9 	.word	0x00081ee9
   82058:	00081f29 	.word	0x00081f29
   8205c:	00081f5d 	.word	0x00081f5d

00082060 <pio_handler_process>:
 *
 * \param p_pio PIO controller base address.
 * \param ul_id PIO controller ID.
 */
void pio_handler_process(Pio *p_pio, uint32_t ul_id)
{
   82060:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   82064:	4604      	mov	r4, r0
   82066:	460e      	mov	r6, r1
	uint32_t status;
	uint32_t i;

	/* Read PIO controller status */
	status = pio_get_interrupt_status(p_pio);
   82068:	4b10      	ldr	r3, [pc, #64]	; (820ac <pio_handler_process+0x4c>)
   8206a:	4798      	blx	r3
   8206c:	4605      	mov	r5, r0
	status &= pio_get_interrupt_mask(p_pio);
   8206e:	4620      	mov	r0, r4
   82070:	4b0f      	ldr	r3, [pc, #60]	; (820b0 <pio_handler_process+0x50>)
   82072:	4798      	blx	r3

	/* Check pending events */
	if (status != 0) {
   82074:	4005      	ands	r5, r0
   82076:	d017      	beq.n	820a8 <pio_handler_process+0x48>
   82078:	4f0e      	ldr	r7, [pc, #56]	; (820b4 <pio_handler_process+0x54>)
   8207a:	f107 040c 	add.w	r4, r7, #12
   8207e:	376c      	adds	r7, #108	; 0x6c
		/* Find triggering source */
		i = 0;
		while (status != 0) {
			/* Source is configured on the same controller */
			if (gs_interrupt_sources[i].id == ul_id) {
   82080:	f854 3c0c 	ldr.w	r3, [r4, #-12]
   82084:	42b3      	cmp	r3, r6
   82086:	d10a      	bne.n	8209e <pio_handler_process+0x3e>
				/* Source has PIOs whose statuses have changed */
				if ((status & gs_interrupt_sources[i].mask) != 0) {
   82088:	f854 1c08 	ldr.w	r1, [r4, #-8]
   8208c:	4229      	tst	r1, r5
   8208e:	d006      	beq.n	8209e <pio_handler_process+0x3e>
					gs_interrupt_sources[i].handler(gs_interrupt_sources[i].id,
   82090:	6823      	ldr	r3, [r4, #0]
   82092:	4630      	mov	r0, r6
   82094:	4798      	blx	r3
							gs_interrupt_sources[i].mask);
					status &= ~(gs_interrupt_sources[i].mask);
   82096:	f854 3c08 	ldr.w	r3, [r4, #-8]
   8209a:	ea25 0503 	bic.w	r5, r5, r3
				}
			}
			i++;
			if (i >= MAX_INTERRUPT_SOURCES) {
   8209e:	42bc      	cmp	r4, r7
   820a0:	d002      	beq.n	820a8 <pio_handler_process+0x48>
   820a2:	3410      	adds	r4, #16

	/* Check pending events */
	if (status != 0) {
		/* Find triggering source */
		i = 0;
		while (status != 0) {
   820a4:	2d00      	cmp	r5, #0
   820a6:	d1eb      	bne.n	82080 <pio_handler_process+0x20>
   820a8:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   820ac:	00081f85 	.word	0x00081f85
   820b0:	00081f89 	.word	0x00081f89
   820b4:	20071644 	.word	0x20071644

000820b8 <PIOA_Handler>:
/**
 * \brief Parallel IO Controller A interrupt handler.
 * Redefined PIOA interrupt handler for NVIC interrupt table.
 */
void PIOA_Handler(void)
{
   820b8:	b508      	push	{r3, lr}
	pio_handler_process(PIOA, ID_PIOA);
   820ba:	4802      	ldr	r0, [pc, #8]	; (820c4 <PIOA_Handler+0xc>)
   820bc:	210b      	movs	r1, #11
   820be:	4b02      	ldr	r3, [pc, #8]	; (820c8 <PIOA_Handler+0x10>)
   820c0:	4798      	blx	r3
   820c2:	bd08      	pop	{r3, pc}
   820c4:	400e0e00 	.word	0x400e0e00
   820c8:	00082061 	.word	0x00082061

000820cc <PIOB_Handler>:
/**
 * \brief Parallel IO Controller B interrupt handler
 * Redefined PIOB interrupt handler for NVIC interrupt table.
 */
void PIOB_Handler(void)
{
   820cc:	b508      	push	{r3, lr}
    pio_handler_process(PIOB, ID_PIOB);
   820ce:	4802      	ldr	r0, [pc, #8]	; (820d8 <PIOB_Handler+0xc>)
   820d0:	210c      	movs	r1, #12
   820d2:	4b02      	ldr	r3, [pc, #8]	; (820dc <PIOB_Handler+0x10>)
   820d4:	4798      	blx	r3
   820d6:	bd08      	pop	{r3, pc}
   820d8:	400e1000 	.word	0x400e1000
   820dc:	00082061 	.word	0x00082061

000820e0 <PIOC_Handler>:
/**
 * \brief Parallel IO Controller C interrupt handler.
 * Redefined PIOC interrupt handler for NVIC interrupt table.
 */
void PIOC_Handler(void)
{
   820e0:	b508      	push	{r3, lr}
	pio_handler_process(PIOC, ID_PIOC);
   820e2:	4802      	ldr	r0, [pc, #8]	; (820ec <PIOC_Handler+0xc>)
   820e4:	210d      	movs	r1, #13
   820e6:	4b02      	ldr	r3, [pc, #8]	; (820f0 <PIOC_Handler+0x10>)
   820e8:	4798      	blx	r3
   820ea:	bd08      	pop	{r3, pc}
   820ec:	400e1200 	.word	0x400e1200
   820f0:	00082061 	.word	0x00082061

000820f4 <PIOD_Handler>:
/**
 * \brief Parallel IO Controller D interrupt handler.
 * Redefined PIOD interrupt handler for NVIC interrupt table.
 */
void PIOD_Handler(void)
{
   820f4:	b508      	push	{r3, lr}
	pio_handler_process(PIOD, ID_PIOD);
   820f6:	4802      	ldr	r0, [pc, #8]	; (82100 <PIOD_Handler+0xc>)
   820f8:	210e      	movs	r1, #14
   820fa:	4b02      	ldr	r3, [pc, #8]	; (82104 <PIOD_Handler+0x10>)
   820fc:	4798      	blx	r3
   820fe:	bd08      	pop	{r3, pc}
   82100:	400e1400 	.word	0x400e1400
   82104:	00082061 	.word	0x00082061

00082108 <pmc_switch_mck_to_pllack>:
 */
uint32_t pmc_switch_mck_to_pllack(uint32_t ul_pres)
{
	uint32_t ul_timeout;

	PMC->PMC_MCKR = (PMC->PMC_MCKR & (~PMC_MCKR_PRES_Msk)) | ul_pres;
   82108:	4b17      	ldr	r3, [pc, #92]	; (82168 <pmc_switch_mck_to_pllack+0x60>)
   8210a:	6b1a      	ldr	r2, [r3, #48]	; 0x30
   8210c:	f022 0270 	bic.w	r2, r2, #112	; 0x70
   82110:	4310      	orrs	r0, r2
   82112:	6318      	str	r0, [r3, #48]	; 0x30
	for (ul_timeout = PMC_TIMEOUT; !(PMC->PMC_SR & PMC_SR_MCKRDY);
   82114:	6e9b      	ldr	r3, [r3, #104]	; 0x68
   82116:	f013 0f08 	tst.w	r3, #8
   8211a:	d109      	bne.n	82130 <pmc_switch_mck_to_pllack+0x28>
   8211c:	f44f 6300 	mov.w	r3, #2048	; 0x800
   82120:	4911      	ldr	r1, [pc, #68]	; (82168 <pmc_switch_mck_to_pllack+0x60>)
   82122:	e001      	b.n	82128 <pmc_switch_mck_to_pllack+0x20>
			--ul_timeout) {
		if (ul_timeout == 0) {
   82124:	3b01      	subs	r3, #1
   82126:	d019      	beq.n	8215c <pmc_switch_mck_to_pllack+0x54>
uint32_t pmc_switch_mck_to_pllack(uint32_t ul_pres)
{
	uint32_t ul_timeout;

	PMC->PMC_MCKR = (PMC->PMC_MCKR & (~PMC_MCKR_PRES_Msk)) | ul_pres;
	for (ul_timeout = PMC_TIMEOUT; !(PMC->PMC_SR & PMC_SR_MCKRDY);
   82128:	6e8a      	ldr	r2, [r1, #104]	; 0x68
   8212a:	f012 0f08 	tst.w	r2, #8
   8212e:	d0f9      	beq.n	82124 <pmc_switch_mck_to_pllack+0x1c>
		if (ul_timeout == 0) {
			return 1;
		}
	}

	PMC->PMC_MCKR = (PMC->PMC_MCKR & (~PMC_MCKR_CSS_Msk)) |
   82130:	4b0d      	ldr	r3, [pc, #52]	; (82168 <pmc_switch_mck_to_pllack+0x60>)
   82132:	6b1a      	ldr	r2, [r3, #48]	; 0x30
   82134:	f022 0203 	bic.w	r2, r2, #3
   82138:	f042 0202 	orr.w	r2, r2, #2
   8213c:	631a      	str	r2, [r3, #48]	; 0x30
			PMC_MCKR_CSS_PLLA_CLK;

	for (ul_timeout = PMC_TIMEOUT; !(PMC->PMC_SR & PMC_SR_MCKRDY);
   8213e:	6e98      	ldr	r0, [r3, #104]	; 0x68
   82140:	f010 0008 	ands.w	r0, r0, #8
   82144:	d10c      	bne.n	82160 <pmc_switch_mck_to_pllack+0x58>
   82146:	f44f 6300 	mov.w	r3, #2048	; 0x800
   8214a:	4907      	ldr	r1, [pc, #28]	; (82168 <pmc_switch_mck_to_pllack+0x60>)
   8214c:	e001      	b.n	82152 <pmc_switch_mck_to_pllack+0x4a>
			--ul_timeout) {
		if (ul_timeout == 0) {
   8214e:	3b01      	subs	r3, #1
   82150:	d008      	beq.n	82164 <pmc_switch_mck_to_pllack+0x5c>
	}

	PMC->PMC_MCKR = (PMC->PMC_MCKR & (~PMC_MCKR_CSS_Msk)) |
			PMC_MCKR_CSS_PLLA_CLK;

	for (ul_timeout = PMC_TIMEOUT; !(PMC->PMC_SR & PMC_SR_MCKRDY);
   82152:	6e8a      	ldr	r2, [r1, #104]	; 0x68
   82154:	f012 0f08 	tst.w	r2, #8
   82158:	d0f9      	beq.n	8214e <pmc_switch_mck_to_pllack+0x46>
   8215a:	4770      	bx	lr

	PMC->PMC_MCKR = (PMC->PMC_MCKR & (~PMC_MCKR_PRES_Msk)) | ul_pres;
	for (ul_timeout = PMC_TIMEOUT; !(PMC->PMC_SR & PMC_SR_MCKRDY);
			--ul_timeout) {
		if (ul_timeout == 0) {
			return 1;
   8215c:	2001      	movs	r0, #1
   8215e:	4770      	bx	lr
		if (ul_timeout == 0) {
			return 1;
		}
	}

	return 0;
   82160:	2000      	movs	r0, #0
   82162:	4770      	bx	lr
			PMC_MCKR_CSS_PLLA_CLK;

	for (ul_timeout = PMC_TIMEOUT; !(PMC->PMC_SR & PMC_SR_MCKRDY);
			--ul_timeout) {
		if (ul_timeout == 0) {
			return 1;
   82164:	2001      	movs	r0, #1
		}
	}

	return 0;
}
   82166:	4770      	bx	lr
   82168:	400e0600 	.word	0x400e0600

0008216c <pmc_switch_mainck_to_xtal>:
 */
void pmc_switch_mainck_to_xtal(uint32_t ul_bypass,
		uint32_t ul_xtal_startup_time)
{
	/* Enable Main Xtal oscillator */
	if (ul_bypass) {
   8216c:	b138      	cbz	r0, 8217e <pmc_switch_mainck_to_xtal+0x12>
		PMC->CKGR_MOR = (PMC->CKGR_MOR & ~CKGR_MOR_MOSCXTEN) |
   8216e:	4911      	ldr	r1, [pc, #68]	; (821b4 <pmc_switch_mainck_to_xtal+0x48>)
   82170:	6a0b      	ldr	r3, [r1, #32]
				CKGR_MOR_KEY_PASSWD | CKGR_MOR_MOSCXTBY |
   82172:	4a11      	ldr	r2, [pc, #68]	; (821b8 <pmc_switch_mainck_to_xtal+0x4c>)
   82174:	401a      	ands	r2, r3
   82176:	4b11      	ldr	r3, [pc, #68]	; (821bc <pmc_switch_mainck_to_xtal+0x50>)
   82178:	4313      	orrs	r3, r2
void pmc_switch_mainck_to_xtal(uint32_t ul_bypass,
		uint32_t ul_xtal_startup_time)
{
	/* Enable Main Xtal oscillator */
	if (ul_bypass) {
		PMC->CKGR_MOR = (PMC->CKGR_MOR & ~CKGR_MOR_MOSCXTEN) |
   8217a:	620b      	str	r3, [r1, #32]
   8217c:	4770      	bx	lr
				CKGR_MOR_KEY_PASSWD | CKGR_MOR_MOSCXTBY |
				CKGR_MOR_MOSCSEL;
	} else {
		PMC->CKGR_MOR = (PMC->CKGR_MOR & ~CKGR_MOR_MOSCXTBY) |
   8217e:	4a0d      	ldr	r2, [pc, #52]	; (821b4 <pmc_switch_mainck_to_xtal+0x48>)
   82180:	6a13      	ldr	r3, [r2, #32]
				CKGR_MOR_KEY_PASSWD | CKGR_MOR_MOSCXTEN |
   82182:	f423 135c 	bic.w	r3, r3, #3604480	; 0x370000
   82186:	f023 0303 	bic.w	r3, r3, #3
   8218a:	f443 135c 	orr.w	r3, r3, #3604480	; 0x370000
   8218e:	f043 0301 	orr.w	r3, r3, #1
				CKGR_MOR_MOSCXTST(ul_xtal_startup_time);
   82192:	0209      	lsls	r1, r1, #8
   82194:	b289      	uxth	r1, r1
		PMC->CKGR_MOR = (PMC->CKGR_MOR & ~CKGR_MOR_MOSCXTEN) |
				CKGR_MOR_KEY_PASSWD | CKGR_MOR_MOSCXTBY |
				CKGR_MOR_MOSCSEL;
	} else {
		PMC->CKGR_MOR = (PMC->CKGR_MOR & ~CKGR_MOR_MOSCXTBY) |
				CKGR_MOR_KEY_PASSWD | CKGR_MOR_MOSCXTEN |
   82196:	430b      	orrs	r3, r1
	if (ul_bypass) {
		PMC->CKGR_MOR = (PMC->CKGR_MOR & ~CKGR_MOR_MOSCXTEN) |
				CKGR_MOR_KEY_PASSWD | CKGR_MOR_MOSCXTBY |
				CKGR_MOR_MOSCSEL;
	} else {
		PMC->CKGR_MOR = (PMC->CKGR_MOR & ~CKGR_MOR_MOSCXTBY) |
   82198:	6213      	str	r3, [r2, #32]
				CKGR_MOR_KEY_PASSWD | CKGR_MOR_MOSCXTEN |
				CKGR_MOR_MOSCXTST(ul_xtal_startup_time);
		/* Wait the Xtal to stabilize */
		while (!(PMC->PMC_SR & PMC_SR_MOSCXTS));
   8219a:	6e93      	ldr	r3, [r2, #104]	; 0x68
   8219c:	f013 0f01 	tst.w	r3, #1
   821a0:	d0fb      	beq.n	8219a <pmc_switch_mainck_to_xtal+0x2e>

		PMC->CKGR_MOR |= CKGR_MOR_KEY_PASSWD | CKGR_MOR_MOSCSEL;
   821a2:	4a04      	ldr	r2, [pc, #16]	; (821b4 <pmc_switch_mainck_to_xtal+0x48>)
   821a4:	6a13      	ldr	r3, [r2, #32]
   821a6:	f043 739b 	orr.w	r3, r3, #20316160	; 0x1360000
   821aa:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
   821ae:	6213      	str	r3, [r2, #32]
   821b0:	4770      	bx	lr
   821b2:	bf00      	nop
   821b4:	400e0600 	.word	0x400e0600
   821b8:	fec8fffc 	.word	0xfec8fffc
   821bc:	01370002 	.word	0x01370002

000821c0 <pmc_osc_is_ready_mainck>:
 * \retval 1 Xtal is ready.
 * \retval 0 Xtal is not ready.
 */
uint32_t pmc_osc_is_ready_mainck(void)
{
	return PMC->PMC_SR & PMC_SR_MOSCSELS;
   821c0:	4b02      	ldr	r3, [pc, #8]	; (821cc <pmc_osc_is_ready_mainck+0xc>)
   821c2:	6e98      	ldr	r0, [r3, #104]	; 0x68
}
   821c4:	f400 3080 	and.w	r0, r0, #65536	; 0x10000
   821c8:	4770      	bx	lr
   821ca:	bf00      	nop
   821cc:	400e0600 	.word	0x400e0600

000821d0 <pmc_disable_pllack>:
void pmc_disable_pllack(void)
{
#if (SAM4C || SAM4CM || SAM4CP || SAMG)
	PMC->CKGR_PLLAR = CKGR_PLLAR_MULA(0);
#else
	PMC->CKGR_PLLAR = CKGR_PLLAR_ONE | CKGR_PLLAR_MULA(0);
   821d0:	f04f 5200 	mov.w	r2, #536870912	; 0x20000000
   821d4:	4b01      	ldr	r3, [pc, #4]	; (821dc <pmc_disable_pllack+0xc>)
   821d6:	629a      	str	r2, [r3, #40]	; 0x28
   821d8:	4770      	bx	lr
   821da:	bf00      	nop
   821dc:	400e0600 	.word	0x400e0600

000821e0 <pmc_is_locked_pllack>:
 * \retval 0 Not locked.
 * \retval 1 Locked.
 */
uint32_t pmc_is_locked_pllack(void)
{
	return (PMC->PMC_SR & PMC_SR_LOCKA);
   821e0:	4b02      	ldr	r3, [pc, #8]	; (821ec <pmc_is_locked_pllack+0xc>)
   821e2:	6e98      	ldr	r0, [r3, #104]	; 0x68
}
   821e4:	f000 0002 	and.w	r0, r0, #2
   821e8:	4770      	bx	lr
   821ea:	bf00      	nop
   821ec:	400e0600 	.word	0x400e0600

000821f0 <pmc_enable_upll_clock>:
/**
 * \brief Enable UPLL clock.
 */
void pmc_enable_upll_clock(void)
{
	PMC->CKGR_UCKR = CKGR_UCKR_UPLLCOUNT(3) | CKGR_UCKR_UPLLEN;
   821f0:	f44f 1244 	mov.w	r2, #3211264	; 0x310000
   821f4:	4b03      	ldr	r3, [pc, #12]	; (82204 <pmc_enable_upll_clock+0x14>)
   821f6:	61da      	str	r2, [r3, #28]

	/* Wait UTMI PLL Lock Status */
	while (!(PMC->PMC_SR & PMC_SR_LOCKU));
   821f8:	461a      	mov	r2, r3
   821fa:	6e93      	ldr	r3, [r2, #104]	; 0x68
   821fc:	f013 0f40 	tst.w	r3, #64	; 0x40
   82200:	d0fb      	beq.n	821fa <pmc_enable_upll_clock+0xa>
}
   82202:	4770      	bx	lr
   82204:	400e0600 	.word	0x400e0600

00082208 <pmc_enable_periph_clk>:
 * \retval 0 Success.
 * \retval 1 Invalid parameter.
 */
uint32_t pmc_enable_periph_clk(uint32_t ul_id)
{
	if (ul_id > MAX_PERIPH_ID) {
   82208:	282c      	cmp	r0, #44	; 0x2c
   8220a:	d820      	bhi.n	8224e <pmc_enable_periph_clk+0x46>
		return 1;
	}

	if (ul_id < 32) {
   8220c:	281f      	cmp	r0, #31
   8220e:	d80d      	bhi.n	8222c <pmc_enable_periph_clk+0x24>
		if ((PMC->PMC_PCSR0 & (1u << ul_id)) != (1u << ul_id)) {
   82210:	4b12      	ldr	r3, [pc, #72]	; (8225c <pmc_enable_periph_clk+0x54>)
   82212:	699a      	ldr	r2, [r3, #24]
   82214:	2301      	movs	r3, #1
   82216:	4083      	lsls	r3, r0
   82218:	401a      	ands	r2, r3
   8221a:	4293      	cmp	r3, r2
   8221c:	d019      	beq.n	82252 <pmc_enable_periph_clk+0x4a>
			PMC->PMC_PCER0 = 1 << ul_id;
   8221e:	2301      	movs	r3, #1
   82220:	fa03 f000 	lsl.w	r0, r3, r0
   82224:	4b0d      	ldr	r3, [pc, #52]	; (8225c <pmc_enable_periph_clk+0x54>)
   82226:	6118      	str	r0, [r3, #16]
			PMC->PMC_PCER1 = 1 << ul_id;
		}
#endif
	}

	return 0;
   82228:	2000      	movs	r0, #0
   8222a:	4770      	bx	lr
			PMC->PMC_PCER0 = 1 << ul_id;
		}
#if (SAM3S || SAM3XA || SAM4S || SAM4E || SAM4C || SAM4CM || SAM4CP || SAMG55 || SAMV71 || SAMV70 || SAME70 || SAMS70)
	} else {
		ul_id -= 32;
		if ((PMC->PMC_PCSR1 & (1u << ul_id)) != (1u << ul_id)) {
   8222c:	4b0b      	ldr	r3, [pc, #44]	; (8225c <pmc_enable_periph_clk+0x54>)
   8222e:	f8d3 2108 	ldr.w	r2, [r3, #264]	; 0x108
		if ((PMC->PMC_PCSR0 & (1u << ul_id)) != (1u << ul_id)) {
			PMC->PMC_PCER0 = 1 << ul_id;
		}
#if (SAM3S || SAM3XA || SAM4S || SAM4E || SAM4C || SAM4CM || SAM4CP || SAMG55 || SAMV71 || SAMV70 || SAME70 || SAMS70)
	} else {
		ul_id -= 32;
   82232:	3820      	subs	r0, #32
		if ((PMC->PMC_PCSR1 & (1u << ul_id)) != (1u << ul_id)) {
   82234:	2301      	movs	r3, #1
   82236:	4083      	lsls	r3, r0
   82238:	401a      	ands	r2, r3
   8223a:	4293      	cmp	r3, r2
   8223c:	d00b      	beq.n	82256 <pmc_enable_periph_clk+0x4e>
			PMC->PMC_PCER1 = 1 << ul_id;
   8223e:	2301      	movs	r3, #1
   82240:	fa03 f000 	lsl.w	r0, r3, r0
   82244:	4b05      	ldr	r3, [pc, #20]	; (8225c <pmc_enable_periph_clk+0x54>)
   82246:	f8c3 0100 	str.w	r0, [r3, #256]	; 0x100
		}
#endif
	}

	return 0;
   8224a:	2000      	movs	r0, #0
   8224c:	4770      	bx	lr
 * \retval 1 Invalid parameter.
 */
uint32_t pmc_enable_periph_clk(uint32_t ul_id)
{
	if (ul_id > MAX_PERIPH_ID) {
		return 1;
   8224e:	2001      	movs	r0, #1
   82250:	4770      	bx	lr
			PMC->PMC_PCER1 = 1 << ul_id;
		}
#endif
	}

	return 0;
   82252:	2000      	movs	r0, #0
   82254:	4770      	bx	lr
   82256:	2000      	movs	r0, #0
}
   82258:	4770      	bx	lr
   8225a:	bf00      	nop
   8225c:	400e0600 	.word	0x400e0600

00082260 <pmc_switch_udpck_to_upllck>:
 *
 * \param ul_usbdiv Clock divisor.
 */
void pmc_switch_udpck_to_upllck(uint32_t ul_usbdiv)
{
	PMC->PMC_USB = PMC_USB_USBS | PMC_USB_USBDIV(ul_usbdiv);
   82260:	0200      	lsls	r0, r0, #8
   82262:	f400 6270 	and.w	r2, r0, #3840	; 0xf00
   82266:	f042 0201 	orr.w	r2, r2, #1
   8226a:	4b01      	ldr	r3, [pc, #4]	; (82270 <pmc_switch_udpck_to_upllck+0x10>)
   8226c:	639a      	str	r2, [r3, #56]	; 0x38
   8226e:	4770      	bx	lr
   82270:	400e0600 	.word	0x400e0600

00082274 <pmc_enable_udpck>:
#if (SAM3S || SAM4S || SAM4E || SAMG55)
	PMC->PMC_SCER = PMC_SCER_UDP;
#elif (SAMV71 || SAMV70 || SAME70 || SAMS70)
	PMC->PMC_SCER = PMC_SCER_USBCLK;
#else
	PMC->PMC_SCER = PMC_SCER_UOTGCLK;
   82274:	2220      	movs	r2, #32
   82276:	4b01      	ldr	r3, [pc, #4]	; (8227c <pmc_enable_udpck+0x8>)
   82278:	601a      	str	r2, [r3, #0]
   8227a:	4770      	bx	lr
   8227c:	400e0600 	.word	0x400e0600

00082280 <pmc_set_fast_startup_input>:
 * \param ul_inputs Wake up inputs to enable.
 */
void pmc_set_fast_startup_input(uint32_t ul_inputs)
{
	ul_inputs &= PMC_FAST_STARTUP_Msk;
	PMC->PMC_FSMR |= ul_inputs;
   82280:	4b03      	ldr	r3, [pc, #12]	; (82290 <pmc_set_fast_startup_input+0x10>)
   82282:	6f1a      	ldr	r2, [r3, #112]	; 0x70
 *
 * \param ul_inputs Wake up inputs to enable.
 */
void pmc_set_fast_startup_input(uint32_t ul_inputs)
{
	ul_inputs &= PMC_FAST_STARTUP_Msk;
   82284:	f3c0 0012 	ubfx	r0, r0, #0, #19
	PMC->PMC_FSMR |= ul_inputs;
   82288:	4302      	orrs	r2, r0
   8228a:	671a      	str	r2, [r3, #112]	; 0x70
   8228c:	4770      	bx	lr
   8228e:	bf00      	nop
   82290:	400e0600 	.word	0x400e0600

00082294 <pmc_is_wakeup_clocks_restored>:
	}
}

bool pmc_is_wakeup_clocks_restored(void)
{
	return !b_is_sleep_clock_used;
   82294:	4b02      	ldr	r3, [pc, #8]	; (822a0 <pmc_is_wakeup_clocks_restored+0xc>)
   82296:	7818      	ldrb	r0, [r3, #0]
}
   82298:	f080 0001 	eor.w	r0, r0, #1
   8229c:	4770      	bx	lr
   8229e:	bf00      	nop
   822a0:	200716b4 	.word	0x200716b4

000822a4 <twi_disable_interrupt>:
 * \param ul_sources Interrupts to be disabled.
 */
void twi_disable_interrupt(Twi *p_twi, uint32_t ul_sources)
{
	/* Disable the specified interrupts */
	p_twi->TWI_IDR = ul_sources;
   822a4:	6281      	str	r1, [r0, #40]	; 0x28
	/* Dummy read */
	p_twi->TWI_SR;
   822a6:	6a03      	ldr	r3, [r0, #32]
   822a8:	4770      	bx	lr
   822aa:	bf00      	nop

000822ac <twi_get_interrupt_status>:
 *
 * \retval TWI interrupt status.
 */
uint32_t twi_get_interrupt_status(Twi *p_twi)
{
	return p_twi->TWI_SR;
   822ac:	6a00      	ldr	r0, [r0, #32]
}
   822ae:	4770      	bx	lr

000822b0 <twi_get_interrupt_mask>:
 *
 * \return The interrupt mask value.
 */
uint32_t twi_get_interrupt_mask(Twi *p_twi)
{
	return p_twi->TWI_IMR;
   822b0:	6ac0      	ldr	r0, [r0, #44]	; 0x2c
}
   822b2:	4770      	bx	lr

000822b4 <uart_enable_interrupt>:
 * \param p_uart Pointer to a UART instance.
 *  \param ul_sources Interrupts to be enabled.
 */
void uart_enable_interrupt(Uart *p_uart, uint32_t ul_sources)
{
	p_uart->UART_IER = ul_sources;
   822b4:	6081      	str	r1, [r0, #8]
   822b6:	4770      	bx	lr

000822b8 <uart_disable_interrupt>:
 * \param p_uart Pointer to a UART instance.
 *  \param ul_sources Interrupts to be disabled.
 */
void uart_disable_interrupt(Uart *p_uart, uint32_t ul_sources)
{
	p_uart->UART_IDR = ul_sources;
   822b8:	60c1      	str	r1, [r0, #12]
   822ba:	4770      	bx	lr

000822bc <uart_get_interrupt_mask>:
 *
 *  \return The interrupt mask value.
 */
uint32_t uart_get_interrupt_mask(Uart *p_uart)
{
	return p_uart->UART_IMR;
   822bc:	6900      	ldr	r0, [r0, #16]
}
   822be:	4770      	bx	lr

000822c0 <uart_get_status>:
 *
 * \return The current UART status.
 */
uint32_t uart_get_status(Uart *p_uart)
{
	return p_uart->UART_SR;
   822c0:	6940      	ldr	r0, [r0, #20]
}
   822c2:	4770      	bx	lr

000822c4 <uart_reset_status>:
 *
 * \param p_uart Pointer to a UART instance.
 */
void uart_reset_status(Uart *p_uart)
{
	p_uart->UART_CR = UART_CR_RSTSTA;
   822c4:	f44f 7380 	mov.w	r3, #256	; 0x100
   822c8:	6003      	str	r3, [r0, #0]
   822ca:	4770      	bx	lr

000822cc <udd_ctrl_init>:
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_PRIMASK(void)
{
  uint32_t result;

  __ASM volatile ("MRS %0, primask" : "=r" (result) );
   822cc:	f3ef 8310 	mrs	r3, PRIMASK
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
   822d0:	b672      	cpsid	i
   822d2:	f3bf 8f5f 	dmb	sy
static volatile bool     cpu_irq_prev_interrupt_state;

static inline irqflags_t cpu_irq_save(void)
{
	irqflags_t flags = cpu_irq_is_enabled();
	cpu_irq_disable();
   822d6:	2100      	movs	r1, #0
   822d8:	4a0a      	ldr	r2, [pc, #40]	; (82304 <udd_ctrl_init+0x38>)
   822da:	7011      	strb	r1, [r2, #0]
	// In case of abort of IN Data Phase:
	// No need to abort IN transfer (rise TXINI),
	// because it is automatically done by hardware when a Setup packet is received.
	// But the interrupt must be disabled to don't generate interrupt TXINI
	// after SETUP reception.
	udd_disable_in_send_interrupt(0);
   822dc:	2101      	movs	r1, #1
   822de:	4a0a      	ldr	r2, [pc, #40]	; (82308 <udd_ctrl_init+0x3c>)
   822e0:	6011      	str	r1, [r2, #0]
	return (flags);
}

static inline void cpu_irq_restore(irqflags_t flags)
{
	if (cpu_irq_is_enabled_flags(flags))
   822e2:	b923      	cbnz	r3, 822ee <udd_ctrl_init+0x22>
		cpu_irq_enable();
   822e4:	4b07      	ldr	r3, [pc, #28]	; (82304 <udd_ctrl_init+0x38>)
   822e6:	7019      	strb	r1, [r3, #0]
   822e8:	f3bf 8f5f 	dmb	sy
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
   822ec:	b662      	cpsie	i
	cpu_irq_restore(flags);

	// In case of OUT ZLP event is no processed before Setup event occurs
	udd_ack_out_received(0);
   822ee:	2202      	movs	r2, #2
   822f0:	4b06      	ldr	r3, [pc, #24]	; (8230c <udd_ctrl_init+0x40>)
   822f2:	601a      	str	r2, [r3, #0]

	udd_g_ctrlreq.callback = NULL;
   822f4:	4a06      	ldr	r2, [pc, #24]	; (82310 <udd_ctrl_init+0x44>)
   822f6:	2300      	movs	r3, #0
   822f8:	6113      	str	r3, [r2, #16]
	udd_g_ctrlreq.over_under_run = NULL;
   822fa:	6153      	str	r3, [r2, #20]
	udd_g_ctrlreq.payload_size = 0;
   822fc:	8193      	strh	r3, [r2, #12]
	udd_ep_control_state = UDD_EPCTRL_SETUP;
   822fe:	4a05      	ldr	r2, [pc, #20]	; (82314 <udd_ctrl_init+0x48>)
   82300:	7013      	strb	r3, [r2, #0]
   82302:	4770      	bx	lr
   82304:	20070270 	.word	0x20070270
   82308:	400ac220 	.word	0x400ac220
   8230c:	400ac160 	.word	0x400ac160
   82310:	20075c44 	.word	0x20075c44
   82314:	20071704 	.word	0x20071704

00082318 <udd_ctrl_stall_data>:


static void udd_ctrl_stall_data(void)
{
	// Stall all packets on IN & OUT control endpoint
	udd_ep_control_state = UDD_EPCTRL_STALL_REQ;
   82318:	2205      	movs	r2, #5
   8231a:	4b03      	ldr	r3, [pc, #12]	; (82328 <udd_ctrl_stall_data+0x10>)
   8231c:	701a      	strb	r2, [r3, #0]
	udd_enable_stall_handshake(0);
   8231e:	f44f 2200 	mov.w	r2, #524288	; 0x80000
   82322:	4b02      	ldr	r3, [pc, #8]	; (8232c <udd_ctrl_stall_data+0x14>)
   82324:	601a      	str	r2, [r3, #0]
   82326:	4770      	bx	lr
   82328:	20071704 	.word	0x20071704
   8232c:	400ac1f0 	.word	0x400ac1f0

00082330 <udd_ctrl_send_zlp_in>:

static void udd_ctrl_send_zlp_in(void)
{
	irqflags_t flags;

	udd_ep_control_state = UDD_EPCTRL_HANDSHAKE_WAIT_IN_ZLP;
   82330:	2203      	movs	r2, #3
   82332:	4b0d      	ldr	r3, [pc, #52]	; (82368 <udd_ctrl_send_zlp_in+0x38>)
   82334:	701a      	strb	r2, [r3, #0]
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_PRIMASK(void)
{
  uint32_t result;

  __ASM volatile ("MRS %0, primask" : "=r" (result) );
   82336:	f3ef 8010 	mrs	r0, PRIMASK
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
   8233a:	b672      	cpsid	i
   8233c:	f3bf 8f5f 	dmb	sy
static volatile bool     cpu_irq_prev_interrupt_state;

static inline irqflags_t cpu_irq_save(void)
{
	irqflags_t flags = cpu_irq_is_enabled();
	cpu_irq_disable();
   82340:	2200      	movs	r2, #0
   82342:	4b0a      	ldr	r3, [pc, #40]	; (8236c <udd_ctrl_send_zlp_in+0x3c>)
   82344:	701a      	strb	r2, [r3, #0]

	// Validate and send empty IN packet on control endpoint
	flags = cpu_irq_save();
	// Send ZLP on IN endpoint
	udd_ack_in_send(0);
   82346:	490a      	ldr	r1, [pc, #40]	; (82370 <udd_ctrl_send_zlp_in+0x40>)
   82348:	2201      	movs	r2, #1
   8234a:	600a      	str	r2, [r1, #0]
	udd_enable_in_send_interrupt(0);
   8234c:	4b09      	ldr	r3, [pc, #36]	; (82374 <udd_ctrl_send_zlp_in+0x44>)
   8234e:	601a      	str	r2, [r3, #0]
	// To detect a protocol error, enable nak interrupt on data OUT phase
	udd_ack_nak_out(0);
   82350:	2208      	movs	r2, #8
   82352:	600a      	str	r2, [r1, #0]
	udd_enable_nak_out_interrupt(0);
   82354:	601a      	str	r2, [r3, #0]
	return (flags);
}

static inline void cpu_irq_restore(irqflags_t flags)
{
	if (cpu_irq_is_enabled_flags(flags))
   82356:	b928      	cbnz	r0, 82364 <udd_ctrl_send_zlp_in+0x34>
		cpu_irq_enable();
   82358:	2201      	movs	r2, #1
   8235a:	4b04      	ldr	r3, [pc, #16]	; (8236c <udd_ctrl_send_zlp_in+0x3c>)
   8235c:	701a      	strb	r2, [r3, #0]
   8235e:	f3bf 8f5f 	dmb	sy
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
   82362:	b662      	cpsie	i
   82364:	4770      	bx	lr
   82366:	bf00      	nop
   82368:	20071704 	.word	0x20071704
   8236c:	20070270 	.word	0x20070270
   82370:	400ac160 	.word	0x400ac160
   82374:	400ac1f0 	.word	0x400ac1f0

00082378 <udd_ctrl_endofrequest>:
	cpu_irq_restore(flags);
}


static void udd_ctrl_endofrequest(void)
{
   82378:	b508      	push	{r3, lr}
	// If a callback is registered then call it
	if (udd_g_ctrlreq.callback) {
   8237a:	4b02      	ldr	r3, [pc, #8]	; (82384 <udd_ctrl_endofrequest+0xc>)
   8237c:	691b      	ldr	r3, [r3, #16]
   8237e:	b103      	cbz	r3, 82382 <udd_ctrl_endofrequest+0xa>
		udd_g_ctrlreq.callback();
   82380:	4798      	blx	r3
   82382:	bd08      	pop	{r3, pc}
   82384:	20075c44 	.word	0x20075c44

00082388 <udd_ctrl_in_sent>:
	}
}


static void udd_ctrl_in_sent(void)
{
   82388:	b538      	push	{r3, r4, r5, lr}
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_PRIMASK(void)
{
  uint32_t result;

  __ASM volatile ("MRS %0, primask" : "=r" (result) );
   8238a:	f3ef 8310 	mrs	r3, PRIMASK
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
   8238e:	b672      	cpsid	i
   82390:	f3bf 8f5f 	dmb	sy
static volatile bool     cpu_irq_prev_interrupt_state;

static inline irqflags_t cpu_irq_save(void)
{
	irqflags_t flags = cpu_irq_is_enabled();
	cpu_irq_disable();
   82394:	2100      	movs	r1, #0
   82396:	4a48      	ldr	r2, [pc, #288]	; (824b8 <udd_ctrl_in_sent+0x130>)
   82398:	7011      	strb	r1, [r2, #0]
	uint8_t i;
	uint8_t *ptr_dest, *ptr_src;
	irqflags_t flags;

	flags = cpu_irq_save();
	udd_disable_in_send_interrupt(0);
   8239a:	2101      	movs	r1, #1
   8239c:	4a47      	ldr	r2, [pc, #284]	; (824bc <udd_ctrl_in_sent+0x134>)
   8239e:	6011      	str	r1, [r2, #0]
	return (flags);
}

static inline void cpu_irq_restore(irqflags_t flags)
{
	if (cpu_irq_is_enabled_flags(flags))
   823a0:	b923      	cbnz	r3, 823ac <udd_ctrl_in_sent+0x24>
		cpu_irq_enable();
   823a2:	4b45      	ldr	r3, [pc, #276]	; (824b8 <udd_ctrl_in_sent+0x130>)
   823a4:	7019      	strb	r1, [r3, #0]
   823a6:	f3bf 8f5f 	dmb	sy
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
   823aa:	b662      	cpsie	i
	cpu_irq_restore(flags);

	if (UDD_EPCTRL_HANDSHAKE_WAIT_IN_ZLP == udd_ep_control_state) {
   823ac:	4b44      	ldr	r3, [pc, #272]	; (824c0 <udd_ctrl_in_sent+0x138>)
   823ae:	781b      	ldrb	r3, [r3, #0]
   823b0:	2b03      	cmp	r3, #3
   823b2:	d104      	bne.n	823be <udd_ctrl_in_sent+0x36>
		// ZLP on IN is sent, then valid end of setup request
		udd_ctrl_endofrequest();
   823b4:	4b43      	ldr	r3, [pc, #268]	; (824c4 <udd_ctrl_in_sent+0x13c>)
   823b6:	4798      	blx	r3
		// Reinitializes control endpoint management
		udd_ctrl_init();
   823b8:	4b43      	ldr	r3, [pc, #268]	; (824c8 <udd_ctrl_in_sent+0x140>)
   823ba:	4798      	blx	r3
		return;
   823bc:	bd38      	pop	{r3, r4, r5, pc}
	}
	Assert(udd_ep_control_state == UDD_EPCTRL_DATA_IN);

	nb_remain = udd_g_ctrlreq.payload_size - udd_ctrl_payload_buf_cnt;
   823be:	4b43      	ldr	r3, [pc, #268]	; (824cc <udd_ctrl_in_sent+0x144>)
   823c0:	881b      	ldrh	r3, [r3, #0]
   823c2:	4a43      	ldr	r2, [pc, #268]	; (824d0 <udd_ctrl_in_sent+0x148>)
   823c4:	8994      	ldrh	r4, [r2, #12]
   823c6:	1ae4      	subs	r4, r4, r3
   823c8:	b2a4      	uxth	r4, r4
	if (0 == nb_remain) {
   823ca:	2c00      	cmp	r4, #0
   823cc:	d12e      	bne.n	8242c <udd_ctrl_in_sent+0xa4>
		// All content of current buffer payload are sent
		// Update number of total data sending by previous playlaod buffer
		udd_ctrl_prev_payload_buf_cnt += udd_ctrl_payload_buf_cnt;
   823ce:	4a41      	ldr	r2, [pc, #260]	; (824d4 <udd_ctrl_in_sent+0x14c>)
   823d0:	8811      	ldrh	r1, [r2, #0]
   823d2:	440b      	add	r3, r1
   823d4:	b29b      	uxth	r3, r3
   823d6:	8013      	strh	r3, [r2, #0]
		if ((udd_g_ctrlreq.req.wLength == udd_ctrl_prev_payload_buf_cnt)
   823d8:	4a3d      	ldr	r2, [pc, #244]	; (824d0 <udd_ctrl_in_sent+0x148>)
   823da:	88d2      	ldrh	r2, [r2, #6]
   823dc:	429a      	cmp	r2, r3
   823de:	d002      	beq.n	823e6 <udd_ctrl_in_sent+0x5e>
					|| b_shortpacket) {
   823e0:	4b3d      	ldr	r3, [pc, #244]	; (824d8 <udd_ctrl_in_sent+0x150>)
   823e2:	781b      	ldrb	r3, [r3, #0]
   823e4:	b1c3      	cbz	r3, 82418 <udd_ctrl_in_sent+0x90>

static void udd_ctrl_send_zlp_out(void)
{
	irqflags_t flags;

	udd_ep_control_state = UDD_EPCTRL_HANDSHAKE_WAIT_OUT_ZLP;
   823e6:	2204      	movs	r2, #4
   823e8:	4b35      	ldr	r3, [pc, #212]	; (824c0 <udd_ctrl_in_sent+0x138>)
   823ea:	701a      	strb	r2, [r3, #0]
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_PRIMASK(void)
{
  uint32_t result;

  __ASM volatile ("MRS %0, primask" : "=r" (result) );
   823ec:	f3ef 8210 	mrs	r2, PRIMASK
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
   823f0:	b672      	cpsid	i
   823f2:	f3bf 8f5f 	dmb	sy
static volatile bool     cpu_irq_prev_interrupt_state;

static inline irqflags_t cpu_irq_save(void)
{
	irqflags_t flags = cpu_irq_is_enabled();
	cpu_irq_disable();
   823f6:	2100      	movs	r1, #0
   823f8:	4b2f      	ldr	r3, [pc, #188]	; (824b8 <udd_ctrl_in_sent+0x130>)
   823fa:	7019      	strb	r1, [r3, #0]
	// No action is necessary to accept OUT ZLP
	// because the buffer of control endpoint is already free

	// To detect a protocol error, enable nak interrupt on data IN phase
	flags = cpu_irq_save();
	udd_ack_nak_in(0);
   823fc:	2310      	movs	r3, #16
   823fe:	4937      	ldr	r1, [pc, #220]	; (824dc <udd_ctrl_in_sent+0x154>)
   82400:	600b      	str	r3, [r1, #0]
	udd_enable_nak_in_interrupt(0);
   82402:	3190      	adds	r1, #144	; 0x90
   82404:	600b      	str	r3, [r1, #0]
	return (flags);
}

static inline void cpu_irq_restore(irqflags_t flags)
{
	if (cpu_irq_is_enabled_flags(flags))
   82406:	2a00      	cmp	r2, #0
   82408:	d155      	bne.n	824b6 <udd_ctrl_in_sent+0x12e>
		cpu_irq_enable();
   8240a:	2201      	movs	r2, #1
   8240c:	4b2a      	ldr	r3, [pc, #168]	; (824b8 <udd_ctrl_in_sent+0x130>)
   8240e:	701a      	strb	r2, [r3, #0]
   82410:	f3bf 8f5f 	dmb	sy
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
   82414:	b662      	cpsie	i
   82416:	bd38      	pop	{r3, r4, r5, pc}
			// Generate an OUT ZLP for handshake phase.
			udd_ctrl_send_zlp_out();
			return;
		}
		// Need of new buffer because the data phase is not complete
		if ((!udd_g_ctrlreq.over_under_run)
   82418:	4b2d      	ldr	r3, [pc, #180]	; (824d0 <udd_ctrl_in_sent+0x148>)
   8241a:	695b      	ldr	r3, [r3, #20]
   8241c:	b16b      	cbz	r3, 8243a <udd_ctrl_in_sent+0xb2>
				|| (!udd_g_ctrlreq.over_under_run())) {
   8241e:	4798      	blx	r3
   82420:	b158      	cbz	r0, 8243a <udd_ctrl_in_sent+0xb2>
			// Underrun then send zlp on IN
			// Here nb_remain=0 and allows to send a IN ZLP
		} else {
			// A new payload buffer is given
			udd_ctrl_payload_buf_cnt = 0;
   82422:	2200      	movs	r2, #0
   82424:	4b29      	ldr	r3, [pc, #164]	; (824cc <udd_ctrl_in_sent+0x144>)
   82426:	801a      	strh	r2, [r3, #0]
			nb_remain = udd_g_ctrlreq.payload_size;
   82428:	4b29      	ldr	r3, [pc, #164]	; (824d0 <udd_ctrl_in_sent+0x148>)
   8242a:	899c      	ldrh	r4, [r3, #12]
		}
	}
	// Continue transfer and send next data
	if (nb_remain >= USB_DEVICE_EP_CTRL_SIZE) {
   8242c:	2c3f      	cmp	r4, #63	; 0x3f
   8242e:	d904      	bls.n	8243a <udd_ctrl_in_sent+0xb2>
		nb_remain = USB_DEVICE_EP_CTRL_SIZE;
		b_shortpacket = false;
   82430:	2200      	movs	r2, #0
   82432:	4b29      	ldr	r3, [pc, #164]	; (824d8 <udd_ctrl_in_sent+0x150>)
   82434:	701a      	strb	r2, [r3, #0]
			nb_remain = udd_g_ctrlreq.payload_size;
		}
	}
	// Continue transfer and send next data
	if (nb_remain >= USB_DEVICE_EP_CTRL_SIZE) {
		nb_remain = USB_DEVICE_EP_CTRL_SIZE;
   82436:	2440      	movs	r4, #64	; 0x40
   82438:	e002      	b.n	82440 <udd_ctrl_in_sent+0xb8>
		b_shortpacket = false;
	} else {
		b_shortpacket = true;
   8243a:	2201      	movs	r2, #1
   8243c:	4b26      	ldr	r3, [pc, #152]	; (824d8 <udd_ctrl_in_sent+0x150>)
   8243e:	701a      	strb	r2, [r3, #0]
	}
	// Fill buffer of endpoint control
	ptr_dest = (uint8_t *) & udd_get_endpoint_fifo_access(0, 8);
	ptr_src = udd_g_ctrlreq.payload + udd_ctrl_payload_buf_cnt;
   82440:	4b23      	ldr	r3, [pc, #140]	; (824d0 <udd_ctrl_in_sent+0x148>)
   82442:	689d      	ldr	r5, [r3, #8]
   82444:	4b21      	ldr	r3, [pc, #132]	; (824cc <udd_ctrl_in_sent+0x144>)
   82446:	881a      	ldrh	r2, [r3, #0]
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_PRIMASK(void)
{
  uint32_t result;

  __ASM volatile ("MRS %0, primask" : "=r" (result) );
   82448:	f3ef 8010 	mrs	r0, PRIMASK
static volatile uint32_t cpu_irq_critical_section_counter;
static volatile bool     cpu_irq_prev_interrupt_state;

static inline irqflags_t cpu_irq_save(void)
{
	irqflags_t flags = cpu_irq_is_enabled();
   8244c:	f1d0 0001 	rsbs	r0, r0, #1
   82450:	bf38      	it	cc
   82452:	2000      	movcc	r0, #0
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
   82454:	b672      	cpsid	i
   82456:	f3bf 8f5f 	dmb	sy
	cpu_irq_disable();
   8245a:	2100      	movs	r1, #0
   8245c:	4b16      	ldr	r3, [pc, #88]	; (824b8 <udd_ctrl_in_sent+0x130>)
   8245e:	7019      	strb	r1, [r3, #0]
	// a next setup reception in same endpoint 0 DPRAM.
	// Thereby, an OUT ZLP reception must check before IN data write
	// and if no OUT ZLP is recevied the data must be written quickly (800us)
	// before an eventually ZLP OUT and SETUP reception
	flags = cpu_irq_save();
	if (Is_udd_out_received(0)) {
   82460:	4b1f      	ldr	r3, [pc, #124]	; (824e0 <udd_ctrl_in_sent+0x158>)
   82462:	681b      	ldr	r3, [r3, #0]
   82464:	f013 0f02 	tst.w	r3, #2
   82468:	d101      	bne.n	8246e <udd_ctrl_in_sent+0xe6>
		cpu_irq_restore(flags);
		udd_ep_control_state = UDD_EPCTRL_HANDSHAKE_WAIT_OUT_ZLP;
		return; // Exit of IN DATA phase
	}
	// Write quickly the IN data
	for (i = 0; i < nb_remain; i++) {
   8246a:	b95c      	cbnz	r4, 82484 <udd_ctrl_in_sent+0xfc>
   8246c:	e013      	b.n	82496 <udd_ctrl_in_sent+0x10e>
	return (flags);
}

static inline void cpu_irq_restore(irqflags_t flags)
{
	if (cpu_irq_is_enabled_flags(flags))
   8246e:	b128      	cbz	r0, 8247c <udd_ctrl_in_sent+0xf4>
		cpu_irq_enable();
   82470:	2201      	movs	r2, #1
   82472:	4b11      	ldr	r3, [pc, #68]	; (824b8 <udd_ctrl_in_sent+0x130>)
   82474:	701a      	strb	r2, [r3, #0]
   82476:	f3bf 8f5f 	dmb	sy
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
   8247a:	b662      	cpsie	i
	// before an eventually ZLP OUT and SETUP reception
	flags = cpu_irq_save();
	if (Is_udd_out_received(0)) {
		// IN DATA phase aborted by OUT ZLP
		cpu_irq_restore(flags);
		udd_ep_control_state = UDD_EPCTRL_HANDSHAKE_WAIT_OUT_ZLP;
   8247c:	2204      	movs	r2, #4
   8247e:	4b10      	ldr	r3, [pc, #64]	; (824c0 <udd_ctrl_in_sent+0x138>)
   82480:	701a      	strb	r2, [r3, #0]
		return; // Exit of IN DATA phase
   82482:	bd38      	pop	{r3, r4, r5, pc}
	} else {
		b_shortpacket = true;
	}
	// Fill buffer of endpoint control
	ptr_dest = (uint8_t *) & udd_get_endpoint_fifo_access(0, 8);
	ptr_src = udd_g_ctrlreq.payload + udd_ctrl_payload_buf_cnt;
   82484:	442a      	add	r2, r5
   82486:	4b17      	ldr	r3, [pc, #92]	; (824e4 <udd_ctrl_in_sent+0x15c>)
		udd_ep_control_state = UDD_EPCTRL_HANDSHAKE_WAIT_OUT_ZLP;
		return; // Exit of IN DATA phase
	}
	// Write quickly the IN data
	for (i = 0; i < nb_remain; i++) {
		*ptr_dest++ = *ptr_src++;
   82488:	f812 1b01 	ldrb.w	r1, [r2], #1
   8248c:	f803 1b01 	strb.w	r1, [r3], #1
		cpu_irq_restore(flags);
		udd_ep_control_state = UDD_EPCTRL_HANDSHAKE_WAIT_OUT_ZLP;
		return; // Exit of IN DATA phase
	}
	// Write quickly the IN data
	for (i = 0; i < nb_remain; i++) {
   82490:	b2d9      	uxtb	r1, r3
   82492:	42a1      	cmp	r1, r4
   82494:	d3f8      	bcc.n	82488 <udd_ctrl_in_sent+0x100>
		*ptr_dest++ = *ptr_src++;
	}
	udd_ctrl_payload_buf_cnt += nb_remain;
   82496:	4b0d      	ldr	r3, [pc, #52]	; (824cc <udd_ctrl_in_sent+0x144>)
   82498:	881a      	ldrh	r2, [r3, #0]
   8249a:	4414      	add	r4, r2
   8249c:	801c      	strh	r4, [r3, #0]

	// Validate and send the data available in the control endpoint buffer
	udd_ack_in_send(0);
   8249e:	2301      	movs	r3, #1
   824a0:	4a0e      	ldr	r2, [pc, #56]	; (824dc <udd_ctrl_in_sent+0x154>)
   824a2:	6013      	str	r3, [r2, #0]
	udd_enable_in_send_interrupt(0);
   824a4:	3290      	adds	r2, #144	; 0x90
   824a6:	6013      	str	r3, [r2, #0]
	return (flags);
}

static inline void cpu_irq_restore(irqflags_t flags)
{
	if (cpu_irq_is_enabled_flags(flags))
   824a8:	b128      	cbz	r0, 824b6 <udd_ctrl_in_sent+0x12e>
		cpu_irq_enable();
   824aa:	461a      	mov	r2, r3
   824ac:	4b02      	ldr	r3, [pc, #8]	; (824b8 <udd_ctrl_in_sent+0x130>)
   824ae:	701a      	strb	r2, [r3, #0]
   824b0:	f3bf 8f5f 	dmb	sy
   824b4:	b662      	cpsie	i
   824b6:	bd38      	pop	{r3, r4, r5, pc}
   824b8:	20070270 	.word	0x20070270
   824bc:	400ac220 	.word	0x400ac220
   824c0:	20071704 	.word	0x20071704
   824c4:	00082379 	.word	0x00082379
   824c8:	000822cd 	.word	0x000822cd
   824cc:	20071706 	.word	0x20071706
   824d0:	20075c44 	.word	0x20075c44
   824d4:	200716b8 	.word	0x200716b8
   824d8:	200716b5 	.word	0x200716b5
   824dc:	400ac160 	.word	0x400ac160
   824e0:	400ac130 	.word	0x400ac130
   824e4:	20180000 	.word	0x20180000

000824e8 <udd_ep_finish_job>:
	udd_ep_finish_job(&udd_ep_job[ep - 1], true, ep);
}


static void udd_ep_finish_job(udd_ep_job_t * ptr_job, bool b_abort, uint8_t ep_num)
{
   824e8:	b510      	push	{r4, lr}
   824ea:	4603      	mov	r3, r0
	if (ptr_job->busy == false) {
   824ec:	7d04      	ldrb	r4, [r0, #20]
   824ee:	f014 0f01 	tst.w	r4, #1
   824f2:	d010      	beq.n	82516 <udd_ep_finish_job+0x2e>
		return; // No on-going job
	}
	dbg_print("(JobE%x:%d) ", (ptr_job-udd_ep_job)+1, b_abort);
	ptr_job->busy = false;
   824f4:	7d04      	ldrb	r4, [r0, #20]
   824f6:	f36f 0400 	bfc	r4, #0, #1
   824fa:	7504      	strb	r4, [r0, #20]
	if (NULL == ptr_job->call_trans) {
   824fc:	6804      	ldr	r4, [r0, #0]
   824fe:	b154      	cbz	r4, 82516 <udd_ep_finish_job+0x2e>
		return; // No callback linked to job
	}
	if (Is_udd_endpoint_in(ep_num)) {
   82500:	4805      	ldr	r0, [pc, #20]	; (82518 <udd_ep_finish_job+0x30>)
   82502:	f850 0022 	ldr.w	r0, [r0, r2, lsl #2]
   82506:	f410 7f80 	tst.w	r0, #256	; 0x100
		ep_num |= USB_EP_DIR_IN;
   8250a:	bf18      	it	ne
   8250c:	f042 0280 	orrne.w	r2, r2, #128	; 0x80
	}
	ptr_job->call_trans((b_abort) ? UDD_EP_TRANSFER_ABORT :
   82510:	4608      	mov	r0, r1
   82512:	6899      	ldr	r1, [r3, #8]
   82514:	47a0      	blx	r4
   82516:	bd10      	pop	{r4, pc}
   82518:	400ac100 	.word	0x400ac100

0008251c <udd_ep_trans_done>:
			UDD_EP_TRANSFER_OK, ptr_job->buf_size, ep_num);
}

#ifdef UDD_EP_DMA_SUPPORTED
static void udd_ep_trans_done(udd_ep_id_t ep)
{
   8251c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   8251e:	4602      	mov	r2, r0
	udd_ep_job_t *ptr_job;
	iram_size_t next_trans;
	irqflags_t flags;

	// Get job corresponding at endpoint
	ptr_job = &udd_ep_job[ep - 1];
   82520:	1e41      	subs	r1, r0, #1
   82522:	eb01 0041 	add.w	r0, r1, r1, lsl #1
   82526:	4b4d      	ldr	r3, [pc, #308]	; (8265c <udd_ep_trans_done+0x140>)
   82528:	eb03 03c0 	add.w	r3, r3, r0, lsl #3

	if (!ptr_job->busy) {
   8252c:	7d18      	ldrb	r0, [r3, #20]
   8252e:	f010 0f01 	tst.w	r0, #1
   82532:	f000 8092 	beq.w	8265a <udd_ep_trans_done+0x13e>
		return; // No job is running, then ignore it (system error)
	}

	if (ptr_job->buf_cnt != ptr_job->buf_size) {
   82536:	68d8      	ldr	r0, [r3, #12]
   82538:	689c      	ldr	r4, [r3, #8]
   8253a:	42a0      	cmp	r0, r4
   8253c:	d067      	beq.n	8260e <udd_ep_trans_done+0xf2>
		// Need to send or receiv other data
		next_trans = ptr_job->buf_size - ptr_job->buf_cnt;
   8253e:	1a24      	subs	r4, r4, r0

		if (UDD_ENDPOINT_MAX_TRANS < next_trans) {
   82540:	f5b4 3f80 	cmp.w	r4, #65536	; 0x10000
			next_trans = UDD_ENDPOINT_MAX_TRANS;

			// Set 0 to tranfer the maximum
			udd_dma_ctrl = UOTGHS_DEVDMACONTROL_BUFF_LENGTH(0);
		} else {
			udd_dma_ctrl = UOTGHS_DEVDMACONTROL_BUFF_LENGTH(next_trans);
   82544:	bf92      	itee	ls
   82546:	0426      	lslls	r6, r4, #16
		next_trans = ptr_job->buf_size - ptr_job->buf_cnt;

		if (UDD_ENDPOINT_MAX_TRANS < next_trans) {
			// The USB hardware support a maximum
			// transfer size of UDD_ENDPOINT_MAX_TRANS Bytes
			next_trans = UDD_ENDPOINT_MAX_TRANS;
   82548:	f44f 3480 	movhi.w	r4, #65536	; 0x10000

			// Set 0 to tranfer the maximum
			udd_dma_ctrl = UOTGHS_DEVDMACONTROL_BUFF_LENGTH(0);
   8254c:	2600      	movhi	r6, #0
		} else {
			udd_dma_ctrl = UOTGHS_DEVDMACONTROL_BUFF_LENGTH(next_trans);
		}
		if (Is_udd_endpoint_in(ep)) {
   8254e:	4d44      	ldr	r5, [pc, #272]	; (82660 <udd_ep_trans_done+0x144>)
   82550:	f855 7022 	ldr.w	r7, [r5, r2, lsl #2]
   82554:	f417 7f80 	tst.w	r7, #256	; 0x100
   82558:	d00f      	beq.n	8257a <udd_ep_trans_done+0x5e>
			if (0 != (next_trans % udd_get_endpoint_size(ep))) {
   8255a:	f855 5022 	ldr.w	r5, [r5, r2, lsl #2]
   8255e:	f3c5 1502 	ubfx	r5, r5, #4, #3
   82562:	2708      	movs	r7, #8
   82564:	fa07 f505 	lsl.w	r5, r7, r5
   82568:	3d01      	subs	r5, #1
   8256a:	422c      	tst	r4, r5
   8256c:	d016      	beq.n	8259c <udd_ep_trans_done+0x80>
				// Enable short packet option
				// else the DMA transfer is accepted
				// and interrupt DMA valid but nothing is sent.
				udd_dma_ctrl |= UOTGHS_DEVDMACONTROL_END_B_EN;
   8256e:	433e      	orrs	r6, r7
				// No need to request another ZLP
				ptr_job->b_shortpacket = false;
   82570:	7d1d      	ldrb	r5, [r3, #20]
   82572:	f36f 0541 	bfc	r5, #1, #1
   82576:	751d      	strb	r5, [r3, #20]
   82578:	e010      	b.n	8259c <udd_ep_trans_done+0x80>
			}
		} else {
			if ((USB_EP_TYPE_ISOCHRONOUS != udd_get_endpoint_type(ep))
   8257a:	f855 7022 	ldr.w	r7, [r5, r2, lsl #2]
   8257e:	f3c7 27c1 	ubfx	r7, r7, #11, #2
   82582:	2f01      	cmp	r7, #1
   82584:	d108      	bne.n	82598 <udd_ep_trans_done+0x7c>
					|| (next_trans <= (iram_size_t) udd_get_endpoint_size(ep))) {
   82586:	f855 5022 	ldr.w	r5, [r5, r2, lsl #2]
   8258a:	f3c5 1502 	ubfx	r5, r5, #4, #3
   8258e:	2708      	movs	r7, #8
   82590:	fa07 f505 	lsl.w	r5, r7, r5
   82594:	42ac      	cmp	r4, r5
   82596:	d801      	bhi.n	8259c <udd_ep_trans_done+0x80>

				// Enable short packet reception
				udd_dma_ctrl |= UOTGHS_DEVDMACONTROL_END_TR_IT
   82598:	f046 0614 	orr.w	r6, r6, #20
						| UOTGHS_DEVDMACONTROL_END_TR_EN;
			}
		}

		// Start USB DMA to fill or read fifo of the selected endpoint
		udd_endpoint_dma_set_addr(ep, (uint32_t) & ptr_job->buf[ptr_job->buf_cnt]);
   8259c:	4d31      	ldr	r5, [pc, #196]	; (82664 <udd_ep_trans_done+0x148>)
   8259e:	eb05 1502 	add.w	r5, r5, r2, lsl #4
   825a2:	685f      	ldr	r7, [r3, #4]
   825a4:	4438      	add	r0, r7
   825a6:	6068      	str	r0, [r5, #4]
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_PRIMASK(void)
{
  uint32_t result;

  __ASM volatile ("MRS %0, primask" : "=r" (result) );
   825a8:	f3ef 8010 	mrs	r0, PRIMASK
static volatile uint32_t cpu_irq_critical_section_counter;
static volatile bool     cpu_irq_prev_interrupt_state;

static inline irqflags_t cpu_irq_save(void)
{
	irqflags_t flags = cpu_irq_is_enabled();
   825ac:	f1d0 0c01 	rsbs	ip, r0, #1
   825b0:	bf38      	it	cc
   825b2:	f04f 0c00 	movcc.w	ip, #0
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
   825b6:	b672      	cpsid	i
   825b8:	f3bf 8f5f 	dmb	sy
	cpu_irq_disable();
   825bc:	2700      	movs	r7, #0
   825be:	482a      	ldr	r0, [pc, #168]	; (82668 <udd_ep_trans_done+0x14c>)
   825c0:	7007      	strb	r7, [r0, #0]


		// Disable IRQs to have a short sequence
		// between read of EOT_STA and DMA enable
		flags = cpu_irq_save();
		if (!(udd_endpoint_dma_get_status(ep)
   825c2:	68e8      	ldr	r0, [r5, #12]
   825c4:	f010 0f10 	tst.w	r0, #16
   825c8:	d116      	bne.n	825f8 <udd_ep_trans_done+0xdc>
			}
		}

		// Start USB DMA to fill or read fifo of the selected endpoint
		udd_endpoint_dma_set_addr(ep, (uint32_t) & ptr_job->buf[ptr_job->buf_cnt]);
		udd_dma_ctrl |= UOTGHS_DEVDMACONTROL_END_BUFFIT |
   825ca:	f046 0621 	orr.w	r6, r6, #33	; 0x21
		// between read of EOT_STA and DMA enable
		flags = cpu_irq_save();
		if (!(udd_endpoint_dma_get_status(ep)
				& UOTGHS_DEVDMASTATUS_END_TR_ST)) {
			dbg_print("dmaS%x ", ep);
			udd_endpoint_dma_set_control(ep, udd_dma_ctrl);
   825ce:	60ae      	str	r6, [r5, #8]
			ptr_job->buf_cnt += next_trans;
   825d0:	68da      	ldr	r2, [r3, #12]
   825d2:	4422      	add	r2, r4
   825d4:	60da      	str	r2, [r3, #12]
			ptr_job->buf_load = next_trans;
   825d6:	611c      	str	r4, [r3, #16]
			udd_enable_endpoint_dma_interrupt(ep);
   825d8:	f04f 7300 	mov.w	r3, #33554432	; 0x2000000
   825dc:	fa03 f101 	lsl.w	r1, r3, r1
   825e0:	4b22      	ldr	r3, [pc, #136]	; (8266c <udd_ep_trans_done+0x150>)
   825e2:	6199      	str	r1, [r3, #24]
	return (flags);
}

static inline void cpu_irq_restore(irqflags_t flags)
{
	if (cpu_irq_is_enabled_flags(flags))
   825e4:	f1bc 0f00 	cmp.w	ip, #0
   825e8:	d037      	beq.n	8265a <udd_ep_trans_done+0x13e>
		cpu_irq_enable();
   825ea:	2201      	movs	r2, #1
   825ec:	4b1e      	ldr	r3, [pc, #120]	; (82668 <udd_ep_trans_done+0x14c>)
   825ee:	701a      	strb	r2, [r3, #0]
   825f0:	f3bf 8f5f 	dmb	sy
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
   825f4:	b662      	cpsie	i
   825f6:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	return (flags);
}

static inline void cpu_irq_restore(irqflags_t flags)
{
	if (cpu_irq_is_enabled_flags(flags))
   825f8:	f1bc 0f00 	cmp.w	ip, #0
   825fc:	d005      	beq.n	8260a <udd_ep_trans_done+0xee>
		cpu_irq_enable();
   825fe:	2001      	movs	r0, #1
   82600:	4919      	ldr	r1, [pc, #100]	; (82668 <udd_ep_trans_done+0x14c>)
   82602:	7008      	strb	r0, [r1, #0]
   82604:	f3bf 8f5f 	dmb	sy
   82608:	b662      	cpsie	i
		cpu_irq_restore(flags);

		// Here a ZLP has been recieved
		// and the DMA transfer must be not started.
		// It is the end of transfer
		ptr_job->buf_size = ptr_job->buf_cnt;
   8260a:	68d9      	ldr	r1, [r3, #12]
   8260c:	6099      	str	r1, [r3, #8]
	}
	if (Is_udd_endpoint_in(ep)) {
   8260e:	4914      	ldr	r1, [pc, #80]	; (82660 <udd_ep_trans_done+0x144>)
   82610:	f851 1022 	ldr.w	r1, [r1, r2, lsl #2]
   82614:	f411 7f80 	tst.w	r1, #256	; 0x100
   82618:	d01b      	beq.n	82652 <udd_ep_trans_done+0x136>
		if (ptr_job->b_shortpacket) {
   8261a:	7d19      	ldrb	r1, [r3, #20]
   8261c:	f011 0f02 	tst.w	r1, #2
   82620:	d017      	beq.n	82652 <udd_ep_trans_done+0x136>
			dbg_print("zlpS%x ", ep);
			// Need to send a ZLP (No possible with USB DMA)
			// enable interrupt to wait a free bank to sent ZLP
			udd_ack_in_send(ep);
   82622:	2101      	movs	r1, #1
   82624:	4b12      	ldr	r3, [pc, #72]	; (82670 <udd_ep_trans_done+0x154>)
   82626:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
			if (Is_udd_write_enabled(ep)) {
   8262a:	3b30      	subs	r3, #48	; 0x30
   8262c:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
   82630:	f413 3f80 	tst.w	r3, #65536	; 0x10000
				// Force interrupt in case of ep already free
				udd_raise_in_send(ep);
   82634:	bf1c      	itt	ne
   82636:	4b0f      	ldrne	r3, [pc, #60]	; (82674 <udd_ep_trans_done+0x158>)
   82638:	f843 1022 	strne.w	r1, [r3, r2, lsl #2]
			}
			udd_enable_in_send_interrupt(ep);
   8263c:	2101      	movs	r1, #1
   8263e:	4b0e      	ldr	r3, [pc, #56]	; (82678 <udd_ep_trans_done+0x15c>)
   82640:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
			udd_enable_endpoint_interrupt(ep);
   82644:	f44f 5380 	mov.w	r3, #4096	; 0x1000
   82648:	fa03 f202 	lsl.w	r2, r3, r2
   8264c:	4b07      	ldr	r3, [pc, #28]	; (8266c <udd_ep_trans_done+0x150>)
   8264e:	619a      	str	r2, [r3, #24]
			return;
   82650:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		}
	}
	dbg_print("dmaE ");
	// Call callback to signal end of transfer
	udd_ep_finish_job(ptr_job, false, ep);
   82652:	4618      	mov	r0, r3
   82654:	2100      	movs	r1, #0
   82656:	4b09      	ldr	r3, [pc, #36]	; (8267c <udd_ep_trans_done+0x160>)
   82658:	4798      	blx	r3
   8265a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   8265c:	200716bc 	.word	0x200716bc
   82660:	400ac100 	.word	0x400ac100
   82664:	400ac300 	.word	0x400ac300
   82668:	20070270 	.word	0x20070270
   8266c:	400ac000 	.word	0x400ac000
   82670:	400ac160 	.word	0x400ac160
   82674:	400ac190 	.word	0x400ac190
   82678:	400ac1f0 	.word	0x400ac1f0
   8267c:	000824e9 	.word	0x000824e9

00082680 <udd_sleep_mode>:
 *
 * \param b_enable true to authorize idle mode
 */
static void udd_sleep_mode(bool b_idle)
{
	if (!b_idle && udd_b_idle) {
   82680:	4602      	mov	r2, r0
   82682:	2800      	cmp	r0, #0
   82684:	d135      	bne.n	826f2 <udd_sleep_mode+0x72>
   82686:	4b1d      	ldr	r3, [pc, #116]	; (826fc <udd_sleep_mode+0x7c>)
   82688:	781b      	ldrb	r3, [r3, #0]
   8268a:	b37b      	cbz	r3, 826ec <udd_sleep_mode+0x6c>
static inline void sleepmgr_unlock_mode(enum sleepmgr_mode mode)
{
#ifdef CONFIG_SLEEPMGR_ENABLE
	irqflags_t flags;

	if(sleepmgr_locks[mode] == 0) {
   8268c:	4b1c      	ldr	r3, [pc, #112]	; (82700 <udd_sleep_mode+0x80>)
   8268e:	789b      	ldrb	r3, [r3, #2]
   82690:	b903      	cbnz	r3, 82694 <udd_sleep_mode+0x14>
   82692:	e7fe      	b.n	82692 <udd_sleep_mode+0x12>
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_PRIMASK(void)
{
  uint32_t result;

  __ASM volatile ("MRS %0, primask" : "=r" (result) );
   82694:	f3ef 8110 	mrs	r1, PRIMASK
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
   82698:	b672      	cpsid	i
   8269a:	f3bf 8f5f 	dmb	sy
static volatile bool     cpu_irq_prev_interrupt_state;

static inline irqflags_t cpu_irq_save(void)
{
	irqflags_t flags = cpu_irq_is_enabled();
	cpu_irq_disable();
   8269e:	2000      	movs	r0, #0
   826a0:	4b18      	ldr	r3, [pc, #96]	; (82704 <udd_sleep_mode+0x84>)
   826a2:	7018      	strb	r0, [r3, #0]
	}

	// Enter a critical section
	flags = cpu_irq_save();

	--sleepmgr_locks[mode];
   826a4:	4b16      	ldr	r3, [pc, #88]	; (82700 <udd_sleep_mode+0x80>)
   826a6:	7898      	ldrb	r0, [r3, #2]
   826a8:	3801      	subs	r0, #1
   826aa:	7098      	strb	r0, [r3, #2]
	return (flags);
}

static inline void cpu_irq_restore(irqflags_t flags)
{
	if (cpu_irq_is_enabled_flags(flags))
   826ac:	b9f1      	cbnz	r1, 826ec <udd_sleep_mode+0x6c>
		cpu_irq_enable();
   826ae:	2101      	movs	r1, #1
   826b0:	4b14      	ldr	r3, [pc, #80]	; (82704 <udd_sleep_mode+0x84>)
   826b2:	7019      	strb	r1, [r3, #0]
   826b4:	f3bf 8f5f 	dmb	sy
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
   826b8:	b662      	cpsie	i
   826ba:	e017      	b.n	826ec <udd_sleep_mode+0x6c>
static inline void sleepmgr_lock_mode(enum sleepmgr_mode mode)
{
#ifdef CONFIG_SLEEPMGR_ENABLE
	irqflags_t flags;

	if(sleepmgr_locks[mode] >= 0xff) {
   826bc:	4b10      	ldr	r3, [pc, #64]	; (82700 <udd_sleep_mode+0x80>)
   826be:	789b      	ldrb	r3, [r3, #2]
   826c0:	2bff      	cmp	r3, #255	; 0xff
   826c2:	d100      	bne.n	826c6 <udd_sleep_mode+0x46>
   826c4:	e7fe      	b.n	826c4 <udd_sleep_mode+0x44>
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_PRIMASK(void)
{
  uint32_t result;

  __ASM volatile ("MRS %0, primask" : "=r" (result) );
   826c6:	f3ef 8110 	mrs	r1, PRIMASK
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
   826ca:	b672      	cpsid	i
   826cc:	f3bf 8f5f 	dmb	sy
static volatile bool     cpu_irq_prev_interrupt_state;

static inline irqflags_t cpu_irq_save(void)
{
	irqflags_t flags = cpu_irq_is_enabled();
	cpu_irq_disable();
   826d0:	2000      	movs	r0, #0
   826d2:	4b0c      	ldr	r3, [pc, #48]	; (82704 <udd_sleep_mode+0x84>)
   826d4:	7018      	strb	r0, [r3, #0]
	}

	// Enter a critical section
	flags = cpu_irq_save();

	++sleepmgr_locks[mode];
   826d6:	4b0a      	ldr	r3, [pc, #40]	; (82700 <udd_sleep_mode+0x80>)
   826d8:	7898      	ldrb	r0, [r3, #2]
   826da:	3001      	adds	r0, #1
   826dc:	7098      	strb	r0, [r3, #2]
	return (flags);
}

static inline void cpu_irq_restore(irqflags_t flags)
{
	if (cpu_irq_is_enabled_flags(flags))
   826de:	b929      	cbnz	r1, 826ec <udd_sleep_mode+0x6c>
		cpu_irq_enable();
   826e0:	2101      	movs	r1, #1
   826e2:	4b08      	ldr	r3, [pc, #32]	; (82704 <udd_sleep_mode+0x84>)
   826e4:	7019      	strb	r1, [r3, #0]
   826e6:	f3bf 8f5f 	dmb	sy
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
   826ea:	b662      	cpsie	i
	}
	if (b_idle && !udd_b_idle) {
		dbg_print("_W ");
		sleepmgr_lock_mode(UOTGHS_SLEEP_MODE_USB_IDLE);
	}
	udd_b_idle = b_idle;
   826ec:	4b03      	ldr	r3, [pc, #12]	; (826fc <udd_sleep_mode+0x7c>)
   826ee:	701a      	strb	r2, [r3, #0]
   826f0:	4770      	bx	lr
{
	if (!b_idle && udd_b_idle) {
		dbg_print("_S ");
		sleepmgr_unlock_mode(UOTGHS_SLEEP_MODE_USB_IDLE);
	}
	if (b_idle && !udd_b_idle) {
   826f2:	4b02      	ldr	r3, [pc, #8]	; (826fc <udd_sleep_mode+0x7c>)
   826f4:	781b      	ldrb	r3, [r3, #0]
   826f6:	2b00      	cmp	r3, #0
   826f8:	d1f8      	bne.n	826ec <udd_sleep_mode+0x6c>
   826fa:	e7df      	b.n	826bc <udd_sleep_mode+0x3c>
   826fc:	200716ba 	.word	0x200716ba
   82700:	20075c3c 	.word	0x20075c3c
   82704:	20070270 	.word	0x20070270

00082708 <udd_include_vbus_monitoring>:


bool udd_include_vbus_monitoring(void)
{
	return true;
}
   82708:	2001      	movs	r0, #1
   8270a:	4770      	bx	lr

0008270c <udd_enable>:


void udd_enable(void)
{
   8270c:	b510      	push	{r4, lr}
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_PRIMASK(void)
{
  uint32_t result;

  __ASM volatile ("MRS %0, primask" : "=r" (result) );
   8270e:	f3ef 8410 	mrs	r4, PRIMASK
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
   82712:	b672      	cpsid	i
   82714:	f3bf 8f5f 	dmb	sy
static volatile bool     cpu_irq_prev_interrupt_state;

static inline irqflags_t cpu_irq_save(void)
{
	irqflags_t flags = cpu_irq_is_enabled();
	cpu_irq_disable();
   82718:	2200      	movs	r2, #0
   8271a:	4b51      	ldr	r3, [pc, #324]	; (82860 <udd_enable+0x154>)
   8271c:	701a      	strb	r2, [r3, #0]
		cpu_irq_restore(flags);
		return;
	}
#else
	// SINGLE DEVICE MODE INITIALIZATION
	pmc_enable_periph_clk(ID_UOTGHS);
   8271e:	2028      	movs	r0, #40	; 0x28
   82720:	4b50      	ldr	r3, [pc, #320]	; (82864 <udd_enable+0x158>)
   82722:	4798      	blx	r3
	sysclk_enable_usb();
   82724:	4b50      	ldr	r3, [pc, #320]	; (82868 <udd_enable+0x15c>)
   82726:	4798      	blx	r3
__STATIC_INLINE void NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
  if(IRQn < 0) {
    SCB->SHP[((uint32_t)(IRQn) & 0xF)-4] = ((priority << (8 - __NVIC_PRIO_BITS)) & 0xff); } /* set Priority for Cortex-M  System Interrupts */
  else {
    NVIC->IP[(uint32_t)(IRQn)] = ((priority << (8 - __NVIC_PRIO_BITS)) & 0xff);    }        /* set Priority for device specific Interrupts  */
   82728:	4b50      	ldr	r3, [pc, #320]	; (8286c <udd_enable+0x160>)
   8272a:	22a0      	movs	r2, #160	; 0xa0
   8272c:	f883 2328 	strb.w	r2, [r3, #808]	; 0x328

    \param [in]      IRQn  External interrupt number. Value cannot be negative.
 */
__STATIC_INLINE void NVIC_EnableIRQ(IRQn_Type IRQn)
{
  NVIC->ISER[((uint32_t)(IRQn) >> 5)] = (1 << ((uint32_t)(IRQn) & 0x1F)); /* enable interrupt */
   82730:	f44f 7280 	mov.w	r2, #256	; 0x100
   82734:	605a      	str	r2, [r3, #4]
	NVIC_SetPriority((IRQn_Type) ID_UOTGHS, UDD_USB_INT_LEVEL);
	NVIC_EnableIRQ((IRQn_Type) ID_UOTGHS);

	// Always authorize asynchrone USB interrupts to exit of sleep mode
	// For SAM USB wake up device except BACKUP mode
	pmc_set_fast_startup_input(PMC_FSMR_USBAL);
   82736:	f44f 2080 	mov.w	r0, #262144	; 0x40000
   8273a:	4b4d      	ldr	r3, [pc, #308]	; (82870 <udd_enable+0x164>)
   8273c:	4798      	blx	r3
		cpu_irq_restore(flags);
		return; // Device is not the current mode
	}
#else
	// ID pin not used then force device mode
	otg_disable_id_pin();
   8273e:	4b4d      	ldr	r3, [pc, #308]	; (82874 <udd_enable+0x168>)
   82740:	f8d3 2800 	ldr.w	r2, [r3, #2048]	; 0x800
   82744:	f022 7280 	bic.w	r2, r2, #16777216	; 0x1000000
   82748:	f8c3 2800 	str.w	r2, [r3, #2048]	; 0x800
	otg_force_device_mode();
   8274c:	f8d3 2800 	ldr.w	r2, [r3, #2048]	; 0x800
   82750:	f042 7200 	orr.w	r2, r2, #33554432	; 0x2000000
   82754:	f8c3 2800 	str.w	r2, [r3, #2048]	; 0x800
   82758:	f8d3 2800 	ldr.w	r2, [r3, #2048]	; 0x800
   8275c:	f022 7280 	bic.w	r2, r2, #16777216	; 0x1000000
   82760:	f8c3 2800 	str.w	r2, [r3, #2048]	; 0x800
#endif
	// Enable USB hardware
	otg_enable_pad();
   82764:	f8d3 2800 	ldr.w	r2, [r3, #2048]	; 0x800
   82768:	f442 5280 	orr.w	r2, r2, #4096	; 0x1000
   8276c:	f8c3 2800 	str.w	r2, [r3, #2048]	; 0x800
	otg_enable();
   82770:	f8d3 2800 	ldr.w	r2, [r3, #2048]	; 0x800
   82774:	f442 4200 	orr.w	r2, r2, #32768	; 0x8000
   82778:	f8c3 2800 	str.w	r2, [r3, #2048]	; 0x800

	// Set the USB speed requested by configuration file
#ifdef USB_DEVICE_LOW_SPEED
	udd_low_speed_enable();
#else
	udd_low_speed_disable();
   8277c:	681a      	ldr	r2, [r3, #0]
   8277e:	f422 5280 	bic.w	r2, r2, #4096	; 0x1000
   82782:	601a      	str	r2, [r3, #0]
# ifdef USB_DEVICE_HS_SUPPORT
	udd_high_speed_enable();
   82784:	681a      	ldr	r2, [r3, #0]
   82786:	f422 6240 	bic.w	r2, r2, #3072	; 0xc00
   8278a:	601a      	str	r2, [r3, #0]
	udd_high_speed_disable();
# endif
#endif // USB_DEVICE_LOW_SPEED

	// Check USB clock
	otg_unfreeze_clock();
   8278c:	f8d3 2800 	ldr.w	r2, [r3, #2048]	; 0x800
   82790:	f422 4280 	bic.w	r2, r2, #16384	; 0x4000
   82794:	f8c3 2800 	str.w	r2, [r3, #2048]	; 0x800
	while (!Is_otg_clock_usable());
   82798:	461a      	mov	r2, r3
   8279a:	f8d2 3804 	ldr.w	r3, [r2, #2052]	; 0x804
   8279e:	f413 4f80 	tst.w	r3, #16384	; 0x4000
   827a2:	d0fa      	beq.n	8279a <udd_enable+0x8e>

static void udd_ep_job_table_reset(void)
{
	uint8_t i;
	for (i = 0; i < USB_DEVICE_MAX_EP; i++) {
		udd_ep_job[i].busy = false;
   827a4:	4b34      	ldr	r3, [pc, #208]	; (82878 <udd_enable+0x16c>)
   827a6:	7d1a      	ldrb	r2, [r3, #20]
		udd_ep_job[i].stall_requested = false;
   827a8:	f002 02fe 	and.w	r2, r2, #254	; 0xfe
   827ac:	f36f 0282 	bfc	r2, #2, #1
   827b0:	751a      	strb	r2, [r3, #20]

static void udd_ep_job_table_reset(void)
{
	uint8_t i;
	for (i = 0; i < USB_DEVICE_MAX_EP; i++) {
		udd_ep_job[i].busy = false;
   827b2:	f893 202c 	ldrb.w	r2, [r3, #44]	; 0x2c
		udd_ep_job[i].stall_requested = false;
   827b6:	f002 02fe 	and.w	r2, r2, #254	; 0xfe
   827ba:	f36f 0282 	bfc	r2, #2, #1
   827be:	f883 202c 	strb.w	r2, [r3, #44]	; 0x2c

static void udd_ep_job_table_reset(void)
{
	uint8_t i;
	for (i = 0; i < USB_DEVICE_MAX_EP; i++) {
		udd_ep_job[i].busy = false;
   827c2:	f893 2044 	ldrb.w	r2, [r3, #68]	; 0x44
		udd_ep_job[i].stall_requested = false;
   827c6:	f002 02fe 	and.w	r2, r2, #254	; 0xfe
   827ca:	f36f 0282 	bfc	r2, #2, #1
   827ce:	f883 2044 	strb.w	r2, [r3, #68]	; 0x44
	// Reset internal variables
#if (0!=USB_DEVICE_MAX_EP)
	udd_ep_job_table_reset();
#endif

	otg_ack_vbus_transition();
   827d2:	4b28      	ldr	r3, [pc, #160]	; (82874 <udd_enable+0x168>)
   827d4:	2202      	movs	r2, #2
   827d6:	f8c3 2808 	str.w	r2, [r3, #2056]	; 0x808
	// Force Vbus interrupt in case of Vbus always with a high level
	// This is possible with a short timing between a Host mode stop/start.
	if (Is_otg_vbus_high()) {
   827da:	f8d3 3804 	ldr.w	r3, [r3, #2052]	; 0x804
   827de:	f413 6f00 	tst.w	r3, #2048	; 0x800
		otg_raise_vbus_transition();
   827e2:	bf1c      	itt	ne
   827e4:	4b23      	ldrne	r3, [pc, #140]	; (82874 <udd_enable+0x168>)
   827e6:	f8c3 280c 	strne.w	r2, [r3, #2060]	; 0x80c
	}
	otg_enable_vbus_interrupt();
   827ea:	4b22      	ldr	r3, [pc, #136]	; (82874 <udd_enable+0x168>)
   827ec:	f8d3 2800 	ldr.w	r2, [r3, #2048]	; 0x800
   827f0:	f042 0202 	orr.w	r2, r2, #2
   827f4:	f8c3 2800 	str.w	r2, [r3, #2048]	; 0x800
	otg_freeze_clock();
   827f8:	f8d3 2800 	ldr.w	r2, [r3, #2048]	; 0x800
   827fc:	f442 4280 	orr.w	r2, r2, #16384	; 0x4000
   82800:	f8c3 2800 	str.w	r2, [r3, #2048]	; 0x800

#ifndef UDD_NO_SLEEP_MGR
	if (!udd_b_sleep_initialized) {
   82804:	4b1d      	ldr	r3, [pc, #116]	; (8287c <udd_enable+0x170>)
   82806:	781b      	ldrb	r3, [r3, #0]
   82808:	b9f3      	cbnz	r3, 82848 <udd_enable+0x13c>
		udd_b_sleep_initialized = true;
   8280a:	2201      	movs	r2, #1
   8280c:	4b1b      	ldr	r3, [pc, #108]	; (8287c <udd_enable+0x170>)
   8280e:	701a      	strb	r2, [r3, #0]
		// Initialize the sleep mode authorized for the USB suspend mode
		udd_b_idle = false;
   82810:	2200      	movs	r2, #0
   82812:	4b1b      	ldr	r3, [pc, #108]	; (82880 <udd_enable+0x174>)
   82814:	701a      	strb	r2, [r3, #0]
static inline void sleepmgr_lock_mode(enum sleepmgr_mode mode)
{
#ifdef CONFIG_SLEEPMGR_ENABLE
	irqflags_t flags;

	if(sleepmgr_locks[mode] >= 0xff) {
   82816:	4b1b      	ldr	r3, [pc, #108]	; (82884 <udd_enable+0x178>)
   82818:	78db      	ldrb	r3, [r3, #3]
   8281a:	2bff      	cmp	r3, #255	; 0xff
   8281c:	d100      	bne.n	82820 <udd_enable+0x114>
   8281e:	e7fe      	b.n	8281e <udd_enable+0x112>
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_PRIMASK(void)
{
  uint32_t result;

  __ASM volatile ("MRS %0, primask" : "=r" (result) );
   82820:	f3ef 8210 	mrs	r2, PRIMASK
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
   82824:	b672      	cpsid	i
   82826:	f3bf 8f5f 	dmb	sy
   8282a:	2100      	movs	r1, #0
   8282c:	4b0c      	ldr	r3, [pc, #48]	; (82860 <udd_enable+0x154>)
   8282e:	7019      	strb	r1, [r3, #0]
	}

	// Enter a critical section
	flags = cpu_irq_save();

	++sleepmgr_locks[mode];
   82830:	4b14      	ldr	r3, [pc, #80]	; (82884 <udd_enable+0x178>)
   82832:	78d9      	ldrb	r1, [r3, #3]
   82834:	3101      	adds	r1, #1
   82836:	70d9      	strb	r1, [r3, #3]
	return (flags);
}

static inline void cpu_irq_restore(irqflags_t flags)
{
	if (cpu_irq_is_enabled_flags(flags))
   82838:	b94a      	cbnz	r2, 8284e <udd_enable+0x142>
		cpu_irq_enable();
   8283a:	2201      	movs	r2, #1
   8283c:	4b08      	ldr	r3, [pc, #32]	; (82860 <udd_enable+0x154>)
   8283e:	701a      	strb	r2, [r3, #0]
   82840:	f3bf 8f5f 	dmb	sy
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
   82844:	b662      	cpsie	i
   82846:	e002      	b.n	8284e <udd_enable+0x142>
		sleepmgr_lock_mode(UOTGHS_SLEEP_MODE_USB_SUSPEND);
	} else {
		udd_sleep_mode(false); // Enter idle mode
   82848:	2000      	movs	r0, #0
   8284a:	4b0f      	ldr	r3, [pc, #60]	; (82888 <udd_enable+0x17c>)
   8284c:	4798      	blx	r3
	return (flags);
}

static inline void cpu_irq_restore(irqflags_t flags)
{
	if (cpu_irq_is_enabled_flags(flags))
   8284e:	b92c      	cbnz	r4, 8285c <udd_enable+0x150>
		cpu_irq_enable();
   82850:	2201      	movs	r2, #1
   82852:	4b03      	ldr	r3, [pc, #12]	; (82860 <udd_enable+0x154>)
   82854:	701a      	strb	r2, [r3, #0]
   82856:	f3bf 8f5f 	dmb	sy
   8285a:	b662      	cpsie	i
   8285c:	bd10      	pop	{r4, pc}
   8285e:	bf00      	nop
   82860:	20070270 	.word	0x20070270
   82864:	00082209 	.word	0x00082209
   82868:	00080149 	.word	0x00080149
   8286c:	e000e100 	.word	0xe000e100
   82870:	00082281 	.word	0x00082281
   82874:	400ac000 	.word	0x400ac000
   82878:	200716bc 	.word	0x200716bc
   8287c:	200716b6 	.word	0x200716b6
   82880:	200716ba 	.word	0x200716ba
   82884:	20075c3c 	.word	0x20075c3c
   82888:	00082681 	.word	0x00082681

0008288c <udd_attach>:
	cpu_irq_restore(flags);
}


void udd_attach(void)
{
   8288c:	b570      	push	{r4, r5, r6, lr}
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_PRIMASK(void)
{
  uint32_t result;

  __ASM volatile ("MRS %0, primask" : "=r" (result) );
   8288e:	f3ef 8510 	mrs	r5, PRIMASK
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
   82892:	b672      	cpsid	i
   82894:	f3bf 8f5f 	dmb	sy
static volatile bool     cpu_irq_prev_interrupt_state;

static inline irqflags_t cpu_irq_save(void)
{
	irqflags_t flags = cpu_irq_is_enabled();
	cpu_irq_disable();
   82898:	2200      	movs	r2, #0
   8289a:	4b19      	ldr	r3, [pc, #100]	; (82900 <udd_attach+0x74>)
   8289c:	701a      	strb	r2, [r3, #0]
	irqflags_t flags;
	flags = cpu_irq_save();

	// At startup the USB bus state is unknown,
	// therefore the state is considered IDLE to not miss any USB event
	udd_sleep_mode(true);
   8289e:	2001      	movs	r0, #1
   828a0:	4b18      	ldr	r3, [pc, #96]	; (82904 <udd_attach+0x78>)
   828a2:	4798      	blx	r3
	otg_unfreeze_clock();
   828a4:	4b18      	ldr	r3, [pc, #96]	; (82908 <udd_attach+0x7c>)
   828a6:	f8d3 2800 	ldr.w	r2, [r3, #2048]	; 0x800
   828aa:	f422 4280 	bic.w	r2, r2, #16384	; 0x4000
   828ae:	f8c3 2800 	str.w	r2, [r3, #2048]	; 0x800

	// This section of clock check can be improved with a chek of
	// USB clock source via sysclk()
	// Check USB clock because the source can be a PLL
	while (!Is_otg_clock_usable());
   828b2:	461a      	mov	r2, r3
   828b4:	f8d2 3804 	ldr.w	r3, [r2, #2052]	; 0x804
   828b8:	f413 4f80 	tst.w	r3, #16384	; 0x4000
   828bc:	d0fa      	beq.n	828b4 <udd_attach+0x28>

	// Authorize attach if Vbus is present
	udd_attach_device();
   828be:	4b12      	ldr	r3, [pc, #72]	; (82908 <udd_attach+0x7c>)
   828c0:	681a      	ldr	r2, [r3, #0]
   828c2:	f422 7280 	bic.w	r2, r2, #256	; 0x100
   828c6:	601a      	str	r2, [r3, #0]

	// Enable USB line events
	udd_enable_reset_interrupt();
   828c8:	2608      	movs	r6, #8
   828ca:	619e      	str	r6, [r3, #24]
	udd_enable_suspend_interrupt();
   828cc:	2101      	movs	r1, #1
   828ce:	6199      	str	r1, [r3, #24]
	udd_enable_wake_up_interrupt();
   828d0:	2210      	movs	r2, #16
   828d2:	619a      	str	r2, [r3, #24]
	udd_enable_sof_interrupt();
   828d4:	2404      	movs	r4, #4
   828d6:	619c      	str	r4, [r3, #24]
#ifdef USB_DEVICE_HS_SUPPORT
	udd_enable_msof_interrupt();
   828d8:	2002      	movs	r0, #2
   828da:	6198      	str	r0, [r3, #24]
#endif
	// Reset following interupts flag
	udd_ack_reset();
   828dc:	609e      	str	r6, [r3, #8]
	udd_ack_sof();
   828de:	609c      	str	r4, [r3, #8]
	udd_ack_msof();
   828e0:	6098      	str	r0, [r3, #8]

	// The first suspend interrupt must be forced
	// The first suspend interrupt is not detected else raise it
	udd_raise_suspend();
   828e2:	60d9      	str	r1, [r3, #12]

	udd_ack_wake_up();
   828e4:	609a      	str	r2, [r3, #8]
	otg_freeze_clock();
   828e6:	f8d3 2800 	ldr.w	r2, [r3, #2048]	; 0x800
   828ea:	f442 4280 	orr.w	r2, r2, #16384	; 0x4000
   828ee:	f8c3 2800 	str.w	r2, [r3, #2048]	; 0x800
	return (flags);
}

static inline void cpu_irq_restore(irqflags_t flags)
{
	if (cpu_irq_is_enabled_flags(flags))
   828f2:	b925      	cbnz	r5, 828fe <udd_attach+0x72>
		cpu_irq_enable();
   828f4:	4b02      	ldr	r3, [pc, #8]	; (82900 <udd_attach+0x74>)
   828f6:	7019      	strb	r1, [r3, #0]
   828f8:	f3bf 8f5f 	dmb	sy
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
   828fc:	b662      	cpsie	i
   828fe:	bd70      	pop	{r4, r5, r6, pc}
   82900:	20070270 	.word	0x20070270
   82904:	00082681 	.word	0x00082681
   82908:	400ac000 	.word	0x400ac000

0008290c <udd_detach>:
	cpu_irq_restore(flags);
}


void udd_detach(void)
{
   8290c:	b508      	push	{r3, lr}
	otg_unfreeze_clock();
   8290e:	4b0a      	ldr	r3, [pc, #40]	; (82938 <udd_detach+0x2c>)
   82910:	f8d3 2800 	ldr.w	r2, [r3, #2048]	; 0x800
   82914:	f422 4280 	bic.w	r2, r2, #16384	; 0x4000
   82918:	f8c3 2800 	str.w	r2, [r3, #2048]	; 0x800

	// Detach device from the bus
	udd_detach_device();
   8291c:	681a      	ldr	r2, [r3, #0]
   8291e:	f442 7280 	orr.w	r2, r2, #256	; 0x100
   82922:	601a      	str	r2, [r3, #0]
	otg_freeze_clock();
   82924:	f8d3 2800 	ldr.w	r2, [r3, #2048]	; 0x800
   82928:	f442 4280 	orr.w	r2, r2, #16384	; 0x4000
   8292c:	f8c3 2800 	str.w	r2, [r3, #2048]	; 0x800
	udd_sleep_mode(false);
   82930:	2000      	movs	r0, #0
   82932:	4b02      	ldr	r3, [pc, #8]	; (8293c <udd_detach+0x30>)
   82934:	4798      	blx	r3
   82936:	bd08      	pop	{r3, pc}
   82938:	400ac000 	.word	0x400ac000
   8293c:	00082681 	.word	0x00082681

00082940 <UOTGHS_Handler>:
void udd_interrupt(void);
void udd_interrupt(void)
#else
ISR(UDD_USB_INT_FUN)
#endif
{
   82940:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
	/* For fast wakeup clocks restore
	 * In WAIT mode, clocks are switched to FASTRC.
	 * After wakeup clocks should be restored, before that ISR should not
	 * be served.
	 */
	if (!pmc_is_wakeup_clocks_restored() && !Is_udd_suspend()) {
   82944:	4b9c      	ldr	r3, [pc, #624]	; (82bb8 <UOTGHS_Handler+0x278>)
   82946:	4798      	blx	r3
   82948:	b960      	cbnz	r0, 82964 <UOTGHS_Handler+0x24>
   8294a:	4b9c      	ldr	r3, [pc, #624]	; (82bbc <UOTGHS_Handler+0x27c>)
   8294c:	685b      	ldr	r3, [r3, #4]
   8294e:	f013 0f01 	tst.w	r3, #1
   82952:	d107      	bne.n	82964 <UOTGHS_Handler+0x24>
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
   82954:	b672      	cpsid	i
   82956:	f3bf 8f5f 	dmb	sy
		cpu_irq_disable();
   8295a:	2200      	movs	r2, #0
   8295c:	4b98      	ldr	r3, [pc, #608]	; (82bc0 <UOTGHS_Handler+0x280>)
   8295e:	701a      	strb	r2, [r3, #0]
		return;
   82960:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
	}

	if (Is_udd_sof()) {
   82964:	4b95      	ldr	r3, [pc, #596]	; (82bbc <UOTGHS_Handler+0x27c>)
   82966:	685b      	ldr	r3, [r3, #4]
   82968:	f013 0f04 	tst.w	r3, #4
   8296c:	d00c      	beq.n	82988 <UOTGHS_Handler+0x48>
		udd_ack_sof();
   8296e:	4b93      	ldr	r3, [pc, #588]	; (82bbc <UOTGHS_Handler+0x27c>)
   82970:	2204      	movs	r2, #4
   82972:	609a      	str	r2, [r3, #8]
		if (Is_udd_full_speed_mode()) {
   82974:	f8d3 3804 	ldr.w	r3, [r3, #2052]	; 0x804
   82978:	f413 5f40 	tst.w	r3, #12288	; 0x3000
   8297c:	f040 82e1 	bne.w	82f42 <UOTGHS_Handler+0x602>
			udc_sof_notify();
   82980:	4b90      	ldr	r3, [pc, #576]	; (82bc4 <UOTGHS_Handler+0x284>)
   82982:	4798      	blx	r3
   82984:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
		UDC_SOF_EVENT();
#endif
		goto udd_interrupt_sof_end;
	}

	if (Is_udd_msof()) {
   82988:	4b8c      	ldr	r3, [pc, #560]	; (82bbc <UOTGHS_Handler+0x27c>)
   8298a:	685b      	ldr	r3, [r3, #4]
   8298c:	f013 0f02 	tst.w	r3, #2
   82990:	d006      	beq.n	829a0 <UOTGHS_Handler+0x60>
		udd_ack_msof();
   82992:	2202      	movs	r2, #2
   82994:	4b89      	ldr	r3, [pc, #548]	; (82bbc <UOTGHS_Handler+0x27c>)
   82996:	609a      	str	r2, [r3, #8]
		udc_sof_notify();
   82998:	4b8a      	ldr	r3, [pc, #552]	; (82bc4 <UOTGHS_Handler+0x284>)
   8299a:	4798      	blx	r3
		goto udd_interrupt_sof_end;
   8299c:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}


static bool udd_ctrl_interrupt(void)
{

	if (!Is_udd_endpoint_interrupt(0)) {
   829a0:	4b86      	ldr	r3, [pc, #536]	; (82bbc <UOTGHS_Handler+0x27c>)
   829a2:	685b      	ldr	r3, [r3, #4]
   829a4:	f413 5f80 	tst.w	r3, #4096	; 0x1000
   829a8:	f000 8292 	beq.w	82ed0 <UOTGHS_Handler+0x590>
	}

	dbg_print("0: ");

	// By default disable overflow and underflow interrupt
	udd_disable_nak_in_interrupt(0);
   829ac:	4b86      	ldr	r3, [pc, #536]	; (82bc8 <UOTGHS_Handler+0x288>)
   829ae:	2210      	movs	r2, #16
   829b0:	601a      	str	r2, [r3, #0]
	udd_disable_nak_out_interrupt(0);
   829b2:	2208      	movs	r2, #8
   829b4:	601a      	str	r2, [r3, #0]

	// Search event on control endpoint
	if (Is_udd_setup_received(0)) {
   829b6:	3bf0      	subs	r3, #240	; 0xf0
   829b8:	681b      	ldr	r3, [r3, #0]
   829ba:	f013 0f04 	tst.w	r3, #4
   829be:	d060      	beq.n	82a82 <UOTGHS_Handler+0x142>
static void udd_ctrl_setup_received(void)
{
	irqflags_t flags;
	uint8_t i;

	if (UDD_EPCTRL_SETUP != udd_ep_control_state) {
   829c0:	4b82      	ldr	r3, [pc, #520]	; (82bcc <UOTGHS_Handler+0x28c>)
   829c2:	781b      	ldrb	r3, [r3, #0]
   829c4:	b11b      	cbz	r3, 829ce <UOTGHS_Handler+0x8e>
		// May be a hidden DATA or ZLP phase or protocol abort
		udd_ctrl_endofrequest();
   829c6:	4b82      	ldr	r3, [pc, #520]	; (82bd0 <UOTGHS_Handler+0x290>)
   829c8:	4798      	blx	r3

		// Reinitializes control endpoint management
		udd_ctrl_init();
   829ca:	4b82      	ldr	r3, [pc, #520]	; (82bd4 <UOTGHS_Handler+0x294>)
   829cc:	4798      	blx	r3
	}
	// Fill setup request structure
	if (8 != udd_byte_count(0)) {
   829ce:	4b82      	ldr	r3, [pc, #520]	; (82bd8 <UOTGHS_Handler+0x298>)
   829d0:	681b      	ldr	r3, [r3, #0]
   829d2:	f3c3 530a 	ubfx	r3, r3, #20, #11
   829d6:	2b08      	cmp	r3, #8
   829d8:	d006      	beq.n	829e8 <UOTGHS_Handler+0xa8>
		udd_ctrl_stall_data();
   829da:	4b80      	ldr	r3, [pc, #512]	; (82bdc <UOTGHS_Handler+0x29c>)
   829dc:	4798      	blx	r3
		udd_ack_setup_received(0);
   829de:	2204      	movs	r2, #4
   829e0:	4b7f      	ldr	r3, [pc, #508]	; (82be0 <UOTGHS_Handler+0x2a0>)
   829e2:	601a      	str	r2, [r3, #0]
   829e4:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}

		// Reinitializes control endpoint management
		udd_ctrl_init();
	}
	// Fill setup request structure
	if (8 != udd_byte_count(0)) {
   829e8:	4b7e      	ldr	r3, [pc, #504]	; (82be4 <UOTGHS_Handler+0x2a4>)
   829ea:	4d7f      	ldr	r5, [pc, #508]	; (82be8 <UOTGHS_Handler+0x2a8>)
   829ec:	4c7f      	ldr	r4, [pc, #508]	; (82bec <UOTGHS_Handler+0x2ac>)
		udd_ctrl_stall_data();
		udd_ack_setup_received(0);
		return; // Error data number doesn't correspond to SETUP packet
	}
	uint8_t *ptr = (uint8_t *) & udd_get_endpoint_fifo_access(0,8);
	for (i = 0; i < 8; i++) {
   829ee:	4880      	ldr	r0, [pc, #512]	; (82bf0 <UOTGHS_Handler+0x2b0>)
		((uint8_t*) &udd_g_ctrlreq.req)[i] = *ptr++;
   829f0:	f813 1b01 	ldrb.w	r1, [r3], #1
   829f4:	195a      	adds	r2, r3, r5
   829f6:	5511      	strb	r1, [r2, r4]
		udd_ctrl_stall_data();
		udd_ack_setup_received(0);
		return; // Error data number doesn't correspond to SETUP packet
	}
	uint8_t *ptr = (uint8_t *) & udd_get_endpoint_fifo_access(0,8);
	for (i = 0; i < 8; i++) {
   829f8:	4283      	cmp	r3, r0
   829fa:	d1f9      	bne.n	829f0 <UOTGHS_Handler+0xb0>
	udd_g_ctrlreq.req.wValue = le16_to_cpu(udd_g_ctrlreq.req.wValue);
	udd_g_ctrlreq.req.wIndex = le16_to_cpu(udd_g_ctrlreq.req.wIndex);
	udd_g_ctrlreq.req.wLength = le16_to_cpu(udd_g_ctrlreq.req.wLength);

	// Decode setup request
	if (udc_process_setup() == false) {
   829fc:	4b7d      	ldr	r3, [pc, #500]	; (82bf4 <UOTGHS_Handler+0x2b4>)
   829fe:	4798      	blx	r3
   82a00:	b930      	cbnz	r0, 82a10 <UOTGHS_Handler+0xd0>
		// Setup request unknow then stall it
		udd_ctrl_stall_data();
   82a02:	4b76      	ldr	r3, [pc, #472]	; (82bdc <UOTGHS_Handler+0x29c>)
   82a04:	4798      	blx	r3
		udd_ack_setup_received(0);
   82a06:	2204      	movs	r2, #4
   82a08:	4b75      	ldr	r3, [pc, #468]	; (82be0 <UOTGHS_Handler+0x2a0>)
   82a0a:	601a      	str	r2, [r3, #0]
   82a0c:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
		return;
	}
	udd_ack_setup_received(0);
   82a10:	2204      	movs	r2, #4
   82a12:	4b73      	ldr	r3, [pc, #460]	; (82be0 <UOTGHS_Handler+0x2a0>)
   82a14:	601a      	str	r2, [r3, #0]

	if (Udd_setup_is_in()) {
   82a16:	4b74      	ldr	r3, [pc, #464]	; (82be8 <UOTGHS_Handler+0x2a8>)
   82a18:	f993 3000 	ldrsb.w	r3, [r3]
   82a1c:	2b00      	cmp	r3, #0
   82a1e:	da0b      	bge.n	82a38 <UOTGHS_Handler+0xf8>
		// IN data phase requested
		udd_ctrl_prev_payload_buf_cnt = 0;
   82a20:	2300      	movs	r3, #0
   82a22:	4a75      	ldr	r2, [pc, #468]	; (82bf8 <UOTGHS_Handler+0x2b8>)
   82a24:	8013      	strh	r3, [r2, #0]
		udd_ctrl_payload_buf_cnt = 0;
   82a26:	4a75      	ldr	r2, [pc, #468]	; (82bfc <UOTGHS_Handler+0x2bc>)
   82a28:	8013      	strh	r3, [r2, #0]
		udd_ep_control_state = UDD_EPCTRL_DATA_IN;
   82a2a:	2202      	movs	r2, #2
   82a2c:	4b67      	ldr	r3, [pc, #412]	; (82bcc <UOTGHS_Handler+0x28c>)
   82a2e:	701a      	strb	r2, [r3, #0]
		udd_ctrl_in_sent(); // Send first data transfer
   82a30:	4b73      	ldr	r3, [pc, #460]	; (82c00 <UOTGHS_Handler+0x2c0>)
   82a32:	4798      	blx	r3
   82a34:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
	} else {
		if (0 == udd_g_ctrlreq.req.wLength) {
   82a38:	4b6b      	ldr	r3, [pc, #428]	; (82be8 <UOTGHS_Handler+0x2a8>)
   82a3a:	88db      	ldrh	r3, [r3, #6]
   82a3c:	b91b      	cbnz	r3, 82a46 <UOTGHS_Handler+0x106>
			// No data phase requested
			// Send IN ZLP to ACK setup request
			udd_ctrl_send_zlp_in();
   82a3e:	4b71      	ldr	r3, [pc, #452]	; (82c04 <UOTGHS_Handler+0x2c4>)
   82a40:	4798      	blx	r3
   82a42:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
			return;
		}
		// OUT data phase requested
		udd_ctrl_prev_payload_buf_cnt = 0;
   82a46:	2300      	movs	r3, #0
   82a48:	4a6b      	ldr	r2, [pc, #428]	; (82bf8 <UOTGHS_Handler+0x2b8>)
   82a4a:	8013      	strh	r3, [r2, #0]
		udd_ctrl_payload_buf_cnt = 0;
   82a4c:	4a6b      	ldr	r2, [pc, #428]	; (82bfc <UOTGHS_Handler+0x2bc>)
   82a4e:	8013      	strh	r3, [r2, #0]
		udd_ep_control_state = UDD_EPCTRL_DATA_OUT;
   82a50:	2101      	movs	r1, #1
   82a52:	4a5e      	ldr	r2, [pc, #376]	; (82bcc <UOTGHS_Handler+0x28c>)
   82a54:	7011      	strb	r1, [r2, #0]
		// To detect a protocol error, enable nak interrupt on data IN phase
		udd_ack_nak_in(0);
   82a56:	2210      	movs	r2, #16
   82a58:	4961      	ldr	r1, [pc, #388]	; (82be0 <UOTGHS_Handler+0x2a0>)
   82a5a:	600a      	str	r2, [r1, #0]
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_PRIMASK(void)
{
  uint32_t result;

  __ASM volatile ("MRS %0, primask" : "=r" (result) );
   82a5c:	f3ef 8110 	mrs	r1, PRIMASK
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
   82a60:	b672      	cpsid	i
   82a62:	f3bf 8f5f 	dmb	sy
static volatile bool     cpu_irq_prev_interrupt_state;

static inline irqflags_t cpu_irq_save(void)
{
	irqflags_t flags = cpu_irq_is_enabled();
	cpu_irq_disable();
   82a66:	4856      	ldr	r0, [pc, #344]	; (82bc0 <UOTGHS_Handler+0x280>)
   82a68:	7003      	strb	r3, [r0, #0]
		flags = cpu_irq_save();
		udd_enable_nak_in_interrupt(0);
   82a6a:	4b67      	ldr	r3, [pc, #412]	; (82c08 <UOTGHS_Handler+0x2c8>)
   82a6c:	601a      	str	r2, [r3, #0]
	return (flags);
}

static inline void cpu_irq_restore(irqflags_t flags)
{
	if (cpu_irq_is_enabled_flags(flags))
   82a6e:	2900      	cmp	r1, #0
   82a70:	f040 8267 	bne.w	82f42 <UOTGHS_Handler+0x602>
		cpu_irq_enable();
   82a74:	2201      	movs	r2, #1
   82a76:	7002      	strb	r2, [r0, #0]
   82a78:	f3bf 8f5f 	dmb	sy
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
   82a7c:	b662      	cpsie	i
   82a7e:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
		dbg_print("stup ");
		// SETUP packet received
		udd_ctrl_setup_received();
		return true;
	}
	if (Is_udd_in_send(0) && Is_udd_in_send_interrupt_enabled(0)) {
   82a82:	4b55      	ldr	r3, [pc, #340]	; (82bd8 <UOTGHS_Handler+0x298>)
   82a84:	681b      	ldr	r3, [r3, #0]
   82a86:	f013 0f01 	tst.w	r3, #1
   82a8a:	d008      	beq.n	82a9e <UOTGHS_Handler+0x15e>
   82a8c:	4b5f      	ldr	r3, [pc, #380]	; (82c0c <UOTGHS_Handler+0x2cc>)
   82a8e:	681b      	ldr	r3, [r3, #0]
   82a90:	f013 0f01 	tst.w	r3, #1
   82a94:	d003      	beq.n	82a9e <UOTGHS_Handler+0x15e>
		dbg_print("in ");
		// IN packet sent
		udd_ctrl_in_sent();
   82a96:	4b5a      	ldr	r3, [pc, #360]	; (82c00 <UOTGHS_Handler+0x2c0>)
   82a98:	4798      	blx	r3
   82a9a:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
		return true;
	}
	if (Is_udd_out_received(0)) {
   82a9e:	4b4e      	ldr	r3, [pc, #312]	; (82bd8 <UOTGHS_Handler+0x298>)
   82aa0:	681b      	ldr	r3, [r3, #0]
   82aa2:	f013 0f02 	tst.w	r3, #2
   82aa6:	f000 80b3 	beq.w	82c10 <UOTGHS_Handler+0x2d0>
{
	irqflags_t flags;
	uint8_t i;
	uint16_t nb_data;

	if (UDD_EPCTRL_DATA_OUT != udd_ep_control_state) {
   82aaa:	4b48      	ldr	r3, [pc, #288]	; (82bcc <UOTGHS_Handler+0x28c>)
   82aac:	781b      	ldrb	r3, [r3, #0]
   82aae:	2b01      	cmp	r3, #1
   82ab0:	d00c      	beq.n	82acc <UOTGHS_Handler+0x18c>
		if ((UDD_EPCTRL_DATA_IN == udd_ep_control_state)
   82ab2:	2b02      	cmp	r3, #2
   82ab4:	d001      	beq.n	82aba <UOTGHS_Handler+0x17a>
				|| (UDD_EPCTRL_HANDSHAKE_WAIT_OUT_ZLP ==
   82ab6:	2b04      	cmp	r3, #4
   82ab8:	d102      	bne.n	82ac0 <UOTGHS_Handler+0x180>
						udd_ep_control_state)) {
			// End of SETUP request:
			// - Data IN Phase aborted,
			// - or last Data IN Phase hidden by ZLP OUT sending quiclky,
			// - or ZLP OUT received normaly.
			udd_ctrl_endofrequest();
   82aba:	4b45      	ldr	r3, [pc, #276]	; (82bd0 <UOTGHS_Handler+0x290>)
   82abc:	4798      	blx	r3
   82abe:	e001      	b.n	82ac4 <UOTGHS_Handler+0x184>
		} else {
			// Protocol error during SETUP request
			udd_ctrl_stall_data();
   82ac0:	4b46      	ldr	r3, [pc, #280]	; (82bdc <UOTGHS_Handler+0x29c>)
   82ac2:	4798      	blx	r3
		}
		// Reinitializes control endpoint management
		udd_ctrl_init();
   82ac4:	4b43      	ldr	r3, [pc, #268]	; (82bd4 <UOTGHS_Handler+0x294>)
   82ac6:	4798      	blx	r3
   82ac8:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
		return;
	}
	// Read data received during OUT phase
	nb_data = udd_byte_count(0);
   82acc:	4b42      	ldr	r3, [pc, #264]	; (82bd8 <UOTGHS_Handler+0x298>)
   82ace:	6818      	ldr	r0, [r3, #0]
   82ad0:	f3c0 500a 	ubfx	r0, r0, #20, #11
	if (udd_g_ctrlreq.payload_size < (udd_ctrl_payload_buf_cnt + nb_data)) {
   82ad4:	4b44      	ldr	r3, [pc, #272]	; (82be8 <UOTGHS_Handler+0x2a8>)
   82ad6:	899b      	ldrh	r3, [r3, #12]
   82ad8:	4a48      	ldr	r2, [pc, #288]	; (82bfc <UOTGHS_Handler+0x2bc>)
   82ada:	8814      	ldrh	r4, [r2, #0]
   82adc:	1822      	adds	r2, r4, r0
   82ade:	4293      	cmp	r3, r2
		// Reinitializes control endpoint management
		udd_ctrl_init();
		return;
	}
	// Read data received during OUT phase
	nb_data = udd_byte_count(0);
   82ae0:	bfae      	itee	ge
   82ae2:	b280      	uxthge	r0, r0
	if (udd_g_ctrlreq.payload_size < (udd_ctrl_payload_buf_cnt + nb_data)) {
		// Payload buffer too small
		nb_data = udd_g_ctrlreq.payload_size - udd_ctrl_payload_buf_cnt;
   82ae4:	ebc4 0303 	rsblt	r3, r4, r3
   82ae8:	b298      	uxthlt	r0, r3
	}
	uint8_t *ptr_src = (uint8_t *) & udd_get_endpoint_fifo_access(0, 8);
	uint8_t *ptr_dest = udd_g_ctrlreq.payload + udd_ctrl_payload_buf_cnt;
   82aea:	4b3f      	ldr	r3, [pc, #252]	; (82be8 <UOTGHS_Handler+0x2a8>)
   82aec:	689a      	ldr	r2, [r3, #8]
   82aee:	4422      	add	r2, r4
	for (i = 0; i < nb_data; i++) {
   82af0:	b1a0      	cbz	r0, 82b1c <UOTGHS_Handler+0x1dc>
	nb_data = udd_byte_count(0);
	if (udd_g_ctrlreq.payload_size < (udd_ctrl_payload_buf_cnt + nb_data)) {
		// Payload buffer too small
		nb_data = udd_g_ctrlreq.payload_size - udd_ctrl_payload_buf_cnt;
	}
	uint8_t *ptr_src = (uint8_t *) & udd_get_endpoint_fifo_access(0, 8);
   82af2:	4b3c      	ldr	r3, [pc, #240]	; (82be4 <UOTGHS_Handler+0x2a4>)
	uint8_t *ptr_dest = udd_g_ctrlreq.payload + udd_ctrl_payload_buf_cnt;
	for (i = 0; i < nb_data; i++) {
		*ptr_dest++ = *ptr_src++;
   82af4:	f813 1b01 	ldrb.w	r1, [r3], #1
   82af8:	f802 1b01 	strb.w	r1, [r2], #1
		// Payload buffer too small
		nb_data = udd_g_ctrlreq.payload_size - udd_ctrl_payload_buf_cnt;
	}
	uint8_t *ptr_src = (uint8_t *) & udd_get_endpoint_fifo_access(0, 8);
	uint8_t *ptr_dest = udd_g_ctrlreq.payload + udd_ctrl_payload_buf_cnt;
	for (i = 0; i < nb_data; i++) {
   82afc:	b2d9      	uxtb	r1, r3
   82afe:	4281      	cmp	r1, r0
   82b00:	d3f8      	bcc.n	82af4 <UOTGHS_Handler+0x1b4>
		*ptr_dest++ = *ptr_src++;
	}
	udd_ctrl_payload_buf_cnt += nb_data;
   82b02:	4404      	add	r4, r0
   82b04:	b2a4      	uxth	r4, r4
   82b06:	4b3d      	ldr	r3, [pc, #244]	; (82bfc <UOTGHS_Handler+0x2bc>)
   82b08:	801c      	strh	r4, [r3, #0]

	if ((USB_DEVICE_EP_CTRL_SIZE != nb_data)
   82b0a:	2840      	cmp	r0, #64	; 0x40
   82b0c:	d106      	bne.n	82b1c <UOTGHS_Handler+0x1dc>
			|| (udd_g_ctrlreq.req.wLength <=
   82b0e:	4b36      	ldr	r3, [pc, #216]	; (82be8 <UOTGHS_Handler+0x2a8>)
   82b10:	88da      	ldrh	r2, [r3, #6]
					(udd_ctrl_prev_payload_buf_cnt +
   82b12:	4b39      	ldr	r3, [pc, #228]	; (82bf8 <UOTGHS_Handler+0x2b8>)
   82b14:	881b      	ldrh	r3, [r3, #0]
   82b16:	4423      	add	r3, r4
		*ptr_dest++ = *ptr_src++;
	}
	udd_ctrl_payload_buf_cnt += nb_data;

	if ((USB_DEVICE_EP_CTRL_SIZE != nb_data)
			|| (udd_g_ctrlreq.req.wLength <=
   82b18:	429a      	cmp	r2, r3
   82b1a:	dc13      	bgt.n	82b44 <UOTGHS_Handler+0x204>
					(udd_ctrl_prev_payload_buf_cnt +
							udd_ctrl_payload_buf_cnt))) {
		// End of reception because it is a short packet
		// Before send ZLP, call intermediat calback
		// in case of data receiv generate a stall
		udd_g_ctrlreq.payload_size = udd_ctrl_payload_buf_cnt;
   82b1c:	4b32      	ldr	r3, [pc, #200]	; (82be8 <UOTGHS_Handler+0x2a8>)
   82b1e:	819c      	strh	r4, [r3, #12]
		if (NULL != udd_g_ctrlreq.over_under_run) {
   82b20:	695b      	ldr	r3, [r3, #20]
   82b22:	b143      	cbz	r3, 82b36 <UOTGHS_Handler+0x1f6>
			if (!udd_g_ctrlreq.over_under_run()) {
   82b24:	4798      	blx	r3
   82b26:	b930      	cbnz	r0, 82b36 <UOTGHS_Handler+0x1f6>
				// Stall ZLP
				udd_ctrl_stall_data();
   82b28:	4b2c      	ldr	r3, [pc, #176]	; (82bdc <UOTGHS_Handler+0x29c>)
   82b2a:	4798      	blx	r3
				// Ack reception of OUT to replace NAK by a STALL
				udd_ack_out_received(0);
   82b2c:	2202      	movs	r2, #2
   82b2e:	4b2c      	ldr	r3, [pc, #176]	; (82be0 <UOTGHS_Handler+0x2a0>)
   82b30:	601a      	str	r2, [r3, #0]
   82b32:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
				return;
			}
		}
		// Send IN ZLP to ACK setup request
		udd_ack_out_received(0);
   82b36:	2202      	movs	r2, #2
   82b38:	4b29      	ldr	r3, [pc, #164]	; (82be0 <UOTGHS_Handler+0x2a0>)
   82b3a:	601a      	str	r2, [r3, #0]
		udd_ctrl_send_zlp_in();
   82b3c:	4b31      	ldr	r3, [pc, #196]	; (82c04 <UOTGHS_Handler+0x2c4>)
   82b3e:	4798      	blx	r3
   82b40:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
		return;
	}

	if (udd_g_ctrlreq.payload_size == udd_ctrl_payload_buf_cnt) {
   82b44:	4b28      	ldr	r3, [pc, #160]	; (82be8 <UOTGHS_Handler+0x2a8>)
   82b46:	899b      	ldrh	r3, [r3, #12]
   82b48:	42a3      	cmp	r3, r4
   82b4a:	d11a      	bne.n	82b82 <UOTGHS_Handler+0x242>
		// Overrun then request a new payload buffer
		if (!udd_g_ctrlreq.over_under_run) {
   82b4c:	4b26      	ldr	r3, [pc, #152]	; (82be8 <UOTGHS_Handler+0x2a8>)
   82b4e:	695b      	ldr	r3, [r3, #20]
   82b50:	b933      	cbnz	r3, 82b60 <UOTGHS_Handler+0x220>
			// No callback availabled to request a new payload buffer
			udd_ctrl_stall_data();
   82b52:	4b22      	ldr	r3, [pc, #136]	; (82bdc <UOTGHS_Handler+0x29c>)
   82b54:	4798      	blx	r3
			// Ack reception of OUT to replace NAK by a STALL
			udd_ack_out_received(0);
   82b56:	2202      	movs	r2, #2
   82b58:	4b21      	ldr	r3, [pc, #132]	; (82be0 <UOTGHS_Handler+0x2a0>)
   82b5a:	601a      	str	r2, [r3, #0]
   82b5c:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
			return;
		}
		if (!udd_g_ctrlreq.over_under_run()) {
   82b60:	4798      	blx	r3
   82b62:	b930      	cbnz	r0, 82b72 <UOTGHS_Handler+0x232>
			// No new payload buffer delivered
			udd_ctrl_stall_data();
   82b64:	4b1d      	ldr	r3, [pc, #116]	; (82bdc <UOTGHS_Handler+0x29c>)
   82b66:	4798      	blx	r3
			// Ack reception of OUT to replace NAK by a STALL
			udd_ack_out_received(0);
   82b68:	2202      	movs	r2, #2
   82b6a:	4b1d      	ldr	r3, [pc, #116]	; (82be0 <UOTGHS_Handler+0x2a0>)
   82b6c:	601a      	str	r2, [r3, #0]
   82b6e:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
			return;
		}
		// New payload buffer available
		// Update number of total data received
		udd_ctrl_prev_payload_buf_cnt += udd_ctrl_payload_buf_cnt;
   82b72:	4a21      	ldr	r2, [pc, #132]	; (82bf8 <UOTGHS_Handler+0x2b8>)
   82b74:	4b21      	ldr	r3, [pc, #132]	; (82bfc <UOTGHS_Handler+0x2bc>)
   82b76:	8818      	ldrh	r0, [r3, #0]
   82b78:	8811      	ldrh	r1, [r2, #0]
   82b7a:	4401      	add	r1, r0
   82b7c:	8011      	strh	r1, [r2, #0]
		// Reinit reception on payload buffer
		udd_ctrl_payload_buf_cnt = 0;
   82b7e:	2200      	movs	r2, #0
   82b80:	801a      	strh	r2, [r3, #0]
	}
	// Free buffer of control endpoint to authorize next reception
	udd_ack_out_received(0);
   82b82:	4a17      	ldr	r2, [pc, #92]	; (82be0 <UOTGHS_Handler+0x2a0>)
   82b84:	2302      	movs	r3, #2
   82b86:	6013      	str	r3, [r2, #0]
	// To detect a protocol error, enable nak interrupt on data IN phase
	udd_ack_nak_in(0);
   82b88:	2310      	movs	r3, #16
   82b8a:	6013      	str	r3, [r2, #0]
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_PRIMASK(void)
{
  uint32_t result;

  __ASM volatile ("MRS %0, primask" : "=r" (result) );
   82b8c:	f3ef 8210 	mrs	r2, PRIMASK
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
   82b90:	b672      	cpsid	i
   82b92:	f3bf 8f5f 	dmb	sy
static volatile bool     cpu_irq_prev_interrupt_state;

static inline irqflags_t cpu_irq_save(void)
{
	irqflags_t flags = cpu_irq_is_enabled();
	cpu_irq_disable();
   82b96:	2000      	movs	r0, #0
   82b98:	4909      	ldr	r1, [pc, #36]	; (82bc0 <UOTGHS_Handler+0x280>)
   82b9a:	7008      	strb	r0, [r1, #0]
	flags = cpu_irq_save();
	udd_enable_nak_in_interrupt(0);
   82b9c:	491a      	ldr	r1, [pc, #104]	; (82c08 <UOTGHS_Handler+0x2c8>)
   82b9e:	600b      	str	r3, [r1, #0]
	return (flags);
}

static inline void cpu_irq_restore(irqflags_t flags)
{
	if (cpu_irq_is_enabled_flags(flags))
   82ba0:	2a00      	cmp	r2, #0
   82ba2:	f040 81ce 	bne.w	82f42 <UOTGHS_Handler+0x602>
		cpu_irq_enable();
   82ba6:	2201      	movs	r2, #1
   82ba8:	4b05      	ldr	r3, [pc, #20]	; (82bc0 <UOTGHS_Handler+0x280>)
   82baa:	701a      	strb	r2, [r3, #0]
   82bac:	f3bf 8f5f 	dmb	sy
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
   82bb0:	b662      	cpsie	i
   82bb2:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
   82bb6:	bf00      	nop
   82bb8:	00082295 	.word	0x00082295
   82bbc:	400ac000 	.word	0x400ac000
   82bc0:	20070270 	.word	0x20070270
   82bc4:	000817e1 	.word	0x000817e1
   82bc8:	400ac220 	.word	0x400ac220
   82bcc:	20071704 	.word	0x20071704
   82bd0:	00082379 	.word	0x00082379
   82bd4:	000822cd 	.word	0x000822cd
   82bd8:	400ac130 	.word	0x400ac130
   82bdc:	00082319 	.word	0x00082319
   82be0:	400ac160 	.word	0x400ac160
   82be4:	20180000 	.word	0x20180000
   82be8:	20075c44 	.word	0x20075c44
   82bec:	dfe7ffff 	.word	0xdfe7ffff
   82bf0:	20180008 	.word	0x20180008
   82bf4:	0008181d 	.word	0x0008181d
   82bf8:	200716b8 	.word	0x200716b8
   82bfc:	20071706 	.word	0x20071706
   82c00:	00082389 	.word	0x00082389
   82c04:	00082331 	.word	0x00082331
   82c08:	400ac1f0 	.word	0x400ac1f0
   82c0c:	400ac1c0 	.word	0x400ac1c0
		dbg_print("out ");
		// OUT packet received
		udd_ctrl_out_received();
		return true;
	}
	if (Is_udd_nak_out(0)) {
   82c10:	4bb4      	ldr	r3, [pc, #720]	; (82ee4 <UOTGHS_Handler+0x5a4>)
   82c12:	681b      	ldr	r3, [r3, #0]
   82c14:	f013 0f08 	tst.w	r3, #8
   82c18:	d013      	beq.n	82c42 <UOTGHS_Handler+0x302>
		dbg_print("nako ");
		// Overflow on OUT packet
		udd_ack_nak_out(0);
   82c1a:	2208      	movs	r2, #8
   82c1c:	4bb2      	ldr	r3, [pc, #712]	; (82ee8 <UOTGHS_Handler+0x5a8>)
   82c1e:	601a      	str	r2, [r3, #0]
}


static void udd_ctrl_overflow(void)
{
	if (Is_udd_in_send(0))
   82c20:	3b30      	subs	r3, #48	; 0x30
   82c22:	681b      	ldr	r3, [r3, #0]
   82c24:	f013 0f01 	tst.w	r3, #1
   82c28:	f040 818b 	bne.w	82f42 <UOTGHS_Handler+0x602>
		return; // Overflow ignored if IN data is received

	// The case of UDD_EPCTRL_DATA_IN is not managed
	// because the OUT endpoint is already free and OUT ZLP accepted

	if (UDD_EPCTRL_HANDSHAKE_WAIT_IN_ZLP == udd_ep_control_state) {
   82c2c:	4baf      	ldr	r3, [pc, #700]	; (82eec <UOTGHS_Handler+0x5ac>)
   82c2e:	781b      	ldrb	r3, [r3, #0]
   82c30:	2b03      	cmp	r3, #3
   82c32:	f040 8186 	bne.w	82f42 <UOTGHS_Handler+0x602>
		// A IN handshake is waiting by device,
		// but host want extra OUT data then stall extra OUT data
		udd_enable_stall_handshake(0);
   82c36:	f44f 2200 	mov.w	r2, #524288	; 0x80000
   82c3a:	4bad      	ldr	r3, [pc, #692]	; (82ef0 <UOTGHS_Handler+0x5b0>)
   82c3c:	601a      	str	r2, [r3, #0]
   82c3e:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
		// Overflow on OUT packet
		udd_ack_nak_out(0);
		udd_ctrl_overflow();
		return true;
	}
	if (Is_udd_nak_in(0)) {
   82c42:	4ba8      	ldr	r3, [pc, #672]	; (82ee4 <UOTGHS_Handler+0x5a4>)
   82c44:	681b      	ldr	r3, [r3, #0]
   82c46:	f013 0f10 	tst.w	r3, #16
   82c4a:	f000 8141 	beq.w	82ed0 <UOTGHS_Handler+0x590>
		dbg_print("naki ");
		// Underflow on IN packet
		udd_ack_nak_in(0);
   82c4e:	2210      	movs	r2, #16
   82c50:	4ba5      	ldr	r3, [pc, #660]	; (82ee8 <UOTGHS_Handler+0x5a8>)
   82c52:	601a      	str	r2, [r3, #0]
}


static void udd_ctrl_underflow(void)
{
	if (Is_udd_out_received(0))
   82c54:	3b30      	subs	r3, #48	; 0x30
   82c56:	681b      	ldr	r3, [r3, #0]
   82c58:	f013 0f02 	tst.w	r3, #2
   82c5c:	f040 8171 	bne.w	82f42 <UOTGHS_Handler+0x602>
		return; // Underflow ignored if OUT data is received

	if (UDD_EPCTRL_DATA_OUT == udd_ep_control_state) {
   82c60:	4ba2      	ldr	r3, [pc, #648]	; (82eec <UOTGHS_Handler+0x5ac>)
   82c62:	781b      	ldrb	r3, [r3, #0]
   82c64:	2b01      	cmp	r3, #1
   82c66:	d103      	bne.n	82c70 <UOTGHS_Handler+0x330>
		// Host want to stop OUT transaction
		// then stop to wait OUT data phase and wait IN ZLP handshake
		udd_ctrl_send_zlp_in();
   82c68:	4ba2      	ldr	r3, [pc, #648]	; (82ef4 <UOTGHS_Handler+0x5b4>)
   82c6a:	4798      	blx	r3
   82c6c:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
	} else if (UDD_EPCTRL_HANDSHAKE_WAIT_OUT_ZLP == udd_ep_control_state) {
   82c70:	2b04      	cmp	r3, #4
   82c72:	f040 8166 	bne.w	82f42 <UOTGHS_Handler+0x602>
		// A OUT handshake is waiting by device,
		// but host want extra IN data then stall extra IN data
		udd_enable_stall_handshake(0);
   82c76:	f44f 2200 	mov.w	r2, #524288	; 0x80000
   82c7a:	4b9d      	ldr	r3, [pc, #628]	; (82ef0 <UOTGHS_Handler+0x5b0>)
   82c7c:	601a      	str	r2, [r3, #0]
   82c7e:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
   82c82:	b2da      	uxtb	r2, r3
	udd_ep_job_t *ptr_job;

	// For each endpoint different of control endpoint (0)
	for (ep = 1; ep <= USB_DEVICE_MAX_EP; ep++) {
		// Get job corresponding at endpoint
		ptr_job = &udd_ep_job[ep - 1];
   82c84:	469c      	mov	ip, r3
   82c86:	46a2      	mov	sl, r4

#ifdef UDD_EP_DMA_SUPPORTED
		// Check DMA event
		if (Is_udd_endpoint_dma_interrupt_enabled(ep)
   82c88:	692f      	ldr	r7, [r5, #16]
   82c8a:	1e5e      	subs	r6, r3, #1
   82c8c:	fa08 f606 	lsl.w	r6, r8, r6
   82c90:	423e      	tst	r6, r7
   82c92:	d018      	beq.n	82cc6 <UOTGHS_Handler+0x386>
				&& Is_udd_endpoint_dma_interrupt(ep)) {
   82c94:	686f      	ldr	r7, [r5, #4]
   82c96:	423e      	tst	r6, r7
   82c98:	d015      	beq.n	82cc6 <UOTGHS_Handler+0x386>
			uint32_t nb_remaining;
			if (udd_endpoint_dma_get_status(ep)
   82c9a:	4b97      	ldr	r3, [pc, #604]	; (82ef8 <UOTGHS_Handler+0x5b8>)
   82c9c:	eb03 1302 	add.w	r3, r3, r2, lsl #4
   82ca0:	68d9      	ldr	r1, [r3, #12]
   82ca2:	f011 0f01 	tst.w	r1, #1
   82ca6:	f040 814c 	bne.w	82f42 <UOTGHS_Handler+0x602>
					& UOTGHS_DEVDMASTATUS_CHANN_ENB) {
				return true; // Ignore EOT_STA interrupt
			}
			dbg_print("dma%x: ", ep);
			udd_disable_endpoint_dma_interrupt(ep);
   82caa:	4994      	ldr	r1, [pc, #592]	; (82efc <UOTGHS_Handler+0x5bc>)
   82cac:	614e      	str	r6, [r1, #20]
			// Save number of data no transfered
			nb_remaining = (udd_endpoint_dma_get_status(ep) &
   82cae:	68db      	ldr	r3, [r3, #12]
					UOTGHS_DEVDMASTATUS_BUFF_COUNT_Msk)
					>> UOTGHS_DEVDMASTATUS_BUFF_COUNT_Pos;
			if (nb_remaining) {
   82cb0:	0c1b      	lsrs	r3, r3, #16
   82cb2:	d003      	beq.n	82cbc <UOTGHS_Handler+0x37c>
				// Transfer no complete (short packet or ZLP) then:
				// Update number of data transfered
				ptr_job->buf_cnt -= nb_remaining;
   82cb4:	68e1      	ldr	r1, [r4, #12]
   82cb6:	1acb      	subs	r3, r1, r3
   82cb8:	60e3      	str	r3, [r4, #12]
				// Set transfer complete to stop the transfer
				ptr_job->buf_size = ptr_job->buf_cnt;
   82cba:	60a3      	str	r3, [r4, #8]
			}
			udd_ep_trans_done(ep);
   82cbc:	4610      	mov	r0, r2
   82cbe:	4b90      	ldr	r3, [pc, #576]	; (82f00 <UOTGHS_Handler+0x5c0>)
   82cc0:	4798      	blx	r3
   82cc2:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
				return true;
			}
		}
#endif // UDD_EP_FIFO_SUPPORTED
		// Check empty bank interrupt event
		if (Is_udd_endpoint_interrupt_enabled(ep)) {
   82cc6:	692e      	ldr	r6, [r5, #16]
   82cc8:	fa09 fc0c 	lsl.w	ip, r9, ip
   82ccc:	ea1c 0f06 	tst.w	ip, r6
   82cd0:	d046      	beq.n	82d60 <UOTGHS_Handler+0x420>
   82cd2:	ea4f 0b83 	mov.w	fp, r3, lsl #2
   82cd6:	f101 0790 	add.w	r7, r1, #144	; 0x90
			dbg_print("bg%x: ", ep);
			if (Is_udd_in_send_interrupt_enabled(ep)
   82cda:	f8d1 6090 	ldr.w	r6, [r1, #144]	; 0x90
   82cde:	f016 0f01 	tst.w	r6, #1
   82ce2:	d014      	beq.n	82d0e <UOTGHS_Handler+0x3ce>
					&& Is_udd_in_send(ep)) {
   82ce4:	680e      	ldr	r6, [r1, #0]
   82ce6:	f016 0f01 	tst.w	r6, #1
   82cea:	d010      	beq.n	82d0e <UOTGHS_Handler+0x3ce>
				dbg_print("I ");
				udd_disable_in_send_interrupt(ep);
   82cec:	4b85      	ldr	r3, [pc, #532]	; (82f04 <UOTGHS_Handler+0x5c4>)
   82cee:	2101      	movs	r1, #1
   82cf0:	f84b 1003 	str.w	r1, [fp, r3]
				// One bank is free then send a ZLP
				udd_ack_in_send(ep);
   82cf4:	487c      	ldr	r0, [pc, #496]	; (82ee8 <UOTGHS_Handler+0x5a8>)
   82cf6:	f84b 1000 	str.w	r1, [fp, r0]
				udd_ack_fifocon(ep);
   82cfa:	f44f 4180 	mov.w	r1, #16384	; 0x4000
   82cfe:	f84b 1003 	str.w	r1, [fp, r3]
				udd_ep_finish_job(ptr_job, false, ep);
   82d02:	4650      	mov	r0, sl
   82d04:	2100      	movs	r1, #0
   82d06:	4b80      	ldr	r3, [pc, #512]	; (82f08 <UOTGHS_Handler+0x5c8>)
   82d08:	4798      	blx	r3
   82d0a:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
				return true;
			}
			if (Is_udd_bank_interrupt_enabled(ep)
   82d0e:	683a      	ldr	r2, [r7, #0]
   82d10:	f412 5f80 	tst.w	r2, #4096	; 0x1000
   82d14:	d024      	beq.n	82d60 <UOTGHS_Handler+0x420>
					&& (0 == udd_nb_busy_bank(ep))) {
   82d16:	680a      	ldr	r2, [r1, #0]
   82d18:	f412 5f40 	tst.w	r2, #12288	; 0x3000
   82d1c:	d120      	bne.n	82d60 <UOTGHS_Handler+0x420>
				dbg_print("EoT ");
				// End of background transfer on IN endpoint
				udd_disable_bank_interrupt(ep);
   82d1e:	f44f 5280 	mov.w	r2, #4096	; 0x1000
   82d22:	4b78      	ldr	r3, [pc, #480]	; (82f04 <UOTGHS_Handler+0x5c4>)
   82d24:	f84b 2003 	str.w	r2, [fp, r3]
				udd_disable_endpoint_interrupt(ep);
   82d28:	f5a3 7308 	sub.w	r3, r3, #544	; 0x220
   82d2c:	f8c3 c014 	str.w	ip, [r3, #20]

				Assert(ptr_job->stall_requested);
				// A stall has been requested during backgound transfer
				ptr_job->stall_requested = false;
   82d30:	f89a 3014 	ldrb.w	r3, [sl, #20]
   82d34:	f36f 0382 	bfc	r3, #2, #1
   82d38:	f88a 3014 	strb.w	r3, [sl, #20]
				udd_disable_endpoint_bank_autoswitch(ep);
   82d3c:	4b73      	ldr	r3, [pc, #460]	; (82f0c <UOTGHS_Handler+0x5cc>)
   82d3e:	f85b 2003 	ldr.w	r2, [fp, r3]
   82d42:	f422 7200 	bic.w	r2, r2, #512	; 0x200
   82d46:	f84b 2003 	str.w	r2, [fp, r3]
				udd_enable_stall_handshake(ep);
   82d4a:	33f0      	adds	r3, #240	; 0xf0
   82d4c:	f44f 2200 	mov.w	r2, #524288	; 0x80000
   82d50:	f84b 2003 	str.w	r2, [fp, r3]
				udd_reset_data_toggle(ep);
   82d54:	f44f 2280 	mov.w	r2, #262144	; 0x40000
   82d58:	f84b 2003 	str.w	r2, [fp, r3]
   82d5c:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
   82d60:	3301      	adds	r3, #1
   82d62:	3418      	adds	r4, #24
   82d64:	3104      	adds	r1, #4
{
	udd_ep_id_t ep;
	udd_ep_job_t *ptr_job;

	// For each endpoint different of control endpoint (0)
	for (ep = 1; ep <= USB_DEVICE_MAX_EP; ep++) {
   82d66:	2b04      	cmp	r3, #4
   82d68:	d18b      	bne.n	82c82 <UOTGHS_Handler+0x342>
   82d6a:	e0e3      	b.n	82f34 <UOTGHS_Handler+0x5f4>
	}
#endif

	// USB bus reset detection
	if (Is_udd_reset()) {
		udd_ack_reset();
   82d6c:	2208      	movs	r2, #8
   82d6e:	4b63      	ldr	r3, [pc, #396]	; (82efc <UOTGHS_Handler+0x5bc>)
   82d70:	609a      	str	r2, [r3, #8]
   82d72:	4605      	mov	r5, r0
static void udd_ep_job_table_kill(void)
{
	uint8_t i;

	// For each endpoint, kill job
	for (i = 0; i < USB_DEVICE_MAX_EP; i++) {
   82d74:	2400      	movs	r4, #0
		udd_ep_finish_job(&udd_ep_job[i], true, i + 1);
   82d76:	2701      	movs	r7, #1
   82d78:	4e63      	ldr	r6, [pc, #396]	; (82f08 <UOTGHS_Handler+0x5c8>)
   82d7a:	3401      	adds	r4, #1
   82d7c:	b2e4      	uxtb	r4, r4
   82d7e:	4628      	mov	r0, r5
   82d80:	4639      	mov	r1, r7
   82d82:	4622      	mov	r2, r4
   82d84:	47b0      	blx	r6
   82d86:	3518      	adds	r5, #24
static void udd_ep_job_table_kill(void)
{
	uint8_t i;

	// For each endpoint, kill job
	for (i = 0; i < USB_DEVICE_MAX_EP; i++) {
   82d88:	2c03      	cmp	r4, #3
   82d8a:	d1f6      	bne.n	82d7a <UOTGHS_Handler+0x43a>
		// Abort all jobs on-going
#if (USB_DEVICE_MAX_EP != 0)
		udd_ep_job_table_kill();
#endif
		// Reset USB Device Stack Core
		udc_reset();
   82d8c:	4b60      	ldr	r3, [pc, #384]	; (82f10 <UOTGHS_Handler+0x5d0>)
   82d8e:	4798      	blx	r3
static void udd_reset_ep_ctrl(void)
{
	irqflags_t flags;

	// Reset USB address to 0
	udd_configure_address(0);
   82d90:	4b5a      	ldr	r3, [pc, #360]	; (82efc <UOTGHS_Handler+0x5bc>)
   82d92:	681a      	ldr	r2, [r3, #0]
   82d94:	f022 027f 	bic.w	r2, r2, #127	; 0x7f
   82d98:	601a      	str	r2, [r3, #0]
	udd_enable_address();
   82d9a:	681a      	ldr	r2, [r3, #0]
   82d9c:	f042 0280 	orr.w	r2, r2, #128	; 0x80
   82da0:	601a      	str	r2, [r3, #0]

	// Alloc and configure control endpoint
	udd_configure_endpoint(0,
   82da2:	4a5a      	ldr	r2, [pc, #360]	; (82f0c <UOTGHS_Handler+0x5cc>)
   82da4:	6811      	ldr	r1, [r2, #0]
   82da6:	f421 51cb 	bic.w	r1, r1, #6496	; 0x1960
   82daa:	f021 011c 	bic.w	r1, r1, #28
   82dae:	f041 0130 	orr.w	r1, r1, #48	; 0x30
   82db2:	6011      	str	r1, [r2, #0]
		USB_EP_TYPE_CONTROL,
		0,
		USB_DEVICE_EP_CTRL_SIZE,
		UOTGHS_DEVEPTCFG_EPBK_1_BANK);

	udd_allocate_memory(0);
   82db4:	6811      	ldr	r1, [r2, #0]
   82db6:	f041 0102 	orr.w	r1, r1, #2
   82dba:	6011      	str	r1, [r2, #0]
	udd_enable_endpoint(0);
   82dbc:	69da      	ldr	r2, [r3, #28]
   82dbe:	f042 0201 	orr.w	r2, r2, #1
   82dc2:	61da      	str	r2, [r3, #28]
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_PRIMASK(void)
{
  uint32_t result;

  __ASM volatile ("MRS %0, primask" : "=r" (result) );
   82dc4:	f3ef 8110 	mrs	r1, PRIMASK
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
   82dc8:	b672      	cpsid	i
   82dca:	f3bf 8f5f 	dmb	sy
static volatile bool     cpu_irq_prev_interrupt_state;

static inline irqflags_t cpu_irq_save(void)
{
	irqflags_t flags = cpu_irq_is_enabled();
	cpu_irq_disable();
   82dce:	2000      	movs	r0, #0
   82dd0:	4a50      	ldr	r2, [pc, #320]	; (82f14 <UOTGHS_Handler+0x5d4>)
   82dd2:	7010      	strb	r0, [r2, #0]
	flags = cpu_irq_save();
	udd_enable_setup_received_interrupt(0);
   82dd4:	4a46      	ldr	r2, [pc, #280]	; (82ef0 <UOTGHS_Handler+0x5b0>)
   82dd6:	2004      	movs	r0, #4
   82dd8:	6010      	str	r0, [r2, #0]
	udd_enable_out_received_interrupt(0);
   82dda:	2002      	movs	r0, #2
   82ddc:	6010      	str	r0, [r2, #0]
	udd_enable_endpoint_interrupt(0);
   82dde:	f44f 5280 	mov.w	r2, #4096	; 0x1000
   82de2:	619a      	str	r2, [r3, #24]
	return (flags);
}

static inline void cpu_irq_restore(irqflags_t flags)
{
	if (cpu_irq_is_enabled_flags(flags))
   82de4:	b929      	cbnz	r1, 82df2 <UOTGHS_Handler+0x4b2>
		cpu_irq_enable();
   82de6:	2201      	movs	r2, #1
   82de8:	4b4a      	ldr	r3, [pc, #296]	; (82f14 <UOTGHS_Handler+0x5d4>)
   82dea:	701a      	strb	r2, [r3, #0]
   82dec:	f3bf 8f5f 	dmb	sy
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
   82df0:	b662      	cpsie	i
		// Reset USB Device Stack Core
		udc_reset();
		// Reset endpoint control
		udd_reset_ep_ctrl();
		// Reset endpoint control management
		udd_ctrl_init();
   82df2:	4b49      	ldr	r3, [pc, #292]	; (82f18 <UOTGHS_Handler+0x5d8>)
   82df4:	4798      	blx	r3
		goto udd_interrupt_end;
   82df6:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
	}

	if (Is_udd_suspend_interrupt_enabled() && Is_udd_suspend()) {
   82dfa:	4b40      	ldr	r3, [pc, #256]	; (82efc <UOTGHS_Handler+0x5bc>)
   82dfc:	691b      	ldr	r3, [r3, #16]
   82dfe:	f013 0f01 	tst.w	r3, #1
   82e02:	d01a      	beq.n	82e3a <UOTGHS_Handler+0x4fa>
   82e04:	4b3d      	ldr	r3, [pc, #244]	; (82efc <UOTGHS_Handler+0x5bc>)
   82e06:	685b      	ldr	r3, [r3, #4]
   82e08:	f013 0f01 	tst.w	r3, #1
   82e0c:	d015      	beq.n	82e3a <UOTGHS_Handler+0x4fa>
		otg_unfreeze_clock();
   82e0e:	4b3b      	ldr	r3, [pc, #236]	; (82efc <UOTGHS_Handler+0x5bc>)
   82e10:	f8d3 2800 	ldr.w	r2, [r3, #2048]	; 0x800
   82e14:	f422 4280 	bic.w	r2, r2, #16384	; 0x4000
   82e18:	f8c3 2800 	str.w	r2, [r3, #2048]	; 0x800
		// The suspend interrupt is automatic acked when a wakeup occur
		udd_disable_suspend_interrupt();
   82e1c:	2201      	movs	r2, #1
   82e1e:	615a      	str	r2, [r3, #20]
		udd_enable_wake_up_interrupt();
   82e20:	2210      	movs	r2, #16
   82e22:	619a      	str	r2, [r3, #24]
		otg_freeze_clock(); // Mandatory to exit of sleep mode after a wakeup event
   82e24:	f8d3 2800 	ldr.w	r2, [r3, #2048]	; 0x800
   82e28:	f442 4280 	orr.w	r2, r2, #16384	; 0x4000
   82e2c:	f8c3 2800 	str.w	r2, [r3, #2048]	; 0x800
		udd_sleep_mode(false);  // Enter in SUSPEND mode
   82e30:	2000      	movs	r0, #0
   82e32:	4b3a      	ldr	r3, [pc, #232]	; (82f1c <UOTGHS_Handler+0x5dc>)
   82e34:	4798      	blx	r3
#ifdef UDC_SUSPEND_EVENT
		UDC_SUSPEND_EVENT();
#endif
		goto udd_interrupt_end;
   82e36:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
	}

	if (Is_udd_wake_up_interrupt_enabled() && Is_udd_wake_up()) {
   82e3a:	4b30      	ldr	r3, [pc, #192]	; (82efc <UOTGHS_Handler+0x5bc>)
   82e3c:	691b      	ldr	r3, [r3, #16]
   82e3e:	f013 0f10 	tst.w	r3, #16
   82e42:	d01e      	beq.n	82e82 <UOTGHS_Handler+0x542>
   82e44:	4b2d      	ldr	r3, [pc, #180]	; (82efc <UOTGHS_Handler+0x5bc>)
   82e46:	685b      	ldr	r3, [r3, #4]
   82e48:	f013 0f10 	tst.w	r3, #16
   82e4c:	d019      	beq.n	82e82 <UOTGHS_Handler+0x542>
		// Ack wakeup interrupt and enable suspend interrupt
		otg_unfreeze_clock();
   82e4e:	4b2b      	ldr	r3, [pc, #172]	; (82efc <UOTGHS_Handler+0x5bc>)
   82e50:	f8d3 2800 	ldr.w	r2, [r3, #2048]	; 0x800
   82e54:	f422 4280 	bic.w	r2, r2, #16384	; 0x4000
   82e58:	f8c3 2800 	str.w	r2, [r3, #2048]	; 0x800
		// Check USB clock ready after suspend and eventually sleep USB clock
		while (!Is_otg_clock_usable()) {
   82e5c:	e003      	b.n	82e66 <UOTGHS_Handler+0x526>
			if (Is_udd_suspend()) {
   82e5e:	685a      	ldr	r2, [r3, #4]
   82e60:	f012 0f01 	tst.w	r2, #1
   82e64:	d104      	bne.n	82e70 <UOTGHS_Handler+0x530>

	if (Is_udd_wake_up_interrupt_enabled() && Is_udd_wake_up()) {
		// Ack wakeup interrupt and enable suspend interrupt
		otg_unfreeze_clock();
		// Check USB clock ready after suspend and eventually sleep USB clock
		while (!Is_otg_clock_usable()) {
   82e66:	f8d3 2804 	ldr.w	r2, [r3, #2052]	; 0x804
   82e6a:	f412 4f80 	tst.w	r2, #16384	; 0x4000
   82e6e:	d0f6      	beq.n	82e5e <UOTGHS_Handler+0x51e>
			if (Is_udd_suspend()) {
				break; // In case of USB state change in HS
			}
		};
		// The wakeup interrupt is automatic acked when a suspend occur
		udd_disable_wake_up_interrupt();
   82e70:	4b22      	ldr	r3, [pc, #136]	; (82efc <UOTGHS_Handler+0x5bc>)
   82e72:	2210      	movs	r2, #16
   82e74:	615a      	str	r2, [r3, #20]
		udd_enable_suspend_interrupt();
   82e76:	2001      	movs	r0, #1
   82e78:	6198      	str	r0, [r3, #24]
		udd_sleep_mode(true); // Enter in IDLE mode
   82e7a:	4b28      	ldr	r3, [pc, #160]	; (82f1c <UOTGHS_Handler+0x5dc>)
   82e7c:	4798      	blx	r3
#ifdef UDC_RESUME_EVENT
		UDC_RESUME_EVENT();
#endif
		goto udd_interrupt_end;
   82e7e:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
	}

	if (Is_otg_vbus_transition()) {
   82e82:	4b1e      	ldr	r3, [pc, #120]	; (82efc <UOTGHS_Handler+0x5bc>)
   82e84:	f8d3 3804 	ldr.w	r3, [r3, #2052]	; 0x804
   82e88:	f013 0f02 	tst.w	r3, #2
   82e8c:	d059      	beq.n	82f42 <UOTGHS_Handler+0x602>
		dbg_print("VBus ");
		// Ack Vbus transition and send status to high level
		otg_unfreeze_clock();
   82e8e:	4b1b      	ldr	r3, [pc, #108]	; (82efc <UOTGHS_Handler+0x5bc>)
   82e90:	f8d3 2800 	ldr.w	r2, [r3, #2048]	; 0x800
   82e94:	f422 4280 	bic.w	r2, r2, #16384	; 0x4000
   82e98:	f8c3 2800 	str.w	r2, [r3, #2048]	; 0x800
		otg_ack_vbus_transition();
   82e9c:	2202      	movs	r2, #2
   82e9e:	f8c3 2808 	str.w	r2, [r3, #2056]	; 0x808
		otg_freeze_clock();
   82ea2:	f8d3 2800 	ldr.w	r2, [r3, #2048]	; 0x800
   82ea6:	f442 4280 	orr.w	r2, r2, #16384	; 0x4000
   82eaa:	f8c3 2800 	str.w	r2, [r3, #2048]	; 0x800
#ifndef USB_DEVICE_ATTACH_AUTO_DISABLE
		if (Is_otg_vbus_high()) {
   82eae:	f8d3 3804 	ldr.w	r3, [r3, #2052]	; 0x804
   82eb2:	f413 6f00 	tst.w	r3, #2048	; 0x800
			udd_attach();
   82eb6:	bf14      	ite	ne
   82eb8:	4b19      	ldrne	r3, [pc, #100]	; (82f20 <UOTGHS_Handler+0x5e0>)
		} else {
			udd_detach();
   82eba:	4b1a      	ldreq	r3, [pc, #104]	; (82f24 <UOTGHS_Handler+0x5e4>)
   82ebc:	4798      	blx	r3
		}
#endif
#ifdef UDC_VBUS_EVENT
		UDC_VBUS_EVENT(Is_otg_vbus_high());
   82ebe:	4b0f      	ldr	r3, [pc, #60]	; (82efc <UOTGHS_Handler+0x5bc>)
   82ec0:	f8d3 0804 	ldr.w	r0, [r3, #2052]	; 0x804
   82ec4:	f3c0 20c0 	ubfx	r0, r0, #11, #1
   82ec8:	4b17      	ldr	r3, [pc, #92]	; (82f28 <UOTGHS_Handler+0x5e8>)
   82eca:	4798      	blx	r3
#endif
		goto udd_interrupt_end;
   82ecc:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
   82ed0:	4816      	ldr	r0, [pc, #88]	; (82f2c <UOTGHS_Handler+0x5ec>)
	uint8_t *ptr_src = (uint8_t *) & udd_get_endpoint_fifo_access(0, 8);
	uint8_t *ptr_dest = udd_g_ctrlreq.payload + udd_ctrl_payload_buf_cnt;
	for (i = 0; i < nb_data; i++) {
		*ptr_dest++ = *ptr_src++;
	}
	udd_ctrl_payload_buf_cnt += nb_data;
   82ed2:	4604      	mov	r4, r0
   82ed4:	4916      	ldr	r1, [pc, #88]	; (82f30 <UOTGHS_Handler+0x5f0>)
   82ed6:	2301      	movs	r3, #1
		// Get job corresponding at endpoint
		ptr_job = &udd_ep_job[ep - 1];

#ifdef UDD_EP_DMA_SUPPORTED
		// Check DMA event
		if (Is_udd_endpoint_dma_interrupt_enabled(ep)
   82ed8:	4d08      	ldr	r5, [pc, #32]	; (82efc <UOTGHS_Handler+0x5bc>)
   82eda:	f04f 7800 	mov.w	r8, #33554432	; 0x2000000
				return true;
			}
		}
#endif // UDD_EP_FIFO_SUPPORTED
		// Check empty bank interrupt event
		if (Is_udd_endpoint_interrupt_enabled(ep)) {
   82ede:	f44f 5980 	mov.w	r9, #4096	; 0x1000
   82ee2:	e6ce      	b.n	82c82 <UOTGHS_Handler+0x342>
   82ee4:	400ac130 	.word	0x400ac130
   82ee8:	400ac160 	.word	0x400ac160
   82eec:	20071704 	.word	0x20071704
   82ef0:	400ac1f0 	.word	0x400ac1f0
   82ef4:	00082331 	.word	0x00082331
   82ef8:	400ac300 	.word	0x400ac300
   82efc:	400ac000 	.word	0x400ac000
   82f00:	0008251d 	.word	0x0008251d
   82f04:	400ac220 	.word	0x400ac220
   82f08:	000824e9 	.word	0x000824e9
   82f0c:	400ac100 	.word	0x400ac100
   82f10:	00081799 	.word	0x00081799
   82f14:	20070270 	.word	0x20070270
   82f18:	000822cd 	.word	0x000822cd
   82f1c:	00082681 	.word	0x00082681
   82f20:	0008288d 	.word	0x0008288d
   82f24:	0008290d 	.word	0x0008290d
   82f28:	00083db1 	.word	0x00083db1
   82f2c:	200716bc 	.word	0x200716bc
   82f30:	400ac134 	.word	0x400ac134
		goto udd_interrupt_end; // Interrupt acked by bulk/interrupt/isochronous endpoint managed
	}
#endif

	// USB bus reset detection
	if (Is_udd_reset()) {
   82f34:	4b04      	ldr	r3, [pc, #16]	; (82f48 <UOTGHS_Handler+0x608>)
   82f36:	685b      	ldr	r3, [r3, #4]
   82f38:	f013 0f08 	tst.w	r3, #8
   82f3c:	f43f af5d 	beq.w	82dfa <UOTGHS_Handler+0x4ba>
   82f40:	e714      	b.n	82d6c <UOTGHS_Handler+0x42c>
   82f42:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
   82f46:	bf00      	nop
   82f48:	400ac000 	.word	0x400ac000

00082f4c <udd_is_high_speed>:


bool udd_is_high_speed(void)
{
#ifdef USB_DEVICE_HS_SUPPORT
	return !Is_udd_full_speed_mode();
   82f4c:	4b03      	ldr	r3, [pc, #12]	; (82f5c <udd_is_high_speed+0x10>)
   82f4e:	f8d3 0804 	ldr.w	r0, [r3, #2052]	; 0x804
#else
	return false;
#endif
}
   82f52:	f410 5040 	ands.w	r0, r0, #12288	; 0x3000
   82f56:	bf18      	it	ne
   82f58:	2001      	movne	r0, #1
   82f5a:	4770      	bx	lr
   82f5c:	400ac000 	.word	0x400ac000

00082f60 <udd_set_address>:


void udd_set_address(uint8_t address)
{
	udd_disable_address();
   82f60:	4b08      	ldr	r3, [pc, #32]	; (82f84 <udd_set_address+0x24>)
   82f62:	681a      	ldr	r2, [r3, #0]
   82f64:	f022 0280 	bic.w	r2, r2, #128	; 0x80
   82f68:	601a      	str	r2, [r3, #0]
	udd_configure_address(address);
   82f6a:	681a      	ldr	r2, [r3, #0]
   82f6c:	f000 007f 	and.w	r0, r0, #127	; 0x7f
   82f70:	f022 027f 	bic.w	r2, r2, #127	; 0x7f
   82f74:	4302      	orrs	r2, r0
   82f76:	601a      	str	r2, [r3, #0]
	udd_enable_address();
   82f78:	681a      	ldr	r2, [r3, #0]
   82f7a:	f042 0280 	orr.w	r2, r2, #128	; 0x80
   82f7e:	601a      	str	r2, [r3, #0]
   82f80:	4770      	bx	lr
   82f82:	bf00      	nop
   82f84:	400ac000 	.word	0x400ac000

00082f88 <udd_getaddress>:
}


uint8_t udd_getaddress(void)
{
	return udd_get_configured_address();
   82f88:	4b02      	ldr	r3, [pc, #8]	; (82f94 <udd_getaddress+0xc>)
   82f8a:	6818      	ldr	r0, [r3, #0]
}
   82f8c:	f000 007f 	and.w	r0, r0, #127	; 0x7f
   82f90:	4770      	bx	lr
   82f92:	bf00      	nop
   82f94:	400ac000 	.word	0x400ac000

00082f98 <udd_get_frame_number>:


uint16_t udd_get_frame_number(void)
{
	return udd_frame_number();
   82f98:	4b02      	ldr	r3, [pc, #8]	; (82fa4 <udd_get_frame_number+0xc>)
   82f9a:	6a18      	ldr	r0, [r3, #32]
}
   82f9c:	f3c0 00ca 	ubfx	r0, r0, #3, #11
   82fa0:	4770      	bx	lr
   82fa2:	bf00      	nop
   82fa4:	400ac000 	.word	0x400ac000

00082fa8 <udd_get_micro_frame_number>:

uint16_t udd_get_micro_frame_number(void)
{
	return udd_micro_frame_number();
   82fa8:	4b02      	ldr	r3, [pc, #8]	; (82fb4 <udd_get_micro_frame_number+0xc>)
   82faa:	6a18      	ldr	r0, [r3, #32]
}
   82fac:	f3c0 000d 	ubfx	r0, r0, #0, #14
   82fb0:	4770      	bx	lr
   82fb2:	bf00      	nop
   82fb4:	400ac000 	.word	0x400ac000

00082fb8 <udd_set_setup_payload>:
}


void udd_set_setup_payload(uint8_t *payload, uint16_t payload_size)
{
	udd_g_ctrlreq.payload = payload;
   82fb8:	4b01      	ldr	r3, [pc, #4]	; (82fc0 <udd_set_setup_payload+0x8>)
   82fba:	6098      	str	r0, [r3, #8]
	udd_g_ctrlreq.payload_size = payload_size;
   82fbc:	8199      	strh	r1, [r3, #12]
   82fbe:	4770      	bx	lr
   82fc0:	20075c44 	.word	0x20075c44

00082fc4 <udd_ep_free>:
	return true;
}


void udd_ep_free(udd_ep_id_t ep)
{
   82fc4:	b570      	push	{r4, r5, r6, lr}
	uint8_t ep_index = ep & USB_EP_ADDR_MASK;
   82fc6:	f000 020f 	and.w	r2, r0, #15
	if (USB_DEVICE_MAX_EP < ep_index) {
   82fca:	2a03      	cmp	r2, #3
   82fcc:	d81f      	bhi.n	8300e <udd_ep_free+0x4a>
		return;
	}
	udd_disable_endpoint(ep_index);
   82fce:	4b10      	ldr	r3, [pc, #64]	; (83010 <udd_ep_free+0x4c>)
   82fd0:	69d8      	ldr	r0, [r3, #28]
   82fd2:	2101      	movs	r1, #1
   82fd4:	fa01 f402 	lsl.w	r4, r1, r2
   82fd8:	ea20 0004 	bic.w	r0, r0, r4
   82fdc:	61d8      	str	r0, [r3, #28]
	udd_unallocate_memory(ep_index);
   82fde:	f503 7380 	add.w	r3, r3, #256	; 0x100
   82fe2:	f853 0022 	ldr.w	r0, [r3, r2, lsl #2]
   82fe6:	f020 0002 	bic.w	r0, r0, #2
   82fea:	f843 0022 	str.w	r0, [r3, r2, lsl #2]
static void udd_ep_abort_job(udd_ep_id_t ep)
{
	ep &= USB_EP_ADDR_MASK;

	// Abort job on endpoint
	udd_ep_finish_job(&udd_ep_job[ep - 1], true, ep);
   82fee:	1e54      	subs	r4, r2, #1
   82ff0:	4d08      	ldr	r5, [pc, #32]	; (83014 <udd_ep_free+0x50>)
   82ff2:	fa04 f601 	lsl.w	r6, r4, r1
   82ff6:	1930      	adds	r0, r6, r4
   82ff8:	eb05 00c0 	add.w	r0, r5, r0, lsl #3
   82ffc:	4b06      	ldr	r3, [pc, #24]	; (83018 <udd_ep_free+0x54>)
   82ffe:	4798      	blx	r3
		return;
	}
	udd_disable_endpoint(ep_index);
	udd_unallocate_memory(ep_index);
	udd_ep_abort_job(ep);
	udd_ep_job[ep_index - 1].stall_requested = false;
   83000:	4434      	add	r4, r6
   83002:	eb05 05c4 	add.w	r5, r5, r4, lsl #3
   83006:	7d2b      	ldrb	r3, [r5, #20]
   83008:	f36f 0382 	bfc	r3, #2, #1
   8300c:	752b      	strb	r3, [r5, #20]
   8300e:	bd70      	pop	{r4, r5, r6, pc}
   83010:	400ac000 	.word	0x400ac000
   83014:	200716bc 	.word	0x200716bc
   83018:	000824e9 	.word	0x000824e9

0008301c <udd_ep_is_halted>:


bool udd_ep_is_halted(udd_ep_id_t ep)
{
	uint8_t ep_index = ep & USB_EP_ADDR_MASK;
	return Is_udd_endpoint_stall_requested(ep_index);
   8301c:	f000 000f 	and.w	r0, r0, #15
   83020:	4b02      	ldr	r3, [pc, #8]	; (8302c <udd_ep_is_halted+0x10>)
   83022:	f853 0020 	ldr.w	r0, [r3, r0, lsl #2]
}
   83026:	f3c0 40c0 	ubfx	r0, r0, #19, #1
   8302a:	4770      	bx	lr
   8302c:	400ac1c0 	.word	0x400ac1c0

00083030 <udd_ep_set_halt>:


bool udd_ep_set_halt(udd_ep_id_t ep)
{
   83030:	b430      	push	{r4, r5}
	uint8_t ep_index = ep & USB_EP_ADDR_MASK;
   83032:	f000 030f 	and.w	r3, r0, #15
	udd_ep_job_t *ptr_job = &udd_ep_job[ep_index - 1];
	irqflags_t flags;

	if (USB_DEVICE_MAX_EP < ep_index) {
   83036:	2b03      	cmp	r3, #3
   83038:	d854      	bhi.n	830e4 <udd_ep_set_halt+0xb4>
		return false;
	}

	if (Is_udd_endpoint_stall_requested(ep_index) // Endpoint stalled
   8303a:	4a31      	ldr	r2, [pc, #196]	; (83100 <udd_ep_set_halt+0xd0>)
   8303c:	f852 2023 	ldr.w	r2, [r2, r3, lsl #2]
   83040:	f412 2f00 	tst.w	r2, #524288	; 0x80000
   83044:	d150      	bne.n	830e8 <udd_ep_set_halt+0xb8>


bool udd_ep_set_halt(udd_ep_id_t ep)
{
	uint8_t ep_index = ep & USB_EP_ADDR_MASK;
	udd_ep_job_t *ptr_job = &udd_ep_job[ep_index - 1];
   83046:	1e5a      	subs	r2, r3, #1
   83048:	eb02 0242 	add.w	r2, r2, r2, lsl #1
   8304c:	492d      	ldr	r1, [pc, #180]	; (83104 <udd_ep_set_halt+0xd4>)
   8304e:	eb01 02c2 	add.w	r2, r1, r2, lsl #3
	if (USB_DEVICE_MAX_EP < ep_index) {
		return false;
	}

	if (Is_udd_endpoint_stall_requested(ep_index) // Endpoint stalled
			|| ptr_job->stall_requested) { // Endpoint stall is requested
   83052:	7d11      	ldrb	r1, [r2, #20]
   83054:	f011 0f04 	tst.w	r1, #4
   83058:	d148      	bne.n	830ec <udd_ep_set_halt+0xbc>
		return true; // Already STALL
	}

	if (ptr_job->busy == true) {
   8305a:	f011 0f01 	tst.w	r1, #1
   8305e:	d147      	bne.n	830f0 <udd_ep_set_halt+0xc0>
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_PRIMASK(void)
{
  uint32_t result;

  __ASM volatile ("MRS %0, primask" : "=r" (result) );
   83060:	f3ef 8110 	mrs	r1, PRIMASK
static volatile uint32_t cpu_irq_critical_section_counter;
static volatile bool     cpu_irq_prev_interrupt_state;

static inline irqflags_t cpu_irq_save(void)
{
	irqflags_t flags = cpu_irq_is_enabled();
   83064:	f1d1 0101 	rsbs	r1, r1, #1
   83068:	bf38      	it	cc
   8306a:	2100      	movcc	r1, #0
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
   8306c:	b672      	cpsid	i
   8306e:	f3bf 8f5f 	dmb	sy
	cpu_irq_disable();
   83072:	2500      	movs	r5, #0
   83074:	4c24      	ldr	r4, [pc, #144]	; (83108 <udd_ep_set_halt+0xd8>)
   83076:	7025      	strb	r5, [r4, #0]
		return false; // Job on going, stall impossible
	}

	flags = cpu_irq_save();
	if ((ep & USB_EP_DIR_IN) && (0 != udd_nb_busy_bank(ep_index))) {
   83078:	f010 0f80 	tst.w	r0, #128	; 0x80
   8307c:	d01a      	beq.n	830b4 <udd_ep_set_halt+0x84>
   8307e:	4823      	ldr	r0, [pc, #140]	; (8310c <udd_ep_set_halt+0xdc>)
   83080:	f850 0023 	ldr.w	r0, [r0, r3, lsl #2]
   83084:	f410 5f40 	tst.w	r0, #12288	; 0x3000
   83088:	d014      	beq.n	830b4 <udd_ep_set_halt+0x84>
		// Delay the stall after the end of IN transfer on USB line
		ptr_job->stall_requested = true;
   8308a:	7d10      	ldrb	r0, [r2, #20]
   8308c:	f040 0004 	orr.w	r0, r0, #4
   83090:	7510      	strb	r0, [r2, #20]
#ifdef UDD_EP_FIFO_SUPPORTED
		udd_disable_in_send_interrupt(ep_index);
		udd_enable_endpoint_bank_autoswitch(ep_index);
#endif
		udd_enable_bank_interrupt(ep_index);
   83092:	f44f 5280 	mov.w	r2, #4096	; 0x1000
   83096:	481e      	ldr	r0, [pc, #120]	; (83110 <udd_ep_set_halt+0xe0>)
   83098:	f840 2023 	str.w	r2, [r0, r3, lsl #2]
		udd_enable_endpoint_interrupt(ep_index);
   8309c:	fa02 f303 	lsl.w	r3, r2, r3
   830a0:	f5a0 70f8 	sub.w	r0, r0, #496	; 0x1f0
   830a4:	6183      	str	r3, [r0, #24]
	return (flags);
}

static inline void cpu_irq_restore(irqflags_t flags)
{
	if (cpu_irq_is_enabled_flags(flags))
   830a6:	b329      	cbz	r1, 830f4 <udd_ep_set_halt+0xc4>
		cpu_irq_enable();
   830a8:	2001      	movs	r0, #1
   830aa:	7020      	strb	r0, [r4, #0]
   830ac:	f3bf 8f5f 	dmb	sy
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
   830b0:	b662      	cpsie	i
   830b2:	e022      	b.n	830fa <udd_ep_set_halt+0xca>
		cpu_irq_restore(flags);
		return true;
	}
	// Stall endpoint immediately
	udd_disable_endpoint_bank_autoswitch(ep_index);
   830b4:	4a17      	ldr	r2, [pc, #92]	; (83114 <udd_ep_set_halt+0xe4>)
   830b6:	f852 0023 	ldr.w	r0, [r2, r3, lsl #2]
   830ba:	f420 7000 	bic.w	r0, r0, #512	; 0x200
   830be:	f842 0023 	str.w	r0, [r2, r3, lsl #2]
	udd_ack_stall(ep_index);
   830c2:	2040      	movs	r0, #64	; 0x40
   830c4:	3260      	adds	r2, #96	; 0x60
   830c6:	f842 0023 	str.w	r0, [r2, r3, lsl #2]
	udd_enable_stall_handshake(ep_index);
   830ca:	f44f 2000 	mov.w	r0, #524288	; 0x80000
   830ce:	3290      	adds	r2, #144	; 0x90
   830d0:	f842 0023 	str.w	r0, [r2, r3, lsl #2]
	return (flags);
}

static inline void cpu_irq_restore(irqflags_t flags)
{
	if (cpu_irq_is_enabled_flags(flags))
   830d4:	b181      	cbz	r1, 830f8 <udd_ep_set_halt+0xc8>
		cpu_irq_enable();
   830d6:	2001      	movs	r0, #1
   830d8:	4b0b      	ldr	r3, [pc, #44]	; (83108 <udd_ep_set_halt+0xd8>)
   830da:	7018      	strb	r0, [r3, #0]
   830dc:	f3bf 8f5f 	dmb	sy
   830e0:	b662      	cpsie	i
   830e2:	e00a      	b.n	830fa <udd_ep_set_halt+0xca>
	uint8_t ep_index = ep & USB_EP_ADDR_MASK;
	udd_ep_job_t *ptr_job = &udd_ep_job[ep_index - 1];
	irqflags_t flags;

	if (USB_DEVICE_MAX_EP < ep_index) {
		return false;
   830e4:	2000      	movs	r0, #0
   830e6:	e008      	b.n	830fa <udd_ep_set_halt+0xca>
	}

	if (Is_udd_endpoint_stall_requested(ep_index) // Endpoint stalled
			|| ptr_job->stall_requested) { // Endpoint stall is requested
		return true; // Already STALL
   830e8:	2001      	movs	r0, #1
   830ea:	e006      	b.n	830fa <udd_ep_set_halt+0xca>
   830ec:	2001      	movs	r0, #1
   830ee:	e004      	b.n	830fa <udd_ep_set_halt+0xca>
	}

	if (ptr_job->busy == true) {
		return false; // Job on going, stall impossible
   830f0:	2000      	movs	r0, #0
   830f2:	e002      	b.n	830fa <udd_ep_set_halt+0xca>
		udd_enable_endpoint_bank_autoswitch(ep_index);
#endif
		udd_enable_bank_interrupt(ep_index);
		udd_enable_endpoint_interrupt(ep_index);
		cpu_irq_restore(flags);
		return true;
   830f4:	2001      	movs	r0, #1
   830f6:	e000      	b.n	830fa <udd_ep_set_halt+0xca>
	// Stall endpoint immediately
	udd_disable_endpoint_bank_autoswitch(ep_index);
	udd_ack_stall(ep_index);
	udd_enable_stall_handshake(ep_index);
	cpu_irq_restore(flags);
	return true;
   830f8:	2001      	movs	r0, #1
}
   830fa:	bc30      	pop	{r4, r5}
   830fc:	4770      	bx	lr
   830fe:	bf00      	nop
   83100:	400ac1c0 	.word	0x400ac1c0
   83104:	200716bc 	.word	0x200716bc
   83108:	20070270 	.word	0x20070270
   8310c:	400ac130 	.word	0x400ac130
   83110:	400ac1f0 	.word	0x400ac1f0
   83114:	400ac100 	.word	0x400ac100

00083118 <udd_ep_clear_halt>:


bool udd_ep_clear_halt(udd_ep_id_t ep)
{
   83118:	b538      	push	{r3, r4, r5, lr}
	uint8_t ep_index = ep & USB_EP_ADDR_MASK;
   8311a:	f000 000f 	and.w	r0, r0, #15
	udd_ep_job_t *ptr_job = &udd_ep_job[ep_index - 1];
	bool b_stall_cleared = false;

	if (USB_DEVICE_MAX_EP < ep_index)
   8311e:	2803      	cmp	r0, #3
   83120:	d840      	bhi.n	831a4 <udd_ep_clear_halt+0x8c>


bool udd_ep_clear_halt(udd_ep_id_t ep)
{
	uint8_t ep_index = ep & USB_EP_ADDR_MASK;
	udd_ep_job_t *ptr_job = &udd_ep_job[ep_index - 1];
   83122:	4927      	ldr	r1, [pc, #156]	; (831c0 <udd_ep_clear_halt+0xa8>)
   83124:	1e43      	subs	r3, r0, #1
   83126:	eb03 0343 	add.w	r3, r3, r3, lsl #1
   8312a:	00dc      	lsls	r4, r3, #3
   8312c:	190b      	adds	r3, r1, r4
	bool b_stall_cleared = false;

	if (USB_DEVICE_MAX_EP < ep_index)
		return false;

	if (ptr_job->stall_requested) {
   8312e:	7d1a      	ldrb	r2, [r3, #20]
   83130:	f012 0f04 	tst.w	r2, #4
   83134:	d03a      	beq.n	831ac <udd_ep_clear_halt+0x94>
		// Endpoint stall has been requested but not done
		// Remove stall request
		ptr_job->stall_requested = false;
   83136:	7d1a      	ldrb	r2, [r3, #20]
   83138:	f36f 0282 	bfc	r2, #2, #1
   8313c:	751a      	strb	r2, [r3, #20]
		udd_disable_bank_interrupt(ep_index);
   8313e:	f44f 5280 	mov.w	r2, #4096	; 0x1000
   83142:	4d20      	ldr	r5, [pc, #128]	; (831c4 <udd_ep_clear_halt+0xac>)
   83144:	f845 2020 	str.w	r2, [r5, r0, lsl #2]
		udd_disable_endpoint_interrupt(ep_index);
   83148:	4082      	lsls	r2, r0
   8314a:	f5a5 7508 	sub.w	r5, r5, #544	; 0x220
   8314e:	616a      	str	r2, [r5, #20]
		b_stall_cleared = true;
	}
	if (Is_udd_endpoint_stall_requested(ep_index)) {
   83150:	0082      	lsls	r2, r0, #2
   83152:	f505 75e0 	add.w	r5, r5, #448	; 0x1c0
   83156:	f855 0020 	ldr.w	r0, [r5, r0, lsl #2]
   8315a:	f410 2f00 	tst.w	r0, #524288	; 0x80000
   8315e:	d015      	beq.n	8318c <udd_ep_clear_halt+0x74>
		if (Is_udd_stall(ep_index)) {
   83160:	4819      	ldr	r0, [pc, #100]	; (831c8 <udd_ep_clear_halt+0xb0>)
   83162:	5810      	ldr	r0, [r2, r0]
   83164:	f010 0f40 	tst.w	r0, #64	; 0x40
   83168:	d006      	beq.n	83178 <udd_ep_clear_halt+0x60>
			udd_ack_stall(ep_index);
   8316a:	2540      	movs	r5, #64	; 0x40
   8316c:	4817      	ldr	r0, [pc, #92]	; (831cc <udd_ep_clear_halt+0xb4>)
   8316e:	5015      	str	r5, [r2, r0]
			// A packet has been stalled
			// then reset datatoggle
			udd_reset_data_toggle(ep_index);
   83170:	f44f 2580 	mov.w	r5, #262144	; 0x40000
   83174:	3090      	adds	r0, #144	; 0x90
   83176:	5015      	str	r5, [r2, r0]
		}
		// Disable stall
		udd_disable_stall_handshake(ep_index);
   83178:	f44f 2500 	mov.w	r5, #524288	; 0x80000
   8317c:	4811      	ldr	r0, [pc, #68]	; (831c4 <udd_ep_clear_halt+0xac>)
   8317e:	5015      	str	r5, [r2, r0]
		udd_enable_endpoint_bank_autoswitch(ep_index);
   83180:	f5a0 7090 	sub.w	r0, r0, #288	; 0x120
   83184:	5815      	ldr	r5, [r2, r0]
   83186:	f445 7500 	orr.w	r5, r5, #512	; 0x200
   8318a:	5015      	str	r5, [r2, r0]
		b_stall_cleared = true;
	}
	if (b_stall_cleared) {
		// If a job is register on clear halt action
		// then execute callback
		if (ptr_job->busy == true) {
   8318c:	7d1a      	ldrb	r2, [r3, #20]
   8318e:	f012 0f01 	tst.w	r2, #1
   83192:	d009      	beq.n	831a8 <udd_ep_clear_halt+0x90>
			ptr_job->busy = false;
   83194:	7d1a      	ldrb	r2, [r3, #20]
   83196:	f36f 0200 	bfc	r2, #0, #1
   8319a:	751a      	strb	r2, [r3, #20]
			ptr_job->call_nohalt();
   8319c:	590b      	ldr	r3, [r1, r4]
   8319e:	4798      	blx	r3
		}
	}
	return true;
   831a0:	2001      	movs	r0, #1
   831a2:	bd38      	pop	{r3, r4, r5, pc}
	uint8_t ep_index = ep & USB_EP_ADDR_MASK;
	udd_ep_job_t *ptr_job = &udd_ep_job[ep_index - 1];
	bool b_stall_cleared = false;

	if (USB_DEVICE_MAX_EP < ep_index)
		return false;
   831a4:	2000      	movs	r0, #0
   831a6:	bd38      	pop	{r3, r4, r5, pc}
		if (ptr_job->busy == true) {
			ptr_job->busy = false;
			ptr_job->call_nohalt();
		}
	}
	return true;
   831a8:	2001      	movs	r0, #1
   831aa:	bd38      	pop	{r3, r4, r5, pc}
		ptr_job->stall_requested = false;
		udd_disable_bank_interrupt(ep_index);
		udd_disable_endpoint_interrupt(ep_index);
		b_stall_cleared = true;
	}
	if (Is_udd_endpoint_stall_requested(ep_index)) {
   831ac:	0082      	lsls	r2, r0, #2
   831ae:	4d08      	ldr	r5, [pc, #32]	; (831d0 <udd_ep_clear_halt+0xb8>)
   831b0:	f855 0020 	ldr.w	r0, [r5, r0, lsl #2]
   831b4:	f410 2f00 	tst.w	r0, #524288	; 0x80000
   831b8:	d1d2      	bne.n	83160 <udd_ep_clear_halt+0x48>
		if (ptr_job->busy == true) {
			ptr_job->busy = false;
			ptr_job->call_nohalt();
		}
	}
	return true;
   831ba:	2001      	movs	r0, #1
}
   831bc:	bd38      	pop	{r3, r4, r5, pc}
   831be:	bf00      	nop
   831c0:	200716bc 	.word	0x200716bc
   831c4:	400ac220 	.word	0x400ac220
   831c8:	400ac130 	.word	0x400ac130
   831cc:	400ac160 	.word	0x400ac160
   831d0:	400ac1c0 	.word	0x400ac1c0

000831d4 <udd_ep_run>:


bool udd_ep_run(udd_ep_id_t ep, bool b_shortpacket,
		uint8_t * buf, iram_size_t buf_size,
		udd_callback_trans_t callback)
{
   831d4:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	bool b_dir_in = Is_udd_endpoint_in(ep & USB_EP_ADDR_MASK);
#endif
	udd_ep_job_t *ptr_job;
	irqflags_t flags;

	ep &= USB_EP_ADDR_MASK;
   831d8:	f000 000f 	and.w	r0, r0, #15
	if (USB_DEVICE_MAX_EP < ep) {
   831dc:	2803      	cmp	r0, #3
   831de:	d85a      	bhi.n	83296 <udd_ep_run+0xc2>
	}

	// Get job about endpoint
	ptr_job = &udd_ep_job[ep - 1];

	if ((!Is_udd_endpoint_enabled(ep))
   831e0:	4c34      	ldr	r4, [pc, #208]	; (832b4 <udd_ep_run+0xe0>)
   831e2:	69e4      	ldr	r4, [r4, #28]
   831e4:	2501      	movs	r5, #1
   831e6:	4085      	lsls	r5, r0
   831e8:	4225      	tst	r5, r4
   831ea:	d057      	beq.n	8329c <udd_ep_run+0xc8>
			|| Is_udd_endpoint_stall_requested(ep)
   831ec:	4c32      	ldr	r4, [pc, #200]	; (832b8 <udd_ep_run+0xe4>)
   831ee:	f854 4020 	ldr.w	r4, [r4, r0, lsl #2]
   831f2:	f414 2f00 	tst.w	r4, #524288	; 0x80000
   831f6:	d154      	bne.n	832a2 <udd_ep_run+0xce>
	if (USB_DEVICE_MAX_EP < ep) {
		return false;
	}

	// Get job about endpoint
	ptr_job = &udd_ep_job[ep - 1];
   831f8:	4e30      	ldr	r6, [pc, #192]	; (832bc <udd_ep_run+0xe8>)
   831fa:	1e44      	subs	r4, r0, #1
   831fc:	eb04 0444 	add.w	r4, r4, r4, lsl #1
   83200:	00e5      	lsls	r5, r4, #3
   83202:	1974      	adds	r4, r6, r5

	if ((!Is_udd_endpoint_enabled(ep))
			|| Is_udd_endpoint_stall_requested(ep)
			|| ptr_job->stall_requested) {
   83204:	7d27      	ldrb	r7, [r4, #20]
   83206:	f017 0f04 	tst.w	r7, #4
   8320a:	d14d      	bne.n	832a8 <udd_ep_run+0xd4>
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_PRIMASK(void)
{
  uint32_t result;

  __ASM volatile ("MRS %0, primask" : "=r" (result) );
   8320c:	f3ef 8710 	mrs	r7, PRIMASK
static volatile uint32_t cpu_irq_critical_section_counter;
static volatile bool     cpu_irq_prev_interrupt_state;

static inline irqflags_t cpu_irq_save(void)
{
	irqflags_t flags = cpu_irq_is_enabled();
   83210:	f1d7 0801 	rsbs	r8, r7, #1
   83214:	bf38      	it	cc
   83216:	f04f 0800 	movcc.w	r8, #0
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
   8321a:	b672      	cpsid	i
   8321c:	f3bf 8f5f 	dmb	sy
	cpu_irq_disable();
   83220:	f04f 0c00 	mov.w	ip, #0
   83224:	4f26      	ldr	r7, [pc, #152]	; (832c0 <udd_ep_run+0xec>)
   83226:	f887 c000 	strb.w	ip, [r7]
		return false; // Endpoint is halted
	}

	flags = cpu_irq_save();
	if (ptr_job->busy == true) {
   8322a:	7d27      	ldrb	r7, [r4, #20]
   8322c:	f017 0f01 	tst.w	r7, #1
   83230:	d00b      	beq.n	8324a <udd_ep_run+0x76>
	return (flags);
}

static inline void cpu_irq_restore(irqflags_t flags)
{
	if (cpu_irq_is_enabled_flags(flags))
   83232:	f1b8 0f00 	cmp.w	r8, #0
   83236:	d03a      	beq.n	832ae <udd_ep_run+0xda>
		cpu_irq_enable();
   83238:	2201      	movs	r2, #1
   8323a:	4b21      	ldr	r3, [pc, #132]	; (832c0 <udd_ep_run+0xec>)
   8323c:	701a      	strb	r2, [r3, #0]
   8323e:	f3bf 8f5f 	dmb	sy
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
   83242:	b662      	cpsie	i
		cpu_irq_restore(flags);
		return false; // Job already on going
   83244:	4660      	mov	r0, ip
   83246:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	}
	ptr_job->busy = true;
   8324a:	7d27      	ldrb	r7, [r4, #20]
   8324c:	f047 0701 	orr.w	r7, r7, #1
   83250:	7527      	strb	r7, [r4, #20]
	return (flags);
}

static inline void cpu_irq_restore(irqflags_t flags)
{
	if (cpu_irq_is_enabled_flags(flags))
   83252:	f1b8 0f00 	cmp.w	r8, #0
   83256:	d007      	beq.n	83268 <udd_ep_run+0x94>
		cpu_irq_enable();
   83258:	f04f 0e01 	mov.w	lr, #1
   8325c:	4f18      	ldr	r7, [pc, #96]	; (832c0 <udd_ep_run+0xec>)
   8325e:	f887 e000 	strb.w	lr, [r7]
   83262:	f3bf 8f5f 	dmb	sy
   83266:	b662      	cpsie	i
	cpu_irq_restore(flags);

	// No job running. Let's setup a new one.
	ptr_job->buf = buf;
   83268:	6062      	str	r2, [r4, #4]
	ptr_job->buf_size = buf_size;
   8326a:	60a3      	str	r3, [r4, #8]
	ptr_job->buf_cnt = 0;
   8326c:	2200      	movs	r2, #0
   8326e:	60e2      	str	r2, [r4, #12]
	ptr_job->buf_load = 0;
   83270:	6122      	str	r2, [r4, #16]
	ptr_job->call_trans = callback;
   83272:	9a06      	ldr	r2, [sp, #24]
   83274:	5172      	str	r2, [r6, r5]
	ptr_job->b_shortpacket = b_shortpacket || (buf_size == 0);
   83276:	b921      	cbnz	r1, 83282 <udd_ep_run+0xae>
   83278:	f1d3 0301 	rsbs	r3, r3, #1
   8327c:	bf38      	it	cc
   8327e:	2300      	movcc	r3, #0
   83280:	e000      	b.n	83284 <udd_ep_run+0xb0>
   83282:	2301      	movs	r3, #1
   83284:	7d22      	ldrb	r2, [r4, #20]
   83286:	f363 0241 	bfi	r2, r3, #1, #1
   8328a:	7522      	strb	r2, [r4, #20]
#endif // UDD_EP_FIFO_SUPPORTED

#ifdef UDD_EP_DMA_SUPPORTED
	// Request first DMA transfer
	dbg_print("(exDMA%x) ", ep);
	udd_ep_trans_done(ep);
   8328c:	4b0d      	ldr	r3, [pc, #52]	; (832c4 <udd_ep_run+0xf0>)
   8328e:	4798      	blx	r3
	return true;
   83290:	2001      	movs	r0, #1
   83292:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	udd_ep_job_t *ptr_job;
	irqflags_t flags;

	ep &= USB_EP_ADDR_MASK;
	if (USB_DEVICE_MAX_EP < ep) {
		return false;
   83296:	2000      	movs	r0, #0
   83298:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	ptr_job = &udd_ep_job[ep - 1];

	if ((!Is_udd_endpoint_enabled(ep))
			|| Is_udd_endpoint_stall_requested(ep)
			|| ptr_job->stall_requested) {
		return false; // Endpoint is halted
   8329c:	2000      	movs	r0, #0
   8329e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   832a2:	2000      	movs	r0, #0
   832a4:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   832a8:	2000      	movs	r0, #0
   832aa:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	}

	flags = cpu_irq_save();
	if (ptr_job->busy == true) {
		cpu_irq_restore(flags);
		return false; // Job already on going
   832ae:	2000      	movs	r0, #0
	// Request first DMA transfer
	dbg_print("(exDMA%x) ", ep);
	udd_ep_trans_done(ep);
	return true;
#endif
}
   832b0:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   832b4:	400ac000 	.word	0x400ac000
   832b8:	400ac1c0 	.word	0x400ac1c0
   832bc:	200716bc 	.word	0x200716bc
   832c0:	20070270 	.word	0x20070270
   832c4:	0008251d 	.word	0x0008251d

000832c8 <udd_ep_alloc>:


#if (0 != USB_DEVICE_MAX_EP)
bool udd_ep_alloc(udd_ep_id_t ep, uint8_t bmAttributes,
		uint16_t MaxEndpointSize)
{
   832c8:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   832cc:	b083      	sub	sp, #12
	bool b_dir_in;
	uint16_t ep_allocated;
	uint8_t nb_bank, bank, i;

	b_dir_in = ep & USB_EP_DIR_IN;
	ep = ep & USB_EP_ADDR_MASK;
   832ce:	f000 040f 	and.w	r4, r0, #15

	if (ep > USB_DEVICE_MAX_EP) {
   832d2:	2c03      	cmp	r4, #3
   832d4:	f200 80c7 	bhi.w	83466 <udd_ep_alloc+0x19e>
		return false;
	}
	if (Is_udd_endpoint_enabled(ep)) {
   832d8:	4b6c      	ldr	r3, [pc, #432]	; (8348c <udd_ep_alloc+0x1c4>)
   832da:	69db      	ldr	r3, [r3, #28]
   832dc:	4626      	mov	r6, r4
   832de:	2501      	movs	r5, #1
   832e0:	40a5      	lsls	r5, r4
   832e2:	421d      	tst	r5, r3
   832e4:	f040 80c1 	bne.w	8346a <udd_ep_alloc+0x1a2>
		return false;
	}
	dbg_print("alloc(%x, %d) ", ep, MaxEndpointSize);

	// Bank choise
	switch (bmAttributes & USB_EP_TYPE_MASK) {
   832e8:	f011 0303 	ands.w	r3, r1, #3
   832ec:	f000 80bf 	beq.w	8346e <udd_ep_alloc+0x1a6>
   832f0:	2b02      	cmp	r3, #2
   832f2:	d902      	bls.n	832fa <udd_ep_alloc+0x32>
   832f4:	2b03      	cmp	r3, #3
   832f6:	d002      	beq.n	832fe <udd_ep_alloc+0x36>
   832f8:	e0b9      	b.n	8346e <udd_ep_alloc+0x1a6>
	case 1:
		bank = UOTGHS_DEVEPTCFG_EPBK_1_BANK >>
				UOTGHS_DEVEPTCFG_EPBK_Pos;
		break;
	case 2:
		bank = UOTGHS_DEVEPTCFG_EPBK_2_BANK >>
   832fa:	2701      	movs	r7, #1
   832fc:	e000      	b.n	83300 <udd_ep_alloc+0x38>
		Assert(false);
		return false;
	}
	switch (nb_bank) {
	case 1:
		bank = UOTGHS_DEVEPTCFG_EPBK_1_BANK >>
   832fe:	2700      	movs	r7, #0
	Assert((MaxEndpointSize == 1023)
		|| !(MaxEndpointSize & (MaxEndpointSize - 1)));
	Assert(MaxEndpointSize >= 8);

	// Set configuration of new endpoint
	udd_configure_endpoint(ep, bmAttributes, (b_dir_in ? 1 : 0),
   83300:	ea4f 0c84 	mov.w	ip, r4, lsl #2
   83304:	4d62      	ldr	r5, [pc, #392]	; (83490 <udd_ep_alloc+0x1c8>)
   83306:	f855 3024 	ldr.w	r3, [r5, r4, lsl #2]
   8330a:	f423 53cb 	bic.w	r3, r3, #6496	; 0x1960
   8330e:	f023 031c 	bic.w	r3, r3, #28
   83312:	02c9      	lsls	r1, r1, #11
   83314:	f401 51c0 	and.w	r1, r1, #6144	; 0x1800
   83318:	f000 0080 	and.w	r0, r0, #128	; 0x80
   8331c:	2800      	cmp	r0, #0
   8331e:	bf0c      	ite	eq
   83320:	2000      	moveq	r0, #0
   83322:	f44f 7080 	movne.w	r0, #256	; 0x100
   83326:	f5a2 6880 	sub.w	r8, r2, #1024	; 0x400
   8332a:	fa1f f888 	uxth.w	r8, r8
   8332e:	f5b8 4f7c 	cmp.w	r8, #64512	; 0xfc00
   83332:	d304      	bcc.n	8333e <udd_ep_alloc+0x76>
   83334:	2a08      	cmp	r2, #8
   83336:	d905      	bls.n	83344 <udd_ep_alloc+0x7c>
   83338:	0052      	lsls	r2, r2, #1
   8333a:	3a01      	subs	r2, #1
   8333c:	e003      	b.n	83346 <udd_ep_alloc+0x7e>
   8333e:	f240 72ff 	movw	r2, #2047	; 0x7ff
   83342:	e000      	b.n	83346 <udd_ep_alloc+0x7e>
   83344:	220f      	movs	r2, #15
   83346:	fab2 f282 	clz	r2, r2
   8334a:	ea41 0787 	orr.w	r7, r1, r7, lsl #2
   8334e:	4307      	orrs	r7, r0
   83350:	f1c2 021c 	rsb	r2, r2, #28
   83354:	ea47 1202 	orr.w	r2, r7, r2, lsl #4
   83358:	f422 62d0 	bic.w	r2, r2, #1664	; 0x680
   8335c:	f022 0203 	bic.w	r2, r2, #3
   83360:	04d2      	lsls	r2, r2, #19
   83362:	0cd2      	lsrs	r2, r2, #19
   83364:	4313      	orrs	r3, r2
   83366:	f84c 3005 	str.w	r3, [ip, r5]
			MaxEndpointSize, bank);
	ep_allocated = 1 << ep;
   8336a:	2701      	movs	r7, #1
   8336c:	fa07 f606 	lsl.w	r6, r7, r6
   83370:	b2b7      	uxth	r7, r6

	// Unalloc endpoints superior
	for (i = USB_DEVICE_MAX_EP; i > ep; i--) {
   83372:	2c02      	cmp	r4, #2
   83374:	f200 8081 	bhi.w	8347a <udd_ep_alloc+0x1b2>
   83378:	4a46      	ldr	r2, [pc, #280]	; (83494 <udd_ep_alloc+0x1cc>)
   8337a:	2303      	movs	r3, #3
		if (Is_udd_endpoint_enabled(i)) {
   8337c:	4843      	ldr	r0, [pc, #268]	; (8348c <udd_ep_alloc+0x1c4>)
   8337e:	2601      	movs	r6, #1
   83380:	69c5      	ldr	r5, [r0, #28]
   83382:	fa06 f103 	lsl.w	r1, r6, r3
   83386:	4229      	tst	r1, r5
   83388:	d009      	beq.n	8339e <udd_ep_alloc+0xd6>
			ep_allocated |= 1 << i;
   8338a:	430f      	orrs	r7, r1
   8338c:	b2bf      	uxth	r7, r7
			udd_disable_endpoint(i);
   8338e:	69c5      	ldr	r5, [r0, #28]
   83390:	ea25 0101 	bic.w	r1, r5, r1
   83394:	61c1      	str	r1, [r0, #28]
			udd_unallocate_memory(i);
   83396:	6811      	ldr	r1, [r2, #0]
   83398:	f021 0102 	bic.w	r1, r1, #2
   8339c:	6011      	str	r1, [r2, #0]
   8339e:	3b01      	subs	r3, #1
   833a0:	3a04      	subs	r2, #4
	udd_configure_endpoint(ep, bmAttributes, (b_dir_in ? 1 : 0),
			MaxEndpointSize, bank);
	ep_allocated = 1 << ep;

	// Unalloc endpoints superior
	for (i = USB_DEVICE_MAX_EP; i > ep; i--) {
   833a2:	b2d9      	uxtb	r1, r3
   833a4:	42a1      	cmp	r1, r4
   833a6:	d8eb      	bhi.n	83380 <udd_ep_alloc+0xb8>
   833a8:	e067      	b.n	8347a <udd_ep_alloc+0x1b2>
		}
	}

	// Realloc/Enable endpoints
	for (i = ep; i <= USB_DEVICE_MAX_EP; i++) {
		if (ep_allocated & (1 << i)) {
   833aa:	fa47 f304 	asr.w	r3, r7, r4
   833ae:	f013 0f01 	tst.w	r3, #1
   833b2:	d052      	beq.n	8345a <udd_ep_alloc+0x192>
			udd_ep_job_t *ptr_job = &udd_ep_job[i - 1];
   833b4:	1e63      	subs	r3, r4, #1
   833b6:	eb03 0c43 	add.w	ip, r3, r3, lsl #1
   833ba:	eb08 05cc 	add.w	r5, r8, ip, lsl #3
			bool b_restart = ptr_job->busy;
   833be:	7d2b      	ldrb	r3, [r5, #20]
   833c0:	f003 0201 	and.w	r2, r3, #1
			// Restart running job because
			// memory window slides up and its data is lost
			ptr_job->busy = false;
   833c4:	f36f 0300 	bfc	r3, #0, #1
   833c8:	752b      	strb	r3, [r5, #20]
			// Re-allocate memory
			udd_allocate_memory(i);
   833ca:	00a1      	lsls	r1, r4, #2
   833cc:	eb01 0a06 	add.w	sl, r1, r6
   833d0:	f856 3024 	ldr.w	r3, [r6, r4, lsl #2]
   833d4:	f043 0302 	orr.w	r3, r3, #2
   833d8:	f846 3024 	str.w	r3, [r6, r4, lsl #2]
			udd_enable_endpoint(i);
   833dc:	4b2b      	ldr	r3, [pc, #172]	; (8348c <udd_ep_alloc+0x1c4>)
   833de:	69d8      	ldr	r0, [r3, #28]
   833e0:	f04f 0b01 	mov.w	fp, #1
   833e4:	fa0b fb04 	lsl.w	fp, fp, r4
   833e8:	ea4b 0000 	orr.w	r0, fp, r0
   833ec:	61d8      	str	r0, [r3, #28]
			if (!Is_udd_endpoint_configured(i)) {
   833ee:	f859 3024 	ldr.w	r3, [r9, r4, lsl #2]
   833f2:	f413 2f80 	tst.w	r3, #262144	; 0x40000
   833f6:	d10f      	bne.n	83418 <udd_ep_alloc+0x150>
				dbg_print("ErrRealloc%d ", i);
				if (NULL == ptr_job->call_trans) {
   833f8:	682b      	ldr	r3, [r5, #0]
   833fa:	2b00      	cmp	r3, #0
   833fc:	d039      	beq.n	83472 <udd_ep_alloc+0x1aa>
					return false;
				}
				if (Is_udd_endpoint_in(i)) {
   833fe:	f8da 2000 	ldr.w	r2, [sl]
   83402:	f412 7f80 	tst.w	r2, #256	; 0x100
					i |= USB_EP_DIR_IN;
   83406:	bf18      	it	ne
   83408:	f044 0480 	orrne.w	r4, r4, #128	; 0x80
				}
				ptr_job->call_trans(UDD_EP_TRANSFER_ABORT,
   8340c:	2001      	movs	r0, #1
   8340e:	68e9      	ldr	r1, [r5, #12]
   83410:	4622      	mov	r2, r4
   83412:	4798      	blx	r3
						ptr_job->buf_cnt, i);
				return false;
   83414:	2000      	movs	r0, #0
   83416:	e036      	b.n	83486 <udd_ep_alloc+0x1be>
			}
			udd_enable_endpoint_bank_autoswitch(i);
   83418:	f856 3024 	ldr.w	r3, [r6, r4, lsl #2]
   8341c:	f443 7300 	orr.w	r3, r3, #512	; 0x200
   83420:	f846 3024 	str.w	r3, [r6, r4, lsl #2]
			if (b_restart) {
   83424:	b1ca      	cbz	r2, 8345a <udd_ep_alloc+0x192>
				if (!Is_udd_endpoint_dma_supported(i)
					&& !Is_udd_endpoint_in(i)) {
					ptr_job->buf_cnt -= ptr_job->buf_load;
				}
#  else
				ptr_job->buf_cnt -= ptr_job->buf_load;
   83426:	68ea      	ldr	r2, [r5, #12]
   83428:	692b      	ldr	r3, [r5, #16]
   8342a:	1ad3      	subs	r3, r2, r3
   8342c:	60eb      	str	r3, [r5, #12]
#  endif
				b_restart = udd_ep_run(Is_udd_endpoint_in(i) ?
   8342e:	598a      	ldr	r2, [r1, r6]
   83430:	f412 7f80 	tst.w	r2, #256	; 0x100
   83434:	bf14      	ite	ne
   83436:	f044 0080 	orrne.w	r0, r4, #128	; 0x80
   8343a:	4620      	moveq	r0, r4
							(i | USB_EP_DIR_IN) : i,
						ptr_job->b_shortpacket,
   8343c:	7d29      	ldrb	r1, [r5, #20]
					ptr_job->buf_cnt -= ptr_job->buf_load;
				}
#  else
				ptr_job->buf_cnt -= ptr_job->buf_load;
#  endif
				b_restart = udd_ep_run(Is_udd_endpoint_in(i) ?
   8343e:	f8d5 e004 	ldr.w	lr, [r5, #4]
   83442:	68ad      	ldr	r5, [r5, #8]
   83444:	f858 203c 	ldr.w	r2, [r8, ip, lsl #3]
   83448:	9200      	str	r2, [sp, #0]
   8344a:	f3c1 0140 	ubfx	r1, r1, #1, #1
   8344e:	eb0e 0203 	add.w	r2, lr, r3
   83452:	1aeb      	subs	r3, r5, r3
   83454:	4d10      	ldr	r5, [pc, #64]	; (83498 <udd_ep_alloc+0x1d0>)
   83456:	47a8      	blx	r5
						ptr_job->b_shortpacket,
						&ptr_job->buf[ptr_job->buf_cnt],
						ptr_job->buf_size
							- ptr_job->buf_cnt,
						ptr_job->call_trans);
				if (!b_restart) {
   83458:	b168      	cbz	r0, 83476 <udd_ep_alloc+0x1ae>
			udd_unallocate_memory(i);
		}
	}

	// Realloc/Enable endpoints
	for (i = ep; i <= USB_DEVICE_MAX_EP; i++) {
   8345a:	3401      	adds	r4, #1
   8345c:	b2e4      	uxtb	r4, r4
   8345e:	2c04      	cmp	r4, #4
   83460:	d1a3      	bne.n	833aa <udd_ep_alloc+0xe2>
					return false;
				}
			}
		}
	}
	return true;
   83462:	2001      	movs	r0, #1
   83464:	e00f      	b.n	83486 <udd_ep_alloc+0x1be>

	b_dir_in = ep & USB_EP_DIR_IN;
	ep = ep & USB_EP_ADDR_MASK;

	if (ep > USB_DEVICE_MAX_EP) {
		return false;
   83466:	2000      	movs	r0, #0
   83468:	e00d      	b.n	83486 <udd_ep_alloc+0x1be>
	}
	if (Is_udd_endpoint_enabled(ep)) {
		return false;
   8346a:	2000      	movs	r0, #0
   8346c:	e00b      	b.n	83486 <udd_ep_alloc+0x1be>
	case USB_EP_TYPE_BULK:
		nb_bank = UDD_BULK_NB_BANK(ep);
		break;
	default:
		Assert(false);
		return false;
   8346e:	2000      	movs	r0, #0
   83470:	e009      	b.n	83486 <udd_ep_alloc+0x1be>
			udd_allocate_memory(i);
			udd_enable_endpoint(i);
			if (!Is_udd_endpoint_configured(i)) {
				dbg_print("ErrRealloc%d ", i);
				if (NULL == ptr_job->call_trans) {
					return false;
   83472:	2000      	movs	r0, #0
   83474:	e007      	b.n	83486 <udd_ep_alloc+0x1be>
						ptr_job->buf_size
							- ptr_job->buf_cnt,
						ptr_job->call_trans);
				if (!b_restart) {
					dbg_print("ErrReRun%d ", i);
					return false;
   83476:	2000      	movs	r0, #0
   83478:	e005      	b.n	83486 <udd_ep_alloc+0x1be>
	}

	// Realloc/Enable endpoints
	for (i = ep; i <= USB_DEVICE_MAX_EP; i++) {
		if (ep_allocated & (1 << i)) {
			udd_ep_job_t *ptr_job = &udd_ep_job[i - 1];
   8347a:	f8df 8020 	ldr.w	r8, [pc, #32]	; 8349c <udd_ep_alloc+0x1d4>
			bool b_restart = ptr_job->busy;
			// Restart running job because
			// memory window slides up and its data is lost
			ptr_job->busy = false;
			// Re-allocate memory
			udd_allocate_memory(i);
   8347e:	4e04      	ldr	r6, [pc, #16]	; (83490 <udd_ep_alloc+0x1c8>)
			udd_enable_endpoint(i);
			if (!Is_udd_endpoint_configured(i)) {
   83480:	f8df 901c 	ldr.w	r9, [pc, #28]	; 834a0 <udd_ep_alloc+0x1d8>
   83484:	e791      	b.n	833aa <udd_ep_alloc+0xe2>
				}
			}
		}
	}
	return true;
}
   83486:	b003      	add	sp, #12
   83488:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   8348c:	400ac000 	.word	0x400ac000
   83490:	400ac100 	.word	0x400ac100
   83494:	400ac10c 	.word	0x400ac10c
   83498:	000831d5 	.word	0x000831d5
   8349c:	200716bc 	.word	0x200716bc
   834a0:	400ac130 	.word	0x400ac130

000834a4 <udd_ep_abort>:
#endif
}


void udd_ep_abort(udd_ep_id_t ep)
{
   834a4:	b570      	push	{r4, r5, r6, lr}
	uint8_t ep_index = ep & USB_EP_ADDR_MASK;
   834a6:	f000 020f 	and.w	r2, r0, #15
		udd_disable_in_send_interrupt(ep_index);
	} else
#endif
	{
		// Stop DMA transfer
		udd_disable_endpoint_dma_interrupt(ep_index);
   834aa:	1e56      	subs	r6, r2, #1
   834ac:	f04f 7100 	mov.w	r1, #33554432	; 0x2000000
   834b0:	40b1      	lsls	r1, r6
   834b2:	4b15      	ldr	r3, [pc, #84]	; (83508 <udd_ep_abort+0x64>)
   834b4:	6159      	str	r1, [r3, #20]
		udd_endpoint_dma_set_control(ep_index, 0);
   834b6:	4915      	ldr	r1, [pc, #84]	; (8350c <udd_ep_abort+0x68>)
   834b8:	eb01 1102 	add.w	r1, r1, r2, lsl #4
   834bc:	2400      	movs	r4, #0
   834be:	608c      	str	r4, [r1, #8]
	}
	udd_disable_endpoint_interrupt(ep_index);
   834c0:	f44f 5180 	mov.w	r1, #4096	; 0x1000
   834c4:	4091      	lsls	r1, r2
   834c6:	6159      	str	r1, [r3, #20]
	// Kill IN banks
	if (ep & USB_EP_DIR_IN) {
   834c8:	f010 0f80 	tst.w	r0, #128	; 0x80
   834cc:	d012      	beq.n	834f4 <udd_ep_abort+0x50>
		while(udd_nb_busy_bank(ep_index)) {
   834ce:	0093      	lsls	r3, r2, #2
   834d0:	480f      	ldr	r0, [pc, #60]	; (83510 <udd_ep_abort+0x6c>)
   834d2:	4418      	add	r0, r3
			udd_kill_last_in_bank(ep_index);
   834d4:	4c0f      	ldr	r4, [pc, #60]	; (83514 <udd_ep_abort+0x70>)
   834d6:	441c      	add	r4, r3
   834d8:	f44f 5500 	mov.w	r5, #8192	; 0x2000
			while(Is_udd_kill_last(ep_index));
   834dc:	490e      	ldr	r1, [pc, #56]	; (83518 <udd_ep_abort+0x74>)
   834de:	4419      	add	r1, r3
   834e0:	e004      	b.n	834ec <udd_ep_abort+0x48>
	}
	udd_disable_endpoint_interrupt(ep_index);
	// Kill IN banks
	if (ep & USB_EP_DIR_IN) {
		while(udd_nb_busy_bank(ep_index)) {
			udd_kill_last_in_bank(ep_index);
   834e2:	6025      	str	r5, [r4, #0]
			while(Is_udd_kill_last(ep_index));
   834e4:	680b      	ldr	r3, [r1, #0]
   834e6:	f413 5f00 	tst.w	r3, #8192	; 0x2000
   834ea:	d1fb      	bne.n	834e4 <udd_ep_abort+0x40>
		udd_endpoint_dma_set_control(ep_index, 0);
	}
	udd_disable_endpoint_interrupt(ep_index);
	// Kill IN banks
	if (ep & USB_EP_DIR_IN) {
		while(udd_nb_busy_bank(ep_index)) {
   834ec:	6803      	ldr	r3, [r0, #0]
   834ee:	f413 5f40 	tst.w	r3, #12288	; 0x3000
   834f2:	d1f6      	bne.n	834e2 <udd_ep_abort+0x3e>
static void udd_ep_abort_job(udd_ep_id_t ep)
{
	ep &= USB_EP_ADDR_MASK;

	// Abort job on endpoint
	udd_ep_finish_job(&udd_ep_job[ep - 1], true, ep);
   834f4:	eb06 0646 	add.w	r6, r6, r6, lsl #1
   834f8:	4808      	ldr	r0, [pc, #32]	; (8351c <udd_ep_abort+0x78>)
   834fa:	eb00 00c6 	add.w	r0, r0, r6, lsl #3
   834fe:	2101      	movs	r1, #1
   83500:	4b07      	ldr	r3, [pc, #28]	; (83520 <udd_ep_abort+0x7c>)
   83502:	4798      	blx	r3
   83504:	bd70      	pop	{r4, r5, r6, pc}
   83506:	bf00      	nop
   83508:	400ac000 	.word	0x400ac000
   8350c:	400ac300 	.word	0x400ac300
   83510:	400ac130 	.word	0x400ac130
   83514:	400ac1f0 	.word	0x400ac1f0
   83518:	400ac1c0 	.word	0x400ac1c0
   8351c:	200716bc 	.word	0x200716bc
   83520:	000824e9 	.word	0x000824e9

00083524 <udd_test_mode_j>:

#ifdef USB_DEVICE_HS_SUPPORT

void udd_test_mode_j(void)
{
	udd_enable_hs_test_mode();
   83524:	4b05      	ldr	r3, [pc, #20]	; (8353c <udd_test_mode_j+0x18>)
   83526:	681a      	ldr	r2, [r3, #0]
   83528:	f422 6240 	bic.w	r2, r2, #3072	; 0xc00
   8352c:	f442 6200 	orr.w	r2, r2, #2048	; 0x800
   83530:	601a      	str	r2, [r3, #0]
	udd_enable_hs_test_mode_j();
   83532:	681a      	ldr	r2, [r3, #0]
   83534:	f442 5200 	orr.w	r2, r2, #8192	; 0x2000
   83538:	601a      	str	r2, [r3, #0]
   8353a:	4770      	bx	lr
   8353c:	400ac000 	.word	0x400ac000

00083540 <udd_test_mode_k>:
}


void udd_test_mode_k(void)
{
	udd_enable_hs_test_mode();
   83540:	4b05      	ldr	r3, [pc, #20]	; (83558 <udd_test_mode_k+0x18>)
   83542:	681a      	ldr	r2, [r3, #0]
   83544:	f422 6240 	bic.w	r2, r2, #3072	; 0xc00
   83548:	f442 6200 	orr.w	r2, r2, #2048	; 0x800
   8354c:	601a      	str	r2, [r3, #0]
	udd_enable_hs_test_mode_k();
   8354e:	681a      	ldr	r2, [r3, #0]
   83550:	f442 4280 	orr.w	r2, r2, #16384	; 0x4000
   83554:	601a      	str	r2, [r3, #0]
   83556:	4770      	bx	lr
   83558:	400ac000 	.word	0x400ac000

0008355c <udd_test_mode_se0_nak>:
}


void udd_test_mode_se0_nak(void)
{
	udd_enable_hs_test_mode();
   8355c:	4b03      	ldr	r3, [pc, #12]	; (8356c <udd_test_mode_se0_nak+0x10>)
   8355e:	681a      	ldr	r2, [r3, #0]
   83560:	f422 6240 	bic.w	r2, r2, #3072	; 0xc00
   83564:	f442 6200 	orr.w	r2, r2, #2048	; 0x800
   83568:	601a      	str	r2, [r3, #0]
   8356a:	4770      	bx	lr
   8356c:	400ac000 	.word	0x400ac000

00083570 <udd_test_mode_packet>:
}


void udd_test_mode_packet(void)
{
   83570:	b4f0      	push	{r4, r5, r6, r7}
   83572:	b08e      	sub	sp, #56	; 0x38
	uint8_t i;
	uint8_t *ptr_dest;
	const uint8_t *ptr_src;

	const uint8_t test_packet[] = {
   83574:	4c22      	ldr	r4, [pc, #136]	; (83600 <udd_test_mode_packet+0x90>)
   83576:	466e      	mov	r6, sp
   83578:	f104 0730 	add.w	r7, r4, #48	; 0x30
   8357c:	4635      	mov	r5, r6
   8357e:	6820      	ldr	r0, [r4, #0]
   83580:	6861      	ldr	r1, [r4, #4]
   83582:	68a2      	ldr	r2, [r4, #8]
   83584:	68e3      	ldr	r3, [r4, #12]
   83586:	c50f      	stmia	r5!, {r0, r1, r2, r3}
   83588:	3410      	adds	r4, #16
   8358a:	462e      	mov	r6, r5
   8358c:	42bc      	cmp	r4, r7
   8358e:	d1f5      	bne.n	8357c <udd_test_mode_packet+0xc>
   83590:	6820      	ldr	r0, [r4, #0]
   83592:	6028      	str	r0, [r5, #0]
   83594:	7923      	ldrb	r3, [r4, #4]
   83596:	712b      	strb	r3, [r5, #4]
		// 00111111, {S0111111 * 9}, S0
		0xFC, 0x7E, 0xBF, 0xDF, 0xEF, 0xF7, 0xFB, 0xFD, 0x7E
	};

	// Reconfigure control endpoint to bulk IN endpoint
	udd_disable_endpoint(0);
   83598:	4b1a      	ldr	r3, [pc, #104]	; (83604 <udd_test_mode_packet+0x94>)
   8359a:	69da      	ldr	r2, [r3, #28]
   8359c:	f022 0201 	bic.w	r2, r2, #1
   835a0:	61da      	str	r2, [r3, #28]
	udd_configure_endpoint(0, USB_EP_TYPE_BULK, 1,
   835a2:	4a19      	ldr	r2, [pc, #100]	; (83608 <udd_test_mode_packet+0x98>)
   835a4:	6811      	ldr	r1, [r2, #0]
   835a6:	f421 51cb 	bic.w	r1, r1, #6496	; 0x1960
   835aa:	f021 011c 	bic.w	r1, r1, #28
   835ae:	f441 5189 	orr.w	r1, r1, #4384	; 0x1120
   835b2:	f041 0110 	orr.w	r1, r1, #16
   835b6:	6011      	str	r1, [r2, #0]
			64, UOTGHS_DEVEPTCFG_EPBK_1_BANK);
	udd_allocate_memory(0);
   835b8:	6811      	ldr	r1, [r2, #0]
   835ba:	f041 0102 	orr.w	r1, r1, #2
   835be:	6011      	str	r1, [r2, #0]
	udd_enable_endpoint(0);
   835c0:	69da      	ldr	r2, [r3, #28]
   835c2:	f042 0201 	orr.w	r2, r2, #1
   835c6:	61da      	str	r2, [r3, #28]

	udd_enable_hs_test_mode();
   835c8:	681a      	ldr	r2, [r3, #0]
   835ca:	f422 6240 	bic.w	r2, r2, #3072	; 0xc00
   835ce:	f442 6200 	orr.w	r2, r2, #2048	; 0x800
   835d2:	601a      	str	r2, [r3, #0]
	udd_enable_hs_test_mode_packet();
   835d4:	681a      	ldr	r2, [r3, #0]
   835d6:	f442 4200 	orr.w	r2, r2, #32768	; 0x8000
   835da:	601a      	str	r2, [r3, #0]

	// Send packet on endpoint 0
	ptr_dest = (uint8_t *) & udd_get_endpoint_fifo_access(0, 8);
	ptr_src = test_packet;
   835dc:	466b      	mov	r3, sp

	udd_enable_hs_test_mode();
	udd_enable_hs_test_mode_packet();

	// Send packet on endpoint 0
	ptr_dest = (uint8_t *) & udd_get_endpoint_fifo_access(0, 8);
   835de:	4a0b      	ldr	r2, [pc, #44]	; (8360c <udd_test_mode_packet+0x9c>)
	ptr_src = test_packet;

	for (i = 0; i < sizeof(test_packet); i++) {
   835e0:	f10d 0035 	add.w	r0, sp, #53	; 0x35
		*ptr_dest++ = *ptr_src++;
   835e4:	f813 1b01 	ldrb.w	r1, [r3], #1
   835e8:	f802 1b01 	strb.w	r1, [r2], #1

	// Send packet on endpoint 0
	ptr_dest = (uint8_t *) & udd_get_endpoint_fifo_access(0, 8);
	ptr_src = test_packet;

	for (i = 0; i < sizeof(test_packet); i++) {
   835ec:	4283      	cmp	r3, r0
   835ee:	d1f9      	bne.n	835e4 <udd_test_mode_packet+0x74>
		*ptr_dest++ = *ptr_src++;
	}
	udd_ack_fifocon(0);
   835f0:	f44f 4280 	mov.w	r2, #16384	; 0x4000
   835f4:	4b06      	ldr	r3, [pc, #24]	; (83610 <udd_test_mode_packet+0xa0>)
   835f6:	601a      	str	r2, [r3, #0]
}
   835f8:	b00e      	add	sp, #56	; 0x38
   835fa:	bcf0      	pop	{r4, r5, r6, r7}
   835fc:	4770      	bx	lr
   835fe:	bf00      	nop
   83600:	0008b4a0 	.word	0x0008b4a0
   83604:	400ac000 	.word	0x400ac000
   83608:	400ac100 	.word	0x400ac100
   8360c:	20180000 	.word	0x20180000
   83610:	400ac220 	.word	0x400ac220

00083614 <usart_set_async_baudrate>:
 * \retval 1 Baud rate set point is out of range for the given input clock
 * frequency.
 */
uint32_t usart_set_async_baudrate(Usart *p_usart,
		uint32_t baudrate, uint32_t ul_mck)
{
   83614:	b410      	push	{r4}
	uint32_t cd_fp;
	uint32_t cd;
	uint32_t fp;

	/* Calculate the receiver sampling divide of baudrate clock. */
	if (ul_mck >= HIGH_FRQ_SAMPLE_DIV * baudrate) {
   83616:	010b      	lsls	r3, r1, #4
   83618:	4293      	cmp	r3, r2
   8361a:	d90d      	bls.n	83638 <usart_set_async_baudrate+0x24>
   8361c:	e01a      	b.n	83654 <usart_set_async_baudrate+0x40>
		return 1;
	}

	/* Configure the OVER bit in MR register. */
	if (over == 8) {
		p_usart->US_MR |= US_MR_OVER;
   8361e:	6841      	ldr	r1, [r0, #4]
   83620:	f441 2100 	orr.w	r1, r1, #524288	; 0x80000
   83624:	6041      	str	r1, [r0, #4]
	}

	/* Configure the baudrate generate register. */
	p_usart->US_BRGR = (cd << US_BRGR_CD_Pos) | (fp << US_BRGR_FP_Pos);
   83626:	ea42 4303 	orr.w	r3, r2, r3, lsl #16
   8362a:	6203      	str	r3, [r0, #32]

	return 0;
   8362c:	2000      	movs	r0, #0
   8362e:	e020      	b.n	83672 <usart_set_async_baudrate+0x5e>
	/* Calculate clock divider according to the fraction calculated formula. */
	cd_fp = (8 * ul_mck + (over * baudrate) / 2) / (over * baudrate);
	cd = cd_fp >> 3;
	fp = cd_fp & 0x07;
	if (cd < MIN_CD_VALUE || cd > MAX_CD_VALUE) {
		return 1;
   83630:	2001      	movs	r0, #1
   83632:	e01e      	b.n	83672 <usart_set_async_baudrate+0x5e>
   83634:	2001      	movs	r0, #1
   83636:	e01c      	b.n	83672 <usart_set_async_baudrate+0x5e>
	} else {
		over = LOW_FRQ_SAMPLE_DIV;
	}

	/* Calculate clock divider according to the fraction calculated formula. */
	cd_fp = (8 * ul_mck + (over * baudrate) / 2) / (over * baudrate);
   83638:	00d2      	lsls	r2, r2, #3
   8363a:	eb02 0253 	add.w	r2, r2, r3, lsr #1
   8363e:	fbb2 f3f3 	udiv	r3, r2, r3
	cd = cd_fp >> 3;
   83642:	08da      	lsrs	r2, r3, #3
	fp = cd_fp & 0x07;
   83644:	f003 0307 	and.w	r3, r3, #7
	if (cd < MIN_CD_VALUE || cd > MAX_CD_VALUE) {
   83648:	1e54      	subs	r4, r2, #1
   8364a:	f64f 71fe 	movw	r1, #65534	; 0xfffe
   8364e:	428c      	cmp	r4, r1
   83650:	d9e9      	bls.n	83626 <usart_set_async_baudrate+0x12>
   83652:	e7ed      	b.n	83630 <usart_set_async_baudrate+0x1c>
	} else {
		over = LOW_FRQ_SAMPLE_DIV;
	}

	/* Calculate clock divider according to the fraction calculated formula. */
	cd_fp = (8 * ul_mck + (over * baudrate) / 2) / (over * baudrate);
   83654:	00c9      	lsls	r1, r1, #3
   83656:	00d3      	lsls	r3, r2, #3
   83658:	eb03 0351 	add.w	r3, r3, r1, lsr #1
   8365c:	fbb3 f3f1 	udiv	r3, r3, r1
	cd = cd_fp >> 3;
   83660:	08da      	lsrs	r2, r3, #3
	fp = cd_fp & 0x07;
   83662:	f003 0307 	and.w	r3, r3, #7
	if (cd < MIN_CD_VALUE || cd > MAX_CD_VALUE) {
   83666:	1e54      	subs	r4, r2, #1
   83668:	f64f 71fe 	movw	r1, #65534	; 0xfffe
   8366c:	428c      	cmp	r4, r1
   8366e:	d9d6      	bls.n	8361e <usart_set_async_baudrate+0xa>
   83670:	e7e0      	b.n	83634 <usart_set_async_baudrate+0x20>

	/* Configure the baudrate generate register. */
	p_usart->US_BRGR = (cd << US_BRGR_CD_Pos) | (fp << US_BRGR_FP_Pos);

	return 0;
}
   83672:	f85d 4b04 	ldr.w	r4, [sp], #4
   83676:	4770      	bx	lr

00083678 <usart_reset>:
 *
 * \param p_usart Pointer to a USART instance.
 */
void usart_disable_writeprotect(Usart *p_usart)
{
	p_usart->US_WPMR = US_WPMR_WPKEY_PASSWD;
   83678:	4b08      	ldr	r3, [pc, #32]	; (8369c <usart_reset+0x24>)
   8367a:	f8c0 30e4 	str.w	r3, [r0, #228]	; 0xe4
{
	/* Disable the Write Protect. */
	usart_disable_writeprotect(p_usart);

	/* Reset registers that could cause unpredictable behavior after reset. */
	p_usart->US_MR = 0;
   8367e:	2300      	movs	r3, #0
   83680:	6043      	str	r3, [r0, #4]
	p_usart->US_RTOR = 0;
   83682:	6243      	str	r3, [r0, #36]	; 0x24
	p_usart->US_TTGR = 0;
   83684:	6283      	str	r3, [r0, #40]	; 0x28
 * \param p_usart Pointer to a USART instance.
 */
void usart_reset_tx(Usart *p_usart)
{
	/* Reset transmitter */
	p_usart->US_CR = US_CR_RSTTX | US_CR_TXDIS;
   83686:	2388      	movs	r3, #136	; 0x88
   83688:	6003      	str	r3, [r0, #0]
 * \param p_usart Pointer to a USART instance.
 */
void usart_reset_rx(Usart *p_usart)
{
	/* Reset Receiver */
	p_usart->US_CR = US_CR_RSTRX | US_CR_RXDIS;
   8368a:	2324      	movs	r3, #36	; 0x24
   8368c:	6003      	str	r3, [r0, #0]
 *
 * \param p_usart Pointer to a USART instance.
 */
void usart_reset_status(Usart *p_usart)
{
	p_usart->US_CR = US_CR_RSTSTA;
   8368e:	f44f 7380 	mov.w	r3, #256	; 0x100
   83692:	6003      	str	r3, [r0, #0]
 *
 * \param p_usart Pointer to a USART instance.
 */
void usart_drive_RTS_pin_high(Usart *p_usart)
{
	p_usart->US_CR = US_CR_RTSDIS;
   83694:	f44f 2300 	mov.w	r3, #524288	; 0x80000
   83698:	6003      	str	r3, [r0, #0]
   8369a:	4770      	bx	lr
   8369c:	55534100 	.word	0x55534100

000836a0 <usart_init_rs232>:
 * \retval 0 on success.
 * \retval 1 on failure.
 */
uint32_t usart_init_rs232(Usart *p_usart,
		const sam_usart_opt_t *p_usart_opt, uint32_t ul_mck)
{
   836a0:	b570      	push	{r4, r5, r6, lr}
   836a2:	4605      	mov	r5, r0
   836a4:	460c      	mov	r4, r1
   836a6:	4616      	mov	r6, r2
	static uint32_t ul_reg_val;

	/* Reset the USART and shut down TX and RX. */
	usart_reset(p_usart);
   836a8:	4b0f      	ldr	r3, [pc, #60]	; (836e8 <usart_init_rs232+0x48>)
   836aa:	4798      	blx	r3

	ul_reg_val = 0;
   836ac:	2100      	movs	r1, #0
   836ae:	4b0f      	ldr	r3, [pc, #60]	; (836ec <usart_init_rs232+0x4c>)
   836b0:	6019      	str	r1, [r3, #0]
	/* Check whether the input values are legal. */
	if (!p_usart_opt || usart_set_async_baudrate(p_usart,
   836b2:	b19c      	cbz	r4, 836dc <usart_init_rs232+0x3c>
   836b4:	4628      	mov	r0, r5
   836b6:	6821      	ldr	r1, [r4, #0]
   836b8:	4632      	mov	r2, r6
   836ba:	4b0d      	ldr	r3, [pc, #52]	; (836f0 <usart_init_rs232+0x50>)
   836bc:	4798      	blx	r3
   836be:	4603      	mov	r3, r0
   836c0:	b970      	cbnz	r0, 836e0 <usart_init_rs232+0x40>
			p_usart_opt->baudrate, ul_mck)) {
		return 1;
	}

	/* Configure the USART option. */
	ul_reg_val |= p_usart_opt->char_length | p_usart_opt->parity_type |
   836c2:	68a1      	ldr	r1, [r4, #8]
   836c4:	6862      	ldr	r2, [r4, #4]
   836c6:	430a      	orrs	r2, r1
   836c8:	6921      	ldr	r1, [r4, #16]
   836ca:	430a      	orrs	r2, r1
			p_usart_opt->channel_mode | p_usart_opt->stop_bits;
   836cc:	68e0      	ldr	r0, [r4, #12]
   836ce:	4302      	orrs	r2, r0
			p_usart_opt->baudrate, ul_mck)) {
		return 1;
	}

	/* Configure the USART option. */
	ul_reg_val |= p_usart_opt->char_length | p_usart_opt->parity_type |
   836d0:	4906      	ldr	r1, [pc, #24]	; (836ec <usart_init_rs232+0x4c>)
   836d2:	600a      	str	r2, [r1, #0]
			p_usart_opt->channel_mode | p_usart_opt->stop_bits;

	/* Configure the USART mode as normal mode. */
	ul_reg_val |= US_MR_USART_MODE_NORMAL;

	p_usart->US_MR |= ul_reg_val;
   836d4:	6869      	ldr	r1, [r5, #4]
   836d6:	430a      	orrs	r2, r1
   836d8:	606a      	str	r2, [r5, #4]

	return 0;
   836da:	e002      	b.n	836e2 <usart_init_rs232+0x42>

	ul_reg_val = 0;
	/* Check whether the input values are legal. */
	if (!p_usart_opt || usart_set_async_baudrate(p_usart,
			p_usart_opt->baudrate, ul_mck)) {
		return 1;
   836dc:	2301      	movs	r3, #1
   836de:	e000      	b.n	836e2 <usart_init_rs232+0x42>
   836e0:	2301      	movs	r3, #1
	ul_reg_val |= US_MR_USART_MODE_NORMAL;

	p_usart->US_MR |= ul_reg_val;

	return 0;
}
   836e2:	4618      	mov	r0, r3
   836e4:	bd70      	pop	{r4, r5, r6, pc}
   836e6:	bf00      	nop
   836e8:	00083679 	.word	0x00083679
   836ec:	20071708 	.word	0x20071708
   836f0:	00083615 	.word	0x00083615

000836f4 <usart_enable_tx>:
 *
 * \param p_usart Pointer to a USART instance.
 */
void usart_enable_tx(Usart *p_usart)
{
	p_usart->US_CR = US_CR_TXEN;
   836f4:	2340      	movs	r3, #64	; 0x40
   836f6:	6003      	str	r3, [r0, #0]
   836f8:	4770      	bx	lr
   836fa:	bf00      	nop

000836fc <usart_disable_tx>:
 *
 * \param p_usart Pointer to a USART instance.
 */
void usart_disable_tx(Usart *p_usart)
{
	p_usart->US_CR = US_CR_TXDIS;
   836fc:	2380      	movs	r3, #128	; 0x80
   836fe:	6003      	str	r3, [r0, #0]
   83700:	4770      	bx	lr
   83702:	bf00      	nop

00083704 <usart_enable_rx>:
 *
 * \param p_usart Pointer to a USART instance.
 */
void usart_enable_rx(Usart *p_usart)
{
	p_usart->US_CR = US_CR_RXEN;
   83704:	2310      	movs	r3, #16
   83706:	6003      	str	r3, [r0, #0]
   83708:	4770      	bx	lr
   8370a:	bf00      	nop

0008370c <usart_disable_rx>:
 *
 * \param p_usart Pointer to a USART instance.
 */
void usart_disable_rx(Usart *p_usart)
{
	p_usart->US_CR = US_CR_RXDIS;
   8370c:	2320      	movs	r3, #32
   8370e:	6003      	str	r3, [r0, #0]
   83710:	4770      	bx	lr
   83712:	bf00      	nop

00083714 <usart_set_rx_timeout>:
 * \param p_usart Pointer to a USART instance.
 * \param timeout The value of receive timeout.
 */
void usart_set_rx_timeout(Usart *p_usart, uint32_t timeout)
{
	p_usart->US_RTOR = timeout;
   83714:	6241      	str	r1, [r0, #36]	; 0x24
   83716:	4770      	bx	lr

00083718 <usart_enable_interrupt>:
 * \param p_usart Pointer to a USART peripheral.
 * \param ul_sources Interrupt sources bit map.
 */
void usart_enable_interrupt(Usart *p_usart, uint32_t ul_sources)
{
	p_usart->US_IER = ul_sources;
   83718:	6081      	str	r1, [r0, #8]
   8371a:	4770      	bx	lr

0008371c <usart_disable_interrupt>:
 * \param p_usart Pointer to a USART peripheral.
 * \param ul_sources Interrupt sources bit map.
 */
void usart_disable_interrupt(Usart *p_usart, uint32_t ul_sources)
{
	p_usart->US_IDR = ul_sources;
   8371c:	60c1      	str	r1, [r0, #12]
   8371e:	4770      	bx	lr

00083720 <usart_get_interrupt_mask>:
 *
 * \return The interrupt mask value.
 */
uint32_t usart_get_interrupt_mask(Usart *p_usart)
{
	return p_usart->US_IMR;
   83720:	6900      	ldr	r0, [r0, #16]
}
   83722:	4770      	bx	lr

00083724 <usart_get_status>:
 *
 * \return The current USART status.
 */
uint32_t usart_get_status(Usart *p_usart)
{
	return p_usart->US_CSR;
   83724:	6940      	ldr	r0, [r0, #20]
}
   83726:	4770      	bx	lr

00083728 <usart_reset_status>:
 *
 * \param p_usart Pointer to a USART instance.
 */
void usart_reset_status(Usart *p_usart)
{
	p_usart->US_CR = US_CR_RSTSTA;
   83728:	f44f 7380 	mov.w	r3, #256	; 0x100
   8372c:	6003      	str	r3, [r0, #0]
   8372e:	4770      	bx	lr

00083730 <usart_start_rx_timeout>:
 *
 * \param p_usart Pointer to a USART instance.
 */
void usart_start_rx_timeout(Usart *p_usart)
{
	p_usart->US_CR = US_CR_STTTO;
   83730:	f44f 6300 	mov.w	r3, #2048	; 0x800
   83734:	6003      	str	r3, [r0, #0]
   83736:	4770      	bx	lr

00083738 <Dummy_Handler>:

/**
 * \brief Default interrupt handler for unused IRQs.
 */
void Dummy_Handler(void)
{
   83738:	e7fe      	b.n	83738 <Dummy_Handler>
   8373a:	bf00      	nop

0008373c <Reset_Handler>:
/**
 * \brief This is the code that gets called on processor reset.
 * To initialize the device, and call the main() routine.
 */
void Reset_Handler(void)
{
   8373c:	b510      	push	{r4, lr}

	/* Initialize the relocate segment */
	pSrc = &_etext;
	pDest = &_srelocate;

	if (pSrc != pDest) {
   8373e:	4b1e      	ldr	r3, [pc, #120]	; (837b8 <Reset_Handler+0x7c>)
   83740:	4a1e      	ldr	r2, [pc, #120]	; (837bc <Reset_Handler+0x80>)
   83742:	429a      	cmp	r2, r3
   83744:	d003      	beq.n	8374e <Reset_Handler+0x12>
		for (; pDest < &_erelocate;) {
   83746:	4b1e      	ldr	r3, [pc, #120]	; (837c0 <Reset_Handler+0x84>)
   83748:	4a1b      	ldr	r2, [pc, #108]	; (837b8 <Reset_Handler+0x7c>)
   8374a:	429a      	cmp	r2, r3
   8374c:	d304      	bcc.n	83758 <Reset_Handler+0x1c>
			*pDest++ = *pSrc++;
		}
	}

	/* Clear the zero segment */
	for (pDest = &_szero; pDest < &_ezero;) {
   8374e:	4b1d      	ldr	r3, [pc, #116]	; (837c4 <Reset_Handler+0x88>)
   83750:	4a1d      	ldr	r2, [pc, #116]	; (837c8 <Reset_Handler+0x8c>)
   83752:	429a      	cmp	r2, r3
   83754:	d30f      	bcc.n	83776 <Reset_Handler+0x3a>
   83756:	e01a      	b.n	8378e <Reset_Handler+0x52>
   83758:	4b1c      	ldr	r3, [pc, #112]	; (837cc <Reset_Handler+0x90>)
   8375a:	4c1d      	ldr	r4, [pc, #116]	; (837d0 <Reset_Handler+0x94>)
   8375c:	1ae4      	subs	r4, r4, r3
   8375e:	f024 0403 	bic.w	r4, r4, #3
   83762:	3404      	adds	r4, #4
	/* Initialize the relocate segment */
	pSrc = &_etext;
	pDest = &_srelocate;

	if (pSrc != pDest) {
		for (; pDest < &_erelocate;) {
   83764:	2300      	movs	r3, #0
			*pDest++ = *pSrc++;
   83766:	4814      	ldr	r0, [pc, #80]	; (837b8 <Reset_Handler+0x7c>)
   83768:	4914      	ldr	r1, [pc, #80]	; (837bc <Reset_Handler+0x80>)
   8376a:	585a      	ldr	r2, [r3, r1]
   8376c:	501a      	str	r2, [r3, r0]
   8376e:	3304      	adds	r3, #4
	/* Initialize the relocate segment */
	pSrc = &_etext;
	pDest = &_srelocate;

	if (pSrc != pDest) {
		for (; pDest < &_erelocate;) {
   83770:	42a3      	cmp	r3, r4
   83772:	d1fa      	bne.n	8376a <Reset_Handler+0x2e>
   83774:	e7eb      	b.n	8374e <Reset_Handler+0x12>
   83776:	4b17      	ldr	r3, [pc, #92]	; (837d4 <Reset_Handler+0x98>)
   83778:	4917      	ldr	r1, [pc, #92]	; (837d8 <Reset_Handler+0x9c>)
   8377a:	1ac9      	subs	r1, r1, r3
   8377c:	f021 0103 	bic.w	r1, r1, #3
   83780:	1d1a      	adds	r2, r3, #4
   83782:	4411      	add	r1, r2
		}
	}

	/* Clear the zero segment */
	for (pDest = &_szero; pDest < &_ezero;) {
		*pDest++ = 0;
   83784:	2200      	movs	r2, #0
   83786:	f843 2f04 	str.w	r2, [r3, #4]!
			*pDest++ = *pSrc++;
		}
	}

	/* Clear the zero segment */
	for (pDest = &_szero; pDest < &_ezero;) {
   8378a:	428b      	cmp	r3, r1
   8378c:	d1fb      	bne.n	83786 <Reset_Handler+0x4a>
		*pDest++ = 0;
	}

	/* Set the vector table base address */
	pSrc = (uint32_t *) & _sfixed;
	SCB->VTOR = ((uint32_t) pSrc & SCB_VTOR_TBLOFF_Msk);
   8378e:	4a13      	ldr	r2, [pc, #76]	; (837dc <Reset_Handler+0xa0>)
   83790:	f022 4360 	bic.w	r3, r2, #3758096384	; 0xe0000000
   83794:	f023 037f 	bic.w	r3, r3, #127	; 0x7f
   83798:	4911      	ldr	r1, [pc, #68]	; (837e0 <Reset_Handler+0xa4>)
   8379a:	608b      	str	r3, [r1, #8]

	if (((uint32_t) pSrc >= IRAM0_ADDR) && ((uint32_t) pSrc < NFC_RAM_ADDR)) {
   8379c:	f102 4260 	add.w	r2, r2, #3758096384	; 0xe0000000
   837a0:	f5b2 1f80 	cmp.w	r2, #1048576	; 0x100000
   837a4:	d203      	bcs.n	837ae <Reset_Handler+0x72>
		SCB->VTOR |= 1 << SCB_VTOR_TBLBASE_Pos;
   837a6:	688a      	ldr	r2, [r1, #8]
   837a8:	f042 5200 	orr.w	r2, r2, #536870912	; 0x20000000
   837ac:	608a      	str	r2, [r1, #8]
	}

	/* Initialize the C library */
	__libc_init_array();
   837ae:	4b0d      	ldr	r3, [pc, #52]	; (837e4 <Reset_Handler+0xa8>)
   837b0:	4798      	blx	r3

	/* Branch to main function */
	main();
   837b2:	4b0d      	ldr	r3, [pc, #52]	; (837e8 <Reset_Handler+0xac>)
   837b4:	4798      	blx	r3
   837b6:	e7fe      	b.n	837b6 <Reset_Handler+0x7a>
   837b8:	20070000 	.word	0x20070000
   837bc:	0008cec0 	.word	0x0008cec0
   837c0:	20070ce0 	.word	0x20070ce0
   837c4:	20075c60 	.word	0x20075c60
   837c8:	20070ce0 	.word	0x20070ce0
   837cc:	20070004 	.word	0x20070004
   837d0:	20070ce3 	.word	0x20070ce3
   837d4:	20070cdc 	.word	0x20070cdc
   837d8:	20075c5b 	.word	0x20075c5b
   837dc:	00080000 	.word	0x00080000
   837e0:	e000ed00 	.word	0xe000ed00
   837e4:	0008621d 	.word	0x0008621d
   837e8:	00085fb1 	.word	0x00085fb1

000837ec <SystemCoreClockUpdate>:
}

void SystemCoreClockUpdate(void)
{
	/* Determine clock frequency according to clock register values */
	switch (PMC->PMC_MCKR & PMC_MCKR_CSS_Msk) {
   837ec:	4b3e      	ldr	r3, [pc, #248]	; (838e8 <SystemCoreClockUpdate+0xfc>)
   837ee:	6b1b      	ldr	r3, [r3, #48]	; 0x30
   837f0:	f003 0303 	and.w	r3, r3, #3
   837f4:	2b03      	cmp	r3, #3
   837f6:	d85f      	bhi.n	838b8 <SystemCoreClockUpdate+0xcc>
   837f8:	e8df f003 	tbb	[pc, r3]
   837fc:	2b2b0e02 	.word	0x2b2b0e02
	case PMC_MCKR_CSS_SLOW_CLK:	/* Slow clock */
		if (SUPC->SUPC_SR & SUPC_SR_OSCSEL) {
   83800:	4b3a      	ldr	r3, [pc, #232]	; (838ec <SystemCoreClockUpdate+0x100>)
   83802:	695b      	ldr	r3, [r3, #20]
   83804:	f013 0f80 	tst.w	r3, #128	; 0x80
			SystemCoreClock = CHIP_FREQ_XTAL_32K;
   83808:	bf14      	ite	ne
   8380a:	f44f 4200 	movne.w	r2, #32768	; 0x8000
		} else {
			SystemCoreClock = CHIP_FREQ_SLCK_RC;
   8380e:	f44f 42fa 	moveq.w	r2, #32000	; 0x7d00
   83812:	4b37      	ldr	r3, [pc, #220]	; (838f0 <SystemCoreClockUpdate+0x104>)
   83814:	601a      	str	r2, [r3, #0]
   83816:	e04f      	b.n	838b8 <SystemCoreClockUpdate+0xcc>
		}
		break;
	case PMC_MCKR_CSS_MAIN_CLK:	/* Main clock */
		if (PMC->CKGR_MOR & CKGR_MOR_MOSCSEL) {
   83818:	4b33      	ldr	r3, [pc, #204]	; (838e8 <SystemCoreClockUpdate+0xfc>)
   8381a:	6a1b      	ldr	r3, [r3, #32]
   8381c:	f013 7f80 	tst.w	r3, #16777216	; 0x1000000
   83820:	d003      	beq.n	8382a <SystemCoreClockUpdate+0x3e>
			SystemCoreClock = CHIP_FREQ_XTAL_12M;
   83822:	4a34      	ldr	r2, [pc, #208]	; (838f4 <SystemCoreClockUpdate+0x108>)
   83824:	4b32      	ldr	r3, [pc, #200]	; (838f0 <SystemCoreClockUpdate+0x104>)
   83826:	601a      	str	r2, [r3, #0]
   83828:	e046      	b.n	838b8 <SystemCoreClockUpdate+0xcc>
		} else {
			SystemCoreClock = CHIP_FREQ_MAINCK_RC_4MHZ;
   8382a:	4a33      	ldr	r2, [pc, #204]	; (838f8 <SystemCoreClockUpdate+0x10c>)
   8382c:	4b30      	ldr	r3, [pc, #192]	; (838f0 <SystemCoreClockUpdate+0x104>)
   8382e:	601a      	str	r2, [r3, #0]

			switch (PMC->CKGR_MOR & CKGR_MOR_MOSCRCF_Msk) {
   83830:	4b2d      	ldr	r3, [pc, #180]	; (838e8 <SystemCoreClockUpdate+0xfc>)
   83832:	6a1b      	ldr	r3, [r3, #32]
   83834:	f003 0370 	and.w	r3, r3, #112	; 0x70
   83838:	2b10      	cmp	r3, #16
   8383a:	d002      	beq.n	83842 <SystemCoreClockUpdate+0x56>
   8383c:	2b20      	cmp	r3, #32
   8383e:	d004      	beq.n	8384a <SystemCoreClockUpdate+0x5e>
   83840:	e03a      	b.n	838b8 <SystemCoreClockUpdate+0xcc>
			case CKGR_MOR_MOSCRCF_4_MHz:
				break;
			case CKGR_MOR_MOSCRCF_8_MHz:
				SystemCoreClock *= 2U;
   83842:	4a2e      	ldr	r2, [pc, #184]	; (838fc <SystemCoreClockUpdate+0x110>)
   83844:	4b2a      	ldr	r3, [pc, #168]	; (838f0 <SystemCoreClockUpdate+0x104>)
   83846:	601a      	str	r2, [r3, #0]
				break;
   83848:	e036      	b.n	838b8 <SystemCoreClockUpdate+0xcc>
			case CKGR_MOR_MOSCRCF_12_MHz:
				SystemCoreClock *= 3U;
   8384a:	4a2a      	ldr	r2, [pc, #168]	; (838f4 <SystemCoreClockUpdate+0x108>)
   8384c:	4b28      	ldr	r3, [pc, #160]	; (838f0 <SystemCoreClockUpdate+0x104>)
   8384e:	601a      	str	r2, [r3, #0]
				break;
   83850:	e032      	b.n	838b8 <SystemCoreClockUpdate+0xcc>
			}
		}
		break;
	case PMC_MCKR_CSS_PLLA_CLK:	/* PLLA clock */
	case PMC_MCKR_CSS_UPLL_CLK:	/* UPLL clock */
		if (PMC->CKGR_MOR & CKGR_MOR_MOSCSEL) {
   83852:	4b25      	ldr	r3, [pc, #148]	; (838e8 <SystemCoreClockUpdate+0xfc>)
   83854:	6a1b      	ldr	r3, [r3, #32]
   83856:	f013 7f80 	tst.w	r3, #16777216	; 0x1000000
   8385a:	d003      	beq.n	83864 <SystemCoreClockUpdate+0x78>
			SystemCoreClock = CHIP_FREQ_XTAL_12M;
   8385c:	4a25      	ldr	r2, [pc, #148]	; (838f4 <SystemCoreClockUpdate+0x108>)
   8385e:	4b24      	ldr	r3, [pc, #144]	; (838f0 <SystemCoreClockUpdate+0x104>)
   83860:	601a      	str	r2, [r3, #0]
   83862:	e012      	b.n	8388a <SystemCoreClockUpdate+0x9e>
		} else {
			SystemCoreClock = CHIP_FREQ_MAINCK_RC_4MHZ;
   83864:	4a24      	ldr	r2, [pc, #144]	; (838f8 <SystemCoreClockUpdate+0x10c>)
   83866:	4b22      	ldr	r3, [pc, #136]	; (838f0 <SystemCoreClockUpdate+0x104>)
   83868:	601a      	str	r2, [r3, #0]

			switch (PMC->CKGR_MOR & CKGR_MOR_MOSCRCF_Msk) {
   8386a:	4b1f      	ldr	r3, [pc, #124]	; (838e8 <SystemCoreClockUpdate+0xfc>)
   8386c:	6a1b      	ldr	r3, [r3, #32]
   8386e:	f003 0370 	and.w	r3, r3, #112	; 0x70
   83872:	2b10      	cmp	r3, #16
   83874:	d002      	beq.n	8387c <SystemCoreClockUpdate+0x90>
   83876:	2b20      	cmp	r3, #32
   83878:	d004      	beq.n	83884 <SystemCoreClockUpdate+0x98>
   8387a:	e006      	b.n	8388a <SystemCoreClockUpdate+0x9e>
			case CKGR_MOR_MOSCRCF_4_MHz:
				break;
			case CKGR_MOR_MOSCRCF_8_MHz:
				SystemCoreClock *= 2U;
   8387c:	4a1f      	ldr	r2, [pc, #124]	; (838fc <SystemCoreClockUpdate+0x110>)
   8387e:	4b1c      	ldr	r3, [pc, #112]	; (838f0 <SystemCoreClockUpdate+0x104>)
   83880:	601a      	str	r2, [r3, #0]
				break;
   83882:	e002      	b.n	8388a <SystemCoreClockUpdate+0x9e>
			case CKGR_MOR_MOSCRCF_12_MHz:
				SystemCoreClock *= 3U;
   83884:	4a1b      	ldr	r2, [pc, #108]	; (838f4 <SystemCoreClockUpdate+0x108>)
   83886:	4b1a      	ldr	r3, [pc, #104]	; (838f0 <SystemCoreClockUpdate+0x104>)
   83888:	601a      	str	r2, [r3, #0]
				break;
			default:
				break;
			}
		}
		if ((PMC->PMC_MCKR & PMC_MCKR_CSS_Msk) == PMC_MCKR_CSS_PLLA_CLK) {
   8388a:	4b17      	ldr	r3, [pc, #92]	; (838e8 <SystemCoreClockUpdate+0xfc>)
   8388c:	6b1b      	ldr	r3, [r3, #48]	; 0x30
   8388e:	f003 0303 	and.w	r3, r3, #3
   83892:	2b02      	cmp	r3, #2
   83894:	d10d      	bne.n	838b2 <SystemCoreClockUpdate+0xc6>
			SystemCoreClock *= ((((PMC->CKGR_PLLAR) & CKGR_PLLAR_MULA_Msk) >> 
   83896:	4b14      	ldr	r3, [pc, #80]	; (838e8 <SystemCoreClockUpdate+0xfc>)
   83898:	6a98      	ldr	r0, [r3, #40]	; 0x28
				                            CKGR_PLLAR_MULA_Pos) + 1U);
			SystemCoreClock /= ((((PMC->CKGR_PLLAR) & CKGR_PLLAR_DIVA_Msk) >> 
   8389a:	6a99      	ldr	r1, [r3, #40]	; 0x28
   8389c:	4b14      	ldr	r3, [pc, #80]	; (838f0 <SystemCoreClockUpdate+0x104>)
			default:
				break;
			}
		}
		if ((PMC->PMC_MCKR & PMC_MCKR_CSS_Msk) == PMC_MCKR_CSS_PLLA_CLK) {
			SystemCoreClock *= ((((PMC->CKGR_PLLAR) & CKGR_PLLAR_MULA_Msk) >> 
   8389e:	f3c0 400a 	ubfx	r0, r0, #16, #11
   838a2:	681a      	ldr	r2, [r3, #0]
   838a4:	fb00 2202 	mla	r2, r0, r2, r2
				                            CKGR_PLLAR_MULA_Pos) + 1U);
			SystemCoreClock /= ((((PMC->CKGR_PLLAR) & CKGR_PLLAR_DIVA_Msk) >> 
   838a8:	b2c9      	uxtb	r1, r1
   838aa:	fbb2 f2f1 	udiv	r2, r2, r1
   838ae:	601a      	str	r2, [r3, #0]
   838b0:	e002      	b.n	838b8 <SystemCoreClockUpdate+0xcc>
				                             CKGR_PLLAR_DIVA_Pos));
		} else {
			SystemCoreClock = SYS_UTMIPLL / 2U;
   838b2:	4a13      	ldr	r2, [pc, #76]	; (83900 <SystemCoreClockUpdate+0x114>)
   838b4:	4b0e      	ldr	r3, [pc, #56]	; (838f0 <SystemCoreClockUpdate+0x104>)
   838b6:	601a      	str	r2, [r3, #0]
		}
		break;
	}

	if ((PMC->PMC_MCKR & PMC_MCKR_PRES_Msk) == PMC_MCKR_PRES_CLK_3) {
   838b8:	4b0b      	ldr	r3, [pc, #44]	; (838e8 <SystemCoreClockUpdate+0xfc>)
   838ba:	6b1b      	ldr	r3, [r3, #48]	; 0x30
   838bc:	f003 0370 	and.w	r3, r3, #112	; 0x70
   838c0:	2b70      	cmp	r3, #112	; 0x70
   838c2:	d107      	bne.n	838d4 <SystemCoreClockUpdate+0xe8>
		SystemCoreClock /= 3U;
   838c4:	4b0a      	ldr	r3, [pc, #40]	; (838f0 <SystemCoreClockUpdate+0x104>)
   838c6:	681a      	ldr	r2, [r3, #0]
   838c8:	490e      	ldr	r1, [pc, #56]	; (83904 <SystemCoreClockUpdate+0x118>)
   838ca:	fba1 0202 	umull	r0, r2, r1, r2
   838ce:	0852      	lsrs	r2, r2, #1
   838d0:	601a      	str	r2, [r3, #0]
   838d2:	4770      	bx	lr
	} else {
		SystemCoreClock >>= ((PMC->PMC_MCKR & PMC_MCKR_PRES_Msk) >> 
   838d4:	4b04      	ldr	r3, [pc, #16]	; (838e8 <SystemCoreClockUpdate+0xfc>)
   838d6:	6b19      	ldr	r1, [r3, #48]	; 0x30
   838d8:	4b05      	ldr	r3, [pc, #20]	; (838f0 <SystemCoreClockUpdate+0x104>)
   838da:	f3c1 1102 	ubfx	r1, r1, #4, #3
   838de:	681a      	ldr	r2, [r3, #0]
   838e0:	40ca      	lsrs	r2, r1
   838e2:	601a      	str	r2, [r3, #0]
   838e4:	4770      	bx	lr
   838e6:	bf00      	nop
   838e8:	400e0600 	.word	0x400e0600
   838ec:	400e1a10 	.word	0x400e1a10
   838f0:	20070274 	.word	0x20070274
   838f4:	00b71b00 	.word	0x00b71b00
   838f8:	003d0900 	.word	0x003d0900
   838fc:	007a1200 	.word	0x007a1200
   83900:	0e4e1c00 	.word	0x0e4e1c00
   83904:	aaaaaaab 	.word	0xaaaaaaab

00083908 <_sbrk>:
{
	static unsigned char *heap = NULL;
	unsigned char *prev_heap;
	int ramend = (int)&__ram_end__;

	if (heap == NULL) {
   83908:	4b09      	ldr	r3, [pc, #36]	; (83930 <_sbrk+0x28>)
   8390a:	681b      	ldr	r3, [r3, #0]
   8390c:	b913      	cbnz	r3, 83914 <_sbrk+0xc>
		heap = (unsigned char *)&_end;
   8390e:	4a09      	ldr	r2, [pc, #36]	; (83934 <_sbrk+0x2c>)
   83910:	4b07      	ldr	r3, [pc, #28]	; (83930 <_sbrk+0x28>)
   83912:	601a      	str	r2, [r3, #0]
	}
	prev_heap = heap;
   83914:	4b06      	ldr	r3, [pc, #24]	; (83930 <_sbrk+0x28>)
   83916:	681b      	ldr	r3, [r3, #0]

	if (((int)prev_heap + incr) > ramend) {
   83918:	181a      	adds	r2, r3, r0
   8391a:	4907      	ldr	r1, [pc, #28]	; (83938 <_sbrk+0x30>)
   8391c:	4291      	cmp	r1, r2
   8391e:	db04      	blt.n	8392a <_sbrk+0x22>
		return (caddr_t) -1;	
	}

	heap += incr;
   83920:	4610      	mov	r0, r2
   83922:	4a03      	ldr	r2, [pc, #12]	; (83930 <_sbrk+0x28>)
   83924:	6010      	str	r0, [r2, #0]

	return (caddr_t) prev_heap;
   83926:	4618      	mov	r0, r3
   83928:	4770      	bx	lr
		heap = (unsigned char *)&_end;
	}
	prev_heap = heap;

	if (((int)prev_heap + incr) > ramend) {
		return (caddr_t) -1;	
   8392a:	f04f 30ff 	mov.w	r0, #4294967295
	}

	heap += incr;

	return (caddr_t) prev_heap;
}
   8392e:	4770      	bx	lr
   83930:	2007170c 	.word	0x2007170c
   83934:	20077c60 	.word	0x20077c60
   83938:	20087ffc 	.word	0x20087ffc

0008393c <usart_echo_rx_task>:
}

/*-----------------------------------------------------------*/

static void usart_echo_rx_task(void *pvParameters)
{
   8393c:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
   83940:	4681      	mov	r9, r0
	unsigned portBASE_TYPE string_index;

	/* The (already open) USART port is passed in as the task parameter. */
	usart_port = (freertos_usart_if)pvParameters;

	string_index = 0;
   83942:	2400      	movs	r4, #0

	for (;;) {
		memset(rx_buffer, 0x00, sizeof(rx_buffer));
   83944:	4e19      	ldr	r6, [pc, #100]	; (839ac <usart_echo_rx_task+0x70>)
   83946:	f8df 8080 	ldr.w	r8, [pc, #128]	; 839c8 <usart_echo_rx_task+0x8c>

		received = freertos_usart_serial_read_packet(usart_port, rx_buffer,
				strlen((const char *) echo_strings[string_index]),
   8394a:	4d19      	ldr	r5, [pc, #100]	; (839b0 <usart_echo_rx_task+0x74>)
	usart_port = (freertos_usart_if)pvParameters;

	string_index = 0;

	for (;;) {
		memset(rx_buffer, 0x00, sizeof(rx_buffer));
   8394c:	4630      	mov	r0, r6
   8394e:	2100      	movs	r1, #0
   83950:	224f      	movs	r2, #79	; 0x4f
   83952:	47c0      	blx	r8

		received = freertos_usart_serial_read_packet(usart_port, rx_buffer,
				strlen((const char *) echo_strings[string_index]),
   83954:	f855 0024 	ldr.w	r0, [r5, r4, lsl #2]
   83958:	4f16      	ldr	r7, [pc, #88]	; (839b4 <usart_echo_rx_task+0x78>)
   8395a:	47b8      	blx	r7
   8395c:	4602      	mov	r2, r0
	string_index = 0;

	for (;;) {
		memset(rx_buffer, 0x00, sizeof(rx_buffer));

		received = freertos_usart_serial_read_packet(usart_port, rx_buffer,
   8395e:	4648      	mov	r0, r9
   83960:	4631      	mov	r1, r6
   83962:	f04f 33ff 	mov.w	r3, #4294967295
   83966:	f8df c064 	ldr.w	ip, [pc, #100]	; 839cc <usart_echo_rx_task+0x90>
   8396a:	47e0      	blx	ip
   8396c:	4682      	mov	sl, r0
				strlen((const char *) echo_strings[string_index]),
				portMAX_DELAY);

		/* Ensure the string received is that expected. */
		configASSERT(received == strlen((const char *) echo_strings[string_index]));
   8396e:	f855 0024 	ldr.w	r0, [r5, r4, lsl #2]
   83972:	47b8      	blx	r7
   83974:	4550      	cmp	r0, sl
   83976:	d004      	beq.n	83982 <usart_echo_rx_task+0x46>
   83978:	480f      	ldr	r0, [pc, #60]	; (839b8 <usart_echo_rx_task+0x7c>)
   8397a:	f44f 71a5 	mov.w	r1, #330	; 0x14a
   8397e:	4b0f      	ldr	r3, [pc, #60]	; (839bc <usart_echo_rx_task+0x80>)
   83980:	4798      	blx	r3
		configASSERT(strcmp((const char *) rx_buffer, (const char *) echo_strings[string_index]) == 0);
   83982:	4630      	mov	r0, r6
   83984:	f855 1024 	ldr.w	r1, [r5, r4, lsl #2]
   83988:	4b0d      	ldr	r3, [pc, #52]	; (839c0 <usart_echo_rx_task+0x84>)
   8398a:	4798      	blx	r3
   8398c:	b120      	cbz	r0, 83998 <usart_echo_rx_task+0x5c>
   8398e:	480a      	ldr	r0, [pc, #40]	; (839b8 <usart_echo_rx_task+0x7c>)
   83990:	f240 114b 	movw	r1, #331	; 0x14b
   83994:	4b09      	ldr	r3, [pc, #36]	; (839bc <usart_echo_rx_task+0x80>)
   83996:	4798      	blx	r3

		/* Increment a loop counter as an indication that this task is still
		actually receiving strings. */
		rx_task_loops++;
   83998:	4b0a      	ldr	r3, [pc, #40]	; (839c4 <usart_echo_rx_task+0x88>)
   8399a:	681a      	ldr	r2, [r3, #0]
   8399c:	3201      	adds	r2, #1
   8399e:	601a      	str	r2, [r3, #0]

		/* Expect the next string the next time around. */
		string_index++;
   839a0:	3401      	adds	r4, #1
		if (string_index >= (sizeof(echo_strings) / sizeof(uint8_t *))) {
			string_index = 0;
   839a2:	2c75      	cmp	r4, #117	; 0x75
   839a4:	bf28      	it	cs
   839a6:	2400      	movcs	r4, #0
   839a8:	e7d0      	b.n	8394c <usart_echo_rx_task+0x10>
   839aa:	bf00      	nop
   839ac:	200717b8 	.word	0x200717b8
   839b0:	20070278 	.word	0x20070278
   839b4:	000867e5 	.word	0x000867e5
   839b8:	0008b500 	.word	0x0008b500
   839bc:	00085f89 	.word	0x00085f89
   839c0:	000864ed 	.word	0x000864ed
   839c4:	20071714 	.word	0x20071714
   839c8:	000863c1 	.word	0x000863c1
   839cc:	00080cd5 	.word	0x00080cd5

000839d0 <usart_echo_tx_task>:
}

/*-----------------------------------------------------------*/

static void usart_echo_tx_task(void *pvParameters)
{
   839d0:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
   839d4:	b082      	sub	sp, #8
   839d6:	4680      	mov	r8, r0
   839d8:	4e29      	ldr	r6, [pc, #164]	; (83a80 <usart_echo_tx_task+0xb0>)
   839da:	1f34      	subs	r4, r6, #4
   839dc:	f506 76e8 	add.w	r6, r6, #464	; 0x1d0
	status_code_t returned_status;

	/* Check the strings being sent fit in the buffers provided. */
	for(string_index = 0; string_index < sizeof(echo_strings) / sizeof(uint8_t *); string_index++)
	{
		configASSERT(strlen((char *) echo_strings[string_index]) <= RX_BUFFER_SIZE);
   839e0:	4d28      	ldr	r5, [pc, #160]	; (83a84 <usart_echo_tx_task+0xb4>)
   839e2:	f8df 90bc 	ldr.w	r9, [pc, #188]	; 83aa0 <usart_echo_tx_task+0xd0>
   839e6:	4f28      	ldr	r7, [pc, #160]	; (83a88 <usart_echo_tx_task+0xb8>)
   839e8:	f854 0f04 	ldr.w	r0, [r4, #4]!
   839ec:	47a8      	blx	r5
   839ee:	284f      	cmp	r0, #79	; 0x4f
   839f0:	d903      	bls.n	839fa <usart_echo_tx_task+0x2a>
   839f2:	4648      	mov	r0, r9
   839f4:	f240 1109 	movw	r1, #265	; 0x109
   839f8:	47b8      	blx	r7
	xSemaphoreHandle notification_semaphore;
	unsigned portBASE_TYPE string_index;
	status_code_t returned_status;

	/* Check the strings being sent fit in the buffers provided. */
	for(string_index = 0; string_index < sizeof(echo_strings) / sizeof(uint8_t *); string_index++)
   839fa:	42b4      	cmp	r4, r6
   839fc:	d1f4      	bne.n	839e8 <usart_echo_tx_task+0x18>
	/* The (already open) USART port is passed in as the task parameter. */
	usart_port = (freertos_usart_if)pvParameters;

	/* Create the semaphore to be used to get notified of end of
	transmissions. */
	vSemaphoreCreateBinary(notification_semaphore);
   839fe:	2001      	movs	r0, #1
   83a00:	2100      	movs	r1, #0
   83a02:	2203      	movs	r2, #3
   83a04:	4b21      	ldr	r3, [pc, #132]	; (83a8c <usart_echo_tx_task+0xbc>)
   83a06:	4798      	blx	r3
   83a08:	4606      	mov	r6, r0
   83a0a:	2800      	cmp	r0, #0
   83a0c:	d032      	beq.n	83a74 <usart_echo_tx_task+0xa4>
   83a0e:	2100      	movs	r1, #0
   83a10:	460a      	mov	r2, r1
   83a12:	460b      	mov	r3, r1
   83a14:	4c1e      	ldr	r4, [pc, #120]	; (83a90 <usart_echo_tx_task+0xc0>)
   83a16:	47a0      	blx	r4
	configASSERT(notification_semaphore);

	/* Start with the semaphore in the expected state - no data has been sent
	yet.  A block time of zero is used as the semaphore is guaranteed to be
	there as it has only just been created. */
	xSemaphoreTake(notification_semaphore, 0);
   83a18:	4630      	mov	r0, r6
   83a1a:	2100      	movs	r1, #0
   83a1c:	460a      	mov	r2, r1
   83a1e:	460b      	mov	r3, r1
   83a20:	4c1c      	ldr	r4, [pc, #112]	; (83a94 <usart_echo_tx_task+0xc4>)
   83a22:	47a0      	blx	r4

	string_index = 0;
   83a24:	2400      	movs	r4, #0

	for (;;) {
		/* Data cannot be sent from Flash, so copy the string to RAM. */
		strcpy((char *) local_buffer,
   83a26:	4d1c      	ldr	r5, [pc, #112]	; (83a98 <usart_echo_tx_task+0xc8>)
				(const char *) echo_strings[string_index]);
   83a28:	f8df a054 	ldr.w	sl, [pc, #84]	; 83a80 <usart_echo_tx_task+0xb0>

	string_index = 0;

	for (;;) {
		/* Data cannot be sent from Flash, so copy the string to RAM. */
		strcpy((char *) local_buffer,
   83a2c:	f8df 9078 	ldr.w	r9, [pc, #120]	; 83aa8 <usart_echo_tx_task+0xd8>
   83a30:	4628      	mov	r0, r5
   83a32:	f85a 1024 	ldr.w	r1, [sl, r4, lsl #2]
   83a36:	47c8      	blx	r9
				(const char *) echo_strings[string_index]);

		/* Start send. */
		returned_status = freertos_usart_write_packet_async(usart_port,
   83a38:	4628      	mov	r0, r5
   83a3a:	4b12      	ldr	r3, [pc, #72]	; (83a84 <usart_echo_tx_task+0xb4>)
   83a3c:	4798      	blx	r3
   83a3e:	4602      	mov	r2, r0
   83a40:	9600      	str	r6, [sp, #0]
   83a42:	4640      	mov	r0, r8
   83a44:	4629      	mov	r1, r5
   83a46:	2364      	movs	r3, #100	; 0x64
   83a48:	4f14      	ldr	r7, [pc, #80]	; (83a9c <usart_echo_tx_task+0xcc>)
   83a4a:	47b8      	blx	r7
				local_buffer, strlen((char *) local_buffer),
				time_out_definition, notification_semaphore);
		configASSERT(returned_status == STATUS_OK);
   83a4c:	b120      	cbz	r0, 83a58 <usart_echo_tx_task+0x88>
   83a4e:	4814      	ldr	r0, [pc, #80]	; (83aa0 <usart_echo_tx_task+0xd0>)
   83a50:	f44f 7192 	mov.w	r1, #292	; 0x124
   83a54:	4b0c      	ldr	r3, [pc, #48]	; (83a88 <usart_echo_tx_task+0xb8>)
   83a56:	4798      	blx	r3

		/* The async version of the write function is being used, so wait for
		the end of the transmission.  No CPU time is used while waiting for the
		semaphore.*/
		xSemaphoreTake(notification_semaphore, time_out_definition * 2);
   83a58:	4630      	mov	r0, r6
   83a5a:	2100      	movs	r1, #0
   83a5c:	22c8      	movs	r2, #200	; 0xc8
   83a5e:	460b      	mov	r3, r1
   83a60:	4f0c      	ldr	r7, [pc, #48]	; (83a94 <usart_echo_tx_task+0xc4>)
   83a62:	47b8      	blx	r7
		vTaskDelay(short_delay);
   83a64:	200a      	movs	r0, #10
   83a66:	4b0f      	ldr	r3, [pc, #60]	; (83aa4 <usart_echo_tx_task+0xd4>)
   83a68:	4798      	blx	r3

		/* Send the next string next time around. */
		string_index++;
   83a6a:	3401      	adds	r4, #1
		if (string_index >= (sizeof(echo_strings) / sizeof(uint8_t *))) {
			string_index = 0;
   83a6c:	2c75      	cmp	r4, #117	; 0x75
   83a6e:	bf28      	it	cs
   83a70:	2400      	movcs	r4, #0
   83a72:	e7dd      	b.n	83a30 <usart_echo_tx_task+0x60>
	usart_port = (freertos_usart_if)pvParameters;

	/* Create the semaphore to be used to get notified of end of
	transmissions. */
	vSemaphoreCreateBinary(notification_semaphore);
	configASSERT(notification_semaphore);
   83a74:	480a      	ldr	r0, [pc, #40]	; (83aa0 <usart_echo_tx_task+0xd0>)
   83a76:	f44f 7189 	mov.w	r1, #274	; 0x112
   83a7a:	4b03      	ldr	r3, [pc, #12]	; (83a88 <usart_echo_tx_task+0xb8>)
   83a7c:	4798      	blx	r3
   83a7e:	e7cb      	b.n	83a18 <usart_echo_tx_task+0x48>
   83a80:	20070278 	.word	0x20070278
   83a84:	000867e5 	.word	0x000867e5
   83a88:	00085f89 	.word	0x00085f89
   83a8c:	00084521 	.word	0x00084521
   83a90:	000845b1 	.word	0x000845b1
   83a94:	000847e9 	.word	0x000847e9
   83a98:	20071718 	.word	0x20071718
   83a9c:	00080c4d 	.word	0x00080c4d
   83aa0:	0008b500 	.word	0x0008b500
   83aa4:	000850f9 	.word	0x000850f9
   83aa8:	00086729 	.word	0x00086729

00083aac <create_usart_echo_test_tasks>:
/*-----------------------------------------------------------*/

void create_usart_echo_test_tasks(Usart *usart_base,
		uint16_t stack_depth_words,
		unsigned portBASE_TYPE task_priority)
{
   83aac:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   83ab0:	b08e      	sub	sp, #56	; 0x38
   83ab2:	4686      	mov	lr, r0
   83ab4:	460f      	mov	r7, r1
   83ab6:	4690      	mov	r8, r2
	freertos_usart_if freertos_usart;
	freertos_peripheral_options_t driver_options = {
   83ab8:	4d19      	ldr	r5, [pc, #100]	; (83b20 <create_usart_echo_test_tasks+0x74>)
   83aba:	ae0a      	add	r6, sp, #40	; 0x28
   83abc:	e895 000f 	ldmia.w	r5, {r0, r1, r2, r3}
   83ac0:	e886 000f 	stmia.w	r6, {r0, r1, r2, r3}
		configLIBRARY_MAX_SYSCALL_INTERRUPT_PRIORITY,	/* The priority used by the USART interrupts. */
		USART_RS232,									/* Configure the USART for RS232 operation. */
		(USE_TX_ACCESS_MUTEX | USE_RX_ACCESS_MUTEX)
	};

	const sam_usart_opt_t usart_settings = {
   83ac4:	ac04      	add	r4, sp, #16
   83ac6:	3510      	adds	r5, #16
   83ac8:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
   83aca:	c40f      	stmia	r4!, {r0, r1, r2, r3}
   83acc:	e895 0003 	ldmia.w	r5, {r0, r1}
   83ad0:	e884 0003 	stmia.w	r4, {r0, r1}
		US_MR_CHMODE_NORMAL,
		0 /* Only used in IrDA mode. */
	}; /*_RB_ TODO This is not SAM specific, not a good thing. */

	/* Initialise the USART interface. */
	freertos_usart = freertos_usart_serial_init(usart_base,
   83ad4:	4670      	mov	r0, lr
   83ad6:	a904      	add	r1, sp, #16
   83ad8:	4632      	mov	r2, r6
   83ada:	4b12      	ldr	r3, [pc, #72]	; (83b24 <create_usart_echo_test_tasks+0x78>)
   83adc:	4798      	blx	r3
			&usart_settings,
			&driver_options);
	configASSERT(freertos_usart);
   83ade:	4606      	mov	r6, r0
   83ae0:	b918      	cbnz	r0, 83aea <create_usart_echo_test_tasks+0x3e>
   83ae2:	4811      	ldr	r0, [pc, #68]	; (83b28 <create_usart_echo_test_tasks+0x7c>)
   83ae4:	21ef      	movs	r1, #239	; 0xef
   83ae6:	4b11      	ldr	r3, [pc, #68]	; (83b2c <create_usart_echo_test_tasks+0x80>)
   83ae8:	4798      	blx	r3

	/* Create the two tasks as described above. */
	xTaskCreate(usart_echo_tx_task, (const signed char *const) "Tx",
   83aea:	f8cd 8000 	str.w	r8, [sp]
   83aee:	2400      	movs	r4, #0
   83af0:	9401      	str	r4, [sp, #4]
   83af2:	9402      	str	r4, [sp, #8]
   83af4:	9403      	str	r4, [sp, #12]
   83af6:	480e      	ldr	r0, [pc, #56]	; (83b30 <create_usart_echo_test_tasks+0x84>)
   83af8:	490e      	ldr	r1, [pc, #56]	; (83b34 <create_usart_echo_test_tasks+0x88>)
   83afa:	463a      	mov	r2, r7
   83afc:	4633      	mov	r3, r6
   83afe:	4d0e      	ldr	r5, [pc, #56]	; (83b38 <create_usart_echo_test_tasks+0x8c>)
   83b00:	47a8      	blx	r5
			stack_depth_words, (void *) freertos_usart,
			task_priority, NULL);
	xTaskCreate(usart_echo_rx_task, (const signed char *const) "Rx",
   83b02:	f108 0301 	add.w	r3, r8, #1
   83b06:	9300      	str	r3, [sp, #0]
   83b08:	9401      	str	r4, [sp, #4]
   83b0a:	9402      	str	r4, [sp, #8]
   83b0c:	9403      	str	r4, [sp, #12]
   83b0e:	480b      	ldr	r0, [pc, #44]	; (83b3c <create_usart_echo_test_tasks+0x90>)
   83b10:	490b      	ldr	r1, [pc, #44]	; (83b40 <create_usart_echo_test_tasks+0x94>)
   83b12:	463a      	mov	r2, r7
   83b14:	4633      	mov	r3, r6
   83b16:	47a8      	blx	r5
			stack_depth_words, (void *) freertos_usart,
			task_priority + 1, NULL);
}
   83b18:	b00e      	add	sp, #56	; 0x38
   83b1a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   83b1e:	bf00      	nop
   83b20:	0008b4d8 	.word	0x0008b4d8
   83b24:	00080a59 	.word	0x00080a59
   83b28:	0008b500 	.word	0x0008b500
   83b2c:	00085f89 	.word	0x00085f89
   83b30:	000839d1 	.word	0x000839d1
   83b34:	0008b558 	.word	0x0008b558
   83b38:	00084b31 	.word	0x00084b31
   83b3c:	0008393d 	.word	0x0008393d
   83b40:	0008b55c 	.word	0x0008b55c

00083b44 <are_usart_echo_tasks_still_running>:
{
	static uint32_t last_loop_count = 0;
	portBASE_TYPE return_value = pdPASS;

	/* Ensure the count of Rx loops is still incrementing. */
	if (last_loop_count == rx_task_loops) {
   83b44:	4b04      	ldr	r3, [pc, #16]	; (83b58 <are_usart_echo_tasks_still_running+0x14>)
   83b46:	681b      	ldr	r3, [r3, #0]
   83b48:	4a04      	ldr	r2, [pc, #16]	; (83b5c <are_usart_echo_tasks_still_running+0x18>)
   83b4a:	6810      	ldr	r0, [r2, #0]
		/* The Rx task has somehow stalled, set the error LED. */
		return_value = pdFAIL;
	}

	last_loop_count = rx_task_loops;
   83b4c:	6013      	str	r3, [r2, #0]

	return return_value;
}
   83b4e:	1ac0      	subs	r0, r0, r3
   83b50:	bf18      	it	ne
   83b52:	2001      	movne	r0, #1
   83b54:	4770      	bx	lr
   83b56:	bf00      	nop
   83b58:	20071714 	.word	0x20071714
   83b5c:	20071710 	.word	0x20071710

00083b60 <usb_cdc_command_console_task>:
}

/*-----------------------------------------------------------*/

static void usb_cdc_command_console_task(void *pvParameters)
{
   83b60:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   83b64:	b083      	sub	sp, #12
	portBASE_TYPE returned_value;

	/* Just to remove compiler warnings. */
	(void) pvParameters;

	udc_start();
   83b66:	4b47      	ldr	r3, [pc, #284]	; (83c84 <usb_cdc_command_console_task+0x124>)
   83b68:	4798      	blx	r3
	}
\endcode
 */
static inline bool udc_include_vbus_monitoring(void)
{
	return udd_include_vbus_monitoring();
   83b6a:	4b47      	ldr	r3, [pc, #284]	; (83c88 <usb_cdc_command_console_task+0x128>)
   83b6c:	4798      	blx	r3

	if (udc_include_vbus_monitoring() == false) {
   83b6e:	b908      	cbnz	r0, 83b74 <usb_cdc_command_console_task+0x14>
 * then it will attach device when an acceptable Vbus
 * level from the host is detected.
 */
static inline void udc_attach(void)
{
	udd_attach();
   83b70:	4b46      	ldr	r3, [pc, #280]	; (83c8c <usb_cdc_command_console_task+0x12c>)
   83b72:	4798      	blx	r3
	}

	/* Obtain the address of the output buffer.  Note there is no mutual
	exclusion on this buffer as it is assumed only one command console
	interface will be used at any one time. */
	output_string = (uint8_t *) FreeRTOS_CLIGetOutputBuffer();
   83b74:	4b46      	ldr	r3, [pc, #280]	; (83c90 <usb_cdc_command_console_task+0x130>)
   83b76:	4798      	blx	r3
   83b78:	4604      	mov	r4, r0

/*-----------------------------------------------------------*/

static void usb_cdc_command_console_task(void *pvParameters)
{
	uint8_t received_char, input_index = 0, *output_string;
   83b7a:	f04f 0900 	mov.w	r9, #0
				} else {
					/* A character was entered.  Add it to the string
					entered so far.  When a \n is entered the complete
					string will be passed to the command interpreter. */
					if (input_index < MAX_INPUT_SIZE) {
						input_string[input_index] = received_char;
   83b7e:	4d45      	ldr	r5, [pc, #276]	; (83c94 <usb_cdc_command_console_task+0x134>)
				command interpreter is called repeatedly until it returns pdFALSE as
				it might generate more than one string. */
				do {
					/* Get the string to write to the UART from the command
					interpreter. */
					returned_value = FreeRTOS_CLIProcessCommand(
   83b80:	4e45      	ldr	r6, [pc, #276]	; (83c98 <usb_cdc_command_console_task+0x138>)
				Remember the command that was just processed first in case it is
				to be processed again. */
				strcpy((char *) last_input_string,
						(char *) input_string);
				input_index = 0;
				memset(input_string, 0x00, MAX_INPUT_SIZE);
   83b82:	1d2b      	adds	r3, r5, #4
   83b84:	9301      	str	r3, [sp, #4]
   83b86:	f105 0b08 	add.w	fp, r5, #8
	interface will be used at any one time. */
	output_string = (uint8_t *) FreeRTOS_CLIGetOutputBuffer();

	for (;;) {
		/* Wait for new data. */
		xSemaphoreTake(cdc_new_data_semaphore, portMAX_DELAY);
   83b8a:	4b44      	ldr	r3, [pc, #272]	; (83c9c <usb_cdc_command_console_task+0x13c>)
   83b8c:	6818      	ldr	r0, [r3, #0]
   83b8e:	2100      	movs	r1, #0
   83b90:	f04f 32ff 	mov.w	r2, #4294967295
   83b94:	460b      	mov	r3, r1
   83b96:	4f42      	ldr	r7, [pc, #264]	; (83ca0 <usb_cdc_command_console_task+0x140>)
   83b98:	47b8      	blx	r7

		/* Ensure mutually exclusive access is obtained as other tasks can write
		to the CLI. */
		xSemaphoreTake(access_mutex, portMAX_DELAY);
   83b9a:	4b42      	ldr	r3, [pc, #264]	; (83ca4 <usb_cdc_command_console_task+0x144>)
   83b9c:	6818      	ldr	r0, [r3, #0]
   83b9e:	2100      	movs	r1, #0
   83ba0:	f04f 32ff 	mov.w	r2, #4294967295
   83ba4:	460b      	mov	r3, r1
   83ba6:	47b8      	blx	r7

		/* While there are input characters. */
		while (udi_cdc_is_rx_ready() == true) {
   83ba8:	f8df a11c 	ldr.w	sl, [pc, #284]	; 83cc8 <usb_cdc_command_console_task+0x168>
   83bac:	e05f      	b.n	83c6e <usb_cdc_command_console_task+0x10e>
			received_char = (uint8_t) udi_cdc_getc();
   83bae:	4b3e      	ldr	r3, [pc, #248]	; (83ca8 <usb_cdc_command_console_task+0x148>)
   83bb0:	4798      	blx	r3
   83bb2:	4680      	mov	r8, r0
   83bb4:	b2c7      	uxtb	r7, r0

			/* Echo the character. */
			udi_cdc_putc(received_char);
   83bb6:	4638      	mov	r0, r7
   83bb8:	4b3c      	ldr	r3, [pc, #240]	; (83cac <usb_cdc_command_console_task+0x14c>)
   83bba:	4798      	blx	r3

			if (received_char == '\r') {
   83bbc:	2f0d      	cmp	r7, #13
   83bbe:	d13e      	bne.n	83c3e <usb_cdc_command_console_task+0xde>
				/* Transmit a line separator, just to make the output easier to
				read. */
				udi_cdc_write_buf((void *) new_line,
   83bc0:	483b      	ldr	r0, [pc, #236]	; (83cb0 <usb_cdc_command_console_task+0x150>)
   83bc2:	2102      	movs	r1, #2
   83bc4:	4b3b      	ldr	r3, [pc, #236]	; (83cb4 <usb_cdc_command_console_task+0x154>)
   83bc6:	4798      	blx	r3
						strlen((char *) new_line));

				/* See if the command is empty, indicating that the last command
				is to be executed again. */
				if (input_index == 0) {
   83bc8:	f1b9 0f00 	cmp.w	r9, #0
   83bcc:	d103      	bne.n	83bd6 <usb_cdc_command_console_task+0x76>
					strcpy((char *) input_string,
   83bce:	4628      	mov	r0, r5
   83bd0:	4939      	ldr	r1, [pc, #228]	; (83cb8 <usb_cdc_command_console_task+0x158>)
   83bd2:	4b3a      	ldr	r3, [pc, #232]	; (83cbc <usb_cdc_command_console_task+0x15c>)
   83bd4:	4798      	blx	r3
							input_string,
							(int8_t *) output_string,
							configCOMMAND_INT_MAX_OUTPUT_SIZE);

					/* Transmit the generated string. */
					udi_cdc_write_buf((void *) output_string, strlen(
   83bd6:	f8df 80f4 	ldr.w	r8, [pc, #244]	; 83ccc <usb_cdc_command_console_task+0x16c>
				command interpreter is called repeatedly until it returns pdFALSE as
				it might generate more than one string. */
				do {
					/* Get the string to write to the UART from the command
					interpreter. */
					returned_value = FreeRTOS_CLIProcessCommand(
   83bda:	4628      	mov	r0, r5
   83bdc:	4621      	mov	r1, r4
   83bde:	f44f 72c8 	mov.w	r2, #400	; 0x190
   83be2:	47b0      	blx	r6
   83be4:	4607      	mov	r7, r0
							input_string,
							(int8_t *) output_string,
							configCOMMAND_INT_MAX_OUTPUT_SIZE);

					/* Transmit the generated string. */
					udi_cdc_write_buf((void *) output_string, strlen(
   83be6:	4620      	mov	r0, r4
   83be8:	47c0      	blx	r8
   83bea:	4601      	mov	r1, r0
   83bec:	4620      	mov	r0, r4
   83bee:	4b31      	ldr	r3, [pc, #196]	; (83cb4 <usb_cdc_command_console_task+0x154>)
   83bf0:	4798      	blx	r3
							(char *) output_string));
				} while (returned_value != pdFALSE);
   83bf2:	2f00      	cmp	r7, #0
   83bf4:	d1f1      	bne.n	83bda <usb_cdc_command_console_task+0x7a>

				/* All the strings generated by the input command have been sent.
				Clear the input	string ready to receive the next command.
				Remember the command that was just processed first in case it is
				to be processed again. */
				strcpy((char *) last_input_string,
   83bf6:	4830      	ldr	r0, [pc, #192]	; (83cb8 <usb_cdc_command_console_task+0x158>)
   83bf8:	4629      	mov	r1, r5
   83bfa:	4b30      	ldr	r3, [pc, #192]	; (83cbc <usb_cdc_command_console_task+0x15c>)
   83bfc:	4798      	blx	r3
						(char *) input_string);
				input_index = 0;
				memset(input_string, 0x00, MAX_INPUT_SIZE);
   83bfe:	602f      	str	r7, [r5, #0]
   83c00:	9b01      	ldr	r3, [sp, #4]
   83c02:	601f      	str	r7, [r3, #0]
   83c04:	465b      	mov	r3, fp
   83c06:	f843 7b04 	str.w	r7, [r3], #4
   83c0a:	f8cb 7004 	str.w	r7, [fp, #4]
   83c0e:	3304      	adds	r3, #4
   83c10:	f843 7b04 	str.w	r7, [r3], #4
   83c14:	f843 7b04 	str.w	r7, [r3], #4
   83c18:	f843 7b04 	str.w	r7, [r3], #4
   83c1c:	f843 7b04 	str.w	r7, [r3], #4
   83c20:	f843 7b04 	str.w	r7, [r3], #4
   83c24:	f843 7b04 	str.w	r7, [r3], #4
   83c28:	f843 7b04 	str.w	r7, [r3], #4
   83c2c:	f843 7b04 	str.w	r7, [r3], #4
   83c30:	801f      	strh	r7, [r3, #0]

				/* Start to transmit a line separator, just to make the output
				easier to read. */
				udi_cdc_write_buf((void *) line_separator, strlen(
   83c32:	4823      	ldr	r0, [pc, #140]	; (83cc0 <usb_cdc_command_console_task+0x160>)
   83c34:	2138      	movs	r1, #56	; 0x38
   83c36:	4b1f      	ldr	r3, [pc, #124]	; (83cb4 <usb_cdc_command_console_task+0x154>)
   83c38:	4798      	blx	r3
				Clear the input	string ready to receive the next command.
				Remember the command that was just processed first in case it is
				to be processed again. */
				strcpy((char *) last_input_string,
						(char *) input_string);
				input_index = 0;
   83c3a:	46b9      	mov	r9, r7
   83c3c:	e017      	b.n	83c6e <usb_cdc_command_console_task+0x10e>
				/* Start to transmit a line separator, just to make the output
				easier to read. */
				udi_cdc_write_buf((void *) line_separator, strlen(
						(char *) line_separator));
			} else {
				if (received_char == '\n') {
   83c3e:	2f0a      	cmp	r7, #10
   83c40:	d015      	beq.n	83c6e <usb_cdc_command_console_task+0x10e>
					/* Ignore the character. */
				} else if (received_char == '\b') {
   83c42:	2f08      	cmp	r7, #8
   83c44:	d10a      	bne.n	83c5c <usb_cdc_command_console_task+0xfc>
					/* Backspace was pressed.  Erase the last character in the
					string - if any. */
					if (input_index > 0) {
   83c46:	f1b9 0f00 	cmp.w	r9, #0
   83c4a:	d010      	beq.n	83c6e <usb_cdc_command_console_task+0x10e>
						input_index--;
   83c4c:	f109 39ff 	add.w	r9, r9, #4294967295
   83c50:	fa5f f989 	uxtb.w	r9, r9
						input_string[input_index]
							= '\0';
   83c54:	2300      	movs	r3, #0
   83c56:	f805 3009 	strb.w	r3, [r5, r9]
   83c5a:	e008      	b.n	83c6e <usb_cdc_command_console_task+0x10e>
					}
				} else {
					/* A character was entered.  Add it to the string
					entered so far.  When a \n is entered the complete
					string will be passed to the command interpreter. */
					if (input_index < MAX_INPUT_SIZE) {
   83c5c:	f1b9 0f31 	cmp.w	r9, #49	; 0x31
   83c60:	d805      	bhi.n	83c6e <usb_cdc_command_console_task+0x10e>
						input_string[input_index] = received_char;
   83c62:	f805 8009 	strb.w	r8, [r5, r9]
						input_index++;
   83c66:	f109 0901 	add.w	r9, r9, #1
   83c6a:	fa5f f989 	uxtb.w	r9, r9
		/* Ensure mutually exclusive access is obtained as other tasks can write
		to the CLI. */
		xSemaphoreTake(access_mutex, portMAX_DELAY);

		/* While there are input characters. */
		while (udi_cdc_is_rx_ready() == true) {
   83c6e:	47d0      	blx	sl
   83c70:	2800      	cmp	r0, #0
   83c72:	d19c      	bne.n	83bae <usb_cdc_command_console_task+0x4e>
			}
		}

		/* Finished with the CDC port, return the mutex until more characters
		arrive. */
		xSemaphoreGive(access_mutex);
   83c74:	4b0b      	ldr	r3, [pc, #44]	; (83ca4 <usb_cdc_command_console_task+0x144>)
   83c76:	6818      	ldr	r0, [r3, #0]
   83c78:	2100      	movs	r1, #0
   83c7a:	460a      	mov	r2, r1
   83c7c:	460b      	mov	r3, r1
   83c7e:	4f11      	ldr	r7, [pc, #68]	; (83cc4 <usb_cdc_command_console_task+0x164>)
   83c80:	47b8      	blx	r7
	}
   83c82:	e782      	b.n	83b8a <usb_cdc_command_console_task+0x2a>
   83c84:	0008178d 	.word	0x0008178d
   83c88:	00082709 	.word	0x00082709
   83c8c:	0008288d 	.word	0x0008288d
   83c90:	00083fa9 	.word	0x00083fa9
   83c94:	20071808 	.word	0x20071808
   83c98:	00083eb5 	.word	0x00083eb5
   83c9c:	2007183c 	.word	0x2007183c
   83ca0:	000847e9 	.word	0x000847e9
   83ca4:	20071840 	.word	0x20071840
   83ca8:	00081411 	.word	0x00081411
   83cac:	00081539 	.word	0x00081539
   83cb0:	0008c998 	.word	0x0008c998
   83cb4:	000815f1 	.word	0x000815f1
   83cb8:	20071848 	.word	0x20071848
   83cbc:	00086729 	.word	0x00086729
   83cc0:	0008c3fc 	.word	0x0008c3fc
   83cc4:	000845b1 	.word	0x000845b1
   83cc8:	00081351 	.word	0x00081351
   83ccc:	000867e5 	.word	0x000867e5

00083cd0 <create_usb_cdc_cli_task>:

/*-----------------------------------------------------------*/

void create_usb_cdc_cli_task(uint16_t stack_depth_words,
		unsigned portBASE_TYPE task_priority)
{
   83cd0:	b570      	push	{r4, r5, r6, lr}
   83cd2:	b084      	sub	sp, #16
   83cd4:	4604      	mov	r4, r0
   83cd6:	460d      	mov	r5, r1
	/* Register the default CLI commands. */
	vRegisterCLICommands();
   83cd8:	4b15      	ldr	r3, [pc, #84]	; (83d30 <create_usb_cdc_cli_task+0x60>)
   83cda:	4798      	blx	r3

	/* Create the semaphore used to signal the arrival of new data. */
	vSemaphoreCreateBinary(cdc_new_data_semaphore);
   83cdc:	2001      	movs	r0, #1
   83cde:	2100      	movs	r1, #0
   83ce0:	2203      	movs	r2, #3
   83ce2:	4b14      	ldr	r3, [pc, #80]	; (83d34 <create_usb_cdc_cli_task+0x64>)
   83ce4:	4798      	blx	r3
   83ce6:	4b14      	ldr	r3, [pc, #80]	; (83d38 <create_usb_cdc_cli_task+0x68>)
   83ce8:	6018      	str	r0, [r3, #0]
   83cea:	b138      	cbz	r0, 83cfc <create_usb_cdc_cli_task+0x2c>
   83cec:	2100      	movs	r1, #0
   83cee:	460a      	mov	r2, r1
   83cf0:	460b      	mov	r3, r1
   83cf2:	4e12      	ldr	r6, [pc, #72]	; (83d3c <create_usb_cdc_cli_task+0x6c>)
   83cf4:	47b0      	blx	r6
	configASSERT(cdc_new_data_semaphore);
   83cf6:	4b10      	ldr	r3, [pc, #64]	; (83d38 <create_usb_cdc_cli_task+0x68>)
   83cf8:	681b      	ldr	r3, [r3, #0]
   83cfa:	b91b      	cbnz	r3, 83d04 <create_usb_cdc_cli_task+0x34>
   83cfc:	4810      	ldr	r0, [pc, #64]	; (83d40 <create_usb_cdc_cli_task+0x70>)
   83cfe:	2170      	movs	r1, #112	; 0x70
   83d00:	4b10      	ldr	r3, [pc, #64]	; (83d44 <create_usb_cdc_cli_task+0x74>)
   83d02:	4798      	blx	r3

	/* Create the semaphore used to access the CDC port as it is written to from
	more than one task. */
	access_mutex = xSemaphoreCreateMutex();
   83d04:	2001      	movs	r0, #1
   83d06:	4b10      	ldr	r3, [pc, #64]	; (83d48 <create_usb_cdc_cli_task+0x78>)
   83d08:	4798      	blx	r3
   83d0a:	4a10      	ldr	r2, [pc, #64]	; (83d4c <create_usb_cdc_cli_task+0x7c>)
   83d0c:	6010      	str	r0, [r2, #0]
	configASSERT(access_mutex);
   83d0e:	b918      	cbnz	r0, 83d18 <create_usb_cdc_cli_task+0x48>
   83d10:	480b      	ldr	r0, [pc, #44]	; (83d40 <create_usb_cdc_cli_task+0x70>)
   83d12:	2175      	movs	r1, #117	; 0x75
   83d14:	4b0b      	ldr	r3, [pc, #44]	; (83d44 <create_usb_cdc_cli_task+0x74>)
   83d16:	4798      	blx	r3

	/* Create the USART CLI task. */
	xTaskCreate(	usb_cdc_command_console_task,		/* The task that implements the command console. */
   83d18:	9500      	str	r5, [sp, #0]
   83d1a:	2300      	movs	r3, #0
   83d1c:	9301      	str	r3, [sp, #4]
   83d1e:	9302      	str	r3, [sp, #8]
   83d20:	9303      	str	r3, [sp, #12]
   83d22:	480b      	ldr	r0, [pc, #44]	; (83d50 <create_usb_cdc_cli_task+0x80>)
   83d24:	490b      	ldr	r1, [pc, #44]	; (83d54 <create_usb_cdc_cli_task+0x84>)
   83d26:	4622      	mov	r2, r4
   83d28:	4c0b      	ldr	r4, [pc, #44]	; (83d58 <create_usb_cdc_cli_task+0x88>)
   83d2a:	47a0      	blx	r4
					(const int8_t *const) "CDC_CLI",	/* Text name assigned to the task.  This is just to assist debugging.  The kernel does not use this name itself. */
					stack_depth_words,					/* The size of the stack allocated to the task. */
					NULL,								/* The parameter is not used. */
					task_priority,						/* The priority allocated to the task. */
					NULL);								/* Used to store the handle to the created task - in this case the handle is not required. */
}
   83d2c:	b004      	add	sp, #16
   83d2e:	bd70      	pop	{r4, r5, r6, pc}
   83d30:	00085f0d 	.word	0x00085f0d
   83d34:	00084521 	.word	0x00084521
   83d38:	2007183c 	.word	0x2007183c
   83d3c:	000845b1 	.word	0x000845b1
   83d40:	0008c438 	.word	0x0008c438
   83d44:	00085f89 	.word	0x00085f89
   83d48:	000846e1 	.word	0x000846e1
   83d4c:	20071840 	.word	0x20071840
   83d50:	00083b61 	.word	0x00083b61
   83d54:	0008c490 	.word	0x0008c490
   83d58:	00084b31 	.word	0x00084b31

00083d5c <cdc_cli_output>:
}

/*-----------------------------------------------------------*/

void cdc_cli_output(const uint8_t const *message_string)
{
   83d5c:	b570      	push	{r4, r5, r6, lr}
   83d5e:	4604      	mov	r4, r0
	if (cdc_connected == true) {
   83d60:	4b0d      	ldr	r3, [pc, #52]	; (83d98 <cdc_cli_output+0x3c>)
   83d62:	781b      	ldrb	r3, [r3, #0]
   83d64:	f013 0fff 	tst.w	r3, #255	; 0xff
   83d68:	d014      	beq.n	83d94 <cdc_cli_output+0x38>
		/* This call is outside of the CLI task, so ensure mutually exclusive
		access is obtained. */
		xSemaphoreTake(access_mutex, portMAX_DELAY);
   83d6a:	4d0c      	ldr	r5, [pc, #48]	; (83d9c <cdc_cli_output+0x40>)
   83d6c:	6828      	ldr	r0, [r5, #0]
   83d6e:	2100      	movs	r1, #0
   83d70:	f04f 32ff 	mov.w	r2, #4294967295
   83d74:	460b      	mov	r3, r1
   83d76:	4e0a      	ldr	r6, [pc, #40]	; (83da0 <cdc_cli_output+0x44>)
   83d78:	47b0      	blx	r6

		udi_cdc_write_buf((void *) message_string,
				strlen((char *) message_string));
   83d7a:	4620      	mov	r0, r4
   83d7c:	4b09      	ldr	r3, [pc, #36]	; (83da4 <cdc_cli_output+0x48>)
   83d7e:	4798      	blx	r3
   83d80:	4601      	mov	r1, r0
	if (cdc_connected == true) {
		/* This call is outside of the CLI task, so ensure mutually exclusive
		access is obtained. */
		xSemaphoreTake(access_mutex, portMAX_DELAY);

		udi_cdc_write_buf((void *) message_string,
   83d82:	4620      	mov	r0, r4
   83d84:	4b08      	ldr	r3, [pc, #32]	; (83da8 <cdc_cli_output+0x4c>)
   83d86:	4798      	blx	r3
				strlen((char *) message_string));

		/* Finished writing to the CDC. */
		xSemaphoreGive(access_mutex);
   83d88:	6828      	ldr	r0, [r5, #0]
   83d8a:	2100      	movs	r1, #0
   83d8c:	460a      	mov	r2, r1
   83d8e:	460b      	mov	r3, r1
   83d90:	4c06      	ldr	r4, [pc, #24]	; (83dac <cdc_cli_output+0x50>)
   83d92:	47a0      	blx	r4
   83d94:	bd70      	pop	{r4, r5, r6, pc}
   83d96:	bf00      	nop
   83d98:	20071844 	.word	0x20071844
   83d9c:	20071840 	.word	0x20071840
   83da0:	000847e9 	.word	0x000847e9
   83da4:	000867e5 	.word	0x000867e5
   83da8:	000815f1 	.word	0x000815f1
   83dac:	000845b1 	.word	0x000845b1

00083db0 <cli_vbus_event>:
/*-----------------------------------------------------------*/

#endif

void cli_vbus_event(bool b_vbus_high)
{
   83db0:	b508      	push	{r3, lr}
	if (b_vbus_high == true) {
   83db2:	b110      	cbz	r0, 83dba <cli_vbus_event+0xa>
   83db4:	4b02      	ldr	r3, [pc, #8]	; (83dc0 <cli_vbus_event+0x10>)
   83db6:	4798      	blx	r3
   83db8:	bd08      	pop	{r3, pc}
 *
 * The driver must remove pull-up on USB line D- or D+.
 */
static inline void udc_detach(void)
{
	udd_detach();
   83dba:	4b02      	ldr	r3, [pc, #8]	; (83dc4 <cli_vbus_event+0x14>)
   83dbc:	4798      	blx	r3
   83dbe:	bd08      	pop	{r3, pc}
   83dc0:	0008288d 	.word	0x0008288d
   83dc4:	0008290d 	.word	0x0008290d

00083dc8 <cli_cdc_enable>:

bool cli_cdc_enable(uint8_t port)
{
	(void) port;

	cdc_connected = true;
   83dc8:	2001      	movs	r0, #1
   83dca:	4b01      	ldr	r3, [pc, #4]	; (83dd0 <cli_cdc_enable+0x8>)
   83dcc:	7018      	strb	r0, [r3, #0]
	return true;
}
   83dce:	4770      	bx	lr
   83dd0:	20071844 	.word	0x20071844

00083dd4 <cli_cdc_rx_notify>:

/*-----------------------------------------------------------*/

void cli_cdc_rx_notify(uint8_t port)
{
   83dd4:	b510      	push	{r4, lr}
   83dd6:	b082      	sub	sp, #8
	portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
   83dd8:	2300      	movs	r3, #0
   83dda:	9301      	str	r3, [sp, #4]

	(void) port;

	/* Sanity check the event semaphore before giving it to indicate to the
	 * task that data is available. */
	configASSERT(cdc_new_data_semaphore);
   83ddc:	4b0a      	ldr	r3, [pc, #40]	; (83e08 <cli_cdc_rx_notify+0x34>)
   83dde:	681b      	ldr	r3, [r3, #0]
   83de0:	b923      	cbnz	r3, 83dec <cli_cdc_rx_notify+0x18>
   83de2:	480a      	ldr	r0, [pc, #40]	; (83e0c <cli_cdc_rx_notify+0x38>)
   83de4:	f240 1121 	movw	r1, #289	; 0x121
   83de8:	4b09      	ldr	r3, [pc, #36]	; (83e10 <cli_cdc_rx_notify+0x3c>)
   83dea:	4798      	blx	r3
	xSemaphoreGiveFromISR(cdc_new_data_semaphore,
   83dec:	4b06      	ldr	r3, [pc, #24]	; (83e08 <cli_cdc_rx_notify+0x34>)
   83dee:	6818      	ldr	r0, [r3, #0]
   83df0:	2100      	movs	r1, #0
   83df2:	aa01      	add	r2, sp, #4
   83df4:	460b      	mov	r3, r1
   83df6:	4c07      	ldr	r4, [pc, #28]	; (83e14 <cli_cdc_rx_notify+0x40>)
   83df8:	47a0      	blx	r4
			&xHigherPriorityTaskWoken);
	portEND_SWITCHING_ISR(xHigherPriorityTaskWoken);
   83dfa:	9b01      	ldr	r3, [sp, #4]
   83dfc:	b10b      	cbz	r3, 83e02 <cli_cdc_rx_notify+0x2e>
   83dfe:	4b06      	ldr	r3, [pc, #24]	; (83e18 <cli_cdc_rx_notify+0x44>)
   83e00:	4798      	blx	r3
}
   83e02:	b002      	add	sp, #8
   83e04:	bd10      	pop	{r4, pc}
   83e06:	bf00      	nop
   83e08:	2007183c 	.word	0x2007183c
   83e0c:	0008c438 	.word	0x0008c438
   83e10:	00085f89 	.word	0x00085f89
   83e14:	00084749 	.word	0x00084749
   83e18:	00084119 	.word	0x00084119

00083e1c <cli_cdc_disable>:

void cli_cdc_disable(uint8_t port)
{
	(void) port;

	cdc_connected = false;
   83e1c:	2200      	movs	r2, #0
   83e1e:	4b01      	ldr	r3, [pc, #4]	; (83e24 <cli_cdc_disable+0x8>)
   83e20:	701a      	strb	r2, [r3, #0]
   83e22:	4770      	bx	lr
   83e24:	20071844 	.word	0x20071844

00083e28 <prvHelpCommand>:
	return pcReturn;
}
/*-----------------------------------------------------------*/

static portBASE_TYPE prvHelpCommand( int8_t *pcWriteBuffer, size_t xWriteBufferLen, const int8_t *pcCommandString )
{
   83e28:	b538      	push	{r3, r4, r5, lr}
   83e2a:	460a      	mov	r2, r1
static const CLI_Definition_List_Item_t * pxCommand = NULL;
signed portBASE_TYPE xReturn;

	( void ) pcCommandString;

	if( pxCommand == NULL )
   83e2c:	4b08      	ldr	r3, [pc, #32]	; (83e50 <prvHelpCommand+0x28>)
   83e2e:	681b      	ldr	r3, [r3, #0]
   83e30:	b913      	cbnz	r3, 83e38 <prvHelpCommand+0x10>
	{
		/* Reset the pxCommand pointer back to the start of the list. */
		pxCommand = &xRegisteredCommands;
   83e32:	4908      	ldr	r1, [pc, #32]	; (83e54 <prvHelpCommand+0x2c>)
   83e34:	4b06      	ldr	r3, [pc, #24]	; (83e50 <prvHelpCommand+0x28>)
   83e36:	6019      	str	r1, [r3, #0]
	}

	/* Return the next command help string, before moving the pointer on to
	the next command in the list. */
	strncpy( ( char * ) pcWriteBuffer, ( const char * ) pxCommand->pxCommandLineDefinition->pcHelpString, xWriteBufferLen );
   83e38:	4c05      	ldr	r4, [pc, #20]	; (83e50 <prvHelpCommand+0x28>)
   83e3a:	6825      	ldr	r5, [r4, #0]
   83e3c:	682b      	ldr	r3, [r5, #0]
   83e3e:	6859      	ldr	r1, [r3, #4]
   83e40:	4b05      	ldr	r3, [pc, #20]	; (83e58 <prvHelpCommand+0x30>)
   83e42:	4798      	blx	r3
	pxCommand = pxCommand->pxNext;
   83e44:	6868      	ldr	r0, [r5, #4]
   83e46:	6020      	str	r0, [r4, #0]
	{
		xReturn = pdTRUE;
	}

	return xReturn;
}
   83e48:	3000      	adds	r0, #0
   83e4a:	bf18      	it	ne
   83e4c:	2001      	movne	r0, #1
   83e4e:	bd38      	pop	{r3, r4, r5, pc}
   83e50:	2007187c 	.word	0x2007187c
   83e54:	20070450 	.word	0x20070450
   83e58:	0008695d 	.word	0x0008695d

00083e5c <FreeRTOS_CLIRegisterCommand>:
static int8_t cOutputBuffer[ configCOMMAND_INT_MAX_OUTPUT_SIZE ];

/*-----------------------------------------------------------*/

portBASE_TYPE FreeRTOS_CLIRegisterCommand( const CLI_Command_Definition_t * const pxCommandToRegister )
{
   83e5c:	b538      	push	{r3, r4, r5, lr}
static CLI_Definition_List_Item_t *pxLastCommandInList = &xRegisteredCommands;
CLI_Definition_List_Item_t *pxNewListItem;
portBASE_TYPE xReturn = pdFAIL;

	/* Check the parameter is not NULL. */
	configASSERT( pxCommandToRegister );
   83e5e:	4605      	mov	r5, r0
   83e60:	b918      	cbnz	r0, 83e6a <FreeRTOS_CLIRegisterCommand+0xe>
   83e62:	480e      	ldr	r0, [pc, #56]	; (83e9c <FreeRTOS_CLIRegisterCommand+0x40>)
   83e64:	2167      	movs	r1, #103	; 0x67
   83e66:	4b0e      	ldr	r3, [pc, #56]	; (83ea0 <FreeRTOS_CLIRegisterCommand+0x44>)
   83e68:	4798      	blx	r3

	/* Create a new list item that will reference the command being registered. */
	pxNewListItem = ( CLI_Definition_List_Item_t * ) pvPortMalloc( sizeof( CLI_Definition_List_Item_t ) );
   83e6a:	2008      	movs	r0, #8
   83e6c:	4b0d      	ldr	r3, [pc, #52]	; (83ea4 <FreeRTOS_CLIRegisterCommand+0x48>)
   83e6e:	4798      	blx	r3
	configASSERT( pxNewListItem );
   83e70:	4604      	mov	r4, r0
   83e72:	b928      	cbnz	r0, 83e80 <FreeRTOS_CLIRegisterCommand+0x24>
   83e74:	4809      	ldr	r0, [pc, #36]	; (83e9c <FreeRTOS_CLIRegisterCommand+0x40>)
   83e76:	216b      	movs	r1, #107	; 0x6b
   83e78:	4b09      	ldr	r3, [pc, #36]	; (83ea0 <FreeRTOS_CLIRegisterCommand+0x44>)
   83e7a:	4798      	blx	r3

portBASE_TYPE FreeRTOS_CLIRegisterCommand( const CLI_Command_Definition_t * const pxCommandToRegister )
{
static CLI_Definition_List_Item_t *pxLastCommandInList = &xRegisteredCommands;
CLI_Definition_List_Item_t *pxNewListItem;
portBASE_TYPE xReturn = pdFAIL;
   83e7c:	2000      	movs	r0, #0
   83e7e:	bd38      	pop	{r3, r4, r5, pc}
	pxNewListItem = ( CLI_Definition_List_Item_t * ) pvPortMalloc( sizeof( CLI_Definition_List_Item_t ) );
	configASSERT( pxNewListItem );

	if( pxNewListItem != NULL )
	{
		taskENTER_CRITICAL();
   83e80:	4b09      	ldr	r3, [pc, #36]	; (83ea8 <FreeRTOS_CLIRegisterCommand+0x4c>)
   83e82:	4798      	blx	r3
		{
			/* Reference the command being registered from the newly created
			list item. */
			pxNewListItem->pxCommandLineDefinition = pxCommandToRegister;
   83e84:	6025      	str	r5, [r4, #0]

			/* The new list item will get added to the end of the list, so
			pxNext has nowhere to point. */
			pxNewListItem->pxNext = NULL;
   83e86:	2300      	movs	r3, #0
   83e88:	6063      	str	r3, [r4, #4]

			/* Add the newly created list item to the end of the already existing
			list. */
			pxLastCommandInList->pxNext = pxNewListItem;
   83e8a:	4b08      	ldr	r3, [pc, #32]	; (83eac <FreeRTOS_CLIRegisterCommand+0x50>)
   83e8c:	681a      	ldr	r2, [r3, #0]
   83e8e:	6054      	str	r4, [r2, #4]

			/* Set the end of list marker to the new list item. */
			pxLastCommandInList = pxNewListItem;
   83e90:	601c      	str	r4, [r3, #0]
		}
		taskEXIT_CRITICAL();
   83e92:	4b07      	ldr	r3, [pc, #28]	; (83eb0 <FreeRTOS_CLIRegisterCommand+0x54>)
   83e94:	4798      	blx	r3

		xReturn = pdPASS;
   83e96:	2001      	movs	r0, #1
	}

	return xReturn;
}
   83e98:	bd38      	pop	{r3, r4, r5, pc}
   83e9a:	bf00      	nop
   83e9c:	0008c4a8 	.word	0x0008c4a8
   83ea0:	00085f89 	.word	0x00085f89
   83ea4:	00084285 	.word	0x00084285
   83ea8:	00084139 	.word	0x00084139
   83eac:	2007044c 	.word	0x2007044c
   83eb0:	00084159 	.word	0x00084159

00083eb4 <FreeRTOS_CLIProcessCommand>:
/*-----------------------------------------------------------*/

portBASE_TYPE FreeRTOS_CLIProcessCommand( const int8_t * const pcCommandInput, int8_t * pcWriteBuffer, size_t xWriteBufferLen  )
{
   83eb4:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
   83eb8:	4606      	mov	r6, r0
   83eba:	468a      	mov	sl, r1
   83ebc:	4693      	mov	fp, r2
size_t xCommandStringLength;

	/* Note:  This function is not re-entrant.  It must not be called from more
	thank one task. */

	if( pxCommand == NULL )
   83ebe:	4b33      	ldr	r3, [pc, #204]	; (83f8c <FreeRTOS_CLIProcessCommand+0xd8>)
   83ec0:	681b      	ldr	r3, [r3, #0]
   83ec2:	2b00      	cmp	r3, #0
   83ec4:	d146      	bne.n	83f54 <FreeRTOS_CLIProcessCommand+0xa0>
	{
		/* Search for the command string in the list of registered commands. */
		for( pxCommand = &xRegisteredCommands; pxCommand != NULL; pxCommand = pxCommand->pxNext )
   83ec6:	4c32      	ldr	r4, [pc, #200]	; (83f90 <FreeRTOS_CLIProcessCommand+0xdc>)
   83ec8:	4b30      	ldr	r3, [pc, #192]	; (83f8c <FreeRTOS_CLIProcessCommand+0xd8>)
   83eca:	601c      	str	r4, [r3, #0]
		{
			pcRegisteredCommandString = pxCommand->pxCommandLineDefinition->pcCommand;
			xCommandStringLength = strlen( ( const char * ) pcRegisteredCommandString );
   83ecc:	f8df 80d4 	ldr.w	r8, [pc, #212]	; 83fa4 <FreeRTOS_CLIProcessCommand+0xf0>
	thank one task. */

	if( pxCommand == NULL )
	{
		/* Search for the command string in the list of registered commands. */
		for( pxCommand = &xRegisteredCommands; pxCommand != NULL; pxCommand = pxCommand->pxNext )
   83ed0:	4699      	mov	r9, r3
		{
			pcRegisteredCommandString = pxCommand->pxCommandLineDefinition->pcCommand;
   83ed2:	6827      	ldr	r7, [r4, #0]
   83ed4:	683d      	ldr	r5, [r7, #0]
			xCommandStringLength = strlen( ( const char * ) pcRegisteredCommandString );
   83ed6:	4628      	mov	r0, r5
   83ed8:	47c0      	blx	r8
   83eda:	4602      	mov	r2, r0

			/* To ensure the string lengths match exactly, so as not to pick up
			a sub-string of a longer command, check the byte after the expected
			end of the string is either the end of the string or a space before
			a parameter. */
			if( ( pcCommandInput[ xCommandStringLength ] == ' ' ) || ( pcCommandInput[ xCommandStringLength ] == 0x00 ) )
   83edc:	5633      	ldrsb	r3, [r6, r0]
   83ede:	f033 0120 	bics.w	r1, r3, #32
   83ee2:	d125      	bne.n	83f30 <FreeRTOS_CLIProcessCommand+0x7c>
			{
				if( strncmp( ( const char * ) pcCommandInput, ( const char * ) pcRegisteredCommandString, xCommandStringLength ) == 0 )
   83ee4:	4630      	mov	r0, r6
   83ee6:	4629      	mov	r1, r5
   83ee8:	4b2a      	ldr	r3, [pc, #168]	; (83f94 <FreeRTOS_CLIProcessCommand+0xe0>)
   83eea:	4798      	blx	r3
   83eec:	bb00      	cbnz	r0, 83f30 <FreeRTOS_CLIProcessCommand+0x7c>
				{
					/* The command has been found.  Check it has the expected
					number of parameters.  If cExpectedNumberOfParameters is -1,
					then there could be a variable number of parameters and no
					check is made. */
					if( pxCommand->pxCommandLineDefinition->cExpectedNumberOfParameters >= 0 )
   83eee:	7b39      	ldrb	r1, [r7, #12]
   83ef0:	f011 0f80 	tst.w	r1, #128	; 0x80
   83ef4:	d141      	bne.n	83f7a <FreeRTOS_CLIProcessCommand+0xc6>
{
int8_t cParameters = 0;
portBASE_TYPE xLastCharacterWasSpace = pdFALSE;

	/* Count the number of space delimited words in pcCommandString. */
	while( *pcCommandString != 0x00 )
   83ef6:	7833      	ldrb	r3, [r6, #0]
   83ef8:	b1ab      	cbz	r3, 83f26 <FreeRTOS_CLIProcessCommand+0x72>
   83efa:	4630      	mov	r0, r6
   83efc:	2200      	movs	r2, #0
   83efe:	4614      	mov	r4, r2
				xLastCharacterWasSpace = pdTRUE;
			}
		}
		else
		{
			xLastCharacterWasSpace = pdFALSE;
   83f00:	4615      	mov	r5, r2
		if( ( *pcCommandString ) == ' ' )
		{
			if( xLastCharacterWasSpace != pdTRUE )
			{
				cParameters++;
				xLastCharacterWasSpace = pdTRUE;
   83f02:	2701      	movs	r7, #1
portBASE_TYPE xLastCharacterWasSpace = pdFALSE;

	/* Count the number of space delimited words in pcCommandString. */
	while( *pcCommandString != 0x00 )
	{
		if( ( *pcCommandString ) == ' ' )
   83f04:	b25b      	sxtb	r3, r3
   83f06:	2b20      	cmp	r3, #32
   83f08:	d104      	bne.n	83f14 <FreeRTOS_CLIProcessCommand+0x60>
		{
			if( xLastCharacterWasSpace != pdTRUE )
   83f0a:	b924      	cbnz	r4, 83f16 <FreeRTOS_CLIProcessCommand+0x62>
			{
				cParameters++;
   83f0c:	3201      	adds	r2, #1
   83f0e:	b2d2      	uxtb	r2, r2
				xLastCharacterWasSpace = pdTRUE;
   83f10:	463c      	mov	r4, r7
   83f12:	e000      	b.n	83f16 <FreeRTOS_CLIProcessCommand+0x62>
			}
		}
		else
		{
			xLastCharacterWasSpace = pdFALSE;
   83f14:	462c      	mov	r4, r5
{
int8_t cParameters = 0;
portBASE_TYPE xLastCharacterWasSpace = pdFALSE;

	/* Count the number of space delimited words in pcCommandString. */
	while( *pcCommandString != 0x00 )
   83f16:	f810 3f01 	ldrb.w	r3, [r0, #1]!
   83f1a:	2b00      	cmp	r3, #0
   83f1c:	d1f2      	bne.n	83f04 <FreeRTOS_CLIProcessCommand+0x50>
		pcCommandString++;
	}

	/* If the command string ended with spaces, then there will have been too
	many parameters counted. */
	if( xLastCharacterWasSpace == pdTRUE )
   83f1e:	b11c      	cbz	r4, 83f28 <FreeRTOS_CLIProcessCommand+0x74>
	{
		cParameters--;
   83f20:	3a01      	subs	r2, #1
   83f22:	b2d2      	uxtb	r2, r2
   83f24:	e000      	b.n	83f28 <FreeRTOS_CLIProcessCommand+0x74>
{
int8_t cParameters = 0;
portBASE_TYPE xLastCharacterWasSpace = pdFALSE;

	/* Count the number of space delimited words in pcCommandString. */
	while( *pcCommandString != 0x00 )
   83f26:	2200      	movs	r2, #0
				}
			}
		}
	}

	if( ( pxCommand != NULL ) && ( xReturn == pdFALSE ) )
   83f28:	4b18      	ldr	r3, [pc, #96]	; (83f8c <FreeRTOS_CLIProcessCommand+0xd8>)
   83f2a:	681b      	ldr	r3, [r3, #0]
   83f2c:	b92b      	cbnz	r3, 83f3a <FreeRTOS_CLIProcessCommand+0x86>
   83f2e:	e01d      	b.n	83f6c <FreeRTOS_CLIProcessCommand+0xb8>
	thank one task. */

	if( pxCommand == NULL )
	{
		/* Search for the command string in the list of registered commands. */
		for( pxCommand = &xRegisteredCommands; pxCommand != NULL; pxCommand = pxCommand->pxNext )
   83f30:	6864      	ldr	r4, [r4, #4]
   83f32:	f8c9 4000 	str.w	r4, [r9]
   83f36:	b1cc      	cbz	r4, 83f6c <FreeRTOS_CLIProcessCommand+0xb8>
   83f38:	e7cb      	b.n	83ed2 <FreeRTOS_CLIProcessCommand+0x1e>
				}
			}
		}
	}

	if( ( pxCommand != NULL ) && ( xReturn == pdFALSE ) )
   83f3a:	b249      	sxtb	r1, r1
   83f3c:	b252      	sxtb	r2, r2
   83f3e:	4291      	cmp	r1, r2
   83f40:	d008      	beq.n	83f54 <FreeRTOS_CLIProcessCommand+0xa0>
	{
		/* The command was found, but the number of parameters with the command
		was incorrect. */
		strncpy( ( char * ) pcWriteBuffer, "Incorrect command parameter(s).  Enter \"help\" to view a list of available commands.\r\n\r\n", xWriteBufferLen );
   83f42:	4650      	mov	r0, sl
   83f44:	4914      	ldr	r1, [pc, #80]	; (83f98 <FreeRTOS_CLIProcessCommand+0xe4>)
   83f46:	465a      	mov	r2, fp
   83f48:	4b14      	ldr	r3, [pc, #80]	; (83f9c <FreeRTOS_CLIProcessCommand+0xe8>)
   83f4a:	4798      	blx	r3
		pxCommand = NULL;
   83f4c:	2300      	movs	r3, #0
   83f4e:	4a0f      	ldr	r2, [pc, #60]	; (83f8c <FreeRTOS_CLIProcessCommand+0xd8>)
   83f50:	6013      	str	r3, [r2, #0]
   83f52:	e017      	b.n	83f84 <FreeRTOS_CLIProcessCommand+0xd0>
	}
	else if( pxCommand != NULL )
	{
		/* Call the callback function that is registered to this command. */
		xReturn = pxCommand->pxCommandLineDefinition->pxCommandInterpreter( pcWriteBuffer, xWriteBufferLen, pcCommandInput );
   83f54:	681b      	ldr	r3, [r3, #0]
   83f56:	689b      	ldr	r3, [r3, #8]
   83f58:	4650      	mov	r0, sl
   83f5a:	4659      	mov	r1, fp
   83f5c:	4632      	mov	r2, r6
   83f5e:	4798      	blx	r3

		/* If xReturn is pdFALSE, then no further strings will be returned
		after this one, and	pxCommand can be reset to NULL ready to search
		for the next entered command. */
		if( xReturn == pdFALSE )
   83f60:	4603      	mov	r3, r0
   83f62:	b978      	cbnz	r0, 83f84 <FreeRTOS_CLIProcessCommand+0xd0>
		{
			pxCommand = NULL;
   83f64:	2100      	movs	r1, #0
   83f66:	4a09      	ldr	r2, [pc, #36]	; (83f8c <FreeRTOS_CLIProcessCommand+0xd8>)
   83f68:	6011      	str	r1, [r2, #0]
   83f6a:	e00b      	b.n	83f84 <FreeRTOS_CLIProcessCommand+0xd0>
		}
	}
	else
	{
		/* pxCommand was NULL, the command was not found. */
		strncpy( ( char * ) pcWriteBuffer, ( const char * const ) "Command not recognised.  Enter \"help\" to view a list of available commands.\r\n\r\n", xWriteBufferLen );
   83f6c:	4650      	mov	r0, sl
   83f6e:	490c      	ldr	r1, [pc, #48]	; (83fa0 <FreeRTOS_CLIProcessCommand+0xec>)
   83f70:	465a      	mov	r2, fp
   83f72:	4b0a      	ldr	r3, [pc, #40]	; (83f9c <FreeRTOS_CLIProcessCommand+0xe8>)
   83f74:	4798      	blx	r3
		xReturn = pdFALSE;
   83f76:	2300      	movs	r3, #0
   83f78:	e004      	b.n	83f84 <FreeRTOS_CLIProcessCommand+0xd0>
				}
			}
		}
	}

	if( ( pxCommand != NULL ) && ( xReturn == pdFALSE ) )
   83f7a:	4b04      	ldr	r3, [pc, #16]	; (83f8c <FreeRTOS_CLIProcessCommand+0xd8>)
   83f7c:	681b      	ldr	r3, [r3, #0]
		/* The command was found, but the number of parameters with the command
		was incorrect. */
		strncpy( ( char * ) pcWriteBuffer, "Incorrect command parameter(s).  Enter \"help\" to view a list of available commands.\r\n\r\n", xWriteBufferLen );
		pxCommand = NULL;
	}
	else if( pxCommand != NULL )
   83f7e:	2b00      	cmp	r3, #0
   83f80:	d0f4      	beq.n	83f6c <FreeRTOS_CLIProcessCommand+0xb8>
   83f82:	e7e7      	b.n	83f54 <FreeRTOS_CLIProcessCommand+0xa0>
		strncpy( ( char * ) pcWriteBuffer, ( const char * const ) "Command not recognised.  Enter \"help\" to view a list of available commands.\r\n\r\n", xWriteBufferLen );
		xReturn = pdFALSE;
	}

	return xReturn;
}
   83f84:	4618      	mov	r0, r3
   83f86:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
   83f8a:	bf00      	nop
   83f8c:	20071880 	.word	0x20071880
   83f90:	20070450 	.word	0x20070450
   83f94:	000868a9 	.word	0x000868a9
   83f98:	0008c4ec 	.word	0x0008c4ec
   83f9c:	0008695d 	.word	0x0008695d
   83fa0:	0008c544 	.word	0x0008c544
   83fa4:	000867e5 	.word	0x000867e5

00083fa8 <FreeRTOS_CLIGetOutputBuffer>:
/*-----------------------------------------------------------*/

int8_t *FreeRTOS_CLIGetOutputBuffer( void )
{
	return cOutputBuffer;
}
   83fa8:	4800      	ldr	r0, [pc, #0]	; (83fac <FreeRTOS_CLIGetOutputBuffer+0x4>)
   83faa:	4770      	bx	lr
   83fac:	20071884 	.word	0x20071884

00083fb0 <FreeRTOS_CLIGetParameter>:
/*-----------------------------------------------------------*/

const int8_t *FreeRTOS_CLIGetParameter( const int8_t *pcCommandString, unsigned portBASE_TYPE uxWantedParameter, portBASE_TYPE *pxParameterStringLength )
{
   83fb0:	b4f0      	push	{r4, r5, r6, r7}
unsigned portBASE_TYPE uxParametersFound = 0;
const int8_t *pcReturn = NULL;

	*pxParameterStringLength = 0;
   83fb2:	2300      	movs	r3, #0
   83fb4:	6013      	str	r3, [r2, #0]

	while( uxParametersFound < uxWantedParameter )
   83fb6:	460f      	mov	r7, r1
   83fb8:	b359      	cbz	r1, 84012 <FreeRTOS_CLIGetParameter+0x62>
}
/*-----------------------------------------------------------*/

const int8_t *FreeRTOS_CLIGetParameter( const int8_t *pcCommandString, unsigned portBASE_TYPE uxWantedParameter, portBASE_TYPE *pxParameterStringLength )
{
unsigned portBASE_TYPE uxParametersFound = 0;
   83fba:	461e      	mov	r6, r3
   83fbc:	e022      	b.n	84004 <FreeRTOS_CLIGetParameter+0x54>
	{
		/* Index the character pointer past the current word.  If this is the start
		of the command string then the first word is the command itself. */
		while( ( ( *pcCommandString ) != 0x00 ) && ( ( *pcCommandString ) != ' ' ) )
		{
			pcCommandString++;
   83fbe:	4618      	mov	r0, r3

	while( uxParametersFound < uxWantedParameter )
	{
		/* Index the character pointer past the current word.  If this is the start
		of the command string then the first word is the command itself. */
		while( ( ( *pcCommandString ) != 0x00 ) && ( ( *pcCommandString ) != ' ' ) )
   83fc0:	f813 4b01 	ldrb.w	r4, [r3], #1
   83fc4:	b34c      	cbz	r4, 8401a <FreeRTOS_CLIGetParameter+0x6a>
   83fc6:	b264      	sxtb	r4, r4
   83fc8:	2c20      	cmp	r4, #32
   83fca:	d1f8      	bne.n	83fbe <FreeRTOS_CLIGetParameter+0xe>
   83fcc:	e027      	b.n	8401e <FreeRTOS_CLIGetParameter+0x6e>
		}

		/* Find the start of the next string. */
		while( ( ( *pcCommandString ) != 0x00 ) && ( ( *pcCommandString ) == ' ' ) )
		{
			pcCommandString++;
   83fce:	4618      	mov	r0, r3
		{
			pcCommandString++;
		}

		/* Find the start of the next string. */
		while( ( ( *pcCommandString ) != 0x00 ) && ( ( *pcCommandString ) == ' ' ) )
   83fd0:	f813 4b01 	ldrb.w	r4, [r3], #1
   83fd4:	b265      	sxtb	r5, r4
   83fd6:	2d20      	cmp	r5, #32
   83fd8:	d0f9      	beq.n	83fce <FreeRTOS_CLIGetParameter+0x1e>
		{
			pcCommandString++;
		}

		/* Was a string found? */
		if( *pcCommandString != 0x00 )
   83fda:	b1e4      	cbz	r4, 84016 <FreeRTOS_CLIGetParameter+0x66>
		{
			/* Is this the start of the required parameter? */
			uxParametersFound++;
   83fdc:	3601      	adds	r6, #1

			if( uxParametersFound == uxWantedParameter )
   83fde:	42be      	cmp	r6, r7
   83fe0:	d110      	bne.n	84004 <FreeRTOS_CLIGetParameter+0x54>
			{
				/* How long is the parameter? */
				pcReturn = pcCommandString;
				while( ( ( *pcCommandString ) != 0x00 ) && ( ( *pcCommandString ) != ' ' ) )
   83fe2:	f990 3000 	ldrsb.w	r3, [r0]
   83fe6:	f033 0120 	bics.w	r1, r3, #32
   83fea:	d009      	beq.n	84000 <FreeRTOS_CLIGetParameter+0x50>
   83fec:	4601      	mov	r1, r0
				{
					( *pxParameterStringLength )++;
   83fee:	6813      	ldr	r3, [r2, #0]
   83ff0:	3301      	adds	r3, #1
   83ff2:	6013      	str	r3, [r2, #0]

			if( uxParametersFound == uxWantedParameter )
			{
				/* How long is the parameter? */
				pcReturn = pcCommandString;
				while( ( ( *pcCommandString ) != 0x00 ) && ( ( *pcCommandString ) != ' ' ) )
   83ff4:	f911 4f01 	ldrsb.w	r4, [r1, #1]!
   83ff8:	f034 0520 	bics.w	r5, r4, #32
   83ffc:	d1f7      	bne.n	83fee <FreeRTOS_CLIGetParameter+0x3e>
				{
					( *pxParameterStringLength )++;
					pcCommandString++;
				}

				if( *pxParameterStringLength == 0 )
   83ffe:	b983      	cbnz	r3, 84022 <FreeRTOS_CLIGetParameter+0x72>
				{
					pcReturn = NULL;
   84000:	2000      	movs	r0, #0
   84002:	e00e      	b.n	84022 <FreeRTOS_CLIGetParameter+0x72>

	while( uxParametersFound < uxWantedParameter )
	{
		/* Index the character pointer past the current word.  If this is the start
		of the command string then the first word is the command itself. */
		while( ( ( *pcCommandString ) != 0x00 ) && ( ( *pcCommandString ) != ' ' ) )
   84004:	7803      	ldrb	r3, [r0, #0]
   84006:	b143      	cbz	r3, 8401a <FreeRTOS_CLIGetParameter+0x6a>
   84008:	b25b      	sxtb	r3, r3
   8400a:	2b20      	cmp	r3, #32
   8400c:	d007      	beq.n	8401e <FreeRTOS_CLIGetParameter+0x6e>
   8400e:	1c43      	adds	r3, r0, #1
   84010:	e7d5      	b.n	83fbe <FreeRTOS_CLIGetParameter+0xe>
/*-----------------------------------------------------------*/

const int8_t *FreeRTOS_CLIGetParameter( const int8_t *pcCommandString, unsigned portBASE_TYPE uxWantedParameter, portBASE_TYPE *pxParameterStringLength )
{
unsigned portBASE_TYPE uxParametersFound = 0;
const int8_t *pcReturn = NULL;
   84012:	2000      	movs	r0, #0
   84014:	e005      	b.n	84022 <FreeRTOS_CLIGetParameter+0x72>
   84016:	2000      	movs	r0, #0
   84018:	e003      	b.n	84022 <FreeRTOS_CLIGetParameter+0x72>
		{
			pcCommandString++;
		}

		/* Find the start of the next string. */
		while( ( ( *pcCommandString ) != 0x00 ) && ( ( *pcCommandString ) == ' ' ) )
   8401a:	7804      	ldrb	r4, [r0, #0]
   8401c:	e7dd      	b.n	83fda <FreeRTOS_CLIGetParameter+0x2a>
   8401e:	1c43      	adds	r3, r0, #1
   84020:	e7d5      	b.n	83fce <FreeRTOS_CLIGetParameter+0x1e>
			break;
		}
	}

	return pcReturn;
}
   84022:	bcf0      	pop	{r4, r5, r6, r7}
   84024:	4770      	bx	lr
   84026:	bf00      	nop

00084028 <vListInitialise>:
void vListInitialise( xList *pxList )
{
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( xListItem * ) &( pxList->xListEnd );
   84028:	f100 0308 	add.w	r3, r0, #8
   8402c:	6043      	str	r3, [r0, #4]

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
   8402e:	f04f 32ff 	mov.w	r2, #4294967295
   84032:	6082      	str	r2, [r0, #8]

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( xListItem * ) &( pxList->xListEnd );
   84034:	60c3      	str	r3, [r0, #12]
	pxList->xListEnd.pxPrevious = ( xListItem * ) &( pxList->xListEnd );
   84036:	6103      	str	r3, [r0, #16]

	pxList->uxNumberOfItems = ( unsigned portBASE_TYPE ) 0U;
   84038:	2300      	movs	r3, #0
   8403a:	6003      	str	r3, [r0, #0]
   8403c:	4770      	bx	lr
   8403e:	bf00      	nop

00084040 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( xListItem *pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
   84040:	2300      	movs	r3, #0
   84042:	6103      	str	r3, [r0, #16]
   84044:	4770      	bx	lr
   84046:	bf00      	nop

00084048 <vListInsertEnd>:

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	pvListGetOwnerOfNextEntry.  This means it has to be the item pointed to by
	the pxIndex member. */
	pxIndex = pxList->pxIndex;
   84048:	6843      	ldr	r3, [r0, #4]

	pxNewListItem->pxNext = pxIndex->pxNext;
   8404a:	685a      	ldr	r2, [r3, #4]
   8404c:	604a      	str	r2, [r1, #4]
	pxNewListItem->pxPrevious = pxList->pxIndex;
   8404e:	6842      	ldr	r2, [r0, #4]
   84050:	608a      	str	r2, [r1, #8]
	pxIndex->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
   84052:	685a      	ldr	r2, [r3, #4]
   84054:	6091      	str	r1, [r2, #8]
	pxIndex->pxNext = ( volatile xListItem * ) pxNewListItem;
   84056:	6059      	str	r1, [r3, #4]
	pxList->pxIndex = ( volatile xListItem * ) pxNewListItem;
   84058:	6041      	str	r1, [r0, #4]

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
   8405a:	6108      	str	r0, [r1, #16]

	( pxList->uxNumberOfItems )++;
   8405c:	6803      	ldr	r3, [r0, #0]
   8405e:	3301      	adds	r3, #1
   84060:	6003      	str	r3, [r0, #0]
   84062:	4770      	bx	lr

00084064 <vListInsert>:
}
/*-----------------------------------------------------------*/

void vListInsert( xList *pxList, xListItem *pxNewListItem )
{
   84064:	b410      	push	{r4}
volatile xListItem *pxIterator;
portTickType xValueOfInsertion;

	/* Insert the new list item into the list, sorted in ulListItem order. */
	xValueOfInsertion = pxNewListItem->xItemValue;
   84066:	680c      	ldr	r4, [r1, #0]
	are stored in ready lists (all of which have the same ulListItem value)
	get an equal share of the CPU.  However, if the xItemValue is the same as
	the back marker the iteration loop below will not end.  This means we need
	to guard against this by checking the value first and modifying the
	algorithm slightly if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
   84068:	f1b4 3fff 	cmp.w	r4, #4294967295
   8406c:	d101      	bne.n	84072 <vListInsert+0xe>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
   8406e:	6903      	ldr	r3, [r0, #16]
   84070:	e00a      	b.n	84088 <vListInsert+0x24>
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		See http://www.freertos.org/FAQHelp.html for more tips.
		**********************************************************************/

		for( pxIterator = ( xListItem * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext )
   84072:	f100 0308 	add.w	r3, r0, #8
   84076:	68c2      	ldr	r2, [r0, #12]
   84078:	6812      	ldr	r2, [r2, #0]
   8407a:	4294      	cmp	r4, r2
   8407c:	d304      	bcc.n	84088 <vListInsert+0x24>
   8407e:	685b      	ldr	r3, [r3, #4]
   84080:	685a      	ldr	r2, [r3, #4]
   84082:	6812      	ldr	r2, [r2, #0]
   84084:	4294      	cmp	r4, r2
   84086:	d2fa      	bcs.n	8407e <vListInsert+0x1a>
			/* There is nothing to do here, we are just iterating to the
			wanted insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
   84088:	685a      	ldr	r2, [r3, #4]
   8408a:	604a      	str	r2, [r1, #4]
	pxNewListItem->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
   8408c:	6091      	str	r1, [r2, #8]
	pxNewListItem->pxPrevious = pxIterator;
   8408e:	608b      	str	r3, [r1, #8]
	pxIterator->pxNext = ( volatile xListItem * ) pxNewListItem;
   84090:	6059      	str	r1, [r3, #4]

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
   84092:	6108      	str	r0, [r1, #16]

	( pxList->uxNumberOfItems )++;
   84094:	6803      	ldr	r3, [r0, #0]
   84096:	3301      	adds	r3, #1
   84098:	6003      	str	r3, [r0, #0]
}
   8409a:	f85d 4b04 	ldr.w	r4, [sp], #4
   8409e:	4770      	bx	lr

000840a0 <uxListRemove>:

unsigned portBASE_TYPE uxListRemove( xListItem *pxItemToRemove )
{
xList * pxList;

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
   840a0:	6843      	ldr	r3, [r0, #4]
   840a2:	6882      	ldr	r2, [r0, #8]
   840a4:	609a      	str	r2, [r3, #8]
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
   840a6:	6883      	ldr	r3, [r0, #8]
   840a8:	6842      	ldr	r2, [r0, #4]
   840aa:	605a      	str	r2, [r3, #4]

	/* The list item knows which list it is in.  Obtain the list from the list
	item. */
	pxList = ( xList * ) pxItemToRemove->pvContainer;
   840ac:	6903      	ldr	r3, [r0, #16]

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
   840ae:	685a      	ldr	r2, [r3, #4]
   840b0:	4282      	cmp	r2, r0
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
   840b2:	bf04      	itt	eq
   840b4:	6882      	ldreq	r2, [r0, #8]
   840b6:	605a      	streq	r2, [r3, #4]
	}

	pxItemToRemove->pvContainer = NULL;
   840b8:	2200      	movs	r2, #0
   840ba:	6102      	str	r2, [r0, #16]
	( pxList->uxNumberOfItems )--;
   840bc:	681a      	ldr	r2, [r3, #0]
   840be:	3a01      	subs	r2, #1
   840c0:	601a      	str	r2, [r3, #0]

	return pxList->uxNumberOfItems;
   840c2:	6818      	ldr	r0, [r3, #0]
}
   840c4:	4770      	bx	lr
   840c6:	bf00      	nop

000840c8 <prvPortStartFirstTask>:
}
/*-----------------------------------------------------------*/

static void prvPortStartFirstTask( void )
{
	__asm volatile(
   840c8:	4803      	ldr	r0, [pc, #12]	; (840d8 <prvPortStartFirstTask+0x10>)
   840ca:	6800      	ldr	r0, [r0, #0]
   840cc:	6800      	ldr	r0, [r0, #0]
   840ce:	f380 8808 	msr	MSP, r0
   840d2:	b662      	cpsie	i
   840d4:	df00      	svc	0
   840d6:	bf00      	nop
   840d8:	e000ed08 	.word	0xe000ed08

000840dc <pxPortInitialiseStack>:
portSTACK_TYPE *pxPortInitialiseStack( portSTACK_TYPE *pxTopOfStack, pdTASK_CODE pxCode, void *pvParameters )
{
	/* Simulate the stack frame as it would be created by a context switch
	interrupt. */
	pxTopOfStack--; /* Offset added to account for the way the MCU uses the stack on entry/exit of interrupts. */
	*pxTopOfStack = portINITIAL_XPSR;	/* xPSR */
   840dc:	f04f 7380 	mov.w	r3, #16777216	; 0x1000000
   840e0:	f840 3c04 	str.w	r3, [r0, #-4]
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) pxCode;	/* PC */
   840e4:	f840 1c08 	str.w	r1, [r0, #-8]
	pxTopOfStack--;
	*pxTopOfStack = 0;	/* LR */
   840e8:	2300      	movs	r3, #0
   840ea:	f840 3c0c 	str.w	r3, [r0, #-12]
	pxTopOfStack -= 5;	/* R12, R3, R2 and R1. */
	*pxTopOfStack = ( portSTACK_TYPE ) pvParameters;	/* R0 */
   840ee:	f840 2c20 	str.w	r2, [r0, #-32]
	pxTopOfStack -= 8;	/* R11, R10, R9, R8, R7, R6, R5 and R4. */

	return pxTopOfStack;
}
   840f2:	3840      	subs	r0, #64	; 0x40
   840f4:	4770      	bx	lr
   840f6:	bf00      	nop

000840f8 <SVC_Handler>:
/*-----------------------------------------------------------*/

__attribute__ (( naked )) void SVC_Handler( void )
{
	__asm volatile (
   840f8:	4b06      	ldr	r3, [pc, #24]	; (84114 <pxCurrentTCBConst2>)
   840fa:	6819      	ldr	r1, [r3, #0]
   840fc:	6808      	ldr	r0, [r1, #0]
   840fe:	e8b0 0ff0 	ldmia.w	r0!, {r4, r5, r6, r7, r8, r9, sl, fp}
   84102:	f380 8809 	msr	PSP, r0
   84106:	f04f 0000 	mov.w	r0, #0
   8410a:	f380 8811 	msr	BASEPRI, r0
   8410e:	f04e 0e0d 	orr.w	lr, lr, #13
   84112:	4770      	bx	lr

00084114 <pxCurrentTCBConst2>:
   84114:	20075ad8 	.word	0x20075ad8

00084118 <vPortYieldFromISR>:
/*-----------------------------------------------------------*/

void vPortYieldFromISR( void )
{
	/* Set a PendSV to request a context switch. */
	portNVIC_INT_CTRL_REG = portNVIC_PENDSVSET_BIT;
   84118:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
   8411c:	4b01      	ldr	r3, [pc, #4]	; (84124 <vPortYieldFromISR+0xc>)
   8411e:	601a      	str	r2, [r3, #0]
   84120:	4770      	bx	lr
   84122:	bf00      	nop
   84124:	e000ed04 	.word	0xe000ed04

00084128 <ulPortSetInterruptMask>:
}
/*-----------------------------------------------------------*/

__attribute__(( naked )) unsigned long ulPortSetInterruptMask( void )
{
	__asm volatile														\
   84128:	f3ef 8011 	mrs	r0, BASEPRI
   8412c:	f04f 01a0 	mov.w	r1, #160	; 0xa0
   84130:	f381 8811 	msr	BASEPRI, r1
   84134:	4770      	bx	lr
	);

	/* This return will not be reached but is necessary to prevent compiler
	warnings. */
	return 0;
}
   84136:	2000      	movs	r0, #0

00084138 <vPortEnterCritical>:
	portNVIC_INT_CTRL_REG = portNVIC_PENDSVSET_BIT;
}
/*-----------------------------------------------------------*/

void vPortEnterCritical( void )
{
   84138:	b508      	push	{r3, lr}
	portDISABLE_INTERRUPTS();
   8413a:	4b03      	ldr	r3, [pc, #12]	; (84148 <vPortEnterCritical+0x10>)
   8413c:	4798      	blx	r3
	uxCriticalNesting++;
   8413e:	4b03      	ldr	r3, [pc, #12]	; (8414c <vPortEnterCritical+0x14>)
   84140:	681a      	ldr	r2, [r3, #0]
   84142:	3201      	adds	r2, #1
   84144:	601a      	str	r2, [r3, #0]
   84146:	bd08      	pop	{r3, pc}
   84148:	00084129 	.word	0x00084129
   8414c:	20070458 	.word	0x20070458

00084150 <vPortClearInterruptMask>:
}
/*-----------------------------------------------------------*/

__attribute__(( naked )) void vPortClearInterruptMask( unsigned long ulNewMaskValue )
{
	__asm volatile													\
   84150:	f380 8811 	msr	BASEPRI, r0
   84154:	4770      	bx	lr
   84156:	bf00      	nop

00084158 <vPortExitCritical>:
	uxCriticalNesting++;
}
/*-----------------------------------------------------------*/

void vPortExitCritical( void )
{
   84158:	b508      	push	{r3, lr}
	uxCriticalNesting--;
   8415a:	4a04      	ldr	r2, [pc, #16]	; (8416c <vPortExitCritical+0x14>)
   8415c:	6813      	ldr	r3, [r2, #0]
   8415e:	3b01      	subs	r3, #1
   84160:	6013      	str	r3, [r2, #0]
	if( uxCriticalNesting == 0 )
   84162:	b913      	cbnz	r3, 8416a <vPortExitCritical+0x12>
	{
		portENABLE_INTERRUPTS();
   84164:	2000      	movs	r0, #0
   84166:	4b02      	ldr	r3, [pc, #8]	; (84170 <vPortExitCritical+0x18>)
   84168:	4798      	blx	r3
   8416a:	bd08      	pop	{r3, pc}
   8416c:	20070458 	.word	0x20070458
   84170:	00084151 	.word	0x00084151

00084174 <PendSV_Handler>:

__attribute__(( naked )) void PendSV_Handler( void )
{
	/* This is a naked function. */

	__asm volatile
   84174:	f3ef 8009 	mrs	r0, PSP
   84178:	4b0c      	ldr	r3, [pc, #48]	; (841ac <pxCurrentTCBConst>)
   8417a:	681a      	ldr	r2, [r3, #0]
   8417c:	e920 0ff0 	stmdb	r0!, {r4, r5, r6, r7, r8, r9, sl, fp}
   84180:	6010      	str	r0, [r2, #0]
   84182:	e92d 4008 	stmdb	sp!, {r3, lr}
   84186:	f04f 00a0 	mov.w	r0, #160	; 0xa0
   8418a:	f380 8811 	msr	BASEPRI, r0
   8418e:	f001 f901 	bl	85394 <vTaskSwitchContext>
   84192:	f04f 0000 	mov.w	r0, #0
   84196:	f380 8811 	msr	BASEPRI, r0
   8419a:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
   8419e:	6819      	ldr	r1, [r3, #0]
   841a0:	6808      	ldr	r0, [r1, #0]
   841a2:	e8b0 0ff0 	ldmia.w	r0!, {r4, r5, r6, r7, r8, r9, sl, fp}
   841a6:	f380 8809 	msr	PSP, r0
   841aa:	4770      	bx	lr

000841ac <pxCurrentTCBConst>:
   841ac:	20075ad8 	.word	0x20075ad8

000841b0 <SysTick_Handler>:
	);
}
/*-----------------------------------------------------------*/

void SysTick_Handler( void )
{
   841b0:	b508      	push	{r3, lr}
	/* If using preemption, also force a context switch. */
	#if configUSE_PREEMPTION == 1
		portNVIC_INT_CTRL_REG = portNVIC_PENDSVSET_BIT;
   841b2:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
   841b6:	4b05      	ldr	r3, [pc, #20]	; (841cc <SysTick_Handler+0x1c>)
   841b8:	601a      	str	r2, [r3, #0]
	to generate the tick interrupt. */
	#if configUSE_TICKLESS_IDLE == 1
		portNVIC_SYSTICK_LOAD_REG = ulTimerReloadValueForOneTick;
	#endif

	( void ) portSET_INTERRUPT_MASK_FROM_ISR();
   841ba:	4b05      	ldr	r3, [pc, #20]	; (841d0 <SysTick_Handler+0x20>)
   841bc:	4798      	blx	r3
	{
		vTaskIncrementTick();
   841be:	4b05      	ldr	r3, [pc, #20]	; (841d4 <SysTick_Handler+0x24>)
   841c0:	4798      	blx	r3
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( 0 );
   841c2:	2000      	movs	r0, #0
   841c4:	4b04      	ldr	r3, [pc, #16]	; (841d8 <SysTick_Handler+0x28>)
   841c6:	4798      	blx	r3
   841c8:	bd08      	pop	{r3, pc}
   841ca:	bf00      	nop
   841cc:	e000ed04 	.word	0xe000ed04
   841d0:	00084129 	.word	0x00084129
   841d4:	00084ec1 	.word	0x00084ec1
   841d8:	00084151 	.word	0x00084151

000841dc <vPortSetupTimerInterrupt>:
		ulStoppedTimerCompensation = 45UL / ( configCPU_CLOCK_HZ / configSYSTICK_CLOCK_HZ );
	}
	#endif /* configUSE_TICKLESS_IDLE */

	/* Configure SysTick to interrupt at the requested rate. */
	portNVIC_SYSTICK_LOAD_REG = ( configSYSTICK_CLOCK_HZ / configTICK_RATE_HZ ) - 1UL;;
   841dc:	4a03      	ldr	r2, [pc, #12]	; (841ec <vPortSetupTimerInterrupt+0x10>)
   841de:	4b04      	ldr	r3, [pc, #16]	; (841f0 <vPortSetupTimerInterrupt+0x14>)
   841e0:	601a      	str	r2, [r3, #0]
	portNVIC_SYSTICK_CTRL_REG = portNVIC_SYSTICK_CLK_BIT | portNVIC_SYSTICK_INT_BIT | portNVIC_SYSTICK_ENABLE_BIT;
   841e2:	2207      	movs	r2, #7
   841e4:	3b04      	subs	r3, #4
   841e6:	601a      	str	r2, [r3, #0]
   841e8:	4770      	bx	lr
   841ea:	bf00      	nop
   841ec:	0001481f 	.word	0x0001481f
   841f0:	e000e014 	.word	0xe000e014

000841f4 <xPortStartScheduler>:

/*
 * See header file for description.
 */
portBASE_TYPE xPortStartScheduler( void )
{
   841f4:	b510      	push	{r4, lr}
	/* configMAX_SYSCALL_INTERRUPT_PRIORITY must not be set to 0.
	See http://www.FreeRTOS.org/RTOS-Cortex-M3-M4.html */
	configASSERT( configMAX_SYSCALL_INTERRUPT_PRIORITY );

	/* Make PendSV, CallSV and SysTick the same priroity as the kernel. */
	portNVIC_SYSPRI2_REG |= portNVIC_PENDSV_PRI;
   841f6:	4b09      	ldr	r3, [pc, #36]	; (8421c <xPortStartScheduler+0x28>)
   841f8:	681a      	ldr	r2, [r3, #0]
   841fa:	f442 0270 	orr.w	r2, r2, #15728640	; 0xf00000
   841fe:	601a      	str	r2, [r3, #0]
	portNVIC_SYSPRI2_REG |= portNVIC_SYSTICK_PRI;
   84200:	681a      	ldr	r2, [r3, #0]
   84202:	f042 4270 	orr.w	r2, r2, #4026531840	; 0xf0000000
   84206:	601a      	str	r2, [r3, #0]

	/* Start the timer that generates the tick ISR.  Interrupts are disabled
	here already. */
	vPortSetupTimerInterrupt();
   84208:	4b05      	ldr	r3, [pc, #20]	; (84220 <xPortStartScheduler+0x2c>)
   8420a:	4798      	blx	r3

	/* Initialise the critical nesting count ready for the first task. */
	uxCriticalNesting = 0;
   8420c:	2400      	movs	r4, #0
   8420e:	4b05      	ldr	r3, [pc, #20]	; (84224 <xPortStartScheduler+0x30>)
   84210:	601c      	str	r4, [r3, #0]

	/* Start the first task. */
	prvPortStartFirstTask();
   84212:	4b05      	ldr	r3, [pc, #20]	; (84228 <xPortStartScheduler+0x34>)
   84214:	4798      	blx	r3

	/* Should not get here! */
	return 0;
}
   84216:	4620      	mov	r0, r4
   84218:	bd10      	pop	{r4, pc}
   8421a:	bf00      	nop
   8421c:	e000ed20 	.word	0xe000ed20
   84220:	000841dd 	.word	0x000841dd
   84224:	20070458 	.word	0x20070458
   84228:	000840c9 	.word	0x000840c9

0008422c <prvInsertBlockIntoFreeList>:
	xFreeBytesRemaining -= heapSTRUCT_SIZE;
}
/*-----------------------------------------------------------*/

static void prvInsertBlockIntoFreeList( xBlockLink *pxBlockToInsert )
{
   8422c:	b430      	push	{r4, r5}
xBlockLink *pxIterator;
unsigned char *puc;

	/* Iterate through the list until a block is found that has a higher address
	than the block being inserted. */
	for( pxIterator = &xStart; pxIterator->pxNextFreeBlock < pxBlockToInsert; pxIterator = pxIterator->pxNextFreeBlock )
   8422e:	4a13      	ldr	r2, [pc, #76]	; (8427c <prvInsertBlockIntoFreeList+0x50>)
   84230:	6813      	ldr	r3, [r2, #0]
   84232:	4283      	cmp	r3, r0
   84234:	d201      	bcs.n	8423a <prvInsertBlockIntoFreeList+0xe>
   84236:	461a      	mov	r2, r3
   84238:	e7fa      	b.n	84230 <prvInsertBlockIntoFreeList+0x4>
   8423a:	4611      	mov	r1, r2
	}

	/* Do the block being inserted, and the block it is being inserted after
	make a contiguous block of memory? */	
	puc = ( unsigned char * ) pxIterator;
	if( ( puc + pxIterator->xBlockSize ) == ( unsigned char * ) pxBlockToInsert )
   8423c:	6854      	ldr	r4, [r2, #4]
   8423e:	1915      	adds	r5, r2, r4
   84240:	4285      	cmp	r5, r0
   84242:	d103      	bne.n	8424c <prvInsertBlockIntoFreeList+0x20>
	{
		pxIterator->xBlockSize += pxBlockToInsert->xBlockSize;
   84244:	6868      	ldr	r0, [r5, #4]
   84246:	4404      	add	r4, r0
   84248:	6054      	str	r4, [r2, #4]
   8424a:	4610      	mov	r0, r2
	}

	/* Do the block being inserted, and the block it is being inserted before
	make a contiguous block of memory? */
	puc = ( unsigned char * ) pxBlockToInsert;
	if( ( puc + pxBlockToInsert->xBlockSize ) == ( unsigned char * ) pxIterator->pxNextFreeBlock )
   8424c:	6842      	ldr	r2, [r0, #4]
   8424e:	1884      	adds	r4, r0, r2
   84250:	42a3      	cmp	r3, r4
   84252:	d10c      	bne.n	8426e <prvInsertBlockIntoFreeList+0x42>
	{
		if( pxIterator->pxNextFreeBlock != pxEnd )
   84254:	4c0a      	ldr	r4, [pc, #40]	; (84280 <prvInsertBlockIntoFreeList+0x54>)
   84256:	6824      	ldr	r4, [r4, #0]
   84258:	429c      	cmp	r4, r3
   8425a:	d006      	beq.n	8426a <prvInsertBlockIntoFreeList+0x3e>
		{
			/* Form one big block from the two blocks. */
			pxBlockToInsert->xBlockSize += pxIterator->pxNextFreeBlock->xBlockSize;
   8425c:	685b      	ldr	r3, [r3, #4]
   8425e:	441a      	add	r2, r3
   84260:	6042      	str	r2, [r0, #4]
			pxBlockToInsert->pxNextFreeBlock = pxIterator->pxNextFreeBlock->pxNextFreeBlock;
   84262:	680b      	ldr	r3, [r1, #0]
   84264:	681b      	ldr	r3, [r3, #0]
   84266:	6003      	str	r3, [r0, #0]
   84268:	e002      	b.n	84270 <prvInsertBlockIntoFreeList+0x44>
		}
		else
		{
			pxBlockToInsert->pxNextFreeBlock = pxEnd;
   8426a:	6003      	str	r3, [r0, #0]
   8426c:	e000      	b.n	84270 <prvInsertBlockIntoFreeList+0x44>
		}
	}
	else
	{
		pxBlockToInsert->pxNextFreeBlock = pxIterator->pxNextFreeBlock;		
   8426e:	6003      	str	r3, [r0, #0]

	/* If the block being inserted plugged a gab, so was merged with the block
	before and the block after, then it's pxNextFreeBlock pointer will have
	already been set, and should not be set here as that would make it point
	to itself. */
	if( pxIterator != pxBlockToInsert )
   84270:	4281      	cmp	r1, r0
	{
		pxIterator->pxNextFreeBlock = pxBlockToInsert;
   84272:	bf18      	it	ne
   84274:	6008      	strne	r0, [r1, #0]
	}
}
   84276:	bc30      	pop	{r4, r5}
   84278:	4770      	bx	lr
   8427a:	bf00      	nop
   8427c:	20075a1c 	.word	0x20075a1c
   84280:	20075a18 	.word	0x20075a18

00084284 <pvPortMalloc>:
/* STATIC FUNCTIONS ARE DEFINED AS MACROS TO MINIMIZE THE FUNCTION CALL DEPTH. */

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
   84284:	b538      	push	{r3, r4, r5, lr}
   84286:	4604      	mov	r4, r0
xBlockLink *pxBlock, *pxPreviousBlock, *pxNewBlockLink;
void *pvReturn = NULL;

	vTaskSuspendAll();
   84288:	4b29      	ldr	r3, [pc, #164]	; (84330 <pvPortMalloc+0xac>)
   8428a:	4798      	blx	r3
	{
		/* If this is the first call to malloc then the heap will require
		initialisation to setup the list of free blocks. */
		if( pxEnd == NULL )
   8428c:	4b29      	ldr	r3, [pc, #164]	; (84334 <pvPortMalloc+0xb0>)
   8428e:	681b      	ldr	r3, [r3, #0]
   84290:	b99b      	cbnz	r3, 842ba <pvPortMalloc+0x36>
	/* Ensure the start of the heap is aligned. */
	configASSERT( ( ( ( unsigned long ) xHeap.ucHeap ) & ( ( unsigned long ) portBYTE_ALIGNMENT_MASK ) ) == 0UL );

	/* xStart is used to hold a pointer to the first item in the list of free
	blocks.  The void cast is used to prevent compiler warnings. */
	xStart.pxNextFreeBlock = ( void * ) xHeap.ucHeap;
   84292:	4a29      	ldr	r2, [pc, #164]	; (84338 <pvPortMalloc+0xb4>)
   84294:	4b29      	ldr	r3, [pc, #164]	; (8433c <pvPortMalloc+0xb8>)
   84296:	6013      	str	r3, [r2, #0]
	xStart.xBlockSize = ( size_t ) 0;
   84298:	2100      	movs	r1, #0
   8429a:	6051      	str	r1, [r2, #4]

	/* pxEnd is used to mark the end of the list of free blocks and is inserted
	at the end of the heap space. */
	pucHeapEnd = xHeap.ucHeap + xTotalHeapSize;
	pucHeapEnd -= heapSTRUCT_SIZE;
	pxEnd = ( void * ) pucHeapEnd;
   8429c:	f643 72f0 	movw	r2, #16368	; 0x3ff0
   842a0:	1898      	adds	r0, r3, r2
   842a2:	4d24      	ldr	r5, [pc, #144]	; (84334 <pvPortMalloc+0xb0>)
   842a4:	6028      	str	r0, [r5, #0]
	configASSERT( ( ( ( unsigned long ) pxEnd ) & ( ( unsigned long ) portBYTE_ALIGNMENT_MASK ) ) == 0UL );
	pxEnd->xBlockSize = 0;
   842a6:	f643 75f4 	movw	r5, #16372	; 0x3ff4
   842aa:	5159      	str	r1, [r3, r5]
	pxEnd->pxNextFreeBlock = NULL;
   842ac:	5099      	str	r1, [r3, r2]

	/* To start with there is a single free block that is sized to take up the
	entire heap space, minus the space taken by pxEnd. */
	pxFirstFreeBlock = ( void * ) xHeap.ucHeap;
	pxFirstFreeBlock->xBlockSize = xTotalHeapSize - heapSTRUCT_SIZE;
   842ae:	605a      	str	r2, [r3, #4]
	pxFirstFreeBlock->pxNextFreeBlock = pxEnd;
   842b0:	6018      	str	r0, [r3, #0]

	/* The heap now contains pxEnd. */
	xFreeBytesRemaining -= heapSTRUCT_SIZE;
   842b2:	4b23      	ldr	r3, [pc, #140]	; (84340 <pvPortMalloc+0xbc>)
   842b4:	681a      	ldr	r2, [r3, #0]
   842b6:	3a10      	subs	r2, #16
   842b8:	601a      	str	r2, [r3, #0]
			prvHeapInit();
		}

		/* The wanted size is increased so it can contain a xBlockLink
		structure in addition to the requested amount of bytes. */
		if( xWantedSize > 0 )
   842ba:	2c00      	cmp	r4, #0
   842bc:	d032      	beq.n	84324 <pvPortMalloc+0xa0>
		{
			xWantedSize += heapSTRUCT_SIZE;
   842be:	f104 0210 	add.w	r2, r4, #16

			/* Ensure that blocks are always aligned to the required number of 
			bytes. */
			if( xWantedSize & portBYTE_ALIGNMENT_MASK )
   842c2:	f012 0f07 	tst.w	r2, #7
			{
				/* Byte alignment required. */
				xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
   842c6:	bf1c      	itt	ne
   842c8:	f022 0207 	bicne.w	r2, r2, #7
   842cc:	3208      	addne	r2, #8
			}
		}

		if( ( xWantedSize > 0 ) && ( xWantedSize < xTotalHeapSize ) )
   842ce:	1e51      	subs	r1, r2, #1
   842d0:	f643 73fe 	movw	r3, #16382	; 0x3ffe
   842d4:	4299      	cmp	r1, r3
   842d6:	d825      	bhi.n	84324 <pvPortMalloc+0xa0>
		{
			/* Traverse the list from the start	(lowest address) block until one
			of adequate size is found. */
			pxPreviousBlock = &xStart;
			pxBlock = xStart.pxNextFreeBlock;
   842d8:	4917      	ldr	r1, [pc, #92]	; (84338 <pvPortMalloc+0xb4>)
   842da:	680c      	ldr	r4, [r1, #0]
			while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock != NULL ) )
   842dc:	6863      	ldr	r3, [r4, #4]
   842de:	429a      	cmp	r2, r3
   842e0:	d904      	bls.n	842ec <pvPortMalloc+0x68>
   842e2:	6823      	ldr	r3, [r4, #0]
   842e4:	b113      	cbz	r3, 842ec <pvPortMalloc+0x68>
   842e6:	4621      	mov	r1, r4
			{
				pxPreviousBlock = pxBlock;
				pxBlock = pxBlock->pxNextFreeBlock;
   842e8:	461c      	mov	r4, r3
   842ea:	e7f7      	b.n	842dc <pvPortMalloc+0x58>
			}

			/* If the end marker was reached then a block of adequate size was
			not found. */
			if( pxBlock != pxEnd )
   842ec:	4b11      	ldr	r3, [pc, #68]	; (84334 <pvPortMalloc+0xb0>)
   842ee:	681b      	ldr	r3, [r3, #0]
   842f0:	429c      	cmp	r4, r3
   842f2:	d017      	beq.n	84324 <pvPortMalloc+0xa0>
			{
				/* Return the memory space - jumping over the xBlockLink structure
				at its start. */
				pvReturn = ( void * ) ( ( ( unsigned char * ) pxPreviousBlock->pxNextFreeBlock ) + heapSTRUCT_SIZE );
   842f4:	680d      	ldr	r5, [r1, #0]
   842f6:	3510      	adds	r5, #16

				/* This block is being returned for use so must be taken out of
				the	list of free blocks. */
				pxPreviousBlock->pxNextFreeBlock = pxBlock->pxNextFreeBlock;
   842f8:	6823      	ldr	r3, [r4, #0]
   842fa:	600b      	str	r3, [r1, #0]

				/* If the block is larger than required it can be split into two. */
				if( ( pxBlock->xBlockSize - xWantedSize ) > heapMINIMUM_BLOCK_SIZE )
   842fc:	6863      	ldr	r3, [r4, #4]
   842fe:	1a9b      	subs	r3, r3, r2
   84300:	2b20      	cmp	r3, #32
   84302:	d904      	bls.n	8430e <pvPortMalloc+0x8a>
				{
					/* This block is to be split into two.  Create a new block
					following the number of bytes requested. The void cast is
					used to prevent byte alignment warnings from the compiler. */
					pxNewBlockLink = ( void * ) ( ( ( unsigned char * ) pxBlock ) + xWantedSize );
   84304:	18a0      	adds	r0, r4, r2

					/* Calculate the sizes of two blocks split from the single
					block. */
					pxNewBlockLink->xBlockSize = pxBlock->xBlockSize - xWantedSize;
   84306:	6043      	str	r3, [r0, #4]
					pxBlock->xBlockSize = xWantedSize;
   84308:	6062      	str	r2, [r4, #4]

					/* Insert the new block into the list of free blocks. */
					prvInsertBlockIntoFreeList( ( pxNewBlockLink ) );
   8430a:	4b0e      	ldr	r3, [pc, #56]	; (84344 <pvPortMalloc+0xc0>)
   8430c:	4798      	blx	r3
				}

				xFreeBytesRemaining -= pxBlock->xBlockSize;
   8430e:	4b0c      	ldr	r3, [pc, #48]	; (84340 <pvPortMalloc+0xbc>)
   84310:	681a      	ldr	r2, [r3, #0]
   84312:	6861      	ldr	r1, [r4, #4]
   84314:	1a52      	subs	r2, r2, r1
   84316:	601a      	str	r2, [r3, #0]
			}
		}
	}
	xTaskResumeAll();
   84318:	4b0b      	ldr	r3, [pc, #44]	; (84348 <pvPortMalloc+0xc4>)
   8431a:	4798      	blx	r3

	#if( configUSE_MALLOC_FAILED_HOOK == 1 )
	{
		if( pvReturn == NULL )
   8431c:	b935      	cbnz	r5, 8432c <pvPortMalloc+0xa8>
		{
			extern void vApplicationMallocFailedHook( void );
			vApplicationMallocFailedHook();
   8431e:	4b0b      	ldr	r3, [pc, #44]	; (8434c <pvPortMalloc+0xc8>)
   84320:	4798      	blx	r3
   84322:	e003      	b.n	8432c <pvPortMalloc+0xa8>

				xFreeBytesRemaining -= pxBlock->xBlockSize;
			}
		}
	}
	xTaskResumeAll();
   84324:	4b08      	ldr	r3, [pc, #32]	; (84348 <pvPortMalloc+0xc4>)
   84326:	4798      	blx	r3
   84328:	2500      	movs	r5, #0
   8432a:	e7f8      	b.n	8431e <pvPortMalloc+0x9a>
		}
	}
	#endif

	return pvReturn;
}
   8432c:	4628      	mov	r0, r5
   8432e:	bd38      	pop	{r3, r4, r5, pc}
   84330:	00084e71 	.word	0x00084e71
   84334:	20075a18 	.word	0x20075a18
   84338:	20075a1c 	.word	0x20075a1c
   8433c:	20071a18 	.word	0x20071a18
   84340:	2007045c 	.word	0x2007045c
   84344:	0008422d 	.word	0x0008422d
   84348:	00084fe9 	.word	0x00084fe9
   8434c:	00085f71 	.word	0x00085f71

00084350 <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
   84350:	b510      	push	{r4, lr}
unsigned char *puc = ( unsigned char * ) pv;
xBlockLink *pxLink;

	if( pv != NULL )
   84352:	4604      	mov	r4, r0
   84354:	b168      	cbz	r0, 84372 <vPortFree+0x22>
		puc -= heapSTRUCT_SIZE;

		/* This casting is to keep the compiler from issuing warnings. */
		pxLink = ( void * ) puc;

		vTaskSuspendAll();
   84356:	4b07      	ldr	r3, [pc, #28]	; (84374 <vPortFree+0x24>)
   84358:	4798      	blx	r3
		{
			/* Add this block to the list of free blocks. */
			xFreeBytesRemaining += pxLink->xBlockSize;
   8435a:	4b07      	ldr	r3, [pc, #28]	; (84378 <vPortFree+0x28>)
   8435c:	6819      	ldr	r1, [r3, #0]
   8435e:	f854 2c0c 	ldr.w	r2, [r4, #-12]
   84362:	440a      	add	r2, r1
   84364:	601a      	str	r2, [r3, #0]
			prvInsertBlockIntoFreeList( ( ( xBlockLink * ) pxLink ) );			
   84366:	f1a4 0010 	sub.w	r0, r4, #16
   8436a:	4b04      	ldr	r3, [pc, #16]	; (8437c <vPortFree+0x2c>)
   8436c:	4798      	blx	r3
		}
		xTaskResumeAll();
   8436e:	4b04      	ldr	r3, [pc, #16]	; (84380 <vPortFree+0x30>)
   84370:	4798      	blx	r3
   84372:	bd10      	pop	{r4, pc}
   84374:	00084e71 	.word	0x00084e71
   84378:	2007045c 	.word	0x2007045c
   8437c:	0008422d 	.word	0x0008422d
   84380:	00084fe9 	.word	0x00084fe9

00084384 <prvCopyDataToQueue>:

#endif
/*-----------------------------------------------------------*/

static void prvCopyDataToQueue( xQUEUE *pxQueue, const void *pvItemToQueue, portBASE_TYPE xPosition )
{
   84384:	b510      	push	{r4, lr}
   84386:	4604      	mov	r4, r0
	if( pxQueue->uxItemSize == ( unsigned portBASE_TYPE ) 0 )
   84388:	6c03      	ldr	r3, [r0, #64]	; 0x40
   8438a:	b93b      	cbnz	r3, 8439c <prvCopyDataToQueue+0x18>
	{
		#if ( configUSE_MUTEXES == 1 )
		{
			if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
   8438c:	6803      	ldr	r3, [r0, #0]
   8438e:	bb1b      	cbnz	r3, 843d8 <prvCopyDataToQueue+0x54>
			{
				/* The mutex is no longer being held. */
				vTaskPriorityDisinherit( ( void * ) pxQueue->pxMutexHolder );
   84390:	6840      	ldr	r0, [r0, #4]
   84392:	4b13      	ldr	r3, [pc, #76]	; (843e0 <prvCopyDataToQueue+0x5c>)
   84394:	4798      	blx	r3
				pxQueue->pxMutexHolder = NULL;
   84396:	2300      	movs	r3, #0
   84398:	6063      	str	r3, [r4, #4]
   8439a:	e01d      	b.n	843d8 <prvCopyDataToQueue+0x54>
			}
		}
		#endif
	}
	else if( xPosition == queueSEND_TO_BACK )
   8439c:	b96a      	cbnz	r2, 843ba <prvCopyDataToQueue+0x36>
	{
		memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
   8439e:	6880      	ldr	r0, [r0, #8]
   843a0:	461a      	mov	r2, r3
   843a2:	4b10      	ldr	r3, [pc, #64]	; (843e4 <prvCopyDataToQueue+0x60>)
   843a4:	4798      	blx	r3
		pxQueue->pcWriteTo += pxQueue->uxItemSize;
   843a6:	68a2      	ldr	r2, [r4, #8]
   843a8:	6c23      	ldr	r3, [r4, #64]	; 0x40
   843aa:	4413      	add	r3, r2
   843ac:	60a3      	str	r3, [r4, #8]
		if( pxQueue->pcWriteTo >= pxQueue->pcTail )
   843ae:	6862      	ldr	r2, [r4, #4]
   843b0:	4293      	cmp	r3, r2
   843b2:	d311      	bcc.n	843d8 <prvCopyDataToQueue+0x54>
		{
			pxQueue->pcWriteTo = pxQueue->pcHead;
   843b4:	6823      	ldr	r3, [r4, #0]
   843b6:	60a3      	str	r3, [r4, #8]
   843b8:	e00e      	b.n	843d8 <prvCopyDataToQueue+0x54>
		}
	}
	else
	{
		memcpy( ( void * ) pxQueue->pcReadFrom, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
   843ba:	68c0      	ldr	r0, [r0, #12]
   843bc:	461a      	mov	r2, r3
   843be:	4b09      	ldr	r3, [pc, #36]	; (843e4 <prvCopyDataToQueue+0x60>)
   843c0:	4798      	blx	r3
		pxQueue->pcReadFrom -= pxQueue->uxItemSize;
   843c2:	6c22      	ldr	r2, [r4, #64]	; 0x40
   843c4:	4252      	negs	r2, r2
   843c6:	68e3      	ldr	r3, [r4, #12]
   843c8:	4413      	add	r3, r2
   843ca:	60e3      	str	r3, [r4, #12]
		if( pxQueue->pcReadFrom < pxQueue->pcHead )
   843cc:	6821      	ldr	r1, [r4, #0]
   843ce:	428b      	cmp	r3, r1
   843d0:	d202      	bcs.n	843d8 <prvCopyDataToQueue+0x54>
		{
			pxQueue->pcReadFrom = ( pxQueue->pcTail - pxQueue->uxItemSize );
   843d2:	6863      	ldr	r3, [r4, #4]
   843d4:	441a      	add	r2, r3
   843d6:	60e2      	str	r2, [r4, #12]
		}
	}

	++( pxQueue->uxMessagesWaiting );
   843d8:	6ba3      	ldr	r3, [r4, #56]	; 0x38
   843da:	3301      	adds	r3, #1
   843dc:	63a3      	str	r3, [r4, #56]	; 0x38
   843de:	bd10      	pop	{r4, pc}
   843e0:	0008576d 	.word	0x0008576d
   843e4:	000862d5 	.word	0x000862d5

000843e8 <prvCopyDataFromQueue>:
}
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( xQUEUE * const pxQueue, const void *pvBuffer )
{
   843e8:	b538      	push	{r3, r4, r5, lr}
   843ea:	4603      	mov	r3, r0
	if( pxQueue->uxQueueType != queueQUEUE_IS_MUTEX )
   843ec:	6805      	ldr	r5, [r0, #0]
   843ee:	b15d      	cbz	r5, 84408 <prvCopyDataFromQueue+0x20>
	{
		pxQueue->pcReadFrom += pxQueue->uxItemSize;
   843f0:	6c02      	ldr	r2, [r0, #64]	; 0x40
   843f2:	68c4      	ldr	r4, [r0, #12]
   843f4:	4414      	add	r4, r2
   843f6:	60c4      	str	r4, [r0, #12]
		if( pxQueue->pcReadFrom >= pxQueue->pcTail )
   843f8:	6840      	ldr	r0, [r0, #4]
   843fa:	4284      	cmp	r4, r0
		{
			pxQueue->pcReadFrom = pxQueue->pcHead;
   843fc:	bf28      	it	cs
   843fe:	60dd      	strcs	r5, [r3, #12]
		}
		memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->pcReadFrom, ( unsigned ) pxQueue->uxItemSize );
   84400:	4608      	mov	r0, r1
   84402:	68d9      	ldr	r1, [r3, #12]
   84404:	4b01      	ldr	r3, [pc, #4]	; (8440c <prvCopyDataFromQueue+0x24>)
   84406:	4798      	blx	r3
   84408:	bd38      	pop	{r3, r4, r5, pc}
   8440a:	bf00      	nop
   8440c:	000862d5 	.word	0x000862d5

00084410 <prvUnlockQueue>:
	}
}
/*-----------------------------------------------------------*/

static void prvUnlockQueue( xQueueHandle pxQueue )
{
   84410:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   84412:	4604      	mov	r4, r0

	/* The lock counts contains the number of extra data items placed or
	removed from the queue while the queue was locked.  When a queue is
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
   84414:	4b1d      	ldr	r3, [pc, #116]	; (8448c <prvUnlockQueue+0x7c>)
   84416:	4798      	blx	r3
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
   84418:	6ca3      	ldr	r3, [r4, #72]	; 0x48
   8441a:	2b00      	cmp	r3, #0
   8441c:	dd12      	ble.n	84444 <prvUnlockQueue+0x34>
		{
			/* Data was posted while the queue was locked.  Are any tasks
			blocked waiting for data to become available? */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
   8441e:	6a63      	ldr	r3, [r4, #36]	; 0x24
   84420:	b183      	cbz	r3, 84444 <prvUnlockQueue+0x34>
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
   84422:	f104 0624 	add.w	r6, r4, #36	; 0x24
   84426:	4d1a      	ldr	r5, [pc, #104]	; (84490 <prvUnlockQueue+0x80>)
				{
					/* The task waiting has a higher priority so record that a
					context	switch is required. */
					vTaskMissedYield();
   84428:	4f1a      	ldr	r7, [pc, #104]	; (84494 <prvUnlockQueue+0x84>)
   8442a:	e001      	b.n	84430 <prvUnlockQueue+0x20>
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
		{
			/* Data was posted while the queue was locked.  Are any tasks
			blocked waiting for data to become available? */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
   8442c:	6a63      	ldr	r3, [r4, #36]	; 0x24
   8442e:	b14b      	cbz	r3, 84444 <prvUnlockQueue+0x34>
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
   84430:	4630      	mov	r0, r6
   84432:	47a8      	blx	r5
   84434:	b100      	cbz	r0, 84438 <prvUnlockQueue+0x28>
				{
					/* The task waiting has a higher priority so record that a
					context	switch is required. */
					vTaskMissedYield();
   84436:	47b8      	blx	r7
				}

				--( pxQueue->xTxLock );
   84438:	6ca3      	ldr	r3, [r4, #72]	; 0x48
   8443a:	3b01      	subs	r3, #1
   8443c:	64a3      	str	r3, [r4, #72]	; 0x48
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
   8443e:	6ca3      	ldr	r3, [r4, #72]	; 0x48
   84440:	2b00      	cmp	r3, #0
   84442:	dcf3      	bgt.n	8442c <prvUnlockQueue+0x1c>
			{
				break;
			}
		}

		pxQueue->xTxLock = queueUNLOCKED;
   84444:	f04f 33ff 	mov.w	r3, #4294967295
   84448:	64a3      	str	r3, [r4, #72]	; 0x48
	}
	taskEXIT_CRITICAL();
   8444a:	4b13      	ldr	r3, [pc, #76]	; (84498 <prvUnlockQueue+0x88>)
   8444c:	4798      	blx	r3

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
   8444e:	4b0f      	ldr	r3, [pc, #60]	; (8448c <prvUnlockQueue+0x7c>)
   84450:	4798      	blx	r3
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
   84452:	6c63      	ldr	r3, [r4, #68]	; 0x44
   84454:	2b00      	cmp	r3, #0
   84456:	dd12      	ble.n	8447e <prvUnlockQueue+0x6e>
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
   84458:	6923      	ldr	r3, [r4, #16]
   8445a:	b183      	cbz	r3, 8447e <prvUnlockQueue+0x6e>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
   8445c:	f104 0610 	add.w	r6, r4, #16
   84460:	4d0b      	ldr	r5, [pc, #44]	; (84490 <prvUnlockQueue+0x80>)
				{
					vTaskMissedYield();
   84462:	4f0c      	ldr	r7, [pc, #48]	; (84494 <prvUnlockQueue+0x84>)
   84464:	e001      	b.n	8446a <prvUnlockQueue+0x5a>
	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
   84466:	6923      	ldr	r3, [r4, #16]
   84468:	b14b      	cbz	r3, 8447e <prvUnlockQueue+0x6e>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
   8446a:	4630      	mov	r0, r6
   8446c:	47a8      	blx	r5
   8446e:	b100      	cbz	r0, 84472 <prvUnlockQueue+0x62>
				{
					vTaskMissedYield();
   84470:	47b8      	blx	r7
				}

				--( pxQueue->xRxLock );
   84472:	6c63      	ldr	r3, [r4, #68]	; 0x44
   84474:	3b01      	subs	r3, #1
   84476:	6463      	str	r3, [r4, #68]	; 0x44
	taskEXIT_CRITICAL();

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
   84478:	6c63      	ldr	r3, [r4, #68]	; 0x44
   8447a:	2b00      	cmp	r3, #0
   8447c:	dcf3      	bgt.n	84466 <prvUnlockQueue+0x56>
			{
				break;
			}
		}

		pxQueue->xRxLock = queueUNLOCKED;
   8447e:	f04f 33ff 	mov.w	r3, #4294967295
   84482:	6463      	str	r3, [r4, #68]	; 0x44
	}
	taskEXIT_CRITICAL();
   84484:	4b04      	ldr	r3, [pc, #16]	; (84498 <prvUnlockQueue+0x88>)
   84486:	4798      	blx	r3
   84488:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   8448a:	bf00      	nop
   8448c:	00084139 	.word	0x00084139
   84490:	00085555 	.word	0x00085555
   84494:	00085699 	.word	0x00085699
   84498:	00084159 	.word	0x00084159

0008449c <xQueueGenericReset>:
/*-----------------------------------------------------------
 * PUBLIC QUEUE MANAGEMENT API documented in queue.h
 *----------------------------------------------------------*/

portBASE_TYPE xQueueGenericReset( xQueueHandle pxQueue, portBASE_TYPE xNewQueue )
{
   8449c:	b538      	push	{r3, r4, r5, lr}
   8449e:	460d      	mov	r5, r1
	configASSERT( pxQueue );
   844a0:	4604      	mov	r4, r0
   844a2:	b920      	cbnz	r0, 844ae <xQueueGenericReset+0x12>
   844a4:	4817      	ldr	r0, [pc, #92]	; (84504 <xQueueGenericReset+0x68>)
   844a6:	f240 111b 	movw	r1, #283	; 0x11b
   844aa:	4b17      	ldr	r3, [pc, #92]	; (84508 <xQueueGenericReset+0x6c>)
   844ac:	4798      	blx	r3

	taskENTER_CRITICAL();
   844ae:	4b17      	ldr	r3, [pc, #92]	; (8450c <xQueueGenericReset+0x70>)
   844b0:	4798      	blx	r3
	{
		pxQueue->pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize );
   844b2:	6823      	ldr	r3, [r4, #0]
   844b4:	6c22      	ldr	r2, [r4, #64]	; 0x40
   844b6:	6be0      	ldr	r0, [r4, #60]	; 0x3c
   844b8:	fb00 f002 	mul.w	r0, r0, r2
   844bc:	1819      	adds	r1, r3, r0
   844be:	6061      	str	r1, [r4, #4]
		pxQueue->uxMessagesWaiting = ( unsigned portBASE_TYPE ) 0U;
   844c0:	2100      	movs	r1, #0
   844c2:	63a1      	str	r1, [r4, #56]	; 0x38
		pxQueue->pcWriteTo = pxQueue->pcHead;
   844c4:	60a3      	str	r3, [r4, #8]
		pxQueue->pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - ( unsigned portBASE_TYPE ) 1U ) * pxQueue->uxItemSize );
   844c6:	1a82      	subs	r2, r0, r2
   844c8:	4413      	add	r3, r2
   844ca:	60e3      	str	r3, [r4, #12]
		pxQueue->xRxLock = queueUNLOCKED;
   844cc:	f04f 33ff 	mov.w	r3, #4294967295
   844d0:	6463      	str	r3, [r4, #68]	; 0x44
		pxQueue->xTxLock = queueUNLOCKED;
   844d2:	64a3      	str	r3, [r4, #72]	; 0x48

		if( xNewQueue == pdFALSE )
   844d4:	b955      	cbnz	r5, 844ec <xQueueGenericReset+0x50>
			/* If there are tasks blocked waiting to read from the queue, then
			the tasks will remain blocked as after this function exits the queue
			will still be empty.  If there are tasks blocked waiting to	write to
			the queue, then one should be unblocked as after this function exits
			it will be possible to write to it. */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
   844d6:	6923      	ldr	r3, [r4, #16]
   844d8:	b17b      	cbz	r3, 844fa <xQueueGenericReset+0x5e>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
   844da:	f104 0010 	add.w	r0, r4, #16
   844de:	4b0c      	ldr	r3, [pc, #48]	; (84510 <xQueueGenericReset+0x74>)
   844e0:	4798      	blx	r3
   844e2:	2801      	cmp	r0, #1
   844e4:	d109      	bne.n	844fa <xQueueGenericReset+0x5e>
				{
					portYIELD_WITHIN_API();
   844e6:	4b0b      	ldr	r3, [pc, #44]	; (84514 <xQueueGenericReset+0x78>)
   844e8:	4798      	blx	r3
   844ea:	e006      	b.n	844fa <xQueueGenericReset+0x5e>
			}
		}
		else
		{
			/* Ensure the event queues start in the correct state. */
			vListInitialise( &( pxQueue->xTasksWaitingToSend ) );
   844ec:	f104 0010 	add.w	r0, r4, #16
   844f0:	4d09      	ldr	r5, [pc, #36]	; (84518 <xQueueGenericReset+0x7c>)
   844f2:	47a8      	blx	r5
			vListInitialise( &( pxQueue->xTasksWaitingToReceive ) );
   844f4:	f104 0024 	add.w	r0, r4, #36	; 0x24
   844f8:	47a8      	blx	r5
		}
	}
	taskEXIT_CRITICAL();
   844fa:	4b08      	ldr	r3, [pc, #32]	; (8451c <xQueueGenericReset+0x80>)
   844fc:	4798      	blx	r3

	/* A value is returned for calling semantic consistency with previous
	versions. */
	return pdPASS;
}
   844fe:	2001      	movs	r0, #1
   84500:	bd38      	pop	{r3, r4, r5, pc}
   84502:	bf00      	nop
   84504:	0008c5cc 	.word	0x0008c5cc
   84508:	00085f89 	.word	0x00085f89
   8450c:	00084139 	.word	0x00084139
   84510:	00085555 	.word	0x00085555
   84514:	00084119 	.word	0x00084119
   84518:	00084029 	.word	0x00084029
   8451c:	00084159 	.word	0x00084159

00084520 <xQueueGenericCreate>:
/*-----------------------------------------------------------*/

xQueueHandle xQueueGenericCreate( unsigned portBASE_TYPE uxQueueLength, unsigned portBASE_TYPE uxItemSize, unsigned char ucQueueType )
{
   84520:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   84522:	460d      	mov	r5, r1
   84524:	4617      	mov	r7, r2
	/* Remove compiler warnings about unused parameters should
	configUSE_TRACE_FACILITY not be set to 1. */
	( void ) ucQueueType;

	/* Allocate the new queue structure. */
	if( uxQueueLength > ( unsigned portBASE_TYPE ) 0 )
   84526:	4606      	mov	r6, r0
   84528:	b1b8      	cbz	r0, 8455a <xQueueGenericCreate+0x3a>
	{
		pxNewQueue = ( xQUEUE * ) pvPortMalloc( sizeof( xQUEUE ) );
   8452a:	2050      	movs	r0, #80	; 0x50
   8452c:	4b0f      	ldr	r3, [pc, #60]	; (8456c <xQueueGenericCreate+0x4c>)
   8452e:	4798      	blx	r3
		if( pxNewQueue != NULL )
   84530:	4604      	mov	r4, r0
   84532:	b190      	cbz	r0, 8455a <xQueueGenericCreate+0x3a>
		{
			/* Create the list of pointers to queue items.  The queue is one byte
			longer than asked for to make wrap checking easier/faster. */
			xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ) + ( size_t ) 1;
   84534:	fb05 f006 	mul.w	r0, r5, r6

			pxNewQueue->pcHead = ( signed char * ) pvPortMalloc( xQueueSizeInBytes );
   84538:	3001      	adds	r0, #1
   8453a:	4b0c      	ldr	r3, [pc, #48]	; (8456c <xQueueGenericCreate+0x4c>)
   8453c:	4798      	blx	r3
   8453e:	6020      	str	r0, [r4, #0]
			if( pxNewQueue->pcHead != NULL )
   84540:	b140      	cbz	r0, 84554 <xQueueGenericCreate+0x34>
			{
				/* Initialise the queue members as described above where the
				queue type is defined. */
				pxNewQueue->uxLength = uxQueueLength;
   84542:	63e6      	str	r6, [r4, #60]	; 0x3c
				pxNewQueue->uxItemSize = uxItemSize;
   84544:	6425      	str	r5, [r4, #64]	; 0x40
				xQueueGenericReset( pxNewQueue, pdTRUE );
   84546:	4620      	mov	r0, r4
   84548:	2101      	movs	r1, #1
   8454a:	4b09      	ldr	r3, [pc, #36]	; (84570 <xQueueGenericCreate+0x50>)
   8454c:	4798      	blx	r3
				#if ( configUSE_TRACE_FACILITY == 1 )
				{
					pxNewQueue->ucQueueType = ucQueueType;
   8454e:	f884 704d 	strb.w	r7, [r4, #77]	; 0x4d
   84552:	e008      	b.n	84566 <xQueueGenericCreate+0x46>
				xReturn = pxNewQueue;
			}
			else
			{
				traceQUEUE_CREATE_FAILED( ucQueueType );
				vPortFree( pxNewQueue );
   84554:	4620      	mov	r0, r4
   84556:	4b07      	ldr	r3, [pc, #28]	; (84574 <xQueueGenericCreate+0x54>)
   84558:	4798      	blx	r3
			}
		}
	}

	configASSERT( xReturn );
   8455a:	4807      	ldr	r0, [pc, #28]	; (84578 <xQueueGenericCreate+0x58>)
   8455c:	f240 1171 	movw	r1, #369	; 0x171
   84560:	4b06      	ldr	r3, [pc, #24]	; (8457c <xQueueGenericCreate+0x5c>)
   84562:	4798      	blx	r3
   84564:	2400      	movs	r4, #0

	return xReturn;
}
   84566:	4620      	mov	r0, r4
   84568:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   8456a:	bf00      	nop
   8456c:	00084285 	.word	0x00084285
   84570:	0008449d 	.word	0x0008449d
   84574:	00084351 	.word	0x00084351
   84578:	0008c5cc 	.word	0x0008c5cc
   8457c:	00085f89 	.word	0x00085f89

00084580 <xQueueCreateCountingSemaphore>:
/*-----------------------------------------------------------*/

#if configUSE_COUNTING_SEMAPHORES == 1

	xQueueHandle xQueueCreateCountingSemaphore( unsigned portBASE_TYPE uxCountValue, unsigned portBASE_TYPE uxInitialCount )
	{
   84580:	b538      	push	{r3, r4, r5, lr}
   84582:	460d      	mov	r5, r1
	xQueueHandle pxHandle;

		pxHandle = xQueueGenericCreate( ( unsigned portBASE_TYPE ) uxCountValue, queueSEMAPHORE_QUEUE_ITEM_LENGTH, queueQUEUE_TYPE_COUNTING_SEMAPHORE );
   84584:	2100      	movs	r1, #0
   84586:	2202      	movs	r2, #2
   84588:	4b06      	ldr	r3, [pc, #24]	; (845a4 <xQueueCreateCountingSemaphore+0x24>)
   8458a:	4798      	blx	r3

		if( pxHandle != NULL )
   8458c:	4604      	mov	r4, r0
   8458e:	b108      	cbz	r0, 84594 <xQueueCreateCountingSemaphore+0x14>
		{
			pxHandle->uxMessagesWaiting = uxInitialCount;
   84590:	6385      	str	r5, [r0, #56]	; 0x38
   84592:	e004      	b.n	8459e <xQueueCreateCountingSemaphore+0x1e>
		else
		{
			traceCREATE_COUNTING_SEMAPHORE_FAILED();
		}

		configASSERT( pxHandle );
   84594:	4804      	ldr	r0, [pc, #16]	; (845a8 <xQueueCreateCountingSemaphore+0x28>)
   84596:	f44f 710f 	mov.w	r1, #572	; 0x23c
   8459a:	4b04      	ldr	r3, [pc, #16]	; (845ac <xQueueCreateCountingSemaphore+0x2c>)
   8459c:	4798      	blx	r3
		return pxHandle;
	}
   8459e:	4620      	mov	r0, r4
   845a0:	bd38      	pop	{r3, r4, r5, pc}
   845a2:	bf00      	nop
   845a4:	00084521 	.word	0x00084521
   845a8:	0008c5cc 	.word	0x0008c5cc
   845ac:	00085f89 	.word	0x00085f89

000845b0 <xQueueGenericSend>:

#endif /* configUSE_COUNTING_SEMAPHORES */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericSend( xQueueHandle pxQueue, const void * const pvItemToQueue, portTickType xTicksToWait, portBASE_TYPE xCopyPosition )
{
   845b0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   845b4:	b085      	sub	sp, #20
   845b6:	468b      	mov	fp, r1
   845b8:	9201      	str	r2, [sp, #4]
   845ba:	9300      	str	r3, [sp, #0]
signed portBASE_TYPE xEntryTimeSet = pdFALSE;
xTimeOutType xTimeOut;

	configASSERT( pxQueue );
   845bc:	4604      	mov	r4, r0
   845be:	b920      	cbnz	r0, 845ca <xQueueGenericSend+0x1a>
   845c0:	483a      	ldr	r0, [pc, #232]	; (846ac <xQueueGenericSend+0xfc>)
   845c2:	f44f 7112 	mov.w	r1, #584	; 0x248
   845c6:	4b3a      	ldr	r3, [pc, #232]	; (846b0 <xQueueGenericSend+0x100>)
   845c8:	4798      	blx	r3
	configASSERT( !( ( pvItemToQueue == NULL ) && ( pxQueue->uxItemSize != ( unsigned portBASE_TYPE ) 0U ) ) );
   845ca:	f1bb 0f00 	cmp.w	fp, #0
   845ce:	d106      	bne.n	845de <xQueueGenericSend+0x2e>
   845d0:	6c23      	ldr	r3, [r4, #64]	; 0x40
   845d2:	b123      	cbz	r3, 845de <xQueueGenericSend+0x2e>
   845d4:	4835      	ldr	r0, [pc, #212]	; (846ac <xQueueGenericSend+0xfc>)
   845d6:	f240 2149 	movw	r1, #585	; 0x249
   845da:	4b35      	ldr	r3, [pc, #212]	; (846b0 <xQueueGenericSend+0x100>)
   845dc:	4798      	blx	r3

#endif /* configUSE_COUNTING_SEMAPHORES */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericSend( xQueueHandle pxQueue, const void * const pvItemToQueue, portTickType xTicksToWait, portBASE_TYPE xCopyPosition )
{
   845de:	f04f 0900 	mov.w	r9, #0
	/* This function relaxes the coding standard somewhat to allow return
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
   845e2:	4d34      	ldr	r5, [pc, #208]	; (846b4 <xQueueGenericSend+0x104>)
				}
				else if( xEntryTimeSet == pdFALSE )
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
   845e4:	f8df a0f4 	ldr.w	sl, [pc, #244]	; 846dc <xQueueGenericSend+0x12c>
					xEntryTimeSet = pdTRUE;
				}
			}
		}
		taskEXIT_CRITICAL();
   845e8:	4e33      	ldr	r6, [pc, #204]	; (846b8 <xQueueGenericSend+0x108>)
	/* This function relaxes the coding standard somewhat to allow return
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
   845ea:	47a8      	blx	r5
		{
			/* Is there room on the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
   845ec:	6ba2      	ldr	r2, [r4, #56]	; 0x38
   845ee:	6be3      	ldr	r3, [r4, #60]	; 0x3c
   845f0:	429a      	cmp	r2, r3
   845f2:	d212      	bcs.n	8461a <xQueueGenericSend+0x6a>
			{
				traceQUEUE_SEND( pxQueue );
				prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
   845f4:	4620      	mov	r0, r4
   845f6:	4659      	mov	r1, fp
   845f8:	9a00      	ldr	r2, [sp, #0]
   845fa:	4b30      	ldr	r3, [pc, #192]	; (846bc <xQueueGenericSend+0x10c>)
   845fc:	4798      	blx	r3

				/* If there was a task waiting for data to arrive on the
				queue then unblock it now. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
   845fe:	6a63      	ldr	r3, [r4, #36]	; 0x24
   84600:	b13b      	cbz	r3, 84612 <xQueueGenericSend+0x62>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) == pdTRUE )
   84602:	f104 0024 	add.w	r0, r4, #36	; 0x24
   84606:	4b2e      	ldr	r3, [pc, #184]	; (846c0 <xQueueGenericSend+0x110>)
   84608:	4798      	blx	r3
   8460a:	2801      	cmp	r0, #1
   8460c:	d101      	bne.n	84612 <xQueueGenericSend+0x62>
					{
						/* The unblocked task has a priority higher than
						our own so yield immediately.  Yes it is ok to do
						this from within the critical section - the kernel
						takes care of that. */
						portYIELD_WITHIN_API();
   8460e:	4b2d      	ldr	r3, [pc, #180]	; (846c4 <xQueueGenericSend+0x114>)
   84610:	4798      	blx	r3
					}
				}

				taskEXIT_CRITICAL();
   84612:	4b29      	ldr	r3, [pc, #164]	; (846b8 <xQueueGenericSend+0x108>)
   84614:	4798      	blx	r3

				/* Return to the original privilege level before exiting the
				function. */
				return pdPASS;
   84616:	2001      	movs	r0, #1
   84618:	e044      	b.n	846a4 <xQueueGenericSend+0xf4>
			}
			else
			{
				if( xTicksToWait == ( portTickType ) 0 )
   8461a:	9b01      	ldr	r3, [sp, #4]
   8461c:	b91b      	cbnz	r3, 84626 <xQueueGenericSend+0x76>
				{
					/* The queue was full and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
   8461e:	4b26      	ldr	r3, [pc, #152]	; (846b8 <xQueueGenericSend+0x108>)
   84620:	4798      	blx	r3

					/* Return to the original privilege level before exiting
					the function. */
					traceQUEUE_SEND_FAILED( pxQueue );
					return errQUEUE_FULL;
   84622:	2000      	movs	r0, #0
   84624:	e03e      	b.n	846a4 <xQueueGenericSend+0xf4>
				}
				else if( xEntryTimeSet == pdFALSE )
   84626:	f1b9 0f00 	cmp.w	r9, #0
   8462a:	d103      	bne.n	84634 <xQueueGenericSend+0x84>
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
   8462c:	a802      	add	r0, sp, #8
   8462e:	47d0      	blx	sl
					xEntryTimeSet = pdTRUE;
   84630:	f04f 0901 	mov.w	r9, #1
				}
			}
		}
		taskEXIT_CRITICAL();
   84634:	47b0      	blx	r6

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
   84636:	4b24      	ldr	r3, [pc, #144]	; (846c8 <xQueueGenericSend+0x118>)
   84638:	4798      	blx	r3
		prvLockQueue( pxQueue );
   8463a:	47a8      	blx	r5
   8463c:	6c63      	ldr	r3, [r4, #68]	; 0x44
   8463e:	f1b3 3fff 	cmp.w	r3, #4294967295
   84642:	bf04      	itt	eq
   84644:	2300      	moveq	r3, #0
   84646:	6463      	streq	r3, [r4, #68]	; 0x44
   84648:	6ca3      	ldr	r3, [r4, #72]	; 0x48
   8464a:	f1b3 3fff 	cmp.w	r3, #4294967295
   8464e:	bf04      	itt	eq
   84650:	2300      	moveq	r3, #0
   84652:	64a3      	streq	r3, [r4, #72]	; 0x48
   84654:	47b0      	blx	r6

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
   84656:	a802      	add	r0, sp, #8
   84658:	a901      	add	r1, sp, #4
   8465a:	4b1c      	ldr	r3, [pc, #112]	; (846cc <xQueueGenericSend+0x11c>)
   8465c:	4798      	blx	r3
   8465e:	b9d8      	cbnz	r0, 84698 <xQueueGenericSend+0xe8>

static signed portBASE_TYPE prvIsQueueFull( const xQueueHandle pxQueue )
{
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
   84660:	47a8      	blx	r5
		xReturn = ( pxQueue->uxMessagesWaiting == pxQueue->uxLength );
   84662:	f8d4 8038 	ldr.w	r8, [r4, #56]	; 0x38
   84666:	6be7      	ldr	r7, [r4, #60]	; 0x3c
	taskEXIT_CRITICAL();
   84668:	47b0      	blx	r6
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
   8466a:	45b8      	cmp	r8, r7
   8466c:	d10e      	bne.n	8468c <xQueueGenericSend+0xdc>
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
   8466e:	f104 0010 	add.w	r0, r4, #16
   84672:	9901      	ldr	r1, [sp, #4]
   84674:	4b16      	ldr	r3, [pc, #88]	; (846d0 <xQueueGenericSend+0x120>)
   84676:	4798      	blx	r3
				/* Unlocking the queue means queue events can effect the
				event list.  It is possible	that interrupts occurring now
				remove this task from the event	list again - but as the
				scheduler is suspended the task will go onto the pending
				ready last instead of the actual ready list. */
				prvUnlockQueue( pxQueue );
   84678:	4620      	mov	r0, r4
   8467a:	4b16      	ldr	r3, [pc, #88]	; (846d4 <xQueueGenericSend+0x124>)
   8467c:	4798      	blx	r3
				/* Resuming the scheduler will move tasks from the pending
				ready list into the ready list - so it is feasible that this
				task is already in a ready list before it yields - in which
				case the yield will not cause a context switch unless there
				is also a higher priority task in the pending ready list. */
				if( xTaskResumeAll() == pdFALSE )
   8467e:	4b16      	ldr	r3, [pc, #88]	; (846d8 <xQueueGenericSend+0x128>)
   84680:	4798      	blx	r3
   84682:	2800      	cmp	r0, #0
   84684:	d1b1      	bne.n	845ea <xQueueGenericSend+0x3a>
				{
					portYIELD_WITHIN_API();
   84686:	4b0f      	ldr	r3, [pc, #60]	; (846c4 <xQueueGenericSend+0x114>)
   84688:	4798      	blx	r3
   8468a:	e7ae      	b.n	845ea <xQueueGenericSend+0x3a>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
   8468c:	4620      	mov	r0, r4
   8468e:	4b11      	ldr	r3, [pc, #68]	; (846d4 <xQueueGenericSend+0x124>)
   84690:	4798      	blx	r3
				( void ) xTaskResumeAll();
   84692:	4b11      	ldr	r3, [pc, #68]	; (846d8 <xQueueGenericSend+0x128>)
   84694:	4798      	blx	r3
   84696:	e7a8      	b.n	845ea <xQueueGenericSend+0x3a>
			}
		}
		else
		{
			/* The timeout has expired. */
			prvUnlockQueue( pxQueue );
   84698:	4620      	mov	r0, r4
   8469a:	4b0e      	ldr	r3, [pc, #56]	; (846d4 <xQueueGenericSend+0x124>)
   8469c:	4798      	blx	r3
			( void ) xTaskResumeAll();
   8469e:	4b0e      	ldr	r3, [pc, #56]	; (846d8 <xQueueGenericSend+0x128>)
   846a0:	4798      	blx	r3

			/* Return to the original privilege level before exiting the
			function. */
			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
   846a2:	2000      	movs	r0, #0
		}
	}
}
   846a4:	b005      	add	sp, #20
   846a6:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   846aa:	bf00      	nop
   846ac:	0008c5cc 	.word	0x0008c5cc
   846b0:	00085f89 	.word	0x00085f89
   846b4:	00084139 	.word	0x00084139
   846b8:	00084159 	.word	0x00084159
   846bc:	00084385 	.word	0x00084385
   846c0:	00085555 	.word	0x00085555
   846c4:	00084119 	.word	0x00084119
   846c8:	00084e71 	.word	0x00084e71
   846cc:	0008560d 	.word	0x0008560d
   846d0:	00085469 	.word	0x00085469
   846d4:	00084411 	.word	0x00084411
   846d8:	00084fe9 	.word	0x00084fe9
   846dc:	000855dd 	.word	0x000855dd

000846e0 <xQueueCreateMutex>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	xQueueHandle xQueueCreateMutex( unsigned char ucQueueType )
	{
   846e0:	b570      	push	{r4, r5, r6, lr}
   846e2:	4606      	mov	r6, r0
		/* Prevent compiler warnings about unused parameters if
		configUSE_TRACE_FACILITY does not equal 1. */
		( void ) ucQueueType;

		/* Allocate the new queue structure. */
		pxNewQueue = ( xQUEUE * ) pvPortMalloc( sizeof( xQUEUE ) );
   846e4:	2050      	movs	r0, #80	; 0x50
   846e6:	4b13      	ldr	r3, [pc, #76]	; (84734 <xQueueCreateMutex+0x54>)
   846e8:	4798      	blx	r3
		if( pxNewQueue != NULL )
   846ea:	4604      	mov	r4, r0
   846ec:	b1d8      	cbz	r0, 84726 <xQueueCreateMutex+0x46>
		{
			/* Information required for priority inheritance. */
			pxNewQueue->pxMutexHolder = NULL;
   846ee:	2500      	movs	r5, #0
   846f0:	6045      	str	r5, [r0, #4]
			pxNewQueue->uxQueueType = queueQUEUE_IS_MUTEX;
   846f2:	6005      	str	r5, [r0, #0]

			/* Queues used as a mutex no data is actually copied into or out
			of the queue. */
			pxNewQueue->pcWriteTo = NULL;
   846f4:	6085      	str	r5, [r0, #8]
			pxNewQueue->pcReadFrom = NULL;
   846f6:	60c5      	str	r5, [r0, #12]

			/* Each mutex has a length of 1 (like a binary semaphore) and
			an item size of 0 as nothing is actually copied into or out
			of the mutex. */
			pxNewQueue->uxMessagesWaiting = ( unsigned portBASE_TYPE ) 0U;
   846f8:	6385      	str	r5, [r0, #56]	; 0x38
			pxNewQueue->uxLength = ( unsigned portBASE_TYPE ) 1U;
   846fa:	2301      	movs	r3, #1
   846fc:	63c3      	str	r3, [r0, #60]	; 0x3c
			pxNewQueue->uxItemSize = ( unsigned portBASE_TYPE ) 0U;
   846fe:	6405      	str	r5, [r0, #64]	; 0x40
			pxNewQueue->xRxLock = queueUNLOCKED;
   84700:	f04f 33ff 	mov.w	r3, #4294967295
   84704:	6443      	str	r3, [r0, #68]	; 0x44
			pxNewQueue->xTxLock = queueUNLOCKED;
   84706:	6483      	str	r3, [r0, #72]	; 0x48

			#if ( configUSE_TRACE_FACILITY == 1 )
			{
				pxNewQueue->ucQueueType = ucQueueType;
   84708:	f880 604d 	strb.w	r6, [r0, #77]	; 0x4d
			}
			#endif

			/* Ensure the event queues start with the correct state. */
			vListInitialise( &( pxNewQueue->xTasksWaitingToSend ) );
   8470c:	3010      	adds	r0, #16
   8470e:	4e0a      	ldr	r6, [pc, #40]	; (84738 <xQueueCreateMutex+0x58>)
   84710:	47b0      	blx	r6
			vListInitialise( &( pxNewQueue->xTasksWaitingToReceive ) );
   84712:	f104 0024 	add.w	r0, r4, #36	; 0x24
   84716:	47b0      	blx	r6

			traceCREATE_MUTEX( pxNewQueue );

			/* Start with the semaphore in the expected state. */
			xQueueGenericSend( pxNewQueue, NULL, ( portTickType ) 0U, queueSEND_TO_BACK );
   84718:	4620      	mov	r0, r4
   8471a:	4629      	mov	r1, r5
   8471c:	462a      	mov	r2, r5
   8471e:	462b      	mov	r3, r5
   84720:	4d06      	ldr	r5, [pc, #24]	; (8473c <xQueueCreateMutex+0x5c>)
   84722:	47a8      	blx	r5
   84724:	e004      	b.n	84730 <xQueueCreateMutex+0x50>
		else
		{
			traceCREATE_MUTEX_FAILED();
		}

		configASSERT( pxNewQueue );
   84726:	4806      	ldr	r0, [pc, #24]	; (84740 <xQueueCreateMutex+0x60>)
   84728:	f240 11ab 	movw	r1, #427	; 0x1ab
   8472c:	4b05      	ldr	r3, [pc, #20]	; (84744 <xQueueCreateMutex+0x64>)
   8472e:	4798      	blx	r3
		return pxNewQueue;
	}
   84730:	4620      	mov	r0, r4
   84732:	bd70      	pop	{r4, r5, r6, pc}
   84734:	00084285 	.word	0x00084285
   84738:	00084029 	.word	0x00084029
   8473c:	000845b1 	.word	0x000845b1
   84740:	0008c5cc 	.word	0x0008c5cc
   84744:	00085f89 	.word	0x00085f89

00084748 <xQueueGenericSendFromISR>:

#endif /* configUSE_ALTERNATIVE_API */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericSendFromISR( xQueueHandle pxQueue, const void * const pvItemToQueue, signed portBASE_TYPE *pxHigherPriorityTaskWoken, portBASE_TYPE xCopyPosition )
{
   84748:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   8474c:	460d      	mov	r5, r1
   8474e:	4690      	mov	r8, r2
   84750:	461f      	mov	r7, r3
signed portBASE_TYPE xReturn;
unsigned portBASE_TYPE uxSavedInterruptStatus;

	configASSERT( pxQueue );
   84752:	4604      	mov	r4, r0
   84754:	b920      	cbnz	r0, 84760 <xQueueGenericSendFromISR+0x18>
   84756:	481e      	ldr	r0, [pc, #120]	; (847d0 <xQueueGenericSendFromISR+0x88>)
   84758:	f240 318f 	movw	r1, #911	; 0x38f
   8475c:	4b1d      	ldr	r3, [pc, #116]	; (847d4 <xQueueGenericSendFromISR+0x8c>)
   8475e:	4798      	blx	r3
	configASSERT( !( ( pvItemToQueue == NULL ) && ( pxQueue->uxItemSize != ( unsigned portBASE_TYPE ) 0U ) ) );
   84760:	b935      	cbnz	r5, 84770 <xQueueGenericSendFromISR+0x28>
   84762:	6c23      	ldr	r3, [r4, #64]	; 0x40
   84764:	b123      	cbz	r3, 84770 <xQueueGenericSendFromISR+0x28>
   84766:	481a      	ldr	r0, [pc, #104]	; (847d0 <xQueueGenericSendFromISR+0x88>)
   84768:	f44f 7164 	mov.w	r1, #912	; 0x390
   8476c:	4b19      	ldr	r3, [pc, #100]	; (847d4 <xQueueGenericSendFromISR+0x8c>)
   8476e:	4798      	blx	r3
	/* Similar to xQueueGenericSend, except we don't block if there is no room
	in the queue.  Also we don't directly wake a task that was blocked on a
	queue read, instead we return a flag to say whether a context switch is
	required or not (i.e. has a task with a higher priority than us been woken
	by this	post). */
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
   84770:	4919      	ldr	r1, [pc, #100]	; (847d8 <xQueueGenericSendFromISR+0x90>)
   84772:	4788      	blx	r1
   84774:	4606      	mov	r6, r0
	{
		if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
   84776:	6ba0      	ldr	r0, [r4, #56]	; 0x38
   84778:	6be1      	ldr	r1, [r4, #60]	; 0x3c
   8477a:	4288      	cmp	r0, r1
   8477c:	d21b      	bcs.n	847b6 <xQueueGenericSendFromISR+0x6e>
		{
			traceQUEUE_SEND_FROM_ISR( pxQueue );

			prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
   8477e:	4620      	mov	r0, r4
   84780:	4629      	mov	r1, r5
   84782:	463a      	mov	r2, r7
   84784:	4b15      	ldr	r3, [pc, #84]	; (847dc <xQueueGenericSendFromISR+0x94>)
   84786:	4798      	blx	r3

			/* If the queue is locked we do not alter the event list.  This will
			be done when the queue is unlocked later. */
			if( pxQueue->xTxLock == queueUNLOCKED )
   84788:	6ca3      	ldr	r3, [r4, #72]	; 0x48
   8478a:	f1b3 3fff 	cmp.w	r3, #4294967295
   8478e:	d10d      	bne.n	847ac <xQueueGenericSendFromISR+0x64>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
   84790:	6a63      	ldr	r3, [r4, #36]	; 0x24
   84792:	b193      	cbz	r3, 847ba <xQueueGenericSendFromISR+0x72>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
   84794:	f104 0024 	add.w	r0, r4, #36	; 0x24
   84798:	4b11      	ldr	r3, [pc, #68]	; (847e0 <xQueueGenericSendFromISR+0x98>)
   8479a:	4798      	blx	r3
   8479c:	b178      	cbz	r0, 847be <xQueueGenericSendFromISR+0x76>
					{
						/* The task waiting has a higher priority so record that a
						context	switch is required. */
						if( pxHigherPriorityTaskWoken != NULL )
   8479e:	f1b8 0f00 	cmp.w	r8, #0
   847a2:	d00e      	beq.n	847c2 <xQueueGenericSendFromISR+0x7a>
						{
							*pxHigherPriorityTaskWoken = pdTRUE;
   847a4:	2401      	movs	r4, #1
   847a6:	f8c8 4000 	str.w	r4, [r8]
   847aa:	e00b      	b.n	847c4 <xQueueGenericSendFromISR+0x7c>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				++( pxQueue->xTxLock );
   847ac:	6ca3      	ldr	r3, [r4, #72]	; 0x48
   847ae:	3301      	adds	r3, #1
   847b0:	64a3      	str	r3, [r4, #72]	; 0x48
			}

			xReturn = pdPASS;
   847b2:	2401      	movs	r4, #1
   847b4:	e006      	b.n	847c4 <xQueueGenericSendFromISR+0x7c>
		}
		else
		{
			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
			xReturn = errQUEUE_FULL;
   847b6:	2400      	movs	r4, #0
   847b8:	e004      	b.n	847c4 <xQueueGenericSendFromISR+0x7c>
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				++( pxQueue->xTxLock );
			}

			xReturn = pdPASS;
   847ba:	2401      	movs	r4, #1
   847bc:	e002      	b.n	847c4 <xQueueGenericSendFromISR+0x7c>
   847be:	2401      	movs	r4, #1
   847c0:	e000      	b.n	847c4 <xQueueGenericSendFromISR+0x7c>
   847c2:	2401      	movs	r4, #1
		{
			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
			xReturn = errQUEUE_FULL;
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
   847c4:	4630      	mov	r0, r6
   847c6:	4b07      	ldr	r3, [pc, #28]	; (847e4 <xQueueGenericSendFromISR+0x9c>)
   847c8:	4798      	blx	r3

	return xReturn;
}
   847ca:	4620      	mov	r0, r4
   847cc:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   847d0:	0008c5cc 	.word	0x0008c5cc
   847d4:	00085f89 	.word	0x00085f89
   847d8:	00084129 	.word	0x00084129
   847dc:	00084385 	.word	0x00084385
   847e0:	00085555 	.word	0x00085555
   847e4:	00084151 	.word	0x00084151

000847e8 <xQueueGenericReceive>:
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericReceive( xQueueHandle pxQueue, void * const pvBuffer, portTickType xTicksToWait, portBASE_TYPE xJustPeeking )
{
   847e8:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   847ec:	b085      	sub	sp, #20
   847ee:	4689      	mov	r9, r1
   847f0:	9201      	str	r2, [sp, #4]
   847f2:	469a      	mov	sl, r3
signed portBASE_TYPE xEntryTimeSet = pdFALSE;
xTimeOutType xTimeOut;
signed char *pcOriginalReadPosition;

	configASSERT( pxQueue );
   847f4:	4604      	mov	r4, r0
   847f6:	b920      	cbnz	r0, 84802 <xQueueGenericReceive+0x1a>
   847f8:	4846      	ldr	r0, [pc, #280]	; (84914 <xQueueGenericReceive+0x12c>)
   847fa:	f240 31cb 	movw	r1, #971	; 0x3cb
   847fe:	4b46      	ldr	r3, [pc, #280]	; (84918 <xQueueGenericReceive+0x130>)
   84800:	4798      	blx	r3
	configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( unsigned portBASE_TYPE ) 0U ) ) );
   84802:	f1b9 0f00 	cmp.w	r9, #0
   84806:	d106      	bne.n	84816 <xQueueGenericReceive+0x2e>
   84808:	6c23      	ldr	r3, [r4, #64]	; 0x40
   8480a:	b123      	cbz	r3, 84816 <xQueueGenericReceive+0x2e>
   8480c:	4841      	ldr	r0, [pc, #260]	; (84914 <xQueueGenericReceive+0x12c>)
   8480e:	f44f 7173 	mov.w	r1, #972	; 0x3cc
   84812:	4b41      	ldr	r3, [pc, #260]	; (84918 <xQueueGenericReceive+0x130>)
   84814:	4798      	blx	r3
	return xReturn;
}
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericReceive( xQueueHandle pxQueue, void * const pvBuffer, portTickType xTicksToWait, portBASE_TYPE xJustPeeking )
{
   84816:	2700      	movs	r7, #0
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */

	for( ;; )
	{
		taskENTER_CRITICAL();
   84818:	4d40      	ldr	r5, [pc, #256]	; (8491c <xQueueGenericReceive+0x134>)
				}
				else if( xEntryTimeSet == pdFALSE )
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
   8481a:	f8df 8130 	ldr.w	r8, [pc, #304]	; 8494c <xQueueGenericReceive+0x164>
					xEntryTimeSet = pdTRUE;
				}
			}
		}
		taskEXIT_CRITICAL();
   8481e:	4e40      	ldr	r6, [pc, #256]	; (84920 <xQueueGenericReceive+0x138>)
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */

	for( ;; )
	{
		taskENTER_CRITICAL();
   84820:	47a8      	blx	r5
		{
			/* Is there data in the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
   84822:	6ba2      	ldr	r2, [r4, #56]	; 0x38
   84824:	2a00      	cmp	r2, #0
   84826:	d028      	beq.n	8487a <xQueueGenericReceive+0x92>
			{
				/* Remember our read position in case we are just peeking. */
				pcOriginalReadPosition = pxQueue->pcReadFrom;
   84828:	68e5      	ldr	r5, [r4, #12]

				prvCopyDataFromQueue( pxQueue, pvBuffer );
   8482a:	4620      	mov	r0, r4
   8482c:	4649      	mov	r1, r9
   8482e:	4b3d      	ldr	r3, [pc, #244]	; (84924 <xQueueGenericReceive+0x13c>)
   84830:	4798      	blx	r3

				if( xJustPeeking == pdFALSE )
   84832:	f1ba 0f00 	cmp.w	sl, #0
   84836:	d112      	bne.n	8485e <xQueueGenericReceive+0x76>
				{
					traceQUEUE_RECEIVE( pxQueue );

					/* We are actually removing data. */
					--( pxQueue->uxMessagesWaiting );
   84838:	6ba3      	ldr	r3, [r4, #56]	; 0x38
   8483a:	3b01      	subs	r3, #1
   8483c:	63a3      	str	r3, [r4, #56]	; 0x38

					#if ( configUSE_MUTEXES == 1 )
					{
						if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
   8483e:	6823      	ldr	r3, [r4, #0]
   84840:	b913      	cbnz	r3, 84848 <xQueueGenericReceive+0x60>
						{
							/* Record the information required to implement
							priority inheritance should it become necessary. */
							pxQueue->pxMutexHolder = xTaskGetCurrentTaskHandle();
   84842:	4b39      	ldr	r3, [pc, #228]	; (84928 <xQueueGenericReceive+0x140>)
   84844:	4798      	blx	r3
   84846:	6060      	str	r0, [r4, #4]
						}
					}
					#endif

					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
   84848:	6923      	ldr	r3, [r4, #16]
   8484a:	b193      	cbz	r3, 84872 <xQueueGenericReceive+0x8a>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
   8484c:	f104 0010 	add.w	r0, r4, #16
   84850:	4b36      	ldr	r3, [pc, #216]	; (8492c <xQueueGenericReceive+0x144>)
   84852:	4798      	blx	r3
   84854:	2801      	cmp	r0, #1
   84856:	d10c      	bne.n	84872 <xQueueGenericReceive+0x8a>
						{
							portYIELD_WITHIN_API();
   84858:	4b35      	ldr	r3, [pc, #212]	; (84930 <xQueueGenericReceive+0x148>)
   8485a:	4798      	blx	r3
   8485c:	e009      	b.n	84872 <xQueueGenericReceive+0x8a>
				{
					traceQUEUE_PEEK( pxQueue );

					/* We are not removing the data, so reset our read
					pointer. */
					pxQueue->pcReadFrom = pcOriginalReadPosition;
   8485e:	60e5      	str	r5, [r4, #12]

					/* The data is being left in the queue, so see if there are
					any other tasks waiting for the data. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
   84860:	6a63      	ldr	r3, [r4, #36]	; 0x24
   84862:	b133      	cbz	r3, 84872 <xQueueGenericReceive+0x8a>
					{
						/* Tasks that are removed from the event list will get added to
						the pending ready list as the scheduler is still suspended. */
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
   84864:	f104 0024 	add.w	r0, r4, #36	; 0x24
   84868:	4b30      	ldr	r3, [pc, #192]	; (8492c <xQueueGenericReceive+0x144>)
   8486a:	4798      	blx	r3
   8486c:	b108      	cbz	r0, 84872 <xQueueGenericReceive+0x8a>
						{
							/* The task waiting has a higher priority than this task. */
							portYIELD_WITHIN_API();
   8486e:	4b30      	ldr	r3, [pc, #192]	; (84930 <xQueueGenericReceive+0x148>)
   84870:	4798      	blx	r3
						}
					}
				}

				taskEXIT_CRITICAL();
   84872:	4b2b      	ldr	r3, [pc, #172]	; (84920 <xQueueGenericReceive+0x138>)
   84874:	4798      	blx	r3
				return pdPASS;
   84876:	2001      	movs	r0, #1
   84878:	e048      	b.n	8490c <xQueueGenericReceive+0x124>
			}
			else
			{
				if( xTicksToWait == ( portTickType ) 0 )
   8487a:	9b01      	ldr	r3, [sp, #4]
   8487c:	b91b      	cbnz	r3, 84886 <xQueueGenericReceive+0x9e>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
   8487e:	4b28      	ldr	r3, [pc, #160]	; (84920 <xQueueGenericReceive+0x138>)
   84880:	4798      	blx	r3
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
   84882:	2000      	movs	r0, #0
   84884:	e042      	b.n	8490c <xQueueGenericReceive+0x124>
				}
				else if( xEntryTimeSet == pdFALSE )
   84886:	b917      	cbnz	r7, 8488e <xQueueGenericReceive+0xa6>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
   84888:	a802      	add	r0, sp, #8
   8488a:	47c0      	blx	r8
					xEntryTimeSet = pdTRUE;
   8488c:	2701      	movs	r7, #1
				}
			}
		}
		taskEXIT_CRITICAL();
   8488e:	47b0      	blx	r6

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
   84890:	4b28      	ldr	r3, [pc, #160]	; (84934 <xQueueGenericReceive+0x14c>)
   84892:	4798      	blx	r3
		prvLockQueue( pxQueue );
   84894:	47a8      	blx	r5
   84896:	6c63      	ldr	r3, [r4, #68]	; 0x44
   84898:	f1b3 3fff 	cmp.w	r3, #4294967295
   8489c:	bf04      	itt	eq
   8489e:	2300      	moveq	r3, #0
   848a0:	6463      	streq	r3, [r4, #68]	; 0x44
   848a2:	6ca3      	ldr	r3, [r4, #72]	; 0x48
   848a4:	f1b3 3fff 	cmp.w	r3, #4294967295
   848a8:	bf04      	itt	eq
   848aa:	2300      	moveq	r3, #0
   848ac:	64a3      	streq	r3, [r4, #72]	; 0x48
   848ae:	47b0      	blx	r6

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
   848b0:	a802      	add	r0, sp, #8
   848b2:	a901      	add	r1, sp, #4
   848b4:	4b20      	ldr	r3, [pc, #128]	; (84938 <xQueueGenericReceive+0x150>)
   848b6:	4798      	blx	r3
   848b8:	bb10      	cbnz	r0, 84900 <xQueueGenericReceive+0x118>

static signed portBASE_TYPE prvIsQueueEmpty( const xQueueHandle pxQueue )
{
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
   848ba:	47a8      	blx	r5
		xReturn = ( pxQueue->uxMessagesWaiting == ( unsigned portBASE_TYPE ) 0 );
   848bc:	f8d4 b038 	ldr.w	fp, [r4, #56]	; 0x38
	taskEXIT_CRITICAL();
   848c0:	47b0      	blx	r6
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
   848c2:	f1bb 0f00 	cmp.w	fp, #0
   848c6:	d115      	bne.n	848f4 <xQueueGenericReceive+0x10c>
			{
				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );

				#if ( configUSE_MUTEXES == 1 )
				{
					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
   848c8:	6823      	ldr	r3, [r4, #0]
   848ca:	b923      	cbnz	r3, 848d6 <xQueueGenericReceive+0xee>
					{
						portENTER_CRITICAL();
   848cc:	47a8      	blx	r5
						{
							vTaskPriorityInherit( ( void * ) pxQueue->pxMutexHolder );
   848ce:	6860      	ldr	r0, [r4, #4]
   848d0:	4b1a      	ldr	r3, [pc, #104]	; (8493c <xQueueGenericReceive+0x154>)
   848d2:	4798      	blx	r3
						}
						portEXIT_CRITICAL();
   848d4:	47b0      	blx	r6
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
   848d6:	f104 0024 	add.w	r0, r4, #36	; 0x24
   848da:	9901      	ldr	r1, [sp, #4]
   848dc:	4b18      	ldr	r3, [pc, #96]	; (84940 <xQueueGenericReceive+0x158>)
   848de:	4798      	blx	r3
				prvUnlockQueue( pxQueue );
   848e0:	4620      	mov	r0, r4
   848e2:	4b18      	ldr	r3, [pc, #96]	; (84944 <xQueueGenericReceive+0x15c>)
   848e4:	4798      	blx	r3
				if( xTaskResumeAll() == pdFALSE )
   848e6:	4b18      	ldr	r3, [pc, #96]	; (84948 <xQueueGenericReceive+0x160>)
   848e8:	4798      	blx	r3
   848ea:	2800      	cmp	r0, #0
   848ec:	d198      	bne.n	84820 <xQueueGenericReceive+0x38>
				{
					portYIELD_WITHIN_API();
   848ee:	4b10      	ldr	r3, [pc, #64]	; (84930 <xQueueGenericReceive+0x148>)
   848f0:	4798      	blx	r3
   848f2:	e795      	b.n	84820 <xQueueGenericReceive+0x38>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
   848f4:	4620      	mov	r0, r4
   848f6:	4b13      	ldr	r3, [pc, #76]	; (84944 <xQueueGenericReceive+0x15c>)
   848f8:	4798      	blx	r3
				( void ) xTaskResumeAll();
   848fa:	4b13      	ldr	r3, [pc, #76]	; (84948 <xQueueGenericReceive+0x160>)
   848fc:	4798      	blx	r3
   848fe:	e78f      	b.n	84820 <xQueueGenericReceive+0x38>
			}
		}
		else
		{
			prvUnlockQueue( pxQueue );
   84900:	4620      	mov	r0, r4
   84902:	4b10      	ldr	r3, [pc, #64]	; (84944 <xQueueGenericReceive+0x15c>)
   84904:	4798      	blx	r3
			( void ) xTaskResumeAll();
   84906:	4b10      	ldr	r3, [pc, #64]	; (84948 <xQueueGenericReceive+0x160>)
   84908:	4798      	blx	r3
			traceQUEUE_RECEIVE_FAILED( pxQueue );
			return errQUEUE_EMPTY;
   8490a:	2000      	movs	r0, #0
		}
	}
}
   8490c:	b005      	add	sp, #20
   8490e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   84912:	bf00      	nop
   84914:	0008c5cc 	.word	0x0008c5cc
   84918:	00085f89 	.word	0x00085f89
   8491c:	00084139 	.word	0x00084139
   84920:	00084159 	.word	0x00084159
   84924:	000843e9 	.word	0x000843e9
   84928:	000856a5 	.word	0x000856a5
   8492c:	00085555 	.word	0x00085555
   84930:	00084119 	.word	0x00084119
   84934:	00084e71 	.word	0x00084e71
   84938:	0008560d 	.word	0x0008560d
   8493c:	000856d1 	.word	0x000856d1
   84940:	00085469 	.word	0x00085469
   84944:	00084411 	.word	0x00084411
   84948:	00084fe9 	.word	0x00084fe9
   8494c:	000855dd 	.word	0x000855dd

00084950 <vQueueWaitForMessageRestricted>:
/*-----------------------------------------------------------*/

#if configUSE_TIMERS == 1

	void vQueueWaitForMessageRestricted( xQueueHandle pxQueue, portTickType xTicksToWait )
	{
   84950:	b538      	push	{r3, r4, r5, lr}
   84952:	4604      	mov	r4, r0
   84954:	460d      	mov	r5, r1
		will not actually cause the task to block, just place it on a blocked
		list.  It will not block until the scheduler is unlocked - at which
		time a yield will be performed.  If an item is added to the queue while
		the queue is locked, and the calling task blocks on the queue, then the
		calling task will be immediately unblocked when the queue is unlocked. */
		prvLockQueue( pxQueue );
   84956:	4b0d      	ldr	r3, [pc, #52]	; (8498c <vQueueWaitForMessageRestricted+0x3c>)
   84958:	4798      	blx	r3
   8495a:	6c63      	ldr	r3, [r4, #68]	; 0x44
   8495c:	f1b3 3fff 	cmp.w	r3, #4294967295
   84960:	bf04      	itt	eq
   84962:	2300      	moveq	r3, #0
   84964:	6463      	streq	r3, [r4, #68]	; 0x44
   84966:	6ca3      	ldr	r3, [r4, #72]	; 0x48
   84968:	f1b3 3fff 	cmp.w	r3, #4294967295
   8496c:	bf04      	itt	eq
   8496e:	2300      	moveq	r3, #0
   84970:	64a3      	streq	r3, [r4, #72]	; 0x48
   84972:	4b07      	ldr	r3, [pc, #28]	; (84990 <vQueueWaitForMessageRestricted+0x40>)
   84974:	4798      	blx	r3
		if( pxQueue->uxMessagesWaiting == ( unsigned portBASE_TYPE ) 0U )
   84976:	6ba3      	ldr	r3, [r4, #56]	; 0x38
   84978:	b923      	cbnz	r3, 84984 <vQueueWaitForMessageRestricted+0x34>
		{
			/* There is nothing in the queue, block for the specified period. */
			vTaskPlaceOnEventListRestricted( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
   8497a:	f104 0024 	add.w	r0, r4, #36	; 0x24
   8497e:	4629      	mov	r1, r5
   84980:	4b04      	ldr	r3, [pc, #16]	; (84994 <vQueueWaitForMessageRestricted+0x44>)
   84982:	4798      	blx	r3
		}
		prvUnlockQueue( pxQueue );
   84984:	4620      	mov	r0, r4
   84986:	4b04      	ldr	r3, [pc, #16]	; (84998 <vQueueWaitForMessageRestricted+0x48>)
   84988:	4798      	blx	r3
   8498a:	bd38      	pop	{r3, r4, r5, pc}
   8498c:	00084139 	.word	0x00084139
   84990:	00084159 	.word	0x00084159
   84994:	000854ed 	.word	0x000854ed
   84998:	00084411 	.word	0x00084411

0008499c <prvAddCurrentTaskToDelayedList>:
	#endif
}
/*-----------------------------------------------------------*/

static void prvAddCurrentTaskToDelayedList( portTickType xTimeToWake )
{
   8499c:	b510      	push	{r4, lr}
   8499e:	4604      	mov	r4, r0
	/* The list item will be inserted in wake time order. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );
   849a0:	4b0e      	ldr	r3, [pc, #56]	; (849dc <prvAddCurrentTaskToDelayedList+0x40>)
   849a2:	681b      	ldr	r3, [r3, #0]
   849a4:	6058      	str	r0, [r3, #4]

	if( xTimeToWake < xTickCount )
   849a6:	4b0e      	ldr	r3, [pc, #56]	; (849e0 <prvAddCurrentTaskToDelayedList+0x44>)
   849a8:	681b      	ldr	r3, [r3, #0]
   849aa:	4298      	cmp	r0, r3
   849ac:	d207      	bcs.n	849be <prvAddCurrentTaskToDelayedList+0x22>
	{
		/* Wake time has overflowed.  Place this item in the overflow list. */
		vListInsert( ( xList * ) pxOverflowDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
   849ae:	4b0d      	ldr	r3, [pc, #52]	; (849e4 <prvAddCurrentTaskToDelayedList+0x48>)
   849b0:	6818      	ldr	r0, [r3, #0]
   849b2:	4b0a      	ldr	r3, [pc, #40]	; (849dc <prvAddCurrentTaskToDelayedList+0x40>)
   849b4:	6819      	ldr	r1, [r3, #0]
   849b6:	3104      	adds	r1, #4
   849b8:	4b0b      	ldr	r3, [pc, #44]	; (849e8 <prvAddCurrentTaskToDelayedList+0x4c>)
   849ba:	4798      	blx	r3
   849bc:	bd10      	pop	{r4, pc}
	}
	else
	{
		/* The wake time has not overflowed, so we can use the current block list. */
		vListInsert( ( xList * ) pxDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
   849be:	4b0b      	ldr	r3, [pc, #44]	; (849ec <prvAddCurrentTaskToDelayedList+0x50>)
   849c0:	6818      	ldr	r0, [r3, #0]
   849c2:	4b06      	ldr	r3, [pc, #24]	; (849dc <prvAddCurrentTaskToDelayedList+0x40>)
   849c4:	6819      	ldr	r1, [r3, #0]
   849c6:	3104      	adds	r1, #4
   849c8:	4b07      	ldr	r3, [pc, #28]	; (849e8 <prvAddCurrentTaskToDelayedList+0x4c>)
   849ca:	4798      	blx	r3

		/* If the task entering the blocked state was placed at the head of the
		list of blocked tasks then xNextTaskUnblockTime needs to be updated
		too. */
		if( xTimeToWake < xNextTaskUnblockTime )
   849cc:	4b08      	ldr	r3, [pc, #32]	; (849f0 <prvAddCurrentTaskToDelayedList+0x54>)
   849ce:	681b      	ldr	r3, [r3, #0]
   849d0:	429c      	cmp	r4, r3
		{
			xNextTaskUnblockTime = xTimeToWake;
   849d2:	bf3c      	itt	cc
   849d4:	4b06      	ldrcc	r3, [pc, #24]	; (849f0 <prvAddCurrentTaskToDelayedList+0x54>)
   849d6:	601c      	strcc	r4, [r3, #0]
   849d8:	bd10      	pop	{r4, pc}
   849da:	bf00      	nop
   849dc:	20075ad8 	.word	0x20075ad8
   849e0:	20075a2c 	.word	0x20075a2c
   849e4:	20075a94 	.word	0x20075a94
   849e8:	00084065 	.word	0x00084065
   849ec:	20075aac 	.word	0x20075aac
   849f0:	20070460 	.word	0x20070460

000849f4 <prvListTaskWithinSingleList>:
/*-----------------------------------------------------------*/

#if ( configUSE_TRACE_FACILITY == 1 )

	static void prvListTaskWithinSingleList( const signed char *pcWriteBuffer, xList *pxList, signed char cStatus )
	{
   849f4:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   849f8:	b085      	sub	sp, #20
   849fa:	4682      	mov	sl, r0
   849fc:	460d      	mov	r5, r1
   849fe:	4693      	mov	fp, r2
	volatile tskTCB *pxNextTCB, *pxFirstTCB;
	unsigned short usStackRemaining;
	PRIVILEGED_DATA static char pcStatusString[ configMAX_TASK_NAME_LEN + 30 ];

		/* Write the details of all the TCB's in pxList into the buffer. */
		listGET_OWNER_OF_NEXT_ENTRY( pxFirstTCB, pxList );
   84a00:	684b      	ldr	r3, [r1, #4]
   84a02:	685b      	ldr	r3, [r3, #4]
   84a04:	604b      	str	r3, [r1, #4]
   84a06:	f101 0708 	add.w	r7, r1, #8
   84a0a:	42bb      	cmp	r3, r7
   84a0c:	bf04      	itt	eq
   84a0e:	685b      	ldreq	r3, [r3, #4]
   84a10:	604b      	streq	r3, [r1, #4]
   84a12:	684b      	ldr	r3, [r1, #4]
   84a14:	f8d3 900c 	ldr.w	r9, [r3, #12]
			{
				usStackRemaining = usTaskCheckFreeStackSpace( ( unsigned char * ) pxNextTCB->pxStack );
			}
			#endif

			sprintf( pcStatusString, ( char * ) "%s\t\t%c\t%u\t%u\t%u\r\n", pxNextTCB->pcTaskName, cStatus, ( unsigned int ) pxNextTCB->uxPriority, ( unsigned int ) usStackRemaining, ( unsigned int ) pxNextTCB->uxTCBNumber );
   84a18:	4e17      	ldr	r6, [pc, #92]	; (84a78 <prvListTaskWithinSingleList+0x84>)
   84a1a:	f8df 8064 	ldr.w	r8, [pc, #100]	; 84a80 <prvListTaskWithinSingleList+0x8c>

		/* Write the details of all the TCB's in pxList into the buffer. */
		listGET_OWNER_OF_NEXT_ENTRY( pxFirstTCB, pxList );
		do
		{
			listGET_OWNER_OF_NEXT_ENTRY( pxNextTCB, pxList );
   84a1e:	686b      	ldr	r3, [r5, #4]
   84a20:	685b      	ldr	r3, [r3, #4]
   84a22:	606b      	str	r3, [r5, #4]
   84a24:	429f      	cmp	r7, r3
   84a26:	bf04      	itt	eq
   84a28:	687b      	ldreq	r3, [r7, #4]
   84a2a:	606b      	streq	r3, [r5, #4]
   84a2c:	686b      	ldr	r3, [r5, #4]
   84a2e:	68dc      	ldr	r4, [r3, #12]
			{
				usStackRemaining = usTaskCheckFreeStackSpace( ( unsigned char * ) pxNextTCB->pxEndOfStack );
			}
			#else
			{
				usStackRemaining = usTaskCheckFreeStackSpace( ( unsigned char * ) pxNextTCB->pxStack );
   84a30:	6b22      	ldr	r2, [r4, #48]	; 0x30

	static unsigned short usTaskCheckFreeStackSpace( const unsigned char * pucStackByte )
	{
	register unsigned short usCount = 0U;

		while( *pucStackByte == tskSTACK_FILL_BYTE )
   84a32:	7813      	ldrb	r3, [r2, #0]
   84a34:	2ba5      	cmp	r3, #165	; 0xa5
   84a36:	d107      	bne.n	84a48 <prvListTaskWithinSingleList+0x54>

#if ( ( configUSE_TRACE_FACILITY == 1 ) || ( INCLUDE_uxTaskGetStackHighWaterMark == 1 ) )

	static unsigned short usTaskCheckFreeStackSpace( const unsigned char * pucStackByte )
	{
	register unsigned short usCount = 0U;
   84a38:	2300      	movs	r3, #0

		while( *pucStackByte == tskSTACK_FILL_BYTE )
		{
			pucStackByte -= portSTACK_GROWTH;
			usCount++;
   84a3a:	3301      	adds	r3, #1
   84a3c:	b29b      	uxth	r3, r3

	static unsigned short usTaskCheckFreeStackSpace( const unsigned char * pucStackByte )
	{
	register unsigned short usCount = 0U;

		while( *pucStackByte == tskSTACK_FILL_BYTE )
   84a3e:	f812 1f01 	ldrb.w	r1, [r2, #1]!
   84a42:	29a5      	cmp	r1, #165	; 0xa5
   84a44:	d0f9      	beq.n	84a3a <prvListTaskWithinSingleList+0x46>
   84a46:	e000      	b.n	84a4a <prvListTaskWithinSingleList+0x56>

#if ( ( configUSE_TRACE_FACILITY == 1 ) || ( INCLUDE_uxTaskGetStackHighWaterMark == 1 ) )

	static unsigned short usTaskCheckFreeStackSpace( const unsigned char * pucStackByte )
	{
	register unsigned short usCount = 0U;
   84a48:	2300      	movs	r3, #0
			{
				usStackRemaining = usTaskCheckFreeStackSpace( ( unsigned char * ) pxNextTCB->pxStack );
			}
			#endif

			sprintf( pcStatusString, ( char * ) "%s\t\t%c\t%u\t%u\t%u\r\n", pxNextTCB->pcTaskName, cStatus, ( unsigned int ) pxNextTCB->uxPriority, ( unsigned int ) usStackRemaining, ( unsigned int ) pxNextTCB->uxTCBNumber );
   84a4a:	6ae1      	ldr	r1, [r4, #44]	; 0x2c
   84a4c:	6c22      	ldr	r2, [r4, #64]	; 0x40
   84a4e:	9100      	str	r1, [sp, #0]
   84a50:	089b      	lsrs	r3, r3, #2
   84a52:	9301      	str	r3, [sp, #4]
   84a54:	9202      	str	r2, [sp, #8]
   84a56:	4630      	mov	r0, r6
   84a58:	4641      	mov	r1, r8
   84a5a:	f104 0234 	add.w	r2, r4, #52	; 0x34
   84a5e:	465b      	mov	r3, fp
   84a60:	f8df c020 	ldr.w	ip, [pc, #32]	; 84a84 <prvListTaskWithinSingleList+0x90>
   84a64:	47e0      	blx	ip
			strcat( ( char * ) pcWriteBuffer, ( char * ) pcStatusString );
   84a66:	4650      	mov	r0, sl
   84a68:	4631      	mov	r1, r6
   84a6a:	4b04      	ldr	r3, [pc, #16]	; (84a7c <prvListTaskWithinSingleList+0x88>)
   84a6c:	4798      	blx	r3

		} while( pxNextTCB != pxFirstTCB );
   84a6e:	454c      	cmp	r4, r9
   84a70:	d1d5      	bne.n	84a1e <prvListTaskWithinSingleList+0x2a>
	}
   84a72:	b005      	add	sp, #20
   84a74:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   84a78:	20075adc 	.word	0x20075adc
   84a7c:	000864a1 	.word	0x000864a1
   84a80:	0008c60c 	.word	0x0008c60c
   84a84:	00086455 	.word	0x00086455

00084a88 <prvGenerateRunTimeStatsForTasksInList>:
/*-----------------------------------------------------------*/

#if ( configGENERATE_RUN_TIME_STATS == 1 )

	static void prvGenerateRunTimeStatsForTasksInList( const signed char *pcWriteBuffer, xList *pxList, unsigned long ulTotalRunTime )
	{
   84a88:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   84a8c:	b083      	sub	sp, #12
   84a8e:	4683      	mov	fp, r0
   84a90:	460d      	mov	r5, r1
   84a92:	4616      	mov	r6, r2
	volatile tskTCB *pxNextTCB, *pxFirstTCB;
	unsigned long ulStatsAsPercentage;

		/* Write the run time stats of all the TCB's in pxList into the buffer. */
		listGET_OWNER_OF_NEXT_ENTRY( pxFirstTCB, pxList );
   84a94:	684b      	ldr	r3, [r1, #4]
   84a96:	685b      	ldr	r3, [r3, #4]
   84a98:	604b      	str	r3, [r1, #4]
   84a9a:	f101 0708 	add.w	r7, r1, #8
   84a9e:	42bb      	cmp	r3, r7
   84aa0:	bf04      	itt	eq
   84aa2:	685b      	ldreq	r3, [r3, #4]
   84aa4:	604b      	streq	r3, [r1, #4]
   84aa6:	684b      	ldr	r3, [r1, #4]
   84aa8:	f8d3 800c 	ldr.w	r8, [r3, #12]
						}
						#endif
					}
				}

				strcat( ( char * ) pcWriteBuffer, ( char * ) pcStatsString );
   84aac:	f8df 9078 	ldr.w	r9, [pc, #120]	; 84b28 <prvGenerateRunTimeStatsForTasksInList+0xa0>
   84ab0:	f8df a078 	ldr.w	sl, [pc, #120]	; 84b2c <prvGenerateRunTimeStatsForTasksInList+0xa4>
		/* Write the run time stats of all the TCB's in pxList into the buffer. */
		listGET_OWNER_OF_NEXT_ENTRY( pxFirstTCB, pxList );
		do
		{
			/* Get next TCB in from the list. */
			listGET_OWNER_OF_NEXT_ENTRY( pxNextTCB, pxList );
   84ab4:	686b      	ldr	r3, [r5, #4]
   84ab6:	685b      	ldr	r3, [r3, #4]
   84ab8:	606b      	str	r3, [r5, #4]
   84aba:	429f      	cmp	r7, r3
   84abc:	bf04      	itt	eq
   84abe:	687b      	ldreq	r3, [r7, #4]
   84ac0:	606b      	streq	r3, [r5, #4]
   84ac2:	686b      	ldr	r3, [r5, #4]
   84ac4:	68dc      	ldr	r4, [r3, #12]

			/* Divide by zero check. */
			if( ulTotalRunTime > 0UL )
   84ac6:	b30e      	cbz	r6, 84b0c <prvGenerateRunTimeStatsForTasksInList+0x84>
			{
				/* Has the task run at all? */
				if( pxNextTCB->ulRunTimeCounter == 0UL )
   84ac8:	6ce3      	ldr	r3, [r4, #76]	; 0x4c
   84aca:	b933      	cbnz	r3, 84ada <prvGenerateRunTimeStatsForTasksInList+0x52>
				{
					/* The task has used no CPU time at all. */
					sprintf( pcStatsString, ( char * ) "%s\t\t0\t\t0%%\r\n", pxNextTCB->pcTaskName );
   84acc:	4648      	mov	r0, r9
   84ace:	4912      	ldr	r1, [pc, #72]	; (84b18 <prvGenerateRunTimeStatsForTasksInList+0x90>)
   84ad0:	f104 0234 	add.w	r2, r4, #52	; 0x34
   84ad4:	4b11      	ldr	r3, [pc, #68]	; (84b1c <prvGenerateRunTimeStatsForTasksInList+0x94>)
   84ad6:	4798      	blx	r3
   84ad8:	e015      	b.n	84b06 <prvGenerateRunTimeStatsForTasksInList+0x7e>
				else
				{
					/* What percentage of the total run time has the task used?
					This will always be rounded down to the nearest integer.
					ulTotalRunTime has already been divided by 100. */
					ulStatsAsPercentage = pxNextTCB->ulRunTimeCounter / ulTotalRunTime;
   84ada:	6ce2      	ldr	r2, [r4, #76]	; 0x4c
   84adc:	fbb2 f2f6 	udiv	r2, r2, r6

					if( ulStatsAsPercentage > 0UL )
   84ae0:	b14a      	cbz	r2, 84af6 <prvGenerateRunTimeStatsForTasksInList+0x6e>
						}
						#else
						{
							/* sizeof( int ) == sizeof( long ) so a smaller
							printf() library can be used. */
							sprintf( pcStatsString, ( char * ) "%s\t\t%u\t\t%u%%\r\n", pxNextTCB->pcTaskName, ( unsigned int ) pxNextTCB->ulRunTimeCounter, ( unsigned int ) ulStatsAsPercentage );
   84ae2:	6ce3      	ldr	r3, [r4, #76]	; 0x4c
   84ae4:	9200      	str	r2, [sp, #0]
   84ae6:	4648      	mov	r0, r9
   84ae8:	490d      	ldr	r1, [pc, #52]	; (84b20 <prvGenerateRunTimeStatsForTasksInList+0x98>)
   84aea:	f104 0234 	add.w	r2, r4, #52	; 0x34
   84aee:	f8df c02c 	ldr.w	ip, [pc, #44]	; 84b1c <prvGenerateRunTimeStatsForTasksInList+0x94>
   84af2:	47e0      	blx	ip
   84af4:	e007      	b.n	84b06 <prvGenerateRunTimeStatsForTasksInList+0x7e>
						}
						#else
						{
							/* sizeof( int ) == sizeof( long ) so a smaller
							printf() library can be used. */
							sprintf( pcStatsString, ( char * ) "%s\t\t%u\t\t<1%%\r\n", pxNextTCB->pcTaskName, ( unsigned int ) pxNextTCB->ulRunTimeCounter );
   84af6:	6ce3      	ldr	r3, [r4, #76]	; 0x4c
   84af8:	4648      	mov	r0, r9
   84afa:	490a      	ldr	r1, [pc, #40]	; (84b24 <prvGenerateRunTimeStatsForTasksInList+0x9c>)
   84afc:	f104 0234 	add.w	r2, r4, #52	; 0x34
   84b00:	f8df c018 	ldr.w	ip, [pc, #24]	; 84b1c <prvGenerateRunTimeStatsForTasksInList+0x94>
   84b04:	47e0      	blx	ip
						}
						#endif
					}
				}

				strcat( ( char * ) pcWriteBuffer, ( char * ) pcStatsString );
   84b06:	4658      	mov	r0, fp
   84b08:	4649      	mov	r1, r9
   84b0a:	47d0      	blx	sl
			}

		} while( pxNextTCB != pxFirstTCB );
   84b0c:	4544      	cmp	r4, r8
   84b0e:	d1d1      	bne.n	84ab4 <prvGenerateRunTimeStatsForTasksInList+0x2c>
	}
   84b10:	b003      	add	sp, #12
   84b12:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   84b16:	bf00      	nop
   84b18:	0008c620 	.word	0x0008c620
   84b1c:	00086455 	.word	0x00086455
   84b20:	0008c630 	.word	0x0008c630
   84b24:	0008c640 	.word	0x0008c640
   84b28:	20075b04 	.word	0x20075b04
   84b2c:	000864a1 	.word	0x000864a1

00084b30 <xTaskGenericCreate>:
/*-----------------------------------------------------------
 * TASK CREATION API documented in task.h
 *----------------------------------------------------------*/

signed portBASE_TYPE xTaskGenericCreate( pdTASK_CODE pxTaskCode, const signed char * const pcName, unsigned short usStackDepth, void *pvParameters, unsigned portBASE_TYPE uxPriority, xTaskHandle *pxCreatedTask, portSTACK_TYPE *puxStackBuffer, const xMemoryRegion * const xRegions )
{
   84b30:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
   84b34:	460e      	mov	r6, r1
   84b36:	4693      	mov	fp, r2
   84b38:	469a      	mov	sl, r3
   84b3a:	9d0c      	ldr	r5, [sp, #48]	; 0x30
signed portBASE_TYPE xReturn;
tskTCB * pxNewTCB;

	configASSERT( pxTaskCode );
   84b3c:	4681      	mov	r9, r0
   84b3e:	b920      	cbnz	r0, 84b4a <xTaskGenericCreate+0x1a>
   84b40:	4865      	ldr	r0, [pc, #404]	; (84cd8 <xTaskGenericCreate+0x1a8>)
   84b42:	f240 11eb 	movw	r1, #491	; 0x1eb
   84b46:	4b65      	ldr	r3, [pc, #404]	; (84cdc <xTaskGenericCreate+0x1ac>)
   84b48:	4798      	blx	r3
	configASSERT( ( ( uxPriority & ( ~portPRIVILEGE_BIT ) ) < configMAX_PRIORITIES ) );
   84b4a:	9a0a      	ldr	r2, [sp, #40]	; 0x28
   84b4c:	2a04      	cmp	r2, #4
   84b4e:	d904      	bls.n	84b5a <xTaskGenericCreate+0x2a>
   84b50:	4861      	ldr	r0, [pc, #388]	; (84cd8 <xTaskGenericCreate+0x1a8>)
   84b52:	f44f 71f6 	mov.w	r1, #492	; 0x1ec
   84b56:	4b61      	ldr	r3, [pc, #388]	; (84cdc <xTaskGenericCreate+0x1ac>)
   84b58:	4798      	blx	r3
{
tskTCB *pxNewTCB;

	/* Allocate space for the TCB.  Where the memory comes from depends on
	the implementation of the port malloc function. */
	pxNewTCB = ( tskTCB * ) pvPortMalloc( sizeof( tskTCB ) );
   84b5a:	2050      	movs	r0, #80	; 0x50
   84b5c:	4b60      	ldr	r3, [pc, #384]	; (84ce0 <xTaskGenericCreate+0x1b0>)
   84b5e:	4798      	blx	r3

	if( pxNewTCB != NULL )
   84b60:	4604      	mov	r4, r0
   84b62:	2800      	cmp	r0, #0
   84b64:	f000 80b3 	beq.w	84cce <xTaskGenericCreate+0x19e>
	{
		/* Allocate space for the stack used by the task being created.
		The base of the stack memory stored in the TCB so the task can
		be deleted later if required. */
		pxNewTCB->pxStack = ( portSTACK_TYPE * ) pvPortMallocAligned( ( ( ( size_t )usStackDepth ) * sizeof( portSTACK_TYPE ) ), puxStackBuffer );
   84b68:	2d00      	cmp	r5, #0
   84b6a:	f040 80ad 	bne.w	84cc8 <xTaskGenericCreate+0x198>
   84b6e:	ea4f 008b 	mov.w	r0, fp, lsl #2
   84b72:	4b5b      	ldr	r3, [pc, #364]	; (84ce0 <xTaskGenericCreate+0x1b0>)
   84b74:	4798      	blx	r3
   84b76:	6320      	str	r0, [r4, #48]	; 0x30

		if( pxNewTCB->pxStack == NULL )
   84b78:	b918      	cbnz	r0, 84b82 <xTaskGenericCreate+0x52>
		{
			/* Could not allocate the stack.  Delete the allocated TCB. */
			vPortFree( pxNewTCB );
   84b7a:	4620      	mov	r0, r4
   84b7c:	4b59      	ldr	r3, [pc, #356]	; (84ce4 <xTaskGenericCreate+0x1b4>)
   84b7e:	4798      	blx	r3
   84b80:	e0a5      	b.n	84cce <xTaskGenericCreate+0x19e>
			pxNewTCB = NULL;
		}
		else
		{
			/* Just to help debugging. */
			memset( pxNewTCB->pxStack, ( int ) tskSTACK_FILL_BYTE, ( size_t ) usStackDepth * sizeof( portSTACK_TYPE ) );
   84b82:	21a5      	movs	r1, #165	; 0xa5
   84b84:	ea4f 028b 	mov.w	r2, fp, lsl #2
   84b88:	4b57      	ldr	r3, [pc, #348]	; (84ce8 <xTaskGenericCreate+0x1b8>)
   84b8a:	4798      	blx	r3
		stack grows from high memory to low (as per the 80x86) or visa versa.
		portSTACK_GROWTH is used to make the result positive or negative as
		required by the port. */
		#if( portSTACK_GROWTH < 0 )
		{
			pxTopOfStack = pxNewTCB->pxStack + ( usStackDepth - ( unsigned short ) 1 );
   84b8c:	f10b 4b80 	add.w	fp, fp, #1073741824	; 0x40000000
   84b90:	f10b 3bff 	add.w	fp, fp, #4294967295
   84b94:	6b23      	ldr	r3, [r4, #48]	; 0x30
   84b96:	eb03 0b8b 	add.w	fp, r3, fp, lsl #2
			pxTopOfStack = ( portSTACK_TYPE * ) ( ( ( portPOINTER_SIZE_TYPE ) pxTopOfStack ) & ( ( portPOINTER_SIZE_TYPE ) ~portBYTE_ALIGNMENT_MASK  ) );
   84b9a:	f02b 0b07 	bic.w	fp, fp, #7
{
	/* Store the function name in the TCB. */
	#if configMAX_TASK_NAME_LEN > 1
	{
		/* Don't bring strncpy into the build unnecessarily. */
		strncpy( ( char * ) pxTCB->pcTaskName, ( const char * ) pcName, ( unsigned short ) configMAX_TASK_NAME_LEN );
   84b9e:	f104 0034 	add.w	r0, r4, #52	; 0x34
   84ba2:	4631      	mov	r1, r6
   84ba4:	220a      	movs	r2, #10
   84ba6:	4b51      	ldr	r3, [pc, #324]	; (84cec <xTaskGenericCreate+0x1bc>)
   84ba8:	4798      	blx	r3
	}
	#endif
	pxTCB->pcTaskName[ ( unsigned short ) configMAX_TASK_NAME_LEN - ( unsigned short ) 1 ] = ( signed char ) '\0';
   84baa:	2700      	movs	r7, #0
   84bac:	f884 703d 	strb.w	r7, [r4, #61]	; 0x3d
   84bb0:	9d0a      	ldr	r5, [sp, #40]	; 0x28
   84bb2:	2d04      	cmp	r5, #4
   84bb4:	bf28      	it	cs
   84bb6:	2504      	movcs	r5, #4
	if( uxPriority >= configMAX_PRIORITIES )
	{
		uxPriority = configMAX_PRIORITIES - ( unsigned portBASE_TYPE ) 1U;
	}

	pxTCB->uxPriority = uxPriority;
   84bb8:	62e5      	str	r5, [r4, #44]	; 0x2c
	#if ( configUSE_MUTEXES == 1 )
	{
		pxTCB->uxBasePriority = uxPriority;
   84bba:	64a5      	str	r5, [r4, #72]	; 0x48
	}
	#endif

	vListInitialiseItem( &( pxTCB->xGenericListItem ) );
   84bbc:	1d26      	adds	r6, r4, #4
   84bbe:	4630      	mov	r0, r6
   84bc0:	f8df 8178 	ldr.w	r8, [pc, #376]	; 84d3c <xTaskGenericCreate+0x20c>
   84bc4:	47c0      	blx	r8
	vListInitialiseItem( &( pxTCB->xEventListItem ) );
   84bc6:	f104 0018 	add.w	r0, r4, #24
   84bca:	47c0      	blx	r8

	/* Set the pxTCB as a link back from the xListItem.  This is so we can get
	back to	the containing TCB from a generic item in a list. */
	listSET_LIST_ITEM_OWNER( &( pxTCB->xGenericListItem ), pxTCB );
   84bcc:	6124      	str	r4, [r4, #16]

	/* Event lists are always in priority order. */
	listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) uxPriority );
   84bce:	f1c5 0505 	rsb	r5, r5, #5
   84bd2:	61a5      	str	r5, [r4, #24]
	listSET_LIST_ITEM_OWNER( &( pxTCB->xEventListItem ), pxTCB );
   84bd4:	6264      	str	r4, [r4, #36]	; 0x24
	}
	#endif

	#if ( configGENERATE_RUN_TIME_STATS == 1 )
	{
		pxTCB->ulRunTimeCounter = 0UL;
   84bd6:	64e7      	str	r7, [r4, #76]	; 0x4c
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters, xRunPrivileged );
		}
		#else
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
   84bd8:	4658      	mov	r0, fp
   84bda:	4649      	mov	r1, r9
   84bdc:	4652      	mov	r2, sl
   84bde:	4b44      	ldr	r3, [pc, #272]	; (84cf0 <xTaskGenericCreate+0x1c0>)
   84be0:	4798      	blx	r3
   84be2:	6020      	str	r0, [r4, #0]
		}
		#endif

		/* Check the alignment of the initialised stack. */
		portALIGNMENT_ASSERT_pxCurrentTCB( ( ( ( unsigned long ) pxNewTCB->pxTopOfStack & ( unsigned long ) portBYTE_ALIGNMENT_MASK ) == 0UL ) );
   84be4:	f010 0f07 	tst.w	r0, #7
   84be8:	d004      	beq.n	84bf4 <xTaskGenericCreate+0xc4>
   84bea:	483b      	ldr	r0, [pc, #236]	; (84cd8 <xTaskGenericCreate+0x1a8>)
   84bec:	f44f 710c 	mov.w	r1, #560	; 0x230
   84bf0:	4b3a      	ldr	r3, [pc, #232]	; (84cdc <xTaskGenericCreate+0x1ac>)
   84bf2:	4798      	blx	r3

		if( ( void * ) pxCreatedTask != NULL )
   84bf4:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
   84bf6:	b103      	cbz	r3, 84bfa <xTaskGenericCreate+0xca>
		{
			/* Pass the TCB out - in an anonymous way.  The calling function/
			task can use this as a handle to delete the task later if
			required.*/
			*pxCreatedTask = ( xTaskHandle ) pxNewTCB;
   84bf8:	601c      	str	r4, [r3, #0]
		}

		/* We are going to manipulate the task queues to add this task to a
		ready list, so must make sure no interrupts occur. */
		taskENTER_CRITICAL();
   84bfa:	4b3e      	ldr	r3, [pc, #248]	; (84cf4 <xTaskGenericCreate+0x1c4>)
   84bfc:	4798      	blx	r3
		{
			uxCurrentNumberOfTasks++;
   84bfe:	4b3e      	ldr	r3, [pc, #248]	; (84cf8 <xTaskGenericCreate+0x1c8>)
   84c00:	681a      	ldr	r2, [r3, #0]
   84c02:	3201      	adds	r2, #1
   84c04:	601a      	str	r2, [r3, #0]
			if( pxCurrentTCB == NULL )
   84c06:	4b3d      	ldr	r3, [pc, #244]	; (84cfc <xTaskGenericCreate+0x1cc>)
   84c08:	681b      	ldr	r3, [r3, #0]
   84c0a:	bb13      	cbnz	r3, 84c52 <xTaskGenericCreate+0x122>
			{
				/* There are no other tasks, or all the other tasks are in
				the suspended state - make this the current task. */
				pxCurrentTCB =  pxNewTCB;
   84c0c:	4b3b      	ldr	r3, [pc, #236]	; (84cfc <xTaskGenericCreate+0x1cc>)
   84c0e:	601c      	str	r4, [r3, #0]

				if( uxCurrentNumberOfTasks == ( unsigned portBASE_TYPE ) 1 )
   84c10:	4b39      	ldr	r3, [pc, #228]	; (84cf8 <xTaskGenericCreate+0x1c8>)
   84c12:	681b      	ldr	r3, [r3, #0]
   84c14:	2b01      	cmp	r3, #1
   84c16:	d127      	bne.n	84c68 <xTaskGenericCreate+0x138>
   84c18:	4d39      	ldr	r5, [pc, #228]	; (84d00 <xTaskGenericCreate+0x1d0>)
   84c1a:	f105 0864 	add.w	r8, r5, #100	; 0x64
{
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = ( unsigned portBASE_TYPE ) 0U; uxPriority < configMAX_PRIORITIES; uxPriority++ )
	{
		vListInitialise( ( xList * ) &( pxReadyTasksLists[ uxPriority ] ) );
   84c1e:	4f39      	ldr	r7, [pc, #228]	; (84d04 <xTaskGenericCreate+0x1d4>)
   84c20:	4628      	mov	r0, r5
   84c22:	47b8      	blx	r7
   84c24:	3514      	adds	r5, #20

static void prvInitialiseTaskLists( void )
{
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = ( unsigned portBASE_TYPE ) 0U; uxPriority < configMAX_PRIORITIES; uxPriority++ )
   84c26:	4545      	cmp	r5, r8
   84c28:	d1fa      	bne.n	84c20 <xTaskGenericCreate+0xf0>
	{
		vListInitialise( ( xList * ) &( pxReadyTasksLists[ uxPriority ] ) );
	}

	vListInitialise( ( xList * ) &xDelayedTaskList1 );
   84c2a:	f8df 8114 	ldr.w	r8, [pc, #276]	; 84d40 <xTaskGenericCreate+0x210>
   84c2e:	4640      	mov	r0, r8
   84c30:	4d34      	ldr	r5, [pc, #208]	; (84d04 <xTaskGenericCreate+0x1d4>)
   84c32:	47a8      	blx	r5
	vListInitialise( ( xList * ) &xDelayedTaskList2 );
   84c34:	4f34      	ldr	r7, [pc, #208]	; (84d08 <xTaskGenericCreate+0x1d8>)
   84c36:	4638      	mov	r0, r7
   84c38:	47a8      	blx	r5
	vListInitialise( ( xList * ) &xPendingReadyList );
   84c3a:	4834      	ldr	r0, [pc, #208]	; (84d0c <xTaskGenericCreate+0x1dc>)
   84c3c:	47a8      	blx	r5

	#if ( INCLUDE_vTaskDelete == 1 )
	{
		vListInitialise( ( xList * ) &xTasksWaitingTermination );
   84c3e:	4834      	ldr	r0, [pc, #208]	; (84d10 <xTaskGenericCreate+0x1e0>)
   84c40:	47a8      	blx	r5
	}
	#endif

	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		vListInitialise( ( xList * ) &xSuspendedTaskList );
   84c42:	4834      	ldr	r0, [pc, #208]	; (84d14 <xTaskGenericCreate+0x1e4>)
   84c44:	47a8      	blx	r5
	}
	#endif

	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
	using list2. */
	pxDelayedTaskList = &xDelayedTaskList1;
   84c46:	4b34      	ldr	r3, [pc, #208]	; (84d18 <xTaskGenericCreate+0x1e8>)
   84c48:	f8c3 8000 	str.w	r8, [r3]
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
   84c4c:	4b33      	ldr	r3, [pc, #204]	; (84d1c <xTaskGenericCreate+0x1ec>)
   84c4e:	601f      	str	r7, [r3, #0]
   84c50:	e00a      	b.n	84c68 <xTaskGenericCreate+0x138>
			else
			{
				/* If the scheduler is not already running, make this task the
				current task if it is the highest priority task to be created
				so far. */
				if( xSchedulerRunning == pdFALSE )
   84c52:	4b33      	ldr	r3, [pc, #204]	; (84d20 <xTaskGenericCreate+0x1f0>)
   84c54:	681b      	ldr	r3, [r3, #0]
   84c56:	b93b      	cbnz	r3, 84c68 <xTaskGenericCreate+0x138>
				{
					if( pxCurrentTCB->uxPriority <= uxPriority )
   84c58:	4b28      	ldr	r3, [pc, #160]	; (84cfc <xTaskGenericCreate+0x1cc>)
   84c5a:	681b      	ldr	r3, [r3, #0]
   84c5c:	6adb      	ldr	r3, [r3, #44]	; 0x2c
   84c5e:	9a0a      	ldr	r2, [sp, #40]	; 0x28
   84c60:	429a      	cmp	r2, r3
					{
						pxCurrentTCB = pxNewTCB;
   84c62:	bf24      	itt	cs
   84c64:	4b25      	ldrcs	r3, [pc, #148]	; (84cfc <xTaskGenericCreate+0x1cc>)
   84c66:	601c      	strcs	r4, [r3, #0]
				}
			}

			/* Remember the top priority to make context switching faster.  Use
			the priority in pxNewTCB as this has been capped to a valid value. */
			if( pxNewTCB->uxPriority > uxTopUsedPriority )
   84c68:	6ae0      	ldr	r0, [r4, #44]	; 0x2c
   84c6a:	4b2e      	ldr	r3, [pc, #184]	; (84d24 <xTaskGenericCreate+0x1f4>)
   84c6c:	681b      	ldr	r3, [r3, #0]
   84c6e:	4298      	cmp	r0, r3
			{
				uxTopUsedPriority = pxNewTCB->uxPriority;
   84c70:	bf84      	itt	hi
   84c72:	4b2c      	ldrhi	r3, [pc, #176]	; (84d24 <xTaskGenericCreate+0x1f4>)
   84c74:	6018      	strhi	r0, [r3, #0]
			}

			#if ( configUSE_TRACE_FACILITY == 1 )
			{
				/* Add a counter into the TCB for tracing only. */
				pxNewTCB->uxTCBNumber = uxTaskNumber;
   84c76:	4b2c      	ldr	r3, [pc, #176]	; (84d28 <xTaskGenericCreate+0x1f8>)
   84c78:	681a      	ldr	r2, [r3, #0]
   84c7a:	6422      	str	r2, [r4, #64]	; 0x40
			}
			#endif
			uxTaskNumber++;
   84c7c:	3201      	adds	r2, #1
   84c7e:	601a      	str	r2, [r3, #0]

			prvAddTaskToReadyQueue( pxNewTCB );
   84c80:	4b2a      	ldr	r3, [pc, #168]	; (84d2c <xTaskGenericCreate+0x1fc>)
   84c82:	6819      	ldr	r1, [r3, #0]
   84c84:	2201      	movs	r2, #1
   84c86:	4082      	lsls	r2, r0
   84c88:	430a      	orrs	r2, r1
   84c8a:	601a      	str	r2, [r3, #0]
   84c8c:	eb00 0080 	add.w	r0, r0, r0, lsl #2
   84c90:	4b1b      	ldr	r3, [pc, #108]	; (84d00 <xTaskGenericCreate+0x1d0>)
   84c92:	eb03 0080 	add.w	r0, r3, r0, lsl #2
   84c96:	4631      	mov	r1, r6
   84c98:	4b25      	ldr	r3, [pc, #148]	; (84d30 <xTaskGenericCreate+0x200>)
   84c9a:	4798      	blx	r3

			xReturn = pdPASS;
			portSETUP_TCB( pxNewTCB );
			traceTASK_CREATE( pxNewTCB );
		}
		taskEXIT_CRITICAL();
   84c9c:	4b25      	ldr	r3, [pc, #148]	; (84d34 <xTaskGenericCreate+0x204>)
   84c9e:	4798      	blx	r3
		traceTASK_CREATE_FAILED();
	}

	if( xReturn == pdPASS )
	{
		if( xSchedulerRunning != pdFALSE )
   84ca0:	4b1f      	ldr	r3, [pc, #124]	; (84d20 <xTaskGenericCreate+0x1f0>)
   84ca2:	681b      	ldr	r3, [r3, #0]
   84ca4:	b153      	cbz	r3, 84cbc <xTaskGenericCreate+0x18c>
		{
			/* If the created task is of a higher priority than the current task
			then it should run now. */
			if( pxCurrentTCB->uxPriority < uxPriority )
   84ca6:	4b15      	ldr	r3, [pc, #84]	; (84cfc <xTaskGenericCreate+0x1cc>)
   84ca8:	681b      	ldr	r3, [r3, #0]
   84caa:	6adb      	ldr	r3, [r3, #44]	; 0x2c
   84cac:	9a0a      	ldr	r2, [sp, #40]	; 0x28
   84cae:	429a      	cmp	r2, r3
   84cb0:	d907      	bls.n	84cc2 <xTaskGenericCreate+0x192>
			{
				portYIELD_WITHIN_API();
   84cb2:	4b21      	ldr	r3, [pc, #132]	; (84d38 <xTaskGenericCreate+0x208>)
   84cb4:	4798      	blx	r3
			#endif
			uxTaskNumber++;

			prvAddTaskToReadyQueue( pxNewTCB );

			xReturn = pdPASS;
   84cb6:	2001      	movs	r0, #1
   84cb8:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
   84cbc:	2001      	movs	r0, #1
   84cbe:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
   84cc2:	2001      	movs	r0, #1
   84cc4:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
	if( pxNewTCB != NULL )
	{
		/* Allocate space for the stack used by the task being created.
		The base of the stack memory stored in the TCB so the task can
		be deleted later if required. */
		pxNewTCB->pxStack = ( portSTACK_TYPE * ) pvPortMallocAligned( ( ( ( size_t )usStackDepth ) * sizeof( portSTACK_TYPE ) ), puxStackBuffer );
   84cc8:	6305      	str	r5, [r0, #48]	; 0x30
   84cca:	4628      	mov	r0, r5
   84ccc:	e759      	b.n	84b82 <xTaskGenericCreate+0x52>
		}
		taskEXIT_CRITICAL();
	}
	else
	{
		xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
   84cce:	f04f 30ff 	mov.w	r0, #4294967295
			}
		}
	}

	return xReturn;
}
   84cd2:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
   84cd6:	bf00      	nop
   84cd8:	0008c650 	.word	0x0008c650
   84cdc:	00085f89 	.word	0x00085f89
   84ce0:	00084285 	.word	0x00084285
   84ce4:	00084351 	.word	0x00084351
   84ce8:	000863c1 	.word	0x000863c1
   84cec:	0008695d 	.word	0x0008695d
   84cf0:	000840dd 	.word	0x000840dd
   84cf4:	00084139 	.word	0x00084139
   84cf8:	20075ab0 	.word	0x20075ab0
   84cfc:	20075ad8 	.word	0x20075ad8
   84d00:	20075a30 	.word	0x20075a30
   84d04:	00084029 	.word	0x00084029
   84d08:	20075b60 	.word	0x20075b60
   84d0c:	20075ab4 	.word	0x20075ab4
   84d10:	20075a98 	.word	0x20075a98
   84d14:	20075b38 	.word	0x20075b38
   84d18:	20075aac 	.word	0x20075aac
   84d1c:	20075a94 	.word	0x20075a94
   84d20:	20075ac8 	.word	0x20075ac8
   84d24:	20075b80 	.word	0x20075b80
   84d28:	20075ad4 	.word	0x20075ad4
   84d2c:	20075a24 	.word	0x20075a24
   84d30:	00084049 	.word	0x00084049
   84d34:	00084159 	.word	0x00084159
   84d38:	00084119 	.word	0x00084119
   84d3c:	00084041 	.word	0x00084041
   84d40:	20075b4c 	.word	0x20075b4c

00084d44 <vTaskDelete>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelete == 1 )

	void vTaskDelete( xTaskHandle pxTaskToDelete )
	{
   84d44:	b570      	push	{r4, r5, r6, lr}
   84d46:	4604      	mov	r4, r0
	tskTCB *pxTCB;

		taskENTER_CRITICAL();
   84d48:	4b1e      	ldr	r3, [pc, #120]	; (84dc4 <vTaskDelete+0x80>)
   84d4a:	4798      	blx	r3
		{
			/* Ensure a yield is performed if the current task is being
			deleted. */
			if( pxTaskToDelete == pxCurrentTCB )
   84d4c:	4b1e      	ldr	r3, [pc, #120]	; (84dc8 <vTaskDelete+0x84>)
   84d4e:	681b      	ldr	r3, [r3, #0]
   84d50:	429c      	cmp	r4, r3
   84d52:	d003      	beq.n	84d5c <vTaskDelete+0x18>
   84d54:	4626      	mov	r6, r4
			{
				pxTaskToDelete = NULL;
			}

			/* If null is passed in here then we are deleting ourselves. */
			pxTCB = prvGetTCBFromHandle( pxTaskToDelete );
   84d56:	b92c      	cbnz	r4, 84d64 <vTaskDelete+0x20>
   84d58:	4626      	mov	r6, r4
   84d5a:	e000      	b.n	84d5e <vTaskDelete+0x1a>
		{
			/* Ensure a yield is performed if the current task is being
			deleted. */
			if( pxTaskToDelete == pxCurrentTCB )
			{
				pxTaskToDelete = NULL;
   84d5c:	2600      	movs	r6, #0
			}

			/* If null is passed in here then we are deleting ourselves. */
			pxTCB = prvGetTCBFromHandle( pxTaskToDelete );
   84d5e:	4b1a      	ldr	r3, [pc, #104]	; (84dc8 <vTaskDelete+0x84>)
   84d60:	681c      	ldr	r4, [r3, #0]
   84d62:	e7ff      	b.n	84d64 <vTaskDelete+0x20>

			/* Remove task from the ready list and place in the	termination list.
			This will stop the task from be scheduled.  The idle task will check
			the termination list and free up any memory allocated by the
			scheduler for the TCB and stack. */
			if( uxListRemove( ( xListItem * ) &( pxTCB->xGenericListItem ) ) == 0 )
   84d64:	1d25      	adds	r5, r4, #4
   84d66:	4628      	mov	r0, r5
   84d68:	4b18      	ldr	r3, [pc, #96]	; (84dcc <vTaskDelete+0x88>)
   84d6a:	4798      	blx	r3
   84d6c:	b970      	cbnz	r0, 84d8c <vTaskDelete+0x48>
			{
				taskRESET_READY_PRIORITY( pxTCB->uxPriority );
   84d6e:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
   84d70:	eb03 0283 	add.w	r2, r3, r3, lsl #2
   84d74:	0092      	lsls	r2, r2, #2
   84d76:	4916      	ldr	r1, [pc, #88]	; (84dd0 <vTaskDelete+0x8c>)
   84d78:	588a      	ldr	r2, [r1, r2]
   84d7a:	b93a      	cbnz	r2, 84d8c <vTaskDelete+0x48>
   84d7c:	4a15      	ldr	r2, [pc, #84]	; (84dd4 <vTaskDelete+0x90>)
   84d7e:	6811      	ldr	r1, [r2, #0]
   84d80:	2001      	movs	r0, #1
   84d82:	fa00 f303 	lsl.w	r3, r0, r3
   84d86:	ea21 0303 	bic.w	r3, r1, r3
   84d8a:	6013      	str	r3, [r2, #0]
			}

			/* Is the task waiting on an event also? */
			if( pxTCB->xEventListItem.pvContainer != NULL )
   84d8c:	6aa3      	ldr	r3, [r4, #40]	; 0x28
   84d8e:	b11b      	cbz	r3, 84d98 <vTaskDelete+0x54>
			{
				uxListRemove( &( pxTCB->xEventListItem ) );
   84d90:	f104 0018 	add.w	r0, r4, #24
   84d94:	4b0d      	ldr	r3, [pc, #52]	; (84dcc <vTaskDelete+0x88>)
   84d96:	4798      	blx	r3
			}

			vListInsertEnd( ( xList * ) &xTasksWaitingTermination, &( pxTCB->xGenericListItem ) );
   84d98:	480f      	ldr	r0, [pc, #60]	; (84dd8 <vTaskDelete+0x94>)
   84d9a:	4629      	mov	r1, r5
   84d9c:	4b0f      	ldr	r3, [pc, #60]	; (84ddc <vTaskDelete+0x98>)
   84d9e:	4798      	blx	r3

			/* Increment the ucTasksDeleted variable so the idle task knows
			there is a task that has been deleted and that it should therefore
			check the xTasksWaitingTermination list. */
			++uxTasksDeleted;
   84da0:	4b0f      	ldr	r3, [pc, #60]	; (84de0 <vTaskDelete+0x9c>)
   84da2:	681a      	ldr	r2, [r3, #0]
   84da4:	3201      	adds	r2, #1
   84da6:	601a      	str	r2, [r3, #0]

			/* Increment the uxTaskNumberVariable also so kernel aware debuggers
			can detect that the task lists need re-generating. */
			uxTaskNumber++;
   84da8:	4b0e      	ldr	r3, [pc, #56]	; (84de4 <vTaskDelete+0xa0>)
   84daa:	681a      	ldr	r2, [r3, #0]
   84dac:	3201      	adds	r2, #1
   84dae:	601a      	str	r2, [r3, #0]

			traceTASK_DELETE( pxTCB );
		}
		taskEXIT_CRITICAL();
   84db0:	4b0d      	ldr	r3, [pc, #52]	; (84de8 <vTaskDelete+0xa4>)
   84db2:	4798      	blx	r3

		/* Force a reschedule if we have just deleted the current task. */
		if( xSchedulerRunning != pdFALSE )
   84db4:	4b0d      	ldr	r3, [pc, #52]	; (84dec <vTaskDelete+0xa8>)
   84db6:	681b      	ldr	r3, [r3, #0]
   84db8:	b113      	cbz	r3, 84dc0 <vTaskDelete+0x7c>
		{
			if( ( void * ) pxTaskToDelete == NULL )
   84dba:	b90e      	cbnz	r6, 84dc0 <vTaskDelete+0x7c>
			{
				portYIELD_WITHIN_API();
   84dbc:	4b0c      	ldr	r3, [pc, #48]	; (84df0 <vTaskDelete+0xac>)
   84dbe:	4798      	blx	r3
   84dc0:	bd70      	pop	{r4, r5, r6, pc}
   84dc2:	bf00      	nop
   84dc4:	00084139 	.word	0x00084139
   84dc8:	20075ad8 	.word	0x20075ad8
   84dcc:	000840a1 	.word	0x000840a1
   84dd0:	20075a30 	.word	0x20075a30
   84dd4:	20075a24 	.word	0x20075a24
   84dd8:	20075a98 	.word	0x20075a98
   84ddc:	00084049 	.word	0x00084049
   84de0:	20075a28 	.word	0x20075a28
   84de4:	20075ad4 	.word	0x20075ad4
   84de8:	00084159 	.word	0x00084159
   84dec:	20075ac8 	.word	0x20075ac8
   84df0:	00084119 	.word	0x00084119

00084df4 <vTaskStartScheduler>:
 * PUBLIC SCHEDULER CONTROL documented in task.h
 *----------------------------------------------------------*/


void vTaskStartScheduler( void )
{
   84df4:	b510      	push	{r4, lr}
   84df6:	b084      	sub	sp, #16
		xReturn = xTaskCreate( prvIdleTask, ( signed char * ) "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), &xIdleTaskHandle );
	}
	#else
	{
		/* Create the idle task without storing its handle. */
		xReturn = xTaskCreate( prvIdleTask, ( signed char * ) "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), NULL );
   84df8:	2300      	movs	r3, #0
   84dfa:	9300      	str	r3, [sp, #0]
   84dfc:	9301      	str	r3, [sp, #4]
   84dfe:	9302      	str	r3, [sp, #8]
   84e00:	9303      	str	r3, [sp, #12]
   84e02:	4810      	ldr	r0, [pc, #64]	; (84e44 <vTaskStartScheduler+0x50>)
   84e04:	4910      	ldr	r1, [pc, #64]	; (84e48 <vTaskStartScheduler+0x54>)
   84e06:	22a0      	movs	r2, #160	; 0xa0
   84e08:	4c10      	ldr	r4, [pc, #64]	; (84e4c <vTaskStartScheduler+0x58>)
   84e0a:	47a0      	blx	r4
	}
	#endif

	#if ( configUSE_TIMERS == 1 )
	{
		if( xReturn == pdPASS )
   84e0c:	2801      	cmp	r0, #1
   84e0e:	d110      	bne.n	84e32 <vTaskStartScheduler+0x3e>
		{
			xReturn = xTimerCreateTimerTask();
   84e10:	4b0f      	ldr	r3, [pc, #60]	; (84e50 <vTaskStartScheduler+0x5c>)
   84e12:	4798      	blx	r3
		}
	}
	#endif

	if( xReturn == pdPASS )
   84e14:	2801      	cmp	r0, #1
   84e16:	d10c      	bne.n	84e32 <vTaskStartScheduler+0x3e>
		so interrupts will automatically get re-enabled when the first task
		starts to run.

		STEPPING THROUGH HERE USING A DEBUGGER CAN CAUSE BIG PROBLEMS IF THE
		DEBUGGER ALLOWS INTERRUPTS TO BE PROCESSED. */
		portDISABLE_INTERRUPTS();
   84e18:	4b0e      	ldr	r3, [pc, #56]	; (84e54 <vTaskStartScheduler+0x60>)
   84e1a:	4798      	blx	r3

		xSchedulerRunning = pdTRUE;
   84e1c:	2201      	movs	r2, #1
   84e1e:	4b0e      	ldr	r3, [pc, #56]	; (84e58 <vTaskStartScheduler+0x64>)
   84e20:	601a      	str	r2, [r3, #0]
		xTickCount = ( portTickType ) 0U;
   84e22:	2200      	movs	r2, #0
   84e24:	4b0d      	ldr	r3, [pc, #52]	; (84e5c <vTaskStartScheduler+0x68>)
   84e26:	601a      	str	r2, [r3, #0]

		/* If configGENERATE_RUN_TIME_STATS is defined then the following
		macro must be defined to configure the timer/counter used to generate
		the run time counter time base. */
		portCONFIGURE_TIMER_FOR_RUN_TIME_STATS();
   84e28:	4b0d      	ldr	r3, [pc, #52]	; (84e60 <vTaskStartScheduler+0x6c>)
   84e2a:	4798      	blx	r3

		/* Setting up the timer tick is hardware specific and thus in the
		portable interface. */
		if( xPortStartScheduler() != pdFALSE )
   84e2c:	4b0d      	ldr	r3, [pc, #52]	; (84e64 <vTaskStartScheduler+0x70>)
   84e2e:	4798      	blx	r3
   84e30:	e005      	b.n	84e3e <vTaskStartScheduler+0x4a>
			/* Should only reach here if a task calls xTaskEndScheduler(). */
		}
	}

	/* This line will only be reached if the kernel could not be started. */
	configASSERT( xReturn );
   84e32:	b920      	cbnz	r0, 84e3e <vTaskStartScheduler+0x4a>
   84e34:	480c      	ldr	r0, [pc, #48]	; (84e68 <vTaskStartScheduler+0x74>)
   84e36:	f240 5113 	movw	r1, #1299	; 0x513
   84e3a:	4b0c      	ldr	r3, [pc, #48]	; (84e6c <vTaskStartScheduler+0x78>)
   84e3c:	4798      	blx	r3
}
   84e3e:	b004      	add	sp, #16
   84e40:	bd10      	pop	{r4, pc}
   84e42:	bf00      	nop
   84e44:	0008515d 	.word	0x0008515d
   84e48:	0008c690 	.word	0x0008c690
   84e4c:	00084b31 	.word	0x00084b31
   84e50:	00085885 	.word	0x00085885
   84e54:	00084129 	.word	0x00084129
   84e58:	20075ac8 	.word	0x20075ac8
   84e5c:	20075a2c 	.word	0x20075a2c
   84e60:	000861b1 	.word	0x000861b1
   84e64:	000841f5 	.word	0x000841f5
   84e68:	0008c650 	.word	0x0008c650
   84e6c:	00085f89 	.word	0x00085f89

00084e70 <vTaskSuspendAll>:

void vTaskSuspendAll( void )
{
	/* A critical section is not required as the variable is of type
	portBASE_TYPE. */
	++uxSchedulerSuspended;
   84e70:	4b02      	ldr	r3, [pc, #8]	; (84e7c <vTaskSuspendAll+0xc>)
   84e72:	681a      	ldr	r2, [r3, #0]
   84e74:	3201      	adds	r2, #1
   84e76:	601a      	str	r2, [r3, #0]
   84e78:	4770      	bx	lr
   84e7a:	bf00      	nop
   84e7c:	20075b74 	.word	0x20075b74

00084e80 <xTaskGetTickCount>:
 *----------------------------------------------------------*/



portTickType xTaskGetTickCount( void )
{
   84e80:	b510      	push	{r4, lr}
portTickType xTicks;

	/* Critical section required if running on a 16 bit processor. */
	taskENTER_CRITICAL();
   84e82:	4b04      	ldr	r3, [pc, #16]	; (84e94 <xTaskGetTickCount+0x14>)
   84e84:	4798      	blx	r3
	{
		xTicks = xTickCount;
   84e86:	4b04      	ldr	r3, [pc, #16]	; (84e98 <xTaskGetTickCount+0x18>)
   84e88:	681c      	ldr	r4, [r3, #0]
	}
	taskEXIT_CRITICAL();
   84e8a:	4b04      	ldr	r3, [pc, #16]	; (84e9c <xTaskGetTickCount+0x1c>)
   84e8c:	4798      	blx	r3

	return xTicks;
}
   84e8e:	4620      	mov	r0, r4
   84e90:	bd10      	pop	{r4, pc}
   84e92:	bf00      	nop
   84e94:	00084139 	.word	0x00084139
   84e98:	20075a2c 	.word	0x20075a2c
   84e9c:	00084159 	.word	0x00084159

00084ea0 <xTaskGetTickCountFromISR>:
/*-----------------------------------------------------------*/

portTickType xTaskGetTickCountFromISR( void )
{
   84ea0:	b510      	push	{r4, lr}
portTickType xReturn;
unsigned portBASE_TYPE uxSavedInterruptStatus;

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
   84ea2:	4b04      	ldr	r3, [pc, #16]	; (84eb4 <xTaskGetTickCountFromISR+0x14>)
   84ea4:	4798      	blx	r3
	xReturn = xTickCount;
   84ea6:	4b04      	ldr	r3, [pc, #16]	; (84eb8 <xTaskGetTickCountFromISR+0x18>)
   84ea8:	681c      	ldr	r4, [r3, #0]
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
   84eaa:	4b04      	ldr	r3, [pc, #16]	; (84ebc <xTaskGetTickCountFromISR+0x1c>)
   84eac:	4798      	blx	r3

	return xReturn;
}
   84eae:	4620      	mov	r0, r4
   84eb0:	bd10      	pop	{r4, pc}
   84eb2:	bf00      	nop
   84eb4:	00084129 	.word	0x00084129
   84eb8:	20075a2c 	.word	0x20075a2c
   84ebc:	00084151 	.word	0x00084151

00084ec0 <vTaskIncrementTick>:
 * SCHEDULER INTERNALS AVAILABLE FOR PORTING PURPOSES
 * documented in task.h
 *----------------------------------------------------------*/

void vTaskIncrementTick( void )
{
   84ec0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}

	/* Called by the portable layer each time a tick interrupt occurs.
	Increments the tick then checks to see if the new tick value will cause any
	tasks to be unblocked. */
	traceTASK_INCREMENT_TICK( xTickCount );
	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
   84ec4:	4b3b      	ldr	r3, [pc, #236]	; (84fb4 <vTaskIncrementTick+0xf4>)
   84ec6:	681b      	ldr	r3, [r3, #0]
   84ec8:	2b00      	cmp	r3, #0
   84eca:	d16d      	bne.n	84fa8 <vTaskIncrementTick+0xe8>
	{
		++xTickCount;
   84ecc:	4b3a      	ldr	r3, [pc, #232]	; (84fb8 <vTaskIncrementTick+0xf8>)
   84ece:	681a      	ldr	r2, [r3, #0]
   84ed0:	3201      	adds	r2, #1
   84ed2:	601a      	str	r2, [r3, #0]
		if( xTickCount == ( portTickType ) 0U )
   84ed4:	681b      	ldr	r3, [r3, #0]
   84ed6:	bb0b      	cbnz	r3, 84f1c <vTaskIncrementTick+0x5c>
			xList *pxTemp;

			/* Tick count has overflowed so we need to swap the delay lists.
			If there are any items in pxDelayedTaskList here then there is
			an error! */
			configASSERT( ( listLIST_IS_EMPTY( pxDelayedTaskList ) ) );
   84ed8:	4b38      	ldr	r3, [pc, #224]	; (84fbc <vTaskIncrementTick+0xfc>)
   84eda:	681b      	ldr	r3, [r3, #0]
   84edc:	681b      	ldr	r3, [r3, #0]
   84ede:	b123      	cbz	r3, 84eea <vTaskIncrementTick+0x2a>
   84ee0:	4837      	ldr	r0, [pc, #220]	; (84fc0 <vTaskIncrementTick+0x100>)
   84ee2:	f240 618c 	movw	r1, #1676	; 0x68c
   84ee6:	4b37      	ldr	r3, [pc, #220]	; (84fc4 <vTaskIncrementTick+0x104>)
   84ee8:	4798      	blx	r3

			pxTemp = pxDelayedTaskList;
   84eea:	4b34      	ldr	r3, [pc, #208]	; (84fbc <vTaskIncrementTick+0xfc>)
   84eec:	6819      	ldr	r1, [r3, #0]
			pxDelayedTaskList = pxOverflowDelayedTaskList;
   84eee:	4a36      	ldr	r2, [pc, #216]	; (84fc8 <vTaskIncrementTick+0x108>)
   84ef0:	6810      	ldr	r0, [r2, #0]
   84ef2:	6018      	str	r0, [r3, #0]
			pxOverflowDelayedTaskList = pxTemp;
   84ef4:	6011      	str	r1, [r2, #0]
			xNumOfOverflows++;
   84ef6:	4a35      	ldr	r2, [pc, #212]	; (84fcc <vTaskIncrementTick+0x10c>)
   84ef8:	6811      	ldr	r1, [r2, #0]
   84efa:	3101      	adds	r1, #1
   84efc:	6011      	str	r1, [r2, #0]

			if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
   84efe:	681b      	ldr	r3, [r3, #0]
   84f00:	681b      	ldr	r3, [r3, #0]
   84f02:	b923      	cbnz	r3, 84f0e <vTaskIncrementTick+0x4e>
				/* The new current delayed list is empty.  Set
				xNextTaskUnblockTime to the maximum possible value so it is
				extremely unlikely that the
				if( xTickCount >= xNextTaskUnblockTime ) test will pass until
				there is an item in the delayed list. */
				xNextTaskUnblockTime = portMAX_DELAY;
   84f04:	f04f 32ff 	mov.w	r2, #4294967295
   84f08:	4b31      	ldr	r3, [pc, #196]	; (84fd0 <vTaskIncrementTick+0x110>)
   84f0a:	601a      	str	r2, [r3, #0]
   84f0c:	e006      	b.n	84f1c <vTaskIncrementTick+0x5c>
			{
				/* The new current delayed list is not empty, get the value of
				the item at the head of the delayed list.  This is the time at
				which the task at the head of the delayed list should be removed
				from the Blocked state. */
				pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
   84f0e:	4b2b      	ldr	r3, [pc, #172]	; (84fbc <vTaskIncrementTick+0xfc>)
   84f10:	681b      	ldr	r3, [r3, #0]
   84f12:	68db      	ldr	r3, [r3, #12]
   84f14:	68db      	ldr	r3, [r3, #12]
				xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( pxTCB->xGenericListItem ) );
   84f16:	685a      	ldr	r2, [r3, #4]
   84f18:	4b2d      	ldr	r3, [pc, #180]	; (84fd0 <vTaskIncrementTick+0x110>)
   84f1a:	601a      	str	r2, [r3, #0]
			}
		}

		/* See if this tick has made a timeout expire. */
		prvCheckDelayedTasks();
   84f1c:	4b26      	ldr	r3, [pc, #152]	; (84fb8 <vTaskIncrementTick+0xf8>)
   84f1e:	681a      	ldr	r2, [r3, #0]
   84f20:	4b2b      	ldr	r3, [pc, #172]	; (84fd0 <vTaskIncrementTick+0x110>)
   84f22:	681b      	ldr	r3, [r3, #0]
   84f24:	429a      	cmp	r2, r3
   84f26:	d343      	bcc.n	84fb0 <vTaskIncrementTick+0xf0>
   84f28:	4b24      	ldr	r3, [pc, #144]	; (84fbc <vTaskIncrementTick+0xfc>)
   84f2a:	681b      	ldr	r3, [r3, #0]
   84f2c:	681b      	ldr	r3, [r3, #0]
   84f2e:	b14b      	cbz	r3, 84f44 <vTaskIncrementTick+0x84>
   84f30:	4b22      	ldr	r3, [pc, #136]	; (84fbc <vTaskIncrementTick+0xfc>)
   84f32:	681b      	ldr	r3, [r3, #0]
   84f34:	68db      	ldr	r3, [r3, #12]
   84f36:	68dc      	ldr	r4, [r3, #12]
   84f38:	6863      	ldr	r3, [r4, #4]
   84f3a:	4a1f      	ldr	r2, [pc, #124]	; (84fb8 <vTaskIncrementTick+0xf8>)
   84f3c:	6812      	ldr	r2, [r2, #0]
   84f3e:	4293      	cmp	r3, r2
   84f40:	d913      	bls.n	84f6a <vTaskIncrementTick+0xaa>
   84f42:	e00e      	b.n	84f62 <vTaskIncrementTick+0xa2>
   84f44:	f04f 32ff 	mov.w	r2, #4294967295
   84f48:	4b21      	ldr	r3, [pc, #132]	; (84fd0 <vTaskIncrementTick+0x110>)
   84f4a:	601a      	str	r2, [r3, #0]
   84f4c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   84f50:	4b1a      	ldr	r3, [pc, #104]	; (84fbc <vTaskIncrementTick+0xfc>)
   84f52:	681b      	ldr	r3, [r3, #0]
   84f54:	68db      	ldr	r3, [r3, #12]
   84f56:	68dc      	ldr	r4, [r3, #12]
   84f58:	6863      	ldr	r3, [r4, #4]
   84f5a:	4a17      	ldr	r2, [pc, #92]	; (84fb8 <vTaskIncrementTick+0xf8>)
   84f5c:	6812      	ldr	r2, [r2, #0]
   84f5e:	4293      	cmp	r3, r2
   84f60:	d907      	bls.n	84f72 <vTaskIncrementTick+0xb2>
   84f62:	4a1b      	ldr	r2, [pc, #108]	; (84fd0 <vTaskIncrementTick+0x110>)
   84f64:	6013      	str	r3, [r2, #0]
   84f66:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   84f6a:	4f1a      	ldr	r7, [pc, #104]	; (84fd4 <vTaskIncrementTick+0x114>)
   84f6c:	4e1a      	ldr	r6, [pc, #104]	; (84fd8 <vTaskIncrementTick+0x118>)
   84f6e:	f8df 8074 	ldr.w	r8, [pc, #116]	; 84fe4 <vTaskIncrementTick+0x124>
   84f72:	1d25      	adds	r5, r4, #4
   84f74:	4628      	mov	r0, r5
   84f76:	47b8      	blx	r7
   84f78:	6aa3      	ldr	r3, [r4, #40]	; 0x28
   84f7a:	b113      	cbz	r3, 84f82 <vTaskIncrementTick+0xc2>
   84f7c:	f104 0018 	add.w	r0, r4, #24
   84f80:	47b8      	blx	r7
   84f82:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
   84f84:	6831      	ldr	r1, [r6, #0]
   84f86:	2201      	movs	r2, #1
   84f88:	409a      	lsls	r2, r3
   84f8a:	430a      	orrs	r2, r1
   84f8c:	6032      	str	r2, [r6, #0]
   84f8e:	eb03 0083 	add.w	r0, r3, r3, lsl #2
   84f92:	eb08 0080 	add.w	r0, r8, r0, lsl #2
   84f96:	4629      	mov	r1, r5
   84f98:	4b10      	ldr	r3, [pc, #64]	; (84fdc <vTaskIncrementTick+0x11c>)
   84f9a:	4798      	blx	r3
   84f9c:	4b07      	ldr	r3, [pc, #28]	; (84fbc <vTaskIncrementTick+0xfc>)
   84f9e:	681b      	ldr	r3, [r3, #0]
   84fa0:	681b      	ldr	r3, [r3, #0]
   84fa2:	2b00      	cmp	r3, #0
   84fa4:	d1d4      	bne.n	84f50 <vTaskIncrementTick+0x90>
   84fa6:	e7cd      	b.n	84f44 <vTaskIncrementTick+0x84>
	}
	else
	{
		++uxMissedTicks;
   84fa8:	4b0d      	ldr	r3, [pc, #52]	; (84fe0 <vTaskIncrementTick+0x120>)
   84faa:	681a      	ldr	r2, [r3, #0]
   84fac:	3201      	adds	r2, #1
   84fae:	601a      	str	r2, [r3, #0]
   84fb0:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   84fb4:	20075b74 	.word	0x20075b74
   84fb8:	20075a2c 	.word	0x20075a2c
   84fbc:	20075aac 	.word	0x20075aac
   84fc0:	0008c650 	.word	0x0008c650
   84fc4:	00085f89 	.word	0x00085f89
   84fc8:	20075a94 	.word	0x20075a94
   84fcc:	20075b7c 	.word	0x20075b7c
   84fd0:	20070460 	.word	0x20070460
   84fd4:	000840a1 	.word	0x000840a1
   84fd8:	20075a24 	.word	0x20075a24
   84fdc:	00084049 	.word	0x00084049
   84fe0:	20075b78 	.word	0x20075b78
   84fe4:	20075a30 	.word	0x20075a30

00084fe8 <xTaskResumeAll>:

#endif /* configUSE_TICKLESS_IDLE != 0  */
/*----------------------------------------------------------*/

signed portBASE_TYPE xTaskResumeAll( void )
{
   84fe8:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
register tskTCB *pxTCB;
signed portBASE_TYPE xAlreadyYielded = pdFALSE;

	/* If uxSchedulerSuspended is zero then this function does not match a
	previous call to vTaskSuspendAll(). */
	configASSERT( uxSchedulerSuspended );
   84fec:	4b32      	ldr	r3, [pc, #200]	; (850b8 <xTaskResumeAll+0xd0>)
   84fee:	681b      	ldr	r3, [r3, #0]
   84ff0:	b923      	cbnz	r3, 84ffc <xTaskResumeAll+0x14>
   84ff2:	4832      	ldr	r0, [pc, #200]	; (850bc <xTaskResumeAll+0xd4>)
   84ff4:	f240 514d 	movw	r1, #1357	; 0x54d
   84ff8:	4b31      	ldr	r3, [pc, #196]	; (850c0 <xTaskResumeAll+0xd8>)
   84ffa:	4798      	blx	r3
	/* It is possible that an ISR caused a task to be removed from an event
	list while the scheduler was suspended.  If this was the case then the
	removed task will have been added to the xPendingReadyList.  Once the
	scheduler has been resumed it is safe to move all the pending ready
	tasks from this list into their appropriate ready list. */
	taskENTER_CRITICAL();
   84ffc:	4b31      	ldr	r3, [pc, #196]	; (850c4 <xTaskResumeAll+0xdc>)
   84ffe:	4798      	blx	r3
	{
		--uxSchedulerSuspended;
   85000:	4b2d      	ldr	r3, [pc, #180]	; (850b8 <xTaskResumeAll+0xd0>)
   85002:	681a      	ldr	r2, [r3, #0]
   85004:	3a01      	subs	r2, #1
   85006:	601a      	str	r2, [r3, #0]

		if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
   85008:	681b      	ldr	r3, [r3, #0]
   8500a:	2b00      	cmp	r3, #0
   8500c:	d149      	bne.n	850a2 <xTaskResumeAll+0xba>
		{
			if( uxCurrentNumberOfTasks > ( unsigned portBASE_TYPE ) 0U )
   8500e:	4b2e      	ldr	r3, [pc, #184]	; (850c8 <xTaskResumeAll+0xe0>)
   85010:	681b      	ldr	r3, [r3, #0]
   85012:	2b00      	cmp	r3, #0
   85014:	d047      	beq.n	850a6 <xTaskResumeAll+0xbe>
   85016:	2700      	movs	r7, #0
			{
				portBASE_TYPE xYieldRequired = pdFALSE;

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
   85018:	4e2c      	ldr	r6, [pc, #176]	; (850cc <xTaskResumeAll+0xe4>)
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) );
					uxListRemove( &( pxTCB->xEventListItem ) );
   8501a:	f8df 90d4 	ldr.w	r9, [pc, #212]	; 850f0 <xTaskResumeAll+0x108>
					uxListRemove( &( pxTCB->xGenericListItem ) );
					prvAddTaskToReadyQueue( pxTCB );
   8501e:	f8df 80d4 	ldr.w	r8, [pc, #212]	; 850f4 <xTaskResumeAll+0x10c>
   85022:	e01e      	b.n	85062 <xTaskResumeAll+0x7a>

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) );
   85024:	68f3      	ldr	r3, [r6, #12]
   85026:	68dc      	ldr	r4, [r3, #12]
					uxListRemove( &( pxTCB->xEventListItem ) );
   85028:	f104 0018 	add.w	r0, r4, #24
   8502c:	47c8      	blx	r9
					uxListRemove( &( pxTCB->xGenericListItem ) );
   8502e:	1d25      	adds	r5, r4, #4
   85030:	4628      	mov	r0, r5
   85032:	47c8      	blx	r9
					prvAddTaskToReadyQueue( pxTCB );
   85034:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
   85036:	f8d8 1000 	ldr.w	r1, [r8]
   8503a:	2201      	movs	r2, #1
   8503c:	409a      	lsls	r2, r3
   8503e:	430a      	orrs	r2, r1
   85040:	f8c8 2000 	str.w	r2, [r8]
   85044:	eb03 0383 	add.w	r3, r3, r3, lsl #2
   85048:	4821      	ldr	r0, [pc, #132]	; (850d0 <xTaskResumeAll+0xe8>)
   8504a:	eb00 0083 	add.w	r0, r0, r3, lsl #2
   8504e:	4629      	mov	r1, r5
   85050:	4b20      	ldr	r3, [pc, #128]	; (850d4 <xTaskResumeAll+0xec>)
   85052:	4798      	blx	r3

					/* If we have moved a task that has a priority higher than
					the current task then we should yield. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
   85054:	4b20      	ldr	r3, [pc, #128]	; (850d8 <xTaskResumeAll+0xf0>)
   85056:	681b      	ldr	r3, [r3, #0]
   85058:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
   8505a:	6adb      	ldr	r3, [r3, #44]	; 0x2c
					{
						xYieldRequired = pdTRUE;
   8505c:	429a      	cmp	r2, r3
   8505e:	bf28      	it	cs
   85060:	2701      	movcs	r7, #1
			{
				portBASE_TYPE xYieldRequired = pdFALSE;

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
   85062:	6833      	ldr	r3, [r6, #0]
   85064:	2b00      	cmp	r3, #0
   85066:	d1dd      	bne.n	85024 <xTaskResumeAll+0x3c>
				}

				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
   85068:	4b1c      	ldr	r3, [pc, #112]	; (850dc <xTaskResumeAll+0xf4>)
   8506a:	681b      	ldr	r3, [r3, #0]
   8506c:	b163      	cbz	r3, 85088 <xTaskResumeAll+0xa0>
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
   8506e:	4b1b      	ldr	r3, [pc, #108]	; (850dc <xTaskResumeAll+0xf4>)
   85070:	681b      	ldr	r3, [r3, #0]
   85072:	b17b      	cbz	r3, 85094 <xTaskResumeAll+0xac>
					{
						vTaskIncrementTick();
   85074:	4d1a      	ldr	r5, [pc, #104]	; (850e0 <xTaskResumeAll+0xf8>)
						--uxMissedTicks;
   85076:	4c19      	ldr	r4, [pc, #100]	; (850dc <xTaskResumeAll+0xf4>)
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
					{
						vTaskIncrementTick();
   85078:	47a8      	blx	r5
						--uxMissedTicks;
   8507a:	6823      	ldr	r3, [r4, #0]
   8507c:	3b01      	subs	r3, #1
   8507e:	6023      	str	r3, [r4, #0]
				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
   85080:	6823      	ldr	r3, [r4, #0]
   85082:	2b00      	cmp	r3, #0
   85084:	d1f8      	bne.n	85078 <xTaskResumeAll+0x90>
   85086:	e005      	b.n	85094 <xTaskResumeAll+0xac>
						xYieldRequired = pdTRUE;
					}
					#endif
				}

				if( ( xYieldRequired == pdTRUE ) || ( xMissedYield == pdTRUE ) )
   85088:	2f01      	cmp	r7, #1
   8508a:	d003      	beq.n	85094 <xTaskResumeAll+0xac>
   8508c:	4b15      	ldr	r3, [pc, #84]	; (850e4 <xTaskResumeAll+0xfc>)
   8508e:	681b      	ldr	r3, [r3, #0]
   85090:	2b01      	cmp	r3, #1
   85092:	d10a      	bne.n	850aa <xTaskResumeAll+0xc2>
				{
					xAlreadyYielded = pdTRUE;
					xMissedYield = pdFALSE;
   85094:	2200      	movs	r2, #0
   85096:	4b13      	ldr	r3, [pc, #76]	; (850e4 <xTaskResumeAll+0xfc>)
   85098:	601a      	str	r2, [r3, #0]
					portYIELD_WITHIN_API();
   8509a:	4b13      	ldr	r3, [pc, #76]	; (850e8 <xTaskResumeAll+0x100>)
   8509c:	4798      	blx	r3
					#endif
				}

				if( ( xYieldRequired == pdTRUE ) || ( xMissedYield == pdTRUE ) )
				{
					xAlreadyYielded = pdTRUE;
   8509e:	2401      	movs	r4, #1
   850a0:	e004      	b.n	850ac <xTaskResumeAll+0xc4>
/*----------------------------------------------------------*/

signed portBASE_TYPE xTaskResumeAll( void )
{
register tskTCB *pxTCB;
signed portBASE_TYPE xAlreadyYielded = pdFALSE;
   850a2:	2400      	movs	r4, #0
   850a4:	e002      	b.n	850ac <xTaskResumeAll+0xc4>
   850a6:	2400      	movs	r4, #0
   850a8:	e000      	b.n	850ac <xTaskResumeAll+0xc4>
   850aa:	2400      	movs	r4, #0
					portYIELD_WITHIN_API();
				}
			}
		}
	}
	taskEXIT_CRITICAL();
   850ac:	4b0f      	ldr	r3, [pc, #60]	; (850ec <xTaskResumeAll+0x104>)
   850ae:	4798      	blx	r3

	return xAlreadyYielded;
}
   850b0:	4620      	mov	r0, r4
   850b2:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
   850b6:	bf00      	nop
   850b8:	20075b74 	.word	0x20075b74
   850bc:	0008c650 	.word	0x0008c650
   850c0:	00085f89 	.word	0x00085f89
   850c4:	00084139 	.word	0x00084139
   850c8:	20075ab0 	.word	0x20075ab0
   850cc:	20075ab4 	.word	0x20075ab4
   850d0:	20075a30 	.word	0x20075a30
   850d4:	00084049 	.word	0x00084049
   850d8:	20075ad8 	.word	0x20075ad8
   850dc:	20075b78 	.word	0x20075b78
   850e0:	00084ec1 	.word	0x00084ec1
   850e4:	20075ad0 	.word	0x20075ad0
   850e8:	00084119 	.word	0x00084119
   850ec:	00084159 	.word	0x00084159
   850f0:	000840a1 	.word	0x000840a1
   850f4:	20075a24 	.word	0x20075a24

000850f8 <vTaskDelay>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelay == 1 )

	void vTaskDelay( portTickType xTicksToDelay )
	{
   850f8:	b510      	push	{r4, lr}
	portTickType xTimeToWake;
	signed portBASE_TYPE xAlreadyYielded = pdFALSE;

		/* A delay time of zero just forces a reschedule. */
		if( xTicksToDelay > ( portTickType ) 0U )
   850fa:	4604      	mov	r4, r0
   850fc:	b1d8      	cbz	r0, 85136 <vTaskDelay+0x3e>
		{
			vTaskSuspendAll();
   850fe:	4b0f      	ldr	r3, [pc, #60]	; (8513c <vTaskDelay+0x44>)
   85100:	4798      	blx	r3
				This task cannot be in an event list as it is the currently
				executing task. */

				/* Calculate the time to wake - this may overflow but this is
				not a problem. */
				xTimeToWake = xTickCount + xTicksToDelay;
   85102:	4b0f      	ldr	r3, [pc, #60]	; (85140 <vTaskDelay+0x48>)
   85104:	681b      	ldr	r3, [r3, #0]
   85106:	441c      	add	r4, r3

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				if( uxListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) ) == 0 )
   85108:	4b0e      	ldr	r3, [pc, #56]	; (85144 <vTaskDelay+0x4c>)
   8510a:	6818      	ldr	r0, [r3, #0]
   8510c:	3004      	adds	r0, #4
   8510e:	4b0e      	ldr	r3, [pc, #56]	; (85148 <vTaskDelay+0x50>)
   85110:	4798      	blx	r3
   85112:	b950      	cbnz	r0, 8512a <vTaskDelay+0x32>
				{
					/* The current task must be in a ready list, so there is
					no need to check, and the port reset macro can be called
					directly. */
					portRESET_READY_PRIORITY( pxCurrentTCB->uxPriority, uxTopReadyPriority );
   85114:	4b0b      	ldr	r3, [pc, #44]	; (85144 <vTaskDelay+0x4c>)
   85116:	681a      	ldr	r2, [r3, #0]
   85118:	4b0c      	ldr	r3, [pc, #48]	; (8514c <vTaskDelay+0x54>)
   8511a:	6819      	ldr	r1, [r3, #0]
   8511c:	6ad2      	ldr	r2, [r2, #44]	; 0x2c
   8511e:	2001      	movs	r0, #1
   85120:	fa00 f202 	lsl.w	r2, r0, r2
   85124:	ea21 0202 	bic.w	r2, r1, r2
   85128:	601a      	str	r2, [r3, #0]
				}
				prvAddCurrentTaskToDelayedList( xTimeToWake );
   8512a:	4620      	mov	r0, r4
   8512c:	4b08      	ldr	r3, [pc, #32]	; (85150 <vTaskDelay+0x58>)
   8512e:	4798      	blx	r3
			}
			xAlreadyYielded = xTaskResumeAll();
   85130:	4b08      	ldr	r3, [pc, #32]	; (85154 <vTaskDelay+0x5c>)
   85132:	4798      	blx	r3
		}

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
   85134:	b908      	cbnz	r0, 8513a <vTaskDelay+0x42>
		{
			portYIELD_WITHIN_API();
   85136:	4b08      	ldr	r3, [pc, #32]	; (85158 <vTaskDelay+0x60>)
   85138:	4798      	blx	r3
   8513a:	bd10      	pop	{r4, pc}
   8513c:	00084e71 	.word	0x00084e71
   85140:	20075a2c 	.word	0x20075a2c
   85144:	20075ad8 	.word	0x20075ad8
   85148:	000840a1 	.word	0x000840a1
   8514c:	20075a24 	.word	0x20075a24
   85150:	0008499d 	.word	0x0008499d
   85154:	00084fe9 	.word	0x00084fe9
   85158:	00084119 	.word	0x00084119

0008515c <prvIdleTask>:
 *
 * void prvIdleTask( void *pvParameters );
 *
 */
static portTASK_FUNCTION( prvIdleTask, pvParameters )
{
   8515c:	b580      	push	{r7, lr}
	{
		portBASE_TYPE xListIsEmpty;

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		while( uxTasksDeleted > ( unsigned portBASE_TYPE ) 0U )
   8515e:	4d15      	ldr	r5, [pc, #84]	; (851b4 <prvIdleTask+0x58>)

			A critical region is not required here as we are just reading from
			the list, and an occasional incorrect value will not matter.  If
			the ready list at the idle priority contains more than one task
			then a task other than the idle task is ready to execute. */
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( unsigned portBASE_TYPE ) 1 )
   85160:	4e15      	ldr	r6, [pc, #84]	; (851b8 <prvIdleTask+0x5c>)
			{
				taskYIELD();
   85162:	f8df 8078 	ldr.w	r8, [pc, #120]	; 851dc <prvIdleTask+0x80>
   85166:	e01c      	b.n	851a2 <prvIdleTask+0x46>

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		while( uxTasksDeleted > ( unsigned portBASE_TYPE ) 0U )
		{
			vTaskSuspendAll();
   85168:	4b14      	ldr	r3, [pc, #80]	; (851bc <prvIdleTask+0x60>)
   8516a:	4798      	blx	r3
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
   8516c:	4b14      	ldr	r3, [pc, #80]	; (851c0 <prvIdleTask+0x64>)
   8516e:	681c      	ldr	r4, [r3, #0]
			xTaskResumeAll();
   85170:	4b14      	ldr	r3, [pc, #80]	; (851c4 <prvIdleTask+0x68>)
   85172:	4798      	blx	r3

			if( xListIsEmpty == pdFALSE )
   85174:	b1ac      	cbz	r4, 851a2 <prvIdleTask+0x46>
			{
				tskTCB *pxTCB;

				taskENTER_CRITICAL();
   85176:	4b14      	ldr	r3, [pc, #80]	; (851c8 <prvIdleTask+0x6c>)
   85178:	4798      	blx	r3
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( ( ( xList * ) &xTasksWaitingTermination ) );
   8517a:	4b11      	ldr	r3, [pc, #68]	; (851c0 <prvIdleTask+0x64>)
   8517c:	68db      	ldr	r3, [r3, #12]
   8517e:	68dc      	ldr	r4, [r3, #12]
					uxListRemove( &( pxTCB->xGenericListItem ) );
   85180:	1d20      	adds	r0, r4, #4
   85182:	4b12      	ldr	r3, [pc, #72]	; (851cc <prvIdleTask+0x70>)
   85184:	4798      	blx	r3
					--uxCurrentNumberOfTasks;
   85186:	4b12      	ldr	r3, [pc, #72]	; (851d0 <prvIdleTask+0x74>)
   85188:	681a      	ldr	r2, [r3, #0]
   8518a:	3a01      	subs	r2, #1
   8518c:	601a      	str	r2, [r3, #0]
					--uxTasksDeleted;
   8518e:	682b      	ldr	r3, [r5, #0]
   85190:	3b01      	subs	r3, #1
   85192:	602b      	str	r3, [r5, #0]
				}
				taskEXIT_CRITICAL();
   85194:	4b0f      	ldr	r3, [pc, #60]	; (851d4 <prvIdleTask+0x78>)
   85196:	4798      	blx	r3
		want to allocate and clean RAM statically. */
		portCLEAN_UP_TCB( pxTCB );

		/* Free up the memory allocated by the scheduler for the task.  It is up to
		the task to free any memory allocated at the application level. */
		vPortFreeAligned( pxTCB->pxStack );
   85198:	6b20      	ldr	r0, [r4, #48]	; 0x30
   8519a:	4f0f      	ldr	r7, [pc, #60]	; (851d8 <prvIdleTask+0x7c>)
   8519c:	47b8      	blx	r7
		vPortFree( pxTCB );
   8519e:	4620      	mov	r0, r4
   851a0:	47b8      	blx	r7
	{
		portBASE_TYPE xListIsEmpty;

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		while( uxTasksDeleted > ( unsigned portBASE_TYPE ) 0U )
   851a2:	682b      	ldr	r3, [r5, #0]
   851a4:	2b00      	cmp	r3, #0
   851a6:	d1df      	bne.n	85168 <prvIdleTask+0xc>

			A critical region is not required here as we are just reading from
			the list, and an occasional incorrect value will not matter.  If
			the ready list at the idle priority contains more than one task
			then a task other than the idle task is ready to execute. */
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( unsigned portBASE_TYPE ) 1 )
   851a8:	6833      	ldr	r3, [r6, #0]
   851aa:	2b01      	cmp	r3, #1
   851ac:	d9f9      	bls.n	851a2 <prvIdleTask+0x46>
			{
				taskYIELD();
   851ae:	47c0      	blx	r8
   851b0:	e7f7      	b.n	851a2 <prvIdleTask+0x46>
   851b2:	bf00      	nop
   851b4:	20075a28 	.word	0x20075a28
   851b8:	20075a30 	.word	0x20075a30
   851bc:	00084e71 	.word	0x00084e71
   851c0:	20075a98 	.word	0x20075a98
   851c4:	00084fe9 	.word	0x00084fe9
   851c8:	00084139 	.word	0x00084139
   851cc:	000840a1 	.word	0x000840a1
   851d0:	20075ab0 	.word	0x20075ab0
   851d4:	00084159 	.word	0x00084159
   851d8:	00084351 	.word	0x00084351
   851dc:	00084119 	.word	0x00084119

000851e0 <vTaskList>:
/*-----------------------------------------------------------*/

#if ( configUSE_TRACE_FACILITY == 1 )

	void vTaskList( signed char *pcWriteBuffer )
	{
   851e0:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
   851e4:	4606      	mov	r6, r0
	unsigned portBASE_TYPE uxQueue;

		/* This is a VERY costly function that should be used for debug only.
		It leaves interrupts disabled for a LONG time. */

		vTaskSuspendAll();
   851e6:	4b27      	ldr	r3, [pc, #156]	; (85284 <vTaskList+0xa4>)
   851e8:	4798      	blx	r3
		{
			/* Run through all the lists that could potentially contain a TCB and
			report the task name, state and stack high water mark. */

			*pcWriteBuffer = ( signed char ) 0x00;
   851ea:	2300      	movs	r3, #0
   851ec:	7033      	strb	r3, [r6, #0]
			strcat( ( char * ) pcWriteBuffer, ( const char * ) "\r\n" );
   851ee:	4630      	mov	r0, r6
   851f0:	4b25      	ldr	r3, [pc, #148]	; (85288 <vTaskList+0xa8>)
   851f2:	4798      	blx	r3
   851f4:	1832      	adds	r2, r6, r0
   851f6:	4b25      	ldr	r3, [pc, #148]	; (8528c <vTaskList+0xac>)
   851f8:	8819      	ldrh	r1, [r3, #0]
   851fa:	789b      	ldrb	r3, [r3, #2]
   851fc:	5231      	strh	r1, [r6, r0]
   851fe:	7093      	strb	r3, [r2, #2]

			uxQueue = uxTopUsedPriority + ( unsigned portBASE_TYPE ) 1U;
   85200:	4b23      	ldr	r3, [pc, #140]	; (85290 <vTaskList+0xb0>)
   85202:	681d      	ldr	r5, [r3, #0]
   85204:	1c6c      	adds	r4, r5, #1
   85206:	eb05 0585 	add.w	r5, r5, r5, lsl #2
   8520a:	4b22      	ldr	r3, [pc, #136]	; (85294 <vTaskList+0xb4>)
   8520c:	eb03 0585 	add.w	r5, r3, r5, lsl #2

			do
			{
				uxQueue--;

				if( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxQueue ] ) ) == pdFALSE )
   85210:	461f      	mov	r7, r3
				{
					prvListTaskWithinSingleList( pcWriteBuffer, ( xList * ) &( pxReadyTasksLists[ uxQueue ] ), tskREADY_CHAR );
   85212:	f04f 0952 	mov.w	r9, #82	; 0x52
   85216:	f8df 8084 	ldr.w	r8, [pc, #132]	; 8529c <vTaskList+0xbc>

			uxQueue = uxTopUsedPriority + ( unsigned portBASE_TYPE ) 1U;

			do
			{
				uxQueue--;
   8521a:	3c01      	subs	r4, #1

				if( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxQueue ] ) ) == pdFALSE )
   8521c:	eb04 0384 	add.w	r3, r4, r4, lsl #2
   85220:	f857 3023 	ldr.w	r3, [r7, r3, lsl #2]
   85224:	b11b      	cbz	r3, 8522e <vTaskList+0x4e>
				{
					prvListTaskWithinSingleList( pcWriteBuffer, ( xList * ) &( pxReadyTasksLists[ uxQueue ] ), tskREADY_CHAR );
   85226:	4630      	mov	r0, r6
   85228:	4629      	mov	r1, r5
   8522a:	464a      	mov	r2, r9
   8522c:	47c0      	blx	r8
   8522e:	3d14      	subs	r5, #20
				}
			}while( uxQueue > ( unsigned short ) tskIDLE_PRIORITY );
   85230:	2c00      	cmp	r4, #0
   85232:	d1f2      	bne.n	8521a <vTaskList+0x3a>

			if( listLIST_IS_EMPTY( pxDelayedTaskList ) == pdFALSE )
   85234:	4b18      	ldr	r3, [pc, #96]	; (85298 <vTaskList+0xb8>)
   85236:	681b      	ldr	r3, [r3, #0]
   85238:	681b      	ldr	r3, [r3, #0]
   8523a:	b12b      	cbz	r3, 85248 <vTaskList+0x68>
			{
				prvListTaskWithinSingleList( pcWriteBuffer, ( xList * ) pxDelayedTaskList, tskBLOCKED_CHAR );
   8523c:	4b16      	ldr	r3, [pc, #88]	; (85298 <vTaskList+0xb8>)
   8523e:	6819      	ldr	r1, [r3, #0]
   85240:	4630      	mov	r0, r6
   85242:	2242      	movs	r2, #66	; 0x42
   85244:	4b15      	ldr	r3, [pc, #84]	; (8529c <vTaskList+0xbc>)
   85246:	4798      	blx	r3
			}

			if( listLIST_IS_EMPTY( pxOverflowDelayedTaskList ) == pdFALSE )
   85248:	4b15      	ldr	r3, [pc, #84]	; (852a0 <vTaskList+0xc0>)
   8524a:	681b      	ldr	r3, [r3, #0]
   8524c:	681b      	ldr	r3, [r3, #0]
   8524e:	b12b      	cbz	r3, 8525c <vTaskList+0x7c>
			{
				prvListTaskWithinSingleList( pcWriteBuffer, ( xList * ) pxOverflowDelayedTaskList, tskBLOCKED_CHAR );
   85250:	4b13      	ldr	r3, [pc, #76]	; (852a0 <vTaskList+0xc0>)
   85252:	6819      	ldr	r1, [r3, #0]
   85254:	4630      	mov	r0, r6
   85256:	2242      	movs	r2, #66	; 0x42
   85258:	4b10      	ldr	r3, [pc, #64]	; (8529c <vTaskList+0xbc>)
   8525a:	4798      	blx	r3
			}

			#if( INCLUDE_vTaskDelete == 1 )
			{
				if( listLIST_IS_EMPTY( &xTasksWaitingTermination ) == pdFALSE )
   8525c:	4b11      	ldr	r3, [pc, #68]	; (852a4 <vTaskList+0xc4>)
   8525e:	681b      	ldr	r3, [r3, #0]
   85260:	b123      	cbz	r3, 8526c <vTaskList+0x8c>
				{
					prvListTaskWithinSingleList( pcWriteBuffer, &xTasksWaitingTermination, tskDELETED_CHAR );
   85262:	4630      	mov	r0, r6
   85264:	490f      	ldr	r1, [pc, #60]	; (852a4 <vTaskList+0xc4>)
   85266:	2244      	movs	r2, #68	; 0x44
   85268:	4b0c      	ldr	r3, [pc, #48]	; (8529c <vTaskList+0xbc>)
   8526a:	4798      	blx	r3
			}
			#endif

			#if ( INCLUDE_vTaskSuspend == 1 )
			{
				if( listLIST_IS_EMPTY( &xSuspendedTaskList ) == pdFALSE )
   8526c:	4b0e      	ldr	r3, [pc, #56]	; (852a8 <vTaskList+0xc8>)
   8526e:	681b      	ldr	r3, [r3, #0]
   85270:	b123      	cbz	r3, 8527c <vTaskList+0x9c>
				{
					prvListTaskWithinSingleList( pcWriteBuffer, &xSuspendedTaskList, tskSUSPENDED_CHAR );
   85272:	4630      	mov	r0, r6
   85274:	490c      	ldr	r1, [pc, #48]	; (852a8 <vTaskList+0xc8>)
   85276:	2253      	movs	r2, #83	; 0x53
   85278:	4b08      	ldr	r3, [pc, #32]	; (8529c <vTaskList+0xbc>)
   8527a:	4798      	blx	r3
				}
			}
			#endif
		}
		xTaskResumeAll();
   8527c:	4b0b      	ldr	r3, [pc, #44]	; (852ac <vTaskList+0xcc>)
   8527e:	4798      	blx	r3
   85280:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
   85284:	00084e71 	.word	0x00084e71
   85288:	000867e5 	.word	0x000867e5
   8528c:	0008c998 	.word	0x0008c998
   85290:	20075b80 	.word	0x20075b80
   85294:	20075a30 	.word	0x20075a30
   85298:	20075aac 	.word	0x20075aac
   8529c:	000849f5 	.word	0x000849f5
   852a0:	20075a94 	.word	0x20075a94
   852a4:	20075a98 	.word	0x20075a98
   852a8:	20075b38 	.word	0x20075b38
   852ac:	00084fe9 	.word	0x00084fe9

000852b0 <vTaskGetRunTimeStats>:
/*----------------------------------------------------------*/

#if ( configGENERATE_RUN_TIME_STATS == 1 )

	void vTaskGetRunTimeStats( signed char *pcWriteBuffer )
	{
   852b0:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
   852b4:	4606      	mov	r6, r0
	unsigned long ulTotalRunTime;

		/* This is a VERY costly function that should be used for debug only.
		It leaves interrupts disabled for a LONG time. */

		vTaskSuspendAll();
   852b6:	4b2a      	ldr	r3, [pc, #168]	; (85360 <vTaskGetRunTimeStats+0xb0>)
   852b8:	4798      	blx	r3
		{
			#ifdef portALT_GET_RUN_TIME_COUNTER_VALUE
				portALT_GET_RUN_TIME_COUNTER_VALUE( ulTotalRunTime );
			#else
				ulTotalRunTime = portGET_RUN_TIME_COUNTER_VALUE();
   852ba:	4b2a      	ldr	r3, [pc, #168]	; (85364 <vTaskGetRunTimeStats+0xb4>)
   852bc:	4798      	blx	r3
			#endif

			/* Divide ulTotalRunTime by 100 to make the percentage caluclations
			simpler in the prvGenerateRunTimeStatsForTasksInList() function. */
			ulTotalRunTime /= 100UL;
   852be:	4b2a      	ldr	r3, [pc, #168]	; (85368 <vTaskGetRunTimeStats+0xb8>)
   852c0:	fba3 2800 	umull	r2, r8, r3, r0
   852c4:	ea4f 1858 	mov.w	r8, r8, lsr #5

			/* Run through all the lists that could potentially contain a TCB,
			generating a table of run timer percentages in the provided
			buffer. */

			*pcWriteBuffer = ( signed char ) 0x00;
   852c8:	2300      	movs	r3, #0
   852ca:	7033      	strb	r3, [r6, #0]
			strcat( ( char * ) pcWriteBuffer, ( const char * ) "\r\n" );
   852cc:	4630      	mov	r0, r6
   852ce:	4b27      	ldr	r3, [pc, #156]	; (8536c <vTaskGetRunTimeStats+0xbc>)
   852d0:	4798      	blx	r3
   852d2:	1832      	adds	r2, r6, r0
   852d4:	4b26      	ldr	r3, [pc, #152]	; (85370 <vTaskGetRunTimeStats+0xc0>)
   852d6:	8819      	ldrh	r1, [r3, #0]
   852d8:	789b      	ldrb	r3, [r3, #2]
   852da:	5231      	strh	r1, [r6, r0]
   852dc:	7093      	strb	r3, [r2, #2]

			uxQueue = uxTopUsedPriority + ( unsigned portBASE_TYPE ) 1U;
   852de:	4b25      	ldr	r3, [pc, #148]	; (85374 <vTaskGetRunTimeStats+0xc4>)
   852e0:	681d      	ldr	r5, [r3, #0]
   852e2:	1c6c      	adds	r4, r5, #1
   852e4:	eb05 0585 	add.w	r5, r5, r5, lsl #2
   852e8:	4b23      	ldr	r3, [pc, #140]	; (85378 <vTaskGetRunTimeStats+0xc8>)
   852ea:	eb03 0585 	add.w	r5, r3, r5, lsl #2

			do
			{
				uxQueue--;

				if( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxQueue ] ) ) == pdFALSE )
   852ee:	461f      	mov	r7, r3
				{
					prvGenerateRunTimeStatsForTasksInList( pcWriteBuffer, ( xList * ) &( pxReadyTasksLists[ uxQueue ] ), ulTotalRunTime );
   852f0:	f8df 908c 	ldr.w	r9, [pc, #140]	; 85380 <vTaskGetRunTimeStats+0xd0>

			uxQueue = uxTopUsedPriority + ( unsigned portBASE_TYPE ) 1U;

			do
			{
				uxQueue--;
   852f4:	3c01      	subs	r4, #1

				if( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxQueue ] ) ) == pdFALSE )
   852f6:	eb04 0384 	add.w	r3, r4, r4, lsl #2
   852fa:	f857 3023 	ldr.w	r3, [r7, r3, lsl #2]
   852fe:	b11b      	cbz	r3, 85308 <vTaskGetRunTimeStats+0x58>
				{
					prvGenerateRunTimeStatsForTasksInList( pcWriteBuffer, ( xList * ) &( pxReadyTasksLists[ uxQueue ] ), ulTotalRunTime );
   85300:	4630      	mov	r0, r6
   85302:	4629      	mov	r1, r5
   85304:	4642      	mov	r2, r8
   85306:	47c8      	blx	r9
   85308:	3d14      	subs	r5, #20
				}
			}while( uxQueue > ( unsigned short ) tskIDLE_PRIORITY );
   8530a:	2c00      	cmp	r4, #0
   8530c:	d1f2      	bne.n	852f4 <vTaskGetRunTimeStats+0x44>

			if( listLIST_IS_EMPTY( pxDelayedTaskList ) == pdFALSE )
   8530e:	4b1b      	ldr	r3, [pc, #108]	; (8537c <vTaskGetRunTimeStats+0xcc>)
   85310:	681b      	ldr	r3, [r3, #0]
   85312:	681b      	ldr	r3, [r3, #0]
   85314:	b12b      	cbz	r3, 85322 <vTaskGetRunTimeStats+0x72>
			{
				prvGenerateRunTimeStatsForTasksInList( pcWriteBuffer, ( xList * ) pxDelayedTaskList, ulTotalRunTime );
   85316:	4b19      	ldr	r3, [pc, #100]	; (8537c <vTaskGetRunTimeStats+0xcc>)
   85318:	6819      	ldr	r1, [r3, #0]
   8531a:	4630      	mov	r0, r6
   8531c:	4642      	mov	r2, r8
   8531e:	4b18      	ldr	r3, [pc, #96]	; (85380 <vTaskGetRunTimeStats+0xd0>)
   85320:	4798      	blx	r3
			}

			if( listLIST_IS_EMPTY( pxOverflowDelayedTaskList ) == pdFALSE )
   85322:	4b18      	ldr	r3, [pc, #96]	; (85384 <vTaskGetRunTimeStats+0xd4>)
   85324:	681b      	ldr	r3, [r3, #0]
   85326:	681b      	ldr	r3, [r3, #0]
   85328:	b12b      	cbz	r3, 85336 <vTaskGetRunTimeStats+0x86>
			{
				prvGenerateRunTimeStatsForTasksInList( pcWriteBuffer, ( xList * ) pxOverflowDelayedTaskList, ulTotalRunTime );
   8532a:	4b16      	ldr	r3, [pc, #88]	; (85384 <vTaskGetRunTimeStats+0xd4>)
   8532c:	6819      	ldr	r1, [r3, #0]
   8532e:	4630      	mov	r0, r6
   85330:	4642      	mov	r2, r8
   85332:	4b13      	ldr	r3, [pc, #76]	; (85380 <vTaskGetRunTimeStats+0xd0>)
   85334:	4798      	blx	r3
			}

			#if ( INCLUDE_vTaskDelete == 1 )
			{
				if( listLIST_IS_EMPTY( &xTasksWaitingTermination ) == pdFALSE )
   85336:	4b14      	ldr	r3, [pc, #80]	; (85388 <vTaskGetRunTimeStats+0xd8>)
   85338:	681b      	ldr	r3, [r3, #0]
   8533a:	b123      	cbz	r3, 85346 <vTaskGetRunTimeStats+0x96>
				{
					prvGenerateRunTimeStatsForTasksInList( pcWriteBuffer, &xTasksWaitingTermination, ulTotalRunTime );
   8533c:	4630      	mov	r0, r6
   8533e:	4912      	ldr	r1, [pc, #72]	; (85388 <vTaskGetRunTimeStats+0xd8>)
   85340:	4642      	mov	r2, r8
   85342:	4b0f      	ldr	r3, [pc, #60]	; (85380 <vTaskGetRunTimeStats+0xd0>)
   85344:	4798      	blx	r3
			}
			#endif

			#if ( INCLUDE_vTaskSuspend == 1 )
			{
				if( listLIST_IS_EMPTY( &xSuspendedTaskList ) == pdFALSE )
   85346:	4b11      	ldr	r3, [pc, #68]	; (8538c <vTaskGetRunTimeStats+0xdc>)
   85348:	681b      	ldr	r3, [r3, #0]
   8534a:	b123      	cbz	r3, 85356 <vTaskGetRunTimeStats+0xa6>
				{
					prvGenerateRunTimeStatsForTasksInList( pcWriteBuffer, &xSuspendedTaskList, ulTotalRunTime );
   8534c:	4630      	mov	r0, r6
   8534e:	490f      	ldr	r1, [pc, #60]	; (8538c <vTaskGetRunTimeStats+0xdc>)
   85350:	4642      	mov	r2, r8
   85352:	4b0b      	ldr	r3, [pc, #44]	; (85380 <vTaskGetRunTimeStats+0xd0>)
   85354:	4798      	blx	r3
				}
			}
			#endif
		}
		xTaskResumeAll();
   85356:	4b0e      	ldr	r3, [pc, #56]	; (85390 <vTaskGetRunTimeStats+0xe0>)
   85358:	4798      	blx	r3
   8535a:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
   8535e:	bf00      	nop
   85360:	00084e71 	.word	0x00084e71
   85364:	000861c1 	.word	0x000861c1
   85368:	51eb851f 	.word	0x51eb851f
   8536c:	000867e5 	.word	0x000867e5
   85370:	0008c998 	.word	0x0008c998
   85374:	20075b80 	.word	0x20075b80
   85378:	20075a30 	.word	0x20075a30
   8537c:	20075aac 	.word	0x20075aac
   85380:	00084a89 	.word	0x00084a89
   85384:	20075a94 	.word	0x20075a94
   85388:	20075a98 	.word	0x20075a98
   8538c:	20075b38 	.word	0x20075b38
   85390:	00084fe9 	.word	0x00084fe9

00085394 <vTaskSwitchContext>:

#endif
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
   85394:	b538      	push	{r3, r4, r5, lr}
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
   85396:	4b28      	ldr	r3, [pc, #160]	; (85438 <vTaskSwitchContext+0xa4>)
   85398:	681b      	ldr	r3, [r3, #0]
   8539a:	b11b      	cbz	r3, 853a4 <vTaskSwitchContext+0x10>
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xMissedYield = pdTRUE;
   8539c:	2201      	movs	r2, #1
   8539e:	4b27      	ldr	r3, [pc, #156]	; (8543c <vTaskSwitchContext+0xa8>)
   853a0:	601a      	str	r2, [r3, #0]
   853a2:	bd38      	pop	{r3, r4, r5, pc}
			unsigned long ulTempCounter;

				#ifdef portALT_GET_RUN_TIME_COUNTER_VALUE
					portALT_GET_RUN_TIME_COUNTER_VALUE( ulTempCounter );
				#else
					ulTempCounter = portGET_RUN_TIME_COUNTER_VALUE();
   853a4:	4b26      	ldr	r3, [pc, #152]	; (85440 <vTaskSwitchContext+0xac>)
   853a6:	4798      	blx	r3
				/* Add the amount of time the task has been running to the accumulated
				time so far.  The time the task started running was stored in
				ulTaskSwitchedInTime.  Note that there is no overflow protection here
				so count values are only valid until the timer overflows.  Generally
				this will be about 1 hour assuming a 1uS timer increment. */
				pxCurrentTCB->ulRunTimeCounter += ( ulTempCounter - ulTaskSwitchedInTime );
   853a8:	4b26      	ldr	r3, [pc, #152]	; (85444 <vTaskSwitchContext+0xb0>)
   853aa:	6819      	ldr	r1, [r3, #0]
   853ac:	4a26      	ldr	r2, [pc, #152]	; (85448 <vTaskSwitchContext+0xb4>)
   853ae:	6ccd      	ldr	r5, [r1, #76]	; 0x4c
   853b0:	6814      	ldr	r4, [r2, #0]
   853b2:	1b2c      	subs	r4, r5, r4
   853b4:	4404      	add	r4, r0
   853b6:	64cc      	str	r4, [r1, #76]	; 0x4c
				ulTaskSwitchedInTime = ulTempCounter;
   853b8:	6010      	str	r0, [r2, #0]
		}
		#endif

		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
   853ba:	681a      	ldr	r2, [r3, #0]
   853bc:	681b      	ldr	r3, [r3, #0]
   853be:	6812      	ldr	r2, [r2, #0]
   853c0:	6b1b      	ldr	r3, [r3, #48]	; 0x30
   853c2:	429a      	cmp	r2, r3
   853c4:	d805      	bhi.n	853d2 <vTaskSwitchContext+0x3e>
   853c6:	4b1f      	ldr	r3, [pc, #124]	; (85444 <vTaskSwitchContext+0xb0>)
   853c8:	6818      	ldr	r0, [r3, #0]
   853ca:	6819      	ldr	r1, [r3, #0]
   853cc:	3134      	adds	r1, #52	; 0x34
   853ce:	4b1f      	ldr	r3, [pc, #124]	; (8544c <vTaskSwitchContext+0xb8>)
   853d0:	4798      	blx	r3
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();
   853d2:	4b1c      	ldr	r3, [pc, #112]	; (85444 <vTaskSwitchContext+0xb0>)
   853d4:	681b      	ldr	r3, [r3, #0]
   853d6:	6b18      	ldr	r0, [r3, #48]	; 0x30
   853d8:	491d      	ldr	r1, [pc, #116]	; (85450 <vTaskSwitchContext+0xbc>)
   853da:	2214      	movs	r2, #20
   853dc:	4b1d      	ldr	r3, [pc, #116]	; (85454 <vTaskSwitchContext+0xc0>)
   853de:	4798      	blx	r3
   853e0:	b128      	cbz	r0, 853ee <vTaskSwitchContext+0x5a>
   853e2:	4b18      	ldr	r3, [pc, #96]	; (85444 <vTaskSwitchContext+0xb0>)
   853e4:	6818      	ldr	r0, [r3, #0]
   853e6:	6819      	ldr	r1, [r3, #0]
   853e8:	3134      	adds	r1, #52	; 0x34
   853ea:	4b18      	ldr	r3, [pc, #96]	; (8544c <vTaskSwitchContext+0xb8>)
   853ec:	4798      	blx	r3

		taskSELECT_HIGHEST_PRIORITY_TASK();
   853ee:	4b1a      	ldr	r3, [pc, #104]	; (85458 <vTaskSwitchContext+0xc4>)
   853f0:	681c      	ldr	r4, [r3, #0]
	/* Generic helper function. */
	__attribute__( ( always_inline ) ) static inline unsigned char ucPortCountLeadingZeros( unsigned long ulBitmap )
	{
	unsigned char ucReturn;

		__asm volatile ( "clz %0, %1" : "=r" ( ucReturn ) : "r" ( ulBitmap ) );
   853f2:	fab4 f484 	clz	r4, r4
   853f6:	b2e4      	uxtb	r4, r4
   853f8:	f1c4 041f 	rsb	r4, r4, #31
   853fc:	eb04 0384 	add.w	r3, r4, r4, lsl #2
   85400:	009b      	lsls	r3, r3, #2
   85402:	4a16      	ldr	r2, [pc, #88]	; (8545c <vTaskSwitchContext+0xc8>)
   85404:	58d3      	ldr	r3, [r2, r3]
   85406:	b923      	cbnz	r3, 85412 <vTaskSwitchContext+0x7e>
   85408:	4815      	ldr	r0, [pc, #84]	; (85460 <vTaskSwitchContext+0xcc>)
   8540a:	f240 713e 	movw	r1, #1854	; 0x73e
   8540e:	4b15      	ldr	r3, [pc, #84]	; (85464 <vTaskSwitchContext+0xd0>)
   85410:	4798      	blx	r3
   85412:	eb04 0484 	add.w	r4, r4, r4, lsl #2
   85416:	4a11      	ldr	r2, [pc, #68]	; (8545c <vTaskSwitchContext+0xc8>)
   85418:	eb02 0384 	add.w	r3, r2, r4, lsl #2
   8541c:	685a      	ldr	r2, [r3, #4]
   8541e:	6852      	ldr	r2, [r2, #4]
   85420:	605a      	str	r2, [r3, #4]
   85422:	f103 0108 	add.w	r1, r3, #8
   85426:	428a      	cmp	r2, r1
   85428:	bf04      	itt	eq
   8542a:	6852      	ldreq	r2, [r2, #4]
   8542c:	605a      	streq	r2, [r3, #4]
   8542e:	685b      	ldr	r3, [r3, #4]
   85430:	68da      	ldr	r2, [r3, #12]
   85432:	4b04      	ldr	r3, [pc, #16]	; (85444 <vTaskSwitchContext+0xb0>)
   85434:	601a      	str	r2, [r3, #0]
   85436:	bd38      	pop	{r3, r4, r5, pc}
   85438:	20075b74 	.word	0x20075b74
   8543c:	20075ad0 	.word	0x20075ad0
   85440:	000861c1 	.word	0x000861c1
   85444:	20075ad8 	.word	0x20075ad8
   85448:	20075acc 	.word	0x20075acc
   8544c:	00085f7d 	.word	0x00085f7d
   85450:	0008c698 	.word	0x0008c698
   85454:	0008626d 	.word	0x0008626d
   85458:	20075a24 	.word	0x20075a24
   8545c:	20075a30 	.word	0x20075a30
   85460:	0008c650 	.word	0x0008c650
   85464:	00085f89 	.word	0x00085f89

00085468 <vTaskPlaceOnEventList>:
	}
}
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( const xList * const pxEventList, portTickType xTicksToWait )
{
   85468:	b570      	push	{r4, r5, r6, lr}
   8546a:	460d      	mov	r5, r1
portTickType xTimeToWake;

	configASSERT( pxEventList );
   8546c:	4606      	mov	r6, r0
   8546e:	b920      	cbnz	r0, 8547a <vTaskPlaceOnEventList+0x12>
   85470:	4814      	ldr	r0, [pc, #80]	; (854c4 <vTaskPlaceOnEventList+0x5c>)
   85472:	f240 7149 	movw	r1, #1865	; 0x749
   85476:	4b14      	ldr	r3, [pc, #80]	; (854c8 <vTaskPlaceOnEventList+0x60>)
   85478:	4798      	blx	r3
	SCHEDULER SUSPENDED. */

	/* Place the event list item of the TCB in the appropriate event list.
	This is placed in the list in priority order so the highest priority task
	is the first to be woken by the event. */
	vListInsert( ( xList * ) pxEventList, ( xListItem * ) &( pxCurrentTCB->xEventListItem ) );
   8547a:	4c14      	ldr	r4, [pc, #80]	; (854cc <vTaskPlaceOnEventList+0x64>)
   8547c:	6821      	ldr	r1, [r4, #0]
   8547e:	4630      	mov	r0, r6
   85480:	3118      	adds	r1, #24
   85482:	4b13      	ldr	r3, [pc, #76]	; (854d0 <vTaskPlaceOnEventList+0x68>)
   85484:	4798      	blx	r3

	/* We must remove ourselves from the ready list before adding ourselves
	to the blocked list as the same list item is used for both lists.  We have
	exclusive access to the ready lists as the scheduler is locked. */
	if( uxListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) ) == 0 )
   85486:	6820      	ldr	r0, [r4, #0]
   85488:	3004      	adds	r0, #4
   8548a:	4b12      	ldr	r3, [pc, #72]	; (854d4 <vTaskPlaceOnEventList+0x6c>)
   8548c:	4798      	blx	r3
   8548e:	b948      	cbnz	r0, 854a4 <vTaskPlaceOnEventList+0x3c>
	{
		/* The current task must be in a ready list, so there is no need to
		check, and the port reset macro can be called directly. */
		portRESET_READY_PRIORITY( pxCurrentTCB->uxPriority, uxTopReadyPriority );
   85490:	6822      	ldr	r2, [r4, #0]
   85492:	4b11      	ldr	r3, [pc, #68]	; (854d8 <vTaskPlaceOnEventList+0x70>)
   85494:	6819      	ldr	r1, [r3, #0]
   85496:	6ad2      	ldr	r2, [r2, #44]	; 0x2c
   85498:	2001      	movs	r0, #1
   8549a:	fa00 f202 	lsl.w	r2, r0, r2
   8549e:	ea21 0202 	bic.w	r2, r1, r2
   854a2:	601a      	str	r2, [r3, #0]
	}

	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		if( xTicksToWait == portMAX_DELAY )
   854a4:	f1b5 3fff 	cmp.w	r5, #4294967295
   854a8:	d106      	bne.n	854b8 <vTaskPlaceOnEventList+0x50>
		{
			/* Add ourselves to the suspended task list instead of a delayed task
			list to ensure we are not woken by a timing event.  We will block
			indefinitely. */
			vListInsertEnd( ( xList * ) &xSuspendedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
   854aa:	4b08      	ldr	r3, [pc, #32]	; (854cc <vTaskPlaceOnEventList+0x64>)
   854ac:	6819      	ldr	r1, [r3, #0]
   854ae:	480b      	ldr	r0, [pc, #44]	; (854dc <vTaskPlaceOnEventList+0x74>)
   854b0:	3104      	adds	r1, #4
   854b2:	4b0b      	ldr	r3, [pc, #44]	; (854e0 <vTaskPlaceOnEventList+0x78>)
   854b4:	4798      	blx	r3
   854b6:	bd70      	pop	{r4, r5, r6, pc}
		}
		else
		{
			/* Calculate the time at which the task should be woken if the event does
			not occur.  This may overflow but this doesn't matter. */
			xTimeToWake = xTickCount + xTicksToWait;
   854b8:	4b0a      	ldr	r3, [pc, #40]	; (854e4 <vTaskPlaceOnEventList+0x7c>)
   854ba:	6818      	ldr	r0, [r3, #0]
			prvAddCurrentTaskToDelayedList( xTimeToWake );
   854bc:	4428      	add	r0, r5
   854be:	4b0a      	ldr	r3, [pc, #40]	; (854e8 <vTaskPlaceOnEventList+0x80>)
   854c0:	4798      	blx	r3
   854c2:	bd70      	pop	{r4, r5, r6, pc}
   854c4:	0008c650 	.word	0x0008c650
   854c8:	00085f89 	.word	0x00085f89
   854cc:	20075ad8 	.word	0x20075ad8
   854d0:	00084065 	.word	0x00084065
   854d4:	000840a1 	.word	0x000840a1
   854d8:	20075a24 	.word	0x20075a24
   854dc:	20075b38 	.word	0x20075b38
   854e0:	00084049 	.word	0x00084049
   854e4:	20075a2c 	.word	0x20075a2c
   854e8:	0008499d 	.word	0x0008499d

000854ec <vTaskPlaceOnEventListRestricted>:
/*-----------------------------------------------------------*/

#if configUSE_TIMERS == 1

	void vTaskPlaceOnEventListRestricted( const xList * const pxEventList, portTickType xTicksToWait )
	{
   854ec:	b570      	push	{r4, r5, r6, lr}
   854ee:	460d      	mov	r5, r1
	portTickType xTimeToWake;

		configASSERT( pxEventList );
   854f0:	4606      	mov	r6, r0
   854f2:	b920      	cbnz	r0, 854fe <vTaskPlaceOnEventListRestricted+0x12>
   854f4:	480f      	ldr	r0, [pc, #60]	; (85534 <vTaskPlaceOnEventListRestricted+0x48>)
   854f6:	f240 717f 	movw	r1, #1919	; 0x77f
   854fa:	4b0f      	ldr	r3, [pc, #60]	; (85538 <vTaskPlaceOnEventListRestricted+0x4c>)
   854fc:	4798      	blx	r3

		/* Place the event list item of the TCB in the appropriate event list.
		In this case it is assume that this is the only task that is going to
		be waiting on this event list, so the faster vListInsertEnd() function
		can be used in place of vListInsert. */
		vListInsertEnd( ( xList * ) pxEventList, ( xListItem * ) &( pxCurrentTCB->xEventListItem ) );
   854fe:	4c0f      	ldr	r4, [pc, #60]	; (8553c <vTaskPlaceOnEventListRestricted+0x50>)
   85500:	6821      	ldr	r1, [r4, #0]
   85502:	4630      	mov	r0, r6
   85504:	3118      	adds	r1, #24
   85506:	4b0e      	ldr	r3, [pc, #56]	; (85540 <vTaskPlaceOnEventListRestricted+0x54>)
   85508:	4798      	blx	r3

		/* We must remove this task from the ready list before adding it to the
		blocked list as the same list item is used for both lists.  This
		function is called form a critical section. */
		if( uxListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) ) == 0 )
   8550a:	6820      	ldr	r0, [r4, #0]
   8550c:	3004      	adds	r0, #4
   8550e:	4b0d      	ldr	r3, [pc, #52]	; (85544 <vTaskPlaceOnEventListRestricted+0x58>)
   85510:	4798      	blx	r3
   85512:	b948      	cbnz	r0, 85528 <vTaskPlaceOnEventListRestricted+0x3c>
		{
			/* The current task must be in a ready list, so there is no need to
			check, and the port reset macro can be called directly. */
			portRESET_READY_PRIORITY( pxCurrentTCB->uxPriority, uxTopReadyPriority );
   85514:	6822      	ldr	r2, [r4, #0]
   85516:	4b0c      	ldr	r3, [pc, #48]	; (85548 <vTaskPlaceOnEventListRestricted+0x5c>)
   85518:	6819      	ldr	r1, [r3, #0]
   8551a:	6ad2      	ldr	r2, [r2, #44]	; 0x2c
   8551c:	2001      	movs	r0, #1
   8551e:	fa00 f202 	lsl.w	r2, r0, r2
   85522:	ea21 0202 	bic.w	r2, r1, r2
   85526:	601a      	str	r2, [r3, #0]
		}

		/* Calculate the time at which the task should be woken if the event does
		not occur.  This may overflow but this doesn't matter. */
		xTimeToWake = xTickCount + xTicksToWait;
   85528:	4b08      	ldr	r3, [pc, #32]	; (8554c <vTaskPlaceOnEventListRestricted+0x60>)
   8552a:	6818      	ldr	r0, [r3, #0]
		
		traceTASK_DELAY_UNTIL();
		prvAddCurrentTaskToDelayedList( xTimeToWake );
   8552c:	4428      	add	r0, r5
   8552e:	4b08      	ldr	r3, [pc, #32]	; (85550 <vTaskPlaceOnEventListRestricted+0x64>)
   85530:	4798      	blx	r3
   85532:	bd70      	pop	{r4, r5, r6, pc}
   85534:	0008c650 	.word	0x0008c650
   85538:	00085f89 	.word	0x00085f89
   8553c:	20075ad8 	.word	0x20075ad8
   85540:	00084049 	.word	0x00084049
   85544:	000840a1 	.word	0x000840a1
   85548:	20075a24 	.word	0x20075a24
   8554c:	20075a2c 	.word	0x20075a2c
   85550:	0008499d 	.word	0x0008499d

00085554 <xTaskRemoveFromEventList>:

#endif /* configUSE_TIMERS */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xTaskRemoveFromEventList( const xList * const pxEventList )
{
   85554:	b538      	push	{r3, r4, r5, lr}
	get called - the lock count on the queue will get modified instead.  This
	means we can always expect exclusive access to the event list here.

	This function assumes that a check has already been made to ensure that
	pxEventList is not empty. */
	pxUnblockedTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
   85556:	68c3      	ldr	r3, [r0, #12]
   85558:	68dc      	ldr	r4, [r3, #12]
	configASSERT( pxUnblockedTCB );
   8555a:	b924      	cbnz	r4, 85566 <xTaskRemoveFromEventList+0x12>
   8555c:	4816      	ldr	r0, [pc, #88]	; (855b8 <xTaskRemoveFromEventList+0x64>)
   8555e:	f240 71b5 	movw	r1, #1973	; 0x7b5
   85562:	4b16      	ldr	r3, [pc, #88]	; (855bc <xTaskRemoveFromEventList+0x68>)
   85564:	4798      	blx	r3
	uxListRemove( &( pxUnblockedTCB->xEventListItem ) );
   85566:	f104 0518 	add.w	r5, r4, #24
   8556a:	4628      	mov	r0, r5
   8556c:	4b14      	ldr	r3, [pc, #80]	; (855c0 <xTaskRemoveFromEventList+0x6c>)
   8556e:	4798      	blx	r3

	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
   85570:	4b14      	ldr	r3, [pc, #80]	; (855c4 <xTaskRemoveFromEventList+0x70>)
   85572:	681b      	ldr	r3, [r3, #0]
   85574:	b99b      	cbnz	r3, 8559e <xTaskRemoveFromEventList+0x4a>
	{
		uxListRemove( &( pxUnblockedTCB->xGenericListItem ) );
   85576:	1d25      	adds	r5, r4, #4
   85578:	4628      	mov	r0, r5
   8557a:	4b11      	ldr	r3, [pc, #68]	; (855c0 <xTaskRemoveFromEventList+0x6c>)
   8557c:	4798      	blx	r3
		prvAddTaskToReadyQueue( pxUnblockedTCB );
   8557e:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
   85580:	4a11      	ldr	r2, [pc, #68]	; (855c8 <xTaskRemoveFromEventList+0x74>)
   85582:	6810      	ldr	r0, [r2, #0]
   85584:	2101      	movs	r1, #1
   85586:	4099      	lsls	r1, r3
   85588:	4301      	orrs	r1, r0
   8558a:	6011      	str	r1, [r2, #0]
   8558c:	eb03 0383 	add.w	r3, r3, r3, lsl #2
   85590:	480e      	ldr	r0, [pc, #56]	; (855cc <xTaskRemoveFromEventList+0x78>)
   85592:	eb00 0083 	add.w	r0, r0, r3, lsl #2
   85596:	4629      	mov	r1, r5
   85598:	4b0d      	ldr	r3, [pc, #52]	; (855d0 <xTaskRemoveFromEventList+0x7c>)
   8559a:	4798      	blx	r3
   8559c:	e003      	b.n	855a6 <xTaskRemoveFromEventList+0x52>
	}
	else
	{
		/* We cannot access the delayed or ready lists, so will hold this
		task pending until the scheduler is resumed. */
		vListInsertEnd( ( xList * ) &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
   8559e:	480d      	ldr	r0, [pc, #52]	; (855d4 <xTaskRemoveFromEventList+0x80>)
   855a0:	4629      	mov	r1, r5
   855a2:	4b0b      	ldr	r3, [pc, #44]	; (855d0 <xTaskRemoveFromEventList+0x7c>)
   855a4:	4798      	blx	r3
	}

	if( pxUnblockedTCB->uxPriority >= pxCurrentTCB->uxPriority )
   855a6:	4b0c      	ldr	r3, [pc, #48]	; (855d8 <xTaskRemoveFromEventList+0x84>)
   855a8:	681b      	ldr	r3, [r3, #0]
   855aa:	6ae0      	ldr	r0, [r4, #44]	; 0x2c
   855ac:	6adb      	ldr	r3, [r3, #44]	; 0x2c
	{
		xReturn = pdFALSE;
	}

	return xReturn;
}
   855ae:	4298      	cmp	r0, r3
   855b0:	bf34      	ite	cc
   855b2:	2000      	movcc	r0, #0
   855b4:	2001      	movcs	r0, #1
   855b6:	bd38      	pop	{r3, r4, r5, pc}
   855b8:	0008c650 	.word	0x0008c650
   855bc:	00085f89 	.word	0x00085f89
   855c0:	000840a1 	.word	0x000840a1
   855c4:	20075b74 	.word	0x20075b74
   855c8:	20075a24 	.word	0x20075a24
   855cc:	20075a30 	.word	0x20075a30
   855d0:	00084049 	.word	0x00084049
   855d4:	20075ab4 	.word	0x20075ab4
   855d8:	20075ad8 	.word	0x20075ad8

000855dc <vTaskSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( xTimeOutType * const pxTimeOut )
{
   855dc:	b510      	push	{r4, lr}
	configASSERT( pxTimeOut );
   855de:	4604      	mov	r4, r0
   855e0:	b920      	cbnz	r0, 855ec <vTaskSetTimeOutState+0x10>
   855e2:	4806      	ldr	r0, [pc, #24]	; (855fc <vTaskSetTimeOutState+0x20>)
   855e4:	f240 71d7 	movw	r1, #2007	; 0x7d7
   855e8:	4b05      	ldr	r3, [pc, #20]	; (85600 <vTaskSetTimeOutState+0x24>)
   855ea:	4798      	blx	r3
	pxTimeOut->xOverflowCount = xNumOfOverflows;
   855ec:	4b05      	ldr	r3, [pc, #20]	; (85604 <vTaskSetTimeOutState+0x28>)
   855ee:	681b      	ldr	r3, [r3, #0]
   855f0:	6023      	str	r3, [r4, #0]
	pxTimeOut->xTimeOnEntering = xTickCount;
   855f2:	4b05      	ldr	r3, [pc, #20]	; (85608 <vTaskSetTimeOutState+0x2c>)
   855f4:	681b      	ldr	r3, [r3, #0]
   855f6:	6063      	str	r3, [r4, #4]
   855f8:	bd10      	pop	{r4, pc}
   855fa:	bf00      	nop
   855fc:	0008c650 	.word	0x0008c650
   85600:	00085f89 	.word	0x00085f89
   85604:	20075b7c 	.word	0x20075b7c
   85608:	20075a2c 	.word	0x20075a2c

0008560c <xTaskCheckForTimeOut>:
}
/*-----------------------------------------------------------*/

portBASE_TYPE xTaskCheckForTimeOut( xTimeOutType * const pxTimeOut, portTickType * const pxTicksToWait )
{
   8560c:	b538      	push	{r3, r4, r5, lr}
   8560e:	460c      	mov	r4, r1
portBASE_TYPE xReturn;

	configASSERT( pxTimeOut );
   85610:	4605      	mov	r5, r0
   85612:	b920      	cbnz	r0, 8561e <xTaskCheckForTimeOut+0x12>
   85614:	4819      	ldr	r0, [pc, #100]	; (8567c <xTaskCheckForTimeOut+0x70>)
   85616:	f240 71e1 	movw	r1, #2017	; 0x7e1
   8561a:	4b19      	ldr	r3, [pc, #100]	; (85680 <xTaskCheckForTimeOut+0x74>)
   8561c:	4798      	blx	r3
	configASSERT( pxTicksToWait );
   8561e:	b924      	cbnz	r4, 8562a <xTaskCheckForTimeOut+0x1e>
   85620:	4816      	ldr	r0, [pc, #88]	; (8567c <xTaskCheckForTimeOut+0x70>)
   85622:	f240 71e2 	movw	r1, #2018	; 0x7e2
   85626:	4b16      	ldr	r3, [pc, #88]	; (85680 <xTaskCheckForTimeOut+0x74>)
   85628:	4798      	blx	r3

	taskENTER_CRITICAL();
   8562a:	4b16      	ldr	r3, [pc, #88]	; (85684 <xTaskCheckForTimeOut+0x78>)
   8562c:	4798      	blx	r3
	{
		#if ( INCLUDE_vTaskSuspend == 1 )
			/* If INCLUDE_vTaskSuspend is set to 1 and the block time specified is
			the maximum block time then the task should block indefinitely, and
			therefore never time out. */
			if( *pxTicksToWait == portMAX_DELAY )
   8562e:	6823      	ldr	r3, [r4, #0]
   85630:	f1b3 3fff 	cmp.w	r3, #4294967295
   85634:	d019      	beq.n	8566a <xTaskCheckForTimeOut+0x5e>
				xReturn = pdFALSE;
			}
			else /* We are not blocking indefinitely, perform the checks below. */
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( ( portTickType ) xTickCount >= ( portTickType ) pxTimeOut->xTimeOnEntering ) )
   85636:	4a14      	ldr	r2, [pc, #80]	; (85688 <xTaskCheckForTimeOut+0x7c>)
   85638:	6811      	ldr	r1, [r2, #0]
   8563a:	682a      	ldr	r2, [r5, #0]
   8563c:	428a      	cmp	r2, r1
   8563e:	d004      	beq.n	8564a <xTaskCheckForTimeOut+0x3e>
   85640:	4a12      	ldr	r2, [pc, #72]	; (8568c <xTaskCheckForTimeOut+0x80>)
   85642:	6811      	ldr	r1, [r2, #0]
   85644:	686a      	ldr	r2, [r5, #4]
   85646:	428a      	cmp	r2, r1
   85648:	d911      	bls.n	8566e <xTaskCheckForTimeOut+0x62>
			was called, but has also overflowed since vTaskSetTimeOut() was called.
			It must have wrapped all the way around and gone past us again. This
			passed since vTaskSetTimeout() was called. */
			xReturn = pdTRUE;
		}
		else if( ( ( portTickType ) ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering ) ) < ( portTickType ) *pxTicksToWait )
   8564a:	4a10      	ldr	r2, [pc, #64]	; (8568c <xTaskCheckForTimeOut+0x80>)
   8564c:	6811      	ldr	r1, [r2, #0]
   8564e:	686a      	ldr	r2, [r5, #4]
   85650:	1a89      	subs	r1, r1, r2
   85652:	428b      	cmp	r3, r1
   85654:	d90d      	bls.n	85672 <xTaskCheckForTimeOut+0x66>
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering );
   85656:	490d      	ldr	r1, [pc, #52]	; (8568c <xTaskCheckForTimeOut+0x80>)
   85658:	6809      	ldr	r1, [r1, #0]
   8565a:	1a52      	subs	r2, r2, r1
   8565c:	4413      	add	r3, r2
   8565e:	6023      	str	r3, [r4, #0]
			vTaskSetTimeOutState( pxTimeOut );
   85660:	4628      	mov	r0, r5
   85662:	4b0b      	ldr	r3, [pc, #44]	; (85690 <xTaskCheckForTimeOut+0x84>)
   85664:	4798      	blx	r3
			xReturn = pdFALSE;
   85666:	2400      	movs	r4, #0
   85668:	e004      	b.n	85674 <xTaskCheckForTimeOut+0x68>
			/* If INCLUDE_vTaskSuspend is set to 1 and the block time specified is
			the maximum block time then the task should block indefinitely, and
			therefore never time out. */
			if( *pxTicksToWait == portMAX_DELAY )
			{
				xReturn = pdFALSE;
   8566a:	2400      	movs	r4, #0
   8566c:	e002      	b.n	85674 <xTaskCheckForTimeOut+0x68>
		{
			/* The tick count is greater than the time at which vTaskSetTimeout()
			was called, but has also overflowed since vTaskSetTimeOut() was called.
			It must have wrapped all the way around and gone past us again. This
			passed since vTaskSetTimeout() was called. */
			xReturn = pdTRUE;
   8566e:	2401      	movs	r4, #1
   85670:	e000      	b.n	85674 <xTaskCheckForTimeOut+0x68>
			vTaskSetTimeOutState( pxTimeOut );
			xReturn = pdFALSE;
		}
		else
		{
			xReturn = pdTRUE;
   85672:	2401      	movs	r4, #1
		}
	}
	taskEXIT_CRITICAL();
   85674:	4b07      	ldr	r3, [pc, #28]	; (85694 <xTaskCheckForTimeOut+0x88>)
   85676:	4798      	blx	r3

	return xReturn;
}
   85678:	4620      	mov	r0, r4
   8567a:	bd38      	pop	{r3, r4, r5, pc}
   8567c:	0008c650 	.word	0x0008c650
   85680:	00085f89 	.word	0x00085f89
   85684:	00084139 	.word	0x00084139
   85688:	20075b7c 	.word	0x20075b7c
   8568c:	20075a2c 	.word	0x20075a2c
   85690:	000855dd 	.word	0x000855dd
   85694:	00084159 	.word	0x00084159

00085698 <vTaskMissedYield>:
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
	xMissedYield = pdTRUE;
   85698:	2201      	movs	r2, #1
   8569a:	4b01      	ldr	r3, [pc, #4]	; (856a0 <vTaskMissedYield+0x8>)
   8569c:	601a      	str	r2, [r3, #0]
   8569e:	4770      	bx	lr
   856a0:	20075ad0 	.word	0x20075ad0

000856a4 <xTaskGetCurrentTaskHandle>:
	xTaskHandle xReturn;

		/* A critical section is not required as this is not called from
		an interrupt and the current TCB will always be the same for any
		individual execution thread. */
		xReturn = pxCurrentTCB;
   856a4:	4b01      	ldr	r3, [pc, #4]	; (856ac <xTaskGetCurrentTaskHandle+0x8>)
   856a6:	6818      	ldr	r0, [r3, #0]

		return xReturn;
	}
   856a8:	4770      	bx	lr
   856aa:	bf00      	nop
   856ac:	20075ad8 	.word	0x20075ad8

000856b0 <xTaskGetSchedulerState>:

	portBASE_TYPE xTaskGetSchedulerState( void )
	{
	portBASE_TYPE xReturn;

		if( xSchedulerRunning == pdFALSE )
   856b0:	4b05      	ldr	r3, [pc, #20]	; (856c8 <xTaskGetSchedulerState+0x18>)
   856b2:	681b      	ldr	r3, [r3, #0]
   856b4:	b133      	cbz	r3, 856c4 <xTaskGetSchedulerState+0x14>
		{
			xReturn = taskSCHEDULER_NOT_STARTED;
		}
		else
		{
			if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
   856b6:	4b05      	ldr	r3, [pc, #20]	; (856cc <xTaskGetSchedulerState+0x1c>)
   856b8:	681b      	ldr	r3, [r3, #0]
			{
				xReturn = taskSCHEDULER_RUNNING;
   856ba:	2b00      	cmp	r3, #0
   856bc:	bf14      	ite	ne
   856be:	2002      	movne	r0, #2
   856c0:	2001      	moveq	r0, #1
   856c2:	4770      	bx	lr
	{
	portBASE_TYPE xReturn;

		if( xSchedulerRunning == pdFALSE )
		{
			xReturn = taskSCHEDULER_NOT_STARTED;
   856c4:	2000      	movs	r0, #0
				xReturn = taskSCHEDULER_SUSPENDED;
			}
		}

		return xReturn;
	}
   856c6:	4770      	bx	lr
   856c8:	20075ac8 	.word	0x20075ac8
   856cc:	20075b74 	.word	0x20075b74

000856d0 <vTaskPriorityInherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityInherit( xTaskHandle * const pxMutexHolder )
	{
   856d0:	b538      	push	{r3, r4, r5, lr}
	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;

		/* If the mutex was given back by an interrupt while the queue was
		locked then the mutex holder might now be NULL. */
		if( pxMutexHolder != NULL )
   856d2:	4604      	mov	r4, r0
   856d4:	2800      	cmp	r0, #0
   856d6:	d03e      	beq.n	85756 <vTaskPriorityInherit+0x86>
		{
			if( pxTCB->uxPriority < pxCurrentTCB->uxPriority )
   856d8:	6ac3      	ldr	r3, [r0, #44]	; 0x2c
   856da:	4a1f      	ldr	r2, [pc, #124]	; (85758 <vTaskPriorityInherit+0x88>)
   856dc:	6812      	ldr	r2, [r2, #0]
   856de:	6ad2      	ldr	r2, [r2, #44]	; 0x2c
   856e0:	4293      	cmp	r3, r2
   856e2:	d238      	bcs.n	85756 <vTaskPriorityInherit+0x86>
			{
				/* Adjust the mutex holder state to account for its new priority. */
				listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) pxCurrentTCB->uxPriority );
   856e4:	4a1c      	ldr	r2, [pc, #112]	; (85758 <vTaskPriorityInherit+0x88>)
   856e6:	6812      	ldr	r2, [r2, #0]
   856e8:	6ad2      	ldr	r2, [r2, #44]	; 0x2c
   856ea:	f1c2 0205 	rsb	r2, r2, #5
   856ee:	6182      	str	r2, [r0, #24]

				/* If the task being modified is in the ready state it will need to
				be moved into a new list. */
				if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ pxTCB->uxPriority ] ), &( pxTCB->xGenericListItem ) ) != pdFALSE )
   856f0:	eb03 0383 	add.w	r3, r3, r3, lsl #2
   856f4:	4a19      	ldr	r2, [pc, #100]	; (8575c <vTaskPriorityInherit+0x8c>)
   856f6:	eb02 0383 	add.w	r3, r2, r3, lsl #2
   856fa:	6942      	ldr	r2, [r0, #20]
   856fc:	429a      	cmp	r2, r3
   856fe:	d126      	bne.n	8574e <vTaskPriorityInherit+0x7e>
				{
					if( uxListRemove( ( xListItem * ) &( pxTCB->xGenericListItem ) ) == 0 )
   85700:	1d05      	adds	r5, r0, #4
   85702:	4628      	mov	r0, r5
   85704:	4b16      	ldr	r3, [pc, #88]	; (85760 <vTaskPriorityInherit+0x90>)
   85706:	4798      	blx	r3
   85708:	b970      	cbnz	r0, 85728 <vTaskPriorityInherit+0x58>
					{
						taskRESET_READY_PRIORITY( pxTCB->uxPriority );
   8570a:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
   8570c:	eb03 0283 	add.w	r2, r3, r3, lsl #2
   85710:	0092      	lsls	r2, r2, #2
   85712:	4912      	ldr	r1, [pc, #72]	; (8575c <vTaskPriorityInherit+0x8c>)
   85714:	588a      	ldr	r2, [r1, r2]
   85716:	b93a      	cbnz	r2, 85728 <vTaskPriorityInherit+0x58>
   85718:	4a12      	ldr	r2, [pc, #72]	; (85764 <vTaskPriorityInherit+0x94>)
   8571a:	6811      	ldr	r1, [r2, #0]
   8571c:	2001      	movs	r0, #1
   8571e:	fa00 f303 	lsl.w	r3, r0, r3
   85722:	ea21 0303 	bic.w	r3, r1, r3
   85726:	6013      	str	r3, [r2, #0]
					}

					/* Inherit the priority before being moved into the new list. */
					pxTCB->uxPriority = pxCurrentTCB->uxPriority;
   85728:	4b0b      	ldr	r3, [pc, #44]	; (85758 <vTaskPriorityInherit+0x88>)
   8572a:	681b      	ldr	r3, [r3, #0]
   8572c:	6adb      	ldr	r3, [r3, #44]	; 0x2c
   8572e:	62e3      	str	r3, [r4, #44]	; 0x2c
					prvAddTaskToReadyQueue( pxTCB );
   85730:	4a0c      	ldr	r2, [pc, #48]	; (85764 <vTaskPriorityInherit+0x94>)
   85732:	6810      	ldr	r0, [r2, #0]
   85734:	2101      	movs	r1, #1
   85736:	4099      	lsls	r1, r3
   85738:	4301      	orrs	r1, r0
   8573a:	6011      	str	r1, [r2, #0]
   8573c:	eb03 0383 	add.w	r3, r3, r3, lsl #2
   85740:	4806      	ldr	r0, [pc, #24]	; (8575c <vTaskPriorityInherit+0x8c>)
   85742:	eb00 0083 	add.w	r0, r0, r3, lsl #2
   85746:	4629      	mov	r1, r5
   85748:	4b07      	ldr	r3, [pc, #28]	; (85768 <vTaskPriorityInherit+0x98>)
   8574a:	4798      	blx	r3
   8574c:	bd38      	pop	{r3, r4, r5, pc}
				}
				else
				{
					/* Just inherit the priority. */
					pxTCB->uxPriority = pxCurrentTCB->uxPriority;
   8574e:	4b02      	ldr	r3, [pc, #8]	; (85758 <vTaskPriorityInherit+0x88>)
   85750:	681b      	ldr	r3, [r3, #0]
   85752:	6adb      	ldr	r3, [r3, #44]	; 0x2c
   85754:	62c3      	str	r3, [r0, #44]	; 0x2c
   85756:	bd38      	pop	{r3, r4, r5, pc}
   85758:	20075ad8 	.word	0x20075ad8
   8575c:	20075a30 	.word	0x20075a30
   85760:	000840a1 	.word	0x000840a1
   85764:	20075a24 	.word	0x20075a24
   85768:	00084049 	.word	0x00084049

0008576c <vTaskPriorityDisinherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityDisinherit( xTaskHandle * const pxMutexHolder )
	{
   8576c:	b538      	push	{r3, r4, r5, lr}
	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;

		if( pxMutexHolder != NULL )
   8576e:	4604      	mov	r4, r0
   85770:	b350      	cbz	r0, 857c8 <vTaskPriorityDisinherit+0x5c>
		{
			if( pxTCB->uxPriority != pxTCB->uxBasePriority )
   85772:	6ac2      	ldr	r2, [r0, #44]	; 0x2c
   85774:	6c83      	ldr	r3, [r0, #72]	; 0x48
   85776:	429a      	cmp	r2, r3
   85778:	d026      	beq.n	857c8 <vTaskPriorityDisinherit+0x5c>
			{
				/* We must be the running task to be able to give the mutex back.
				Remove ourselves from the ready list we currently appear in. */
				if( uxListRemove( ( xListItem * ) &( pxTCB->xGenericListItem ) ) == 0 )
   8577a:	1d05      	adds	r5, r0, #4
   8577c:	4628      	mov	r0, r5
   8577e:	4b13      	ldr	r3, [pc, #76]	; (857cc <vTaskPriorityDisinherit+0x60>)
   85780:	4798      	blx	r3
   85782:	b970      	cbnz	r0, 857a2 <vTaskPriorityDisinherit+0x36>
				{
					taskRESET_READY_PRIORITY( pxTCB->uxPriority );
   85784:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
   85786:	eb03 0283 	add.w	r2, r3, r3, lsl #2
   8578a:	0092      	lsls	r2, r2, #2
   8578c:	4910      	ldr	r1, [pc, #64]	; (857d0 <vTaskPriorityDisinherit+0x64>)
   8578e:	588a      	ldr	r2, [r1, r2]
   85790:	b93a      	cbnz	r2, 857a2 <vTaskPriorityDisinherit+0x36>
   85792:	4a10      	ldr	r2, [pc, #64]	; (857d4 <vTaskPriorityDisinherit+0x68>)
   85794:	6811      	ldr	r1, [r2, #0]
   85796:	2001      	movs	r0, #1
   85798:	fa00 f303 	lsl.w	r3, r0, r3
   8579c:	ea21 0303 	bic.w	r3, r1, r3
   857a0:	6013      	str	r3, [r2, #0]
				}

				/* Disinherit the priority before adding the task into the new
				ready list. */
				traceTASK_PRIORITY_DISINHERIT( pxTCB, pxTCB->uxBasePriority );
				pxTCB->uxPriority = pxTCB->uxBasePriority;
   857a2:	6ca3      	ldr	r3, [r4, #72]	; 0x48
   857a4:	62e3      	str	r3, [r4, #44]	; 0x2c
				listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) pxTCB->uxPriority );
   857a6:	f1c3 0205 	rsb	r2, r3, #5
   857aa:	61a2      	str	r2, [r4, #24]
				prvAddTaskToReadyQueue( pxTCB );
   857ac:	4a09      	ldr	r2, [pc, #36]	; (857d4 <vTaskPriorityDisinherit+0x68>)
   857ae:	6810      	ldr	r0, [r2, #0]
   857b0:	2101      	movs	r1, #1
   857b2:	4099      	lsls	r1, r3
   857b4:	4301      	orrs	r1, r0
   857b6:	6011      	str	r1, [r2, #0]
   857b8:	eb03 0383 	add.w	r3, r3, r3, lsl #2
   857bc:	4804      	ldr	r0, [pc, #16]	; (857d0 <vTaskPriorityDisinherit+0x64>)
   857be:	eb00 0083 	add.w	r0, r0, r3, lsl #2
   857c2:	4629      	mov	r1, r5
   857c4:	4b04      	ldr	r3, [pc, #16]	; (857d8 <vTaskPriorityDisinherit+0x6c>)
   857c6:	4798      	blx	r3
   857c8:	bd38      	pop	{r3, r4, r5, pc}
   857ca:	bf00      	nop
   857cc:	000840a1 	.word	0x000840a1
   857d0:	20075a30 	.word	0x20075a30
   857d4:	20075a24 	.word	0x20075a24
   857d8:	00084049 	.word	0x00084049

000857dc <prvInsertTimerInActiveList>:
	return xTimeNow;
}
/*-----------------------------------------------------------*/

static portBASE_TYPE prvInsertTimerInActiveList( xTIMER *pxTimer, portTickType xNextExpiryTime, portTickType xTimeNow, portTickType xCommandTime )
{
   857dc:	b510      	push	{r4, lr}
   857de:	4604      	mov	r4, r0
portBASE_TYPE xProcessTimerNow = pdFALSE;

	listSET_LIST_ITEM_VALUE( &( pxTimer->xTimerListItem ), xNextExpiryTime );
   857e0:	6041      	str	r1, [r0, #4]
	listSET_LIST_ITEM_OWNER( &( pxTimer->xTimerListItem ), pxTimer );
   857e2:	6120      	str	r0, [r4, #16]

	if( xNextExpiryTime <= xTimeNow )
   857e4:	4291      	cmp	r1, r2
   857e6:	d80a      	bhi.n	857fe <prvInsertTimerInActiveList+0x22>
	{
		/* Has the expiry time elapsed between the command to start/reset a
		timer was issued, and the time the command was processed? */
		if( ( ( portTickType ) ( xTimeNow - xCommandTime ) ) >= pxTimer->xTimerPeriodInTicks )
   857e8:	1ad2      	subs	r2, r2, r3
   857ea:	6981      	ldr	r1, [r0, #24]
   857ec:	428a      	cmp	r2, r1
   857ee:	d211      	bcs.n	85814 <prvInsertTimerInActiveList+0x38>
			processed actually exceeds the timers period.  */
			xProcessTimerNow = pdTRUE;
		}
		else
		{
			vListInsert( pxOverflowTimerList, &( pxTimer->xTimerListItem ) );
   857f0:	4b0a      	ldr	r3, [pc, #40]	; (8581c <prvInsertTimerInActiveList+0x40>)
   857f2:	6818      	ldr	r0, [r3, #0]
   857f4:	1d21      	adds	r1, r4, #4
   857f6:	4b0a      	ldr	r3, [pc, #40]	; (85820 <prvInsertTimerInActiveList+0x44>)
   857f8:	4798      	blx	r3
}
/*-----------------------------------------------------------*/

static portBASE_TYPE prvInsertTimerInActiveList( xTIMER *pxTimer, portTickType xNextExpiryTime, portTickType xTimeNow, portTickType xCommandTime )
{
portBASE_TYPE xProcessTimerNow = pdFALSE;
   857fa:	2000      	movs	r0, #0
   857fc:	bd10      	pop	{r4, pc}
			vListInsert( pxOverflowTimerList, &( pxTimer->xTimerListItem ) );
		}
	}
	else
	{
		if( ( xTimeNow < xCommandTime ) && ( xNextExpiryTime >= xCommandTime ) )
   857fe:	429a      	cmp	r2, r3
   85800:	d201      	bcs.n	85806 <prvInsertTimerInActiveList+0x2a>
   85802:	4299      	cmp	r1, r3
   85804:	d208      	bcs.n	85818 <prvInsertTimerInActiveList+0x3c>
			its expiry time and should be processed immediately. */
			xProcessTimerNow = pdTRUE;
		}
		else
		{
			vListInsert( pxCurrentTimerList, &( pxTimer->xTimerListItem ) );
   85806:	4b07      	ldr	r3, [pc, #28]	; (85824 <prvInsertTimerInActiveList+0x48>)
   85808:	6818      	ldr	r0, [r3, #0]
   8580a:	1d21      	adds	r1, r4, #4
   8580c:	4b04      	ldr	r3, [pc, #16]	; (85820 <prvInsertTimerInActiveList+0x44>)
   8580e:	4798      	blx	r3
}
/*-----------------------------------------------------------*/

static portBASE_TYPE prvInsertTimerInActiveList( xTIMER *pxTimer, portTickType xNextExpiryTime, portTickType xTimeNow, portTickType xCommandTime )
{
portBASE_TYPE xProcessTimerNow = pdFALSE;
   85810:	2000      	movs	r0, #0
   85812:	bd10      	pop	{r4, pc}
		timer was issued, and the time the command was processed? */
		if( ( ( portTickType ) ( xTimeNow - xCommandTime ) ) >= pxTimer->xTimerPeriodInTicks )
		{
			/* The time between a command being issued and the command being
			processed actually exceeds the timers period.  */
			xProcessTimerNow = pdTRUE;
   85814:	2001      	movs	r0, #1
   85816:	bd10      	pop	{r4, pc}
		if( ( xTimeNow < xCommandTime ) && ( xNextExpiryTime >= xCommandTime ) )
		{
			/* If, since the command was issued, the tick count has overflowed
			but the expiry time has not, then the timer must have already passed
			its expiry time and should be processed immediately. */
			xProcessTimerNow = pdTRUE;
   85818:	2001      	movs	r0, #1
			vListInsert( pxCurrentTimerList, &( pxTimer->xTimerListItem ) );
		}
	}

	return xProcessTimerNow;
}
   8581a:	bd10      	pop	{r4, pc}
   8581c:	20075bb8 	.word	0x20075bb8
   85820:	00084065 	.word	0x00084065
   85824:	20075b84 	.word	0x20075b84

00085828 <prvCheckForValidListAndQueue>:
	pxOverflowTimerList = pxTemp;
}
/*-----------------------------------------------------------*/

static void prvCheckForValidListAndQueue( void )
{
   85828:	b570      	push	{r4, r5, r6, lr}
	/* Check that the list from which active timers are referenced, and the
	queue used to communicate with the timer service, have been
	initialised. */
	taskENTER_CRITICAL();
   8582a:	4b0d      	ldr	r3, [pc, #52]	; (85860 <prvCheckForValidListAndQueue+0x38>)
   8582c:	4798      	blx	r3
	{
		if( xTimerQueue == NULL )
   8582e:	4b0d      	ldr	r3, [pc, #52]	; (85864 <prvCheckForValidListAndQueue+0x3c>)
   85830:	681b      	ldr	r3, [r3, #0]
   85832:	b98b      	cbnz	r3, 85858 <prvCheckForValidListAndQueue+0x30>
		{
			vListInitialise( &xActiveTimerList1 );
   85834:	4d0c      	ldr	r5, [pc, #48]	; (85868 <prvCheckForValidListAndQueue+0x40>)
   85836:	4628      	mov	r0, r5
   85838:	4e0c      	ldr	r6, [pc, #48]	; (8586c <prvCheckForValidListAndQueue+0x44>)
   8583a:	47b0      	blx	r6
			vListInitialise( &xActiveTimerList2 );
   8583c:	4c0c      	ldr	r4, [pc, #48]	; (85870 <prvCheckForValidListAndQueue+0x48>)
   8583e:	4620      	mov	r0, r4
   85840:	47b0      	blx	r6
			pxCurrentTimerList = &xActiveTimerList1;
   85842:	4b0c      	ldr	r3, [pc, #48]	; (85874 <prvCheckForValidListAndQueue+0x4c>)
   85844:	601d      	str	r5, [r3, #0]
			pxOverflowTimerList = &xActiveTimerList2;
   85846:	4b0c      	ldr	r3, [pc, #48]	; (85878 <prvCheckForValidListAndQueue+0x50>)
   85848:	601c      	str	r4, [r3, #0]
			xTimerQueue = xQueueCreate( ( unsigned portBASE_TYPE ) configTIMER_QUEUE_LENGTH, sizeof( xTIMER_MESSAGE ) );
   8584a:	2005      	movs	r0, #5
   8584c:	210c      	movs	r1, #12
   8584e:	2200      	movs	r2, #0
   85850:	4b0a      	ldr	r3, [pc, #40]	; (8587c <prvCheckForValidListAndQueue+0x54>)
   85852:	4798      	blx	r3
   85854:	4b03      	ldr	r3, [pc, #12]	; (85864 <prvCheckForValidListAndQueue+0x3c>)
   85856:	6018      	str	r0, [r3, #0]
		}
	}
	taskEXIT_CRITICAL();
   85858:	4b09      	ldr	r3, [pc, #36]	; (85880 <prvCheckForValidListAndQueue+0x58>)
   8585a:	4798      	blx	r3
   8585c:	bd70      	pop	{r4, r5, r6, pc}
   8585e:	bf00      	nop
   85860:	00084139 	.word	0x00084139
   85864:	20075bb4 	.word	0x20075bb4
   85868:	20075b88 	.word	0x20075b88
   8586c:	00084029 	.word	0x00084029
   85870:	20075b9c 	.word	0x20075b9c
   85874:	20075b84 	.word	0x20075b84
   85878:	20075bb8 	.word	0x20075bb8
   8587c:	00084521 	.word	0x00084521
   85880:	00084159 	.word	0x00084159

00085884 <xTimerCreateTimerTask>:
static void prvProcessTimerOrBlockTask( portTickType xNextExpireTime, portBASE_TYPE xListWasEmpty ) PRIVILEGED_FUNCTION;

/*-----------------------------------------------------------*/

portBASE_TYPE xTimerCreateTimerTask( void )
{
   85884:	b510      	push	{r4, lr}
   85886:	b084      	sub	sp, #16

	/* This function is called when the scheduler is started if
	configUSE_TIMERS is set to 1.  Check that the infrastructure used by the
	timer service task has been created/initialised.  If timers have already
	been created then the initialisation will already have been performed. */
	prvCheckForValidListAndQueue();
   85888:	4b0d      	ldr	r3, [pc, #52]	; (858c0 <xTimerCreateTimerTask+0x3c>)
   8588a:	4798      	blx	r3

	if( xTimerQueue != NULL )
   8588c:	4b0d      	ldr	r3, [pc, #52]	; (858c4 <xTimerCreateTimerTask+0x40>)
   8588e:	681b      	ldr	r3, [r3, #0]
   85890:	b173      	cbz	r3, 858b0 <xTimerCreateTimerTask+0x2c>
			xReturn = xTaskCreate( prvTimerTask, ( const signed char * ) "Tmr Svc", ( unsigned short ) configTIMER_TASK_STACK_DEPTH, NULL, ( ( unsigned portBASE_TYPE ) configTIMER_TASK_PRIORITY ) | portPRIVILEGE_BIT, &xTimerTaskHandle );
		}
		#else
		{
			/* Create the timer task without storing its handle. */
			xReturn = xTaskCreate( prvTimerTask, ( const signed char * ) "Tmr Svc", ( unsigned short ) configTIMER_TASK_STACK_DEPTH, NULL, ( ( unsigned portBASE_TYPE ) configTIMER_TASK_PRIORITY ) | portPRIVILEGE_BIT, NULL);
   85892:	2304      	movs	r3, #4
   85894:	9300      	str	r3, [sp, #0]
   85896:	2300      	movs	r3, #0
   85898:	9301      	str	r3, [sp, #4]
   8589a:	9302      	str	r3, [sp, #8]
   8589c:	9303      	str	r3, [sp, #12]
   8589e:	480a      	ldr	r0, [pc, #40]	; (858c8 <xTimerCreateTimerTask+0x44>)
   858a0:	490a      	ldr	r1, [pc, #40]	; (858cc <xTimerCreateTimerTask+0x48>)
   858a2:	f44f 72a0 	mov.w	r2, #320	; 0x140
   858a6:	4c0a      	ldr	r4, [pc, #40]	; (858d0 <xTimerCreateTimerTask+0x4c>)
   858a8:	47a0      	blx	r4
		}
		#endif
	}

	configASSERT( xReturn );
   858aa:	4604      	mov	r4, r0
   858ac:	b928      	cbnz	r0, 858ba <xTimerCreateTimerTask+0x36>
   858ae:	e000      	b.n	858b2 <xTimerCreateTimerTask+0x2e>

/*-----------------------------------------------------------*/

portBASE_TYPE xTimerCreateTimerTask( void )
{
portBASE_TYPE xReturn = pdFAIL;
   858b0:	2400      	movs	r4, #0
			xReturn = xTaskCreate( prvTimerTask, ( const signed char * ) "Tmr Svc", ( unsigned short ) configTIMER_TASK_STACK_DEPTH, NULL, ( ( unsigned portBASE_TYPE ) configTIMER_TASK_PRIORITY ) | portPRIVILEGE_BIT, NULL);
		}
		#endif
	}

	configASSERT( xReturn );
   858b2:	4808      	ldr	r0, [pc, #32]	; (858d4 <xTimerCreateTimerTask+0x50>)
   858b4:	21d7      	movs	r1, #215	; 0xd7
   858b6:	4b08      	ldr	r3, [pc, #32]	; (858d8 <xTimerCreateTimerTask+0x54>)
   858b8:	4798      	blx	r3
	return xReturn;
}
   858ba:	4620      	mov	r0, r4
   858bc:	b004      	add	sp, #16
   858be:	bd10      	pop	{r4, pc}
   858c0:	00085829 	.word	0x00085829
   858c4:	20075bb4 	.word	0x20075bb4
   858c8:	00085a45 	.word	0x00085a45
   858cc:	0008c6ac 	.word	0x0008c6ac
   858d0:	00084b31 	.word	0x00084b31
   858d4:	0008c6b4 	.word	0x0008c6b4
   858d8:	00085f89 	.word	0x00085f89

000858dc <xTimerCreate>:
/*-----------------------------------------------------------*/

xTimerHandle xTimerCreate( const signed char *pcTimerName, portTickType xTimerPeriodInTicks, unsigned portBASE_TYPE uxAutoReload, void *pvTimerID, tmrTIMER_CALLBACK pxCallbackFunction )
{
   858dc:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   858e0:	4680      	mov	r8, r0
   858e2:	4616      	mov	r6, r2
   858e4:	461d      	mov	r5, r3
xTIMER *pxNewTimer;

	/* Allocate the timer structure. */
	if( xTimerPeriodInTicks == ( portTickType ) 0U )
   858e6:	460f      	mov	r7, r1
   858e8:	b929      	cbnz	r1, 858f6 <xTimerCreate+0x1a>
	{
		pxNewTimer = NULL;
		configASSERT( ( xTimerPeriodInTicks > 0 ) );
   858ea:	480d      	ldr	r0, [pc, #52]	; (85920 <xTimerCreate+0x44>)
   858ec:	21e4      	movs	r1, #228	; 0xe4
   858ee:	4b0d      	ldr	r3, [pc, #52]	; (85924 <xTimerCreate+0x48>)
   858f0:	4798      	blx	r3
xTIMER *pxNewTimer;

	/* Allocate the timer structure. */
	if( xTimerPeriodInTicks == ( portTickType ) 0U )
	{
		pxNewTimer = NULL;
   858f2:	2400      	movs	r4, #0
   858f4:	e010      	b.n	85918 <xTimerCreate+0x3c>
		configASSERT( ( xTimerPeriodInTicks > 0 ) );
	}
	else
	{
		pxNewTimer = ( xTIMER * ) pvPortMalloc( sizeof( xTIMER ) );
   858f6:	2028      	movs	r0, #40	; 0x28
   858f8:	4b0b      	ldr	r3, [pc, #44]	; (85928 <xTimerCreate+0x4c>)
   858fa:	4798      	blx	r3
		if( pxNewTimer != NULL )
   858fc:	4604      	mov	r4, r0
   858fe:	b158      	cbz	r0, 85918 <xTimerCreate+0x3c>
		{
			/* Ensure the infrastructure used by the timer service task has been
			created/initialised. */
			prvCheckForValidListAndQueue();
   85900:	4b0a      	ldr	r3, [pc, #40]	; (8592c <xTimerCreate+0x50>)
   85902:	4798      	blx	r3

			/* Initialise the timer structure members using the function parameters. */
			pxNewTimer->pcTimerName = pcTimerName;
   85904:	f8c4 8000 	str.w	r8, [r4]
			pxNewTimer->xTimerPeriodInTicks = xTimerPeriodInTicks;
   85908:	61a7      	str	r7, [r4, #24]
			pxNewTimer->uxAutoReload = uxAutoReload;
   8590a:	61e6      	str	r6, [r4, #28]
			pxNewTimer->pvTimerID = pvTimerID;
   8590c:	6225      	str	r5, [r4, #32]
			pxNewTimer->pxCallbackFunction = pxCallbackFunction;
   8590e:	9b06      	ldr	r3, [sp, #24]
   85910:	6263      	str	r3, [r4, #36]	; 0x24
			vListInitialiseItem( &( pxNewTimer->xTimerListItem ) );
   85912:	1d20      	adds	r0, r4, #4
   85914:	4b06      	ldr	r3, [pc, #24]	; (85930 <xTimerCreate+0x54>)
   85916:	4798      	blx	r3
			traceTIMER_CREATE_FAILED();
		}
	}

	return ( xTimerHandle ) pxNewTimer;
}
   85918:	4620      	mov	r0, r4
   8591a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   8591e:	bf00      	nop
   85920:	0008c6b4 	.word	0x0008c6b4
   85924:	00085f89 	.word	0x00085f89
   85928:	00084285 	.word	0x00084285
   8592c:	00085829 	.word	0x00085829
   85930:	00084041 	.word	0x00084041

00085934 <xTimerGenericCommand>:
/*-----------------------------------------------------------*/

portBASE_TYPE xTimerGenericCommand( xTimerHandle xTimer, portBASE_TYPE xCommandID, portTickType xOptionalValue, signed portBASE_TYPE *pxHigherPriorityTaskWoken, portTickType xBlockTime )
{
   85934:	b510      	push	{r4, lr}
   85936:	b084      	sub	sp, #16
portBASE_TYPE xReturn = pdFAIL;
xTIMER_MESSAGE xMessage;

	/* Send a message to the timer service task to perform a particular action
	on a particular timer definition. */
	if( xTimerQueue != NULL )
   85938:	4c0f      	ldr	r4, [pc, #60]	; (85978 <xTimerGenericCommand+0x44>)
   8593a:	6824      	ldr	r4, [r4, #0]
   8593c:	b1c4      	cbz	r4, 85970 <xTimerGenericCommand+0x3c>
	{
		/* Send a command to the timer service task to start the xTimer timer. */
		xMessage.xMessageID = xCommandID;
   8593e:	9101      	str	r1, [sp, #4]
		xMessage.xMessageValue = xOptionalValue;
   85940:	9202      	str	r2, [sp, #8]
		xMessage.pxTimer = ( xTIMER * ) xTimer;
   85942:	9003      	str	r0, [sp, #12]

		if( pxHigherPriorityTaskWoken == NULL )
   85944:	b96b      	cbnz	r3, 85962 <xTimerGenericCommand+0x2e>
		{
			if( xTaskGetSchedulerState() == taskSCHEDULER_RUNNING )
   85946:	4b0d      	ldr	r3, [pc, #52]	; (8597c <xTimerGenericCommand+0x48>)
   85948:	4798      	blx	r3
   8594a:	2801      	cmp	r0, #1
			{
				xReturn = xQueueSendToBack( xTimerQueue, &xMessage, xBlockTime );
   8594c:	4b0a      	ldr	r3, [pc, #40]	; (85978 <xTimerGenericCommand+0x44>)
   8594e:	6818      	ldr	r0, [r3, #0]
   85950:	a901      	add	r1, sp, #4
   85952:	bf07      	ittee	eq
   85954:	9a06      	ldreq	r2, [sp, #24]
   85956:	2300      	moveq	r3, #0
			}
			else
			{
				xReturn = xQueueSendToBack( xTimerQueue, &xMessage, tmrNO_DELAY );
   85958:	2200      	movne	r2, #0
   8595a:	4613      	movne	r3, r2
   8595c:	4c08      	ldr	r4, [pc, #32]	; (85980 <xTimerGenericCommand+0x4c>)
   8595e:	47a0      	blx	r4
   85960:	e007      	b.n	85972 <xTimerGenericCommand+0x3e>
			}
		}
		else
		{
			xReturn = xQueueSendToBackFromISR( xTimerQueue, &xMessage, pxHigherPriorityTaskWoken );
   85962:	4620      	mov	r0, r4
   85964:	a901      	add	r1, sp, #4
   85966:	461a      	mov	r2, r3
   85968:	2300      	movs	r3, #0
   8596a:	4c06      	ldr	r4, [pc, #24]	; (85984 <xTimerGenericCommand+0x50>)
   8596c:	47a0      	blx	r4
   8596e:	e000      	b.n	85972 <xTimerGenericCommand+0x3e>
}
/*-----------------------------------------------------------*/

portBASE_TYPE xTimerGenericCommand( xTimerHandle xTimer, portBASE_TYPE xCommandID, portTickType xOptionalValue, signed portBASE_TYPE *pxHigherPriorityTaskWoken, portTickType xBlockTime )
{
portBASE_TYPE xReturn = pdFAIL;
   85970:	2000      	movs	r0, #0

		traceTIMER_COMMAND_SEND( xTimer, xCommandID, xOptionalValue, xReturn );
	}

	return xReturn;
}
   85972:	b004      	add	sp, #16
   85974:	bd10      	pop	{r4, pc}
   85976:	bf00      	nop
   85978:	20075bb4 	.word	0x20075bb4
   8597c:	000856b1 	.word	0x000856b1
   85980:	000845b1 	.word	0x000845b1
   85984:	00084749 	.word	0x00084749

00085988 <prvSampleTimeNow>:
	return xNextExpireTime;
}
/*-----------------------------------------------------------*/

static portTickType prvSampleTimeNow( portBASE_TYPE *pxTimerListsWereSwitched )
{
   85988:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
   8598c:	b082      	sub	sp, #8
   8598e:	4681      	mov	r9, r0
portTickType xTimeNow;
PRIVILEGED_DATA static portTickType xLastTime = ( portTickType ) 0U;

	xTimeNow = xTaskGetTickCount();
   85990:	4b23      	ldr	r3, [pc, #140]	; (85a20 <prvSampleTimeNow+0x98>)
   85992:	4798      	blx	r3
   85994:	4680      	mov	r8, r0

	if( xTimeNow < xLastTime )
   85996:	4b23      	ldr	r3, [pc, #140]	; (85a24 <prvSampleTimeNow+0x9c>)
   85998:	681b      	ldr	r3, [r3, #0]
   8599a:	4298      	cmp	r0, r3
   8599c:	d235      	bcs.n	85a0a <prvSampleTimeNow+0x82>

	/* The tick count has overflowed.  The timer lists must be switched.
	If there are any timers still referenced from the current timer list
	then they must have expired and should be processed before the lists
	are switched. */
	while( listLIST_IS_EMPTY( pxCurrentTimerList ) == pdFALSE )
   8599e:	4e22      	ldr	r6, [pc, #136]	; (85a28 <prvSampleTimeNow+0xa0>)
	{
		xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );

		/* Remove the timer from the list. */
		pxTimer = ( xTIMER * ) listGET_OWNER_OF_HEAD_ENTRY( pxCurrentTimerList );
		uxListRemove( &( pxTimer->xTimerListItem ) );
   859a0:	4f22      	ldr	r7, [pc, #136]	; (85a2c <prvSampleTimeNow+0xa4>)
   859a2:	e025      	b.n	859f0 <prvSampleTimeNow+0x68>
	If there are any timers still referenced from the current timer list
	then they must have expired and should be processed before the lists
	are switched. */
	while( listLIST_IS_EMPTY( pxCurrentTimerList ) == pdFALSE )
	{
		xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
   859a4:	68da      	ldr	r2, [r3, #12]
   859a6:	f8d2 a000 	ldr.w	sl, [r2]

		/* Remove the timer from the list. */
		pxTimer = ( xTIMER * ) listGET_OWNER_OF_HEAD_ENTRY( pxCurrentTimerList );
   859aa:	68db      	ldr	r3, [r3, #12]
   859ac:	68dc      	ldr	r4, [r3, #12]
		uxListRemove( &( pxTimer->xTimerListItem ) );
   859ae:	1d25      	adds	r5, r4, #4
   859b0:	4628      	mov	r0, r5
   859b2:	47b8      	blx	r7

		/* Execute its callback, then send a command to restart the timer if
		it is an auto-reload timer.  It cannot be restarted here as the lists
		have not yet been switched. */
		pxTimer->pxCallbackFunction( ( xTimerHandle ) pxTimer );
   859b4:	6a63      	ldr	r3, [r4, #36]	; 0x24
   859b6:	4620      	mov	r0, r4
   859b8:	4798      	blx	r3

		if( pxTimer->uxAutoReload == ( unsigned portBASE_TYPE ) pdTRUE )
   859ba:	69e3      	ldr	r3, [r4, #28]
   859bc:	2b01      	cmp	r3, #1
   859be:	d117      	bne.n	859f0 <prvSampleTimeNow+0x68>
			the timer going into the same timer list then it has already expired
			and the timer should be re-inserted into the current list so it is
			processed again within this loop.  Otherwise a command should be sent
			to restart the timer to ensure it is only inserted into a list after
			the lists have been swapped. */
			xReloadTime = ( xNextExpireTime + pxTimer->xTimerPeriodInTicks );
   859c0:	69a3      	ldr	r3, [r4, #24]
   859c2:	4453      	add	r3, sl
			if( xReloadTime > xNextExpireTime )
   859c4:	4553      	cmp	r3, sl
   859c6:	d906      	bls.n	859d6 <prvSampleTimeNow+0x4e>
			{
				listSET_LIST_ITEM_VALUE( &( pxTimer->xTimerListItem ), xReloadTime );
   859c8:	6063      	str	r3, [r4, #4]
				listSET_LIST_ITEM_OWNER( &( pxTimer->xTimerListItem ), pxTimer );
   859ca:	6124      	str	r4, [r4, #16]
				vListInsert( pxCurrentTimerList, &( pxTimer->xTimerListItem ) );
   859cc:	6830      	ldr	r0, [r6, #0]
   859ce:	4629      	mov	r1, r5
   859d0:	4b17      	ldr	r3, [pc, #92]	; (85a30 <prvSampleTimeNow+0xa8>)
   859d2:	4798      	blx	r3
   859d4:	e00c      	b.n	859f0 <prvSampleTimeNow+0x68>
			}
			else
			{
				xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START, xNextExpireTime, NULL, tmrNO_DELAY );
   859d6:	2300      	movs	r3, #0
   859d8:	9300      	str	r3, [sp, #0]
   859da:	4620      	mov	r0, r4
   859dc:	4619      	mov	r1, r3
   859de:	4652      	mov	r2, sl
   859e0:	4c14      	ldr	r4, [pc, #80]	; (85a34 <prvSampleTimeNow+0xac>)
   859e2:	47a0      	blx	r4
				configASSERT( xResult );
   859e4:	b920      	cbnz	r0, 859f0 <prvSampleTimeNow+0x68>
   859e6:	4814      	ldr	r0, [pc, #80]	; (85a38 <prvSampleTimeNow+0xb0>)
   859e8:	f240 2172 	movw	r1, #626	; 0x272
   859ec:	4b13      	ldr	r3, [pc, #76]	; (85a3c <prvSampleTimeNow+0xb4>)
   859ee:	4798      	blx	r3

	/* The tick count has overflowed.  The timer lists must be switched.
	If there are any timers still referenced from the current timer list
	then they must have expired and should be processed before the lists
	are switched. */
	while( listLIST_IS_EMPTY( pxCurrentTimerList ) == pdFALSE )
   859f0:	6833      	ldr	r3, [r6, #0]
   859f2:	681a      	ldr	r2, [r3, #0]
   859f4:	2a00      	cmp	r2, #0
   859f6:	d1d5      	bne.n	859a4 <prvSampleTimeNow+0x1c>
			}
		}
	}

	pxTemp = pxCurrentTimerList;
	pxCurrentTimerList = pxOverflowTimerList;
   859f8:	4a11      	ldr	r2, [pc, #68]	; (85a40 <prvSampleTimeNow+0xb8>)
   859fa:	6811      	ldr	r1, [r2, #0]
   859fc:	480a      	ldr	r0, [pc, #40]	; (85a28 <prvSampleTimeNow+0xa0>)
   859fe:	6001      	str	r1, [r0, #0]
	pxOverflowTimerList = pxTemp;
   85a00:	6013      	str	r3, [r2, #0]
	xTimeNow = xTaskGetTickCount();

	if( xTimeNow < xLastTime )
	{
		prvSwitchTimerLists( xLastTime );
		*pxTimerListsWereSwitched = pdTRUE;
   85a02:	2301      	movs	r3, #1
   85a04:	f8c9 3000 	str.w	r3, [r9]
   85a08:	e002      	b.n	85a10 <prvSampleTimeNow+0x88>
	}
	else
	{
		*pxTimerListsWereSwitched = pdFALSE;
   85a0a:	2300      	movs	r3, #0
   85a0c:	f8c9 3000 	str.w	r3, [r9]
	}

	xLastTime = xTimeNow;
   85a10:	4b04      	ldr	r3, [pc, #16]	; (85a24 <prvSampleTimeNow+0x9c>)
   85a12:	f8c3 8000 	str.w	r8, [r3]

	return xTimeNow;
}
   85a16:	4640      	mov	r0, r8
   85a18:	b002      	add	sp, #8
   85a1a:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
   85a1e:	bf00      	nop
   85a20:	00084e81 	.word	0x00084e81
   85a24:	20075bb0 	.word	0x20075bb0
   85a28:	20075b84 	.word	0x20075b84
   85a2c:	000840a1 	.word	0x000840a1
   85a30:	00084065 	.word	0x00084065
   85a34:	00085935 	.word	0x00085935
   85a38:	0008c6b4 	.word	0x0008c6b4
   85a3c:	00085f89 	.word	0x00085f89
   85a40:	20075bb8 	.word	0x20075bb8

00085a44 <prvTimerTask>:
	pxTimer->pxCallbackFunction( ( xTimerHandle ) pxTimer );
}
/*-----------------------------------------------------------*/

static void prvTimerTask( void *pvParameters )
{
   85a44:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   85a48:	b087      	sub	sp, #28
	the timer with the nearest expiry time will expire.  If there are no
	active timers then just set the next expire time to 0.  That will cause
	this task to unblock when the tick count overflows, at which point the
	timer lists will be switched and the next expiry time can be
	re-assessed.  */
	*pxListWasEmpty = listLIST_IS_EMPTY( pxCurrentTimerList );
   85a4a:	f8df a16c 	ldr.w	sl, [pc, #364]	; 85bb8 <prvTimerTask+0x174>
static void prvProcessTimerOrBlockTask( portTickType xNextExpireTime, portBASE_TYPE xListWasEmpty )
{
portTickType xTimeNow;
portBASE_TYPE xTimerListsWereSwitched;

	vTaskSuspendAll();
   85a4e:	f8df b16c 	ldr.w	fp, [pc, #364]	; 85bbc <prvTimerTask+0x178>
				time has not been reached yet.  This task should therefore
				block to wait for the next expire time or a command to be
				received - whichever comes first.  The following line cannot
				be reached unless xNextExpireTime > xTimeNow, except in the
				case when the current timer list is empty. */
				vQueueWaitForMessageRestricted( xTimerQueue, ( xNextExpireTime - xTimeNow ) );
   85a52:	4e4e      	ldr	r6, [pc, #312]	; (85b8c <prvTimerTask+0x148>)
portBASE_TYPE xResult;

	/* Remove the timer from the list of active timers.  A check has already
	been performed to ensure the list is not empty. */
	pxTimer = ( xTIMER * ) listGET_OWNER_OF_HEAD_ENTRY( pxCurrentTimerList );
	uxListRemove( &( pxTimer->xTimerListItem ) );
   85a54:	f8df 8168 	ldr.w	r8, [pc, #360]	; 85bc0 <prvTimerTask+0x17c>
	the timer with the nearest expiry time will expire.  If there are no
	active timers then just set the next expire time to 0.  That will cause
	this task to unblock when the tick count overflows, at which point the
	timer lists will be switched and the next expiry time can be
	re-assessed.  */
	*pxListWasEmpty = listLIST_IS_EMPTY( pxCurrentTimerList );
   85a58:	f8da 3000 	ldr.w	r3, [sl]
   85a5c:	681a      	ldr	r2, [r3, #0]
	if( *pxListWasEmpty == pdFALSE )
   85a5e:	2a00      	cmp	r2, #0
   85a60:	f000 808b 	beq.w	85b7a <prvTimerTask+0x136>
	{
		xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
   85a64:	68db      	ldr	r3, [r3, #12]
   85a66:	681c      	ldr	r4, [r3, #0]
static void prvProcessTimerOrBlockTask( portTickType xNextExpireTime, portBASE_TYPE xListWasEmpty )
{
portTickType xTimeNow;
portBASE_TYPE xTimerListsWereSwitched;

	vTaskSuspendAll();
   85a68:	47d8      	blx	fp
		/* Obtain the time now to make an assessment as to whether the timer
		has expired or not.  If obtaining the time causes the lists to switch
		then don't process this timer as any timers that remained in the list
		when the lists were switched will have been processed within the
		prvSampelTimeNow() function. */
		xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
   85a6a:	a803      	add	r0, sp, #12
   85a6c:	4b48      	ldr	r3, [pc, #288]	; (85b90 <prvTimerTask+0x14c>)
   85a6e:	4798      	blx	r3
   85a70:	4605      	mov	r5, r0
		if( xTimerListsWereSwitched == pdFALSE )
   85a72:	9b03      	ldr	r3, [sp, #12]
   85a74:	2b00      	cmp	r3, #0
   85a76:	d131      	bne.n	85adc <prvTimerTask+0x98>
		{
			/* The tick count has not overflowed, has the timer expired? */
			if( ( xListWasEmpty == pdFALSE ) && ( xNextExpireTime <= xTimeNow ) )
   85a78:	4284      	cmp	r4, r0
   85a7a:	d825      	bhi.n	85ac8 <prvTimerTask+0x84>
			{
				xTaskResumeAll();
   85a7c:	4b45      	ldr	r3, [pc, #276]	; (85b94 <prvTimerTask+0x150>)
   85a7e:	4798      	blx	r3
xTIMER *pxTimer;
portBASE_TYPE xResult;

	/* Remove the timer from the list of active timers.  A check has already
	been performed to ensure the list is not empty. */
	pxTimer = ( xTIMER * ) listGET_OWNER_OF_HEAD_ENTRY( pxCurrentTimerList );
   85a80:	f8da 3000 	ldr.w	r3, [sl]
   85a84:	68db      	ldr	r3, [r3, #12]
   85a86:	68df      	ldr	r7, [r3, #12]
	uxListRemove( &( pxTimer->xTimerListItem ) );
   85a88:	1d38      	adds	r0, r7, #4
   85a8a:	47c0      	blx	r8
	traceTIMER_EXPIRED( pxTimer );

	/* If the timer is an auto reload timer then calculate the next
	expiry time and re-insert the timer in the list of active timers. */
	if( pxTimer->uxAutoReload == ( unsigned portBASE_TYPE ) pdTRUE )
   85a8c:	69fb      	ldr	r3, [r7, #28]
   85a8e:	2b01      	cmp	r3, #1
   85a90:	d115      	bne.n	85abe <prvTimerTask+0x7a>
		a time relative to anything other than the current time.  It
		will therefore be inserted into the correct list relative to
		the time this task thinks it is now, even if a command to
		switch lists due to a tick count overflow is already waiting in
		the timer queue. */
		if( prvInsertTimerInActiveList( pxTimer, ( xNextExpireTime + pxTimer->xTimerPeriodInTicks ), xTimeNow, xNextExpireTime ) == pdTRUE )
   85a92:	69b9      	ldr	r1, [r7, #24]
   85a94:	4638      	mov	r0, r7
   85a96:	4421      	add	r1, r4
   85a98:	462a      	mov	r2, r5
   85a9a:	4623      	mov	r3, r4
   85a9c:	4d3e      	ldr	r5, [pc, #248]	; (85b98 <prvTimerTask+0x154>)
   85a9e:	47a8      	blx	r5
   85aa0:	2801      	cmp	r0, #1
   85aa2:	d10c      	bne.n	85abe <prvTimerTask+0x7a>
		{
			/* The timer expired before it was added to the active timer
			list.  Reload it now.  */
			xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START, xNextExpireTime, NULL, tmrNO_DELAY );
   85aa4:	2300      	movs	r3, #0
   85aa6:	9300      	str	r3, [sp, #0]
   85aa8:	4638      	mov	r0, r7
   85aaa:	4619      	mov	r1, r3
   85aac:	4622      	mov	r2, r4
   85aae:	4c3b      	ldr	r4, [pc, #236]	; (85b9c <prvTimerTask+0x158>)
   85ab0:	47a0      	blx	r4
			configASSERT( xResult );
   85ab2:	b920      	cbnz	r0, 85abe <prvTimerTask+0x7a>
   85ab4:	483a      	ldr	r0, [pc, #232]	; (85ba0 <prvTimerTask+0x15c>)
   85ab6:	f240 114f 	movw	r1, #335	; 0x14f
   85aba:	4b3a      	ldr	r3, [pc, #232]	; (85ba4 <prvTimerTask+0x160>)
   85abc:	4798      	blx	r3
			( void ) xResult;
		}
	}

	/* Call the timer callback. */
	pxTimer->pxCallbackFunction( ( xTimerHandle ) pxTimer );
   85abe:	6a7b      	ldr	r3, [r7, #36]	; 0x24
   85ac0:	4638      	mov	r0, r7
   85ac2:	4798      	blx	r3
   85ac4:	e00c      	b.n	85ae0 <prvTimerTask+0x9c>
		xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
	}
	else
	{
		/* Ensure the task unblocks when the tick count rolls over. */
		xNextExpireTime = ( portTickType ) 0U;
   85ac6:	2400      	movs	r4, #0
				time has not been reached yet.  This task should therefore
				block to wait for the next expire time or a command to be
				received - whichever comes first.  The following line cannot
				be reached unless xNextExpireTime > xTimeNow, except in the
				case when the current timer list is empty. */
				vQueueWaitForMessageRestricted( xTimerQueue, ( xNextExpireTime - xTimeNow ) );
   85ac8:	6830      	ldr	r0, [r6, #0]
   85aca:	1b61      	subs	r1, r4, r5
   85acc:	4b36      	ldr	r3, [pc, #216]	; (85ba8 <prvTimerTask+0x164>)
   85ace:	4798      	blx	r3

				if( xTaskResumeAll() == pdFALSE )
   85ad0:	4b30      	ldr	r3, [pc, #192]	; (85b94 <prvTimerTask+0x150>)
   85ad2:	4798      	blx	r3
   85ad4:	b920      	cbnz	r0, 85ae0 <prvTimerTask+0x9c>
				{
					/* Yield to wait for either a command to arrive, or the block time
					to expire.  If a command arrived between the critical section being
					exited and this yield then the yield will not cause the task
					to block. */
					portYIELD_WITHIN_API();
   85ad6:	4b35      	ldr	r3, [pc, #212]	; (85bac <prvTimerTask+0x168>)
   85ad8:	4798      	blx	r3
   85ada:	e001      	b.n	85ae0 <prvTimerTask+0x9c>
				}
			}
		}
		else
		{
			xTaskResumeAll();
   85adc:	4b2d      	ldr	r3, [pc, #180]	; (85b94 <prvTimerTask+0x150>)
   85ade:	4798      	blx	r3
portBASE_TYPE xTimerListsWereSwitched, xResult;
portTickType xTimeNow;

	/* In this case the xTimerListsWereSwitched parameter is not used, but it
	must be present in the function call. */
	xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
   85ae0:	a802      	add	r0, sp, #8
   85ae2:	4b2b      	ldr	r3, [pc, #172]	; (85b90 <prvTimerTask+0x14c>)
   85ae4:	4798      	blx	r3
   85ae6:	4607      	mov	r7, r0

	while( xQueueReceive( xTimerQueue, &xMessage, tmrNO_DELAY ) != pdFAIL )
   85ae8:	4d31      	ldr	r5, [pc, #196]	; (85bb0 <prvTimerTask+0x16c>)
				break;

			case tmrCOMMAND_CHANGE_PERIOD :
				pxTimer->xTimerPeriodInTicks = xMessage.xMessageValue;
				configASSERT( ( pxTimer->xTimerPeriodInTicks > 0 ) );
				prvInsertTimerInActiveList( pxTimer, ( xTimeNow + pxTimer->xTimerPeriodInTicks ), xTimeNow, xTimeNow );
   85aea:	f8df 90ac 	ldr.w	r9, [pc, #172]	; 85b98 <prvTimerTask+0x154>
   85aee:	e03c      	b.n	85b6a <prvTimerTask+0x126>
	must be present in the function call. */
	xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );

	while( xQueueReceive( xTimerQueue, &xMessage, tmrNO_DELAY ) != pdFAIL )
	{
		pxTimer = xMessage.pxTimer;
   85af0:	9c05      	ldr	r4, [sp, #20]

		/* Is the timer already in a list of active timers?  When the command
		is trmCOMMAND_PROCESS_TIMER_OVERFLOW, the timer will be NULL as the
		command is to the task rather than to an individual timer. */
		if( pxTimer != NULL )
   85af2:	b11c      	cbz	r4, 85afc <prvTimerTask+0xb8>
		{
			if( listIS_CONTAINED_WITHIN( NULL, &( pxTimer->xTimerListItem ) ) == pdFALSE )
   85af4:	6963      	ldr	r3, [r4, #20]
   85af6:	b10b      	cbz	r3, 85afc <prvTimerTask+0xb8>
			{
				/* The timer is in a list, remove it. */
				uxListRemove( &( pxTimer->xTimerListItem ) );
   85af8:	1d20      	adds	r0, r4, #4
   85afa:	47c0      	blx	r8
			}
		}

		traceTIMER_COMMAND_RECEIVED( pxTimer, xMessage.xMessageID, xMessage.xMessageValue );

		switch( xMessage.xMessageID )
   85afc:	9b03      	ldr	r3, [sp, #12]
   85afe:	2b02      	cmp	r3, #2
   85b00:	d021      	beq.n	85b46 <prvTimerTask+0x102>
   85b02:	2b03      	cmp	r3, #3
   85b04:	d02e      	beq.n	85b64 <prvTimerTask+0x120>
   85b06:	2b00      	cmp	r3, #0
   85b08:	d12f      	bne.n	85b6a <prvTimerTask+0x126>
		{
			case tmrCOMMAND_START :
				/* Start or restart a timer. */
				if( prvInsertTimerInActiveList( pxTimer,  xMessage.xMessageValue + pxTimer->xTimerPeriodInTicks, xTimeNow, xMessage.xMessageValue ) == pdTRUE )
   85b0a:	9b04      	ldr	r3, [sp, #16]
   85b0c:	69a1      	ldr	r1, [r4, #24]
   85b0e:	4620      	mov	r0, r4
   85b10:	4419      	add	r1, r3
   85b12:	463a      	mov	r2, r7
   85b14:	47c8      	blx	r9
   85b16:	2801      	cmp	r0, #1
   85b18:	d127      	bne.n	85b6a <prvTimerTask+0x126>
				{
					/* The timer expired before it was added to the active timer
					list.  Process it now. */
					pxTimer->pxCallbackFunction( ( xTimerHandle ) pxTimer );
   85b1a:	6a63      	ldr	r3, [r4, #36]	; 0x24
   85b1c:	4620      	mov	r0, r4
   85b1e:	4798      	blx	r3

					if( pxTimer->uxAutoReload == ( unsigned portBASE_TYPE ) pdTRUE )
   85b20:	69e3      	ldr	r3, [r4, #28]
   85b22:	2b01      	cmp	r3, #1
   85b24:	d121      	bne.n	85b6a <prvTimerTask+0x126>
					{
						xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START, xMessage.xMessageValue + pxTimer->xTimerPeriodInTicks, NULL, tmrNO_DELAY );
   85b26:	69a2      	ldr	r2, [r4, #24]
   85b28:	2300      	movs	r3, #0
   85b2a:	9300      	str	r3, [sp, #0]
   85b2c:	4620      	mov	r0, r4
   85b2e:	4619      	mov	r1, r3
   85b30:	9c04      	ldr	r4, [sp, #16]
   85b32:	4422      	add	r2, r4
   85b34:	4c19      	ldr	r4, [pc, #100]	; (85b9c <prvTimerTask+0x158>)
   85b36:	47a0      	blx	r4
						configASSERT( xResult );
   85b38:	b9b8      	cbnz	r0, 85b6a <prvTimerTask+0x126>
   85b3a:	4819      	ldr	r0, [pc, #100]	; (85ba0 <prvTimerTask+0x15c>)
   85b3c:	f240 2126 	movw	r1, #550	; 0x226
   85b40:	4b18      	ldr	r3, [pc, #96]	; (85ba4 <prvTimerTask+0x160>)
   85b42:	4798      	blx	r3
   85b44:	e011      	b.n	85b6a <prvTimerTask+0x126>
				/* The timer has already been removed from the active list.
				There is nothing to do here. */
				break;

			case tmrCOMMAND_CHANGE_PERIOD :
				pxTimer->xTimerPeriodInTicks = xMessage.xMessageValue;
   85b46:	9b04      	ldr	r3, [sp, #16]
   85b48:	61a3      	str	r3, [r4, #24]
				configASSERT( ( pxTimer->xTimerPeriodInTicks > 0 ) );
   85b4a:	b923      	cbnz	r3, 85b56 <prvTimerTask+0x112>
   85b4c:	4814      	ldr	r0, [pc, #80]	; (85ba0 <prvTimerTask+0x15c>)
   85b4e:	f240 2133 	movw	r1, #563	; 0x233
   85b52:	4b14      	ldr	r3, [pc, #80]	; (85ba4 <prvTimerTask+0x160>)
   85b54:	4798      	blx	r3
				prvInsertTimerInActiveList( pxTimer, ( xTimeNow + pxTimer->xTimerPeriodInTicks ), xTimeNow, xTimeNow );
   85b56:	69a1      	ldr	r1, [r4, #24]
   85b58:	4620      	mov	r0, r4
   85b5a:	4439      	add	r1, r7
   85b5c:	463a      	mov	r2, r7
   85b5e:	463b      	mov	r3, r7
   85b60:	47c8      	blx	r9
   85b62:	e002      	b.n	85b6a <prvTimerTask+0x126>
				break;

			case tmrCOMMAND_DELETE :
				/* The timer has already been removed from the active list,
				just free up the memory. */
				vPortFree( pxTimer );
   85b64:	4620      	mov	r0, r4
   85b66:	4b13      	ldr	r3, [pc, #76]	; (85bb4 <prvTimerTask+0x170>)
   85b68:	4798      	blx	r3

	/* In this case the xTimerListsWereSwitched parameter is not used, but it
	must be present in the function call. */
	xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );

	while( xQueueReceive( xTimerQueue, &xMessage, tmrNO_DELAY ) != pdFAIL )
   85b6a:	6830      	ldr	r0, [r6, #0]
   85b6c:	a903      	add	r1, sp, #12
   85b6e:	2200      	movs	r2, #0
   85b70:	4613      	mov	r3, r2
   85b72:	47a8      	blx	r5
   85b74:	2800      	cmp	r0, #0
   85b76:	d1bb      	bne.n	85af0 <prvTimerTask+0xac>
   85b78:	e76e      	b.n	85a58 <prvTimerTask+0x14>
static void prvProcessTimerOrBlockTask( portTickType xNextExpireTime, portBASE_TYPE xListWasEmpty )
{
portTickType xTimeNow;
portBASE_TYPE xTimerListsWereSwitched;

	vTaskSuspendAll();
   85b7a:	47d8      	blx	fp
		/* Obtain the time now to make an assessment as to whether the timer
		has expired or not.  If obtaining the time causes the lists to switch
		then don't process this timer as any timers that remained in the list
		when the lists were switched will have been processed within the
		prvSampelTimeNow() function. */
		xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
   85b7c:	a803      	add	r0, sp, #12
   85b7e:	4b04      	ldr	r3, [pc, #16]	; (85b90 <prvTimerTask+0x14c>)
   85b80:	4798      	blx	r3
   85b82:	4605      	mov	r5, r0
		if( xTimerListsWereSwitched == pdFALSE )
   85b84:	9b03      	ldr	r3, [sp, #12]
   85b86:	2b00      	cmp	r3, #0
   85b88:	d09d      	beq.n	85ac6 <prvTimerTask+0x82>
   85b8a:	e7a7      	b.n	85adc <prvTimerTask+0x98>
   85b8c:	20075bb4 	.word	0x20075bb4
   85b90:	00085989 	.word	0x00085989
   85b94:	00084fe9 	.word	0x00084fe9
   85b98:	000857dd 	.word	0x000857dd
   85b9c:	00085935 	.word	0x00085935
   85ba0:	0008c6b4 	.word	0x0008c6b4
   85ba4:	00085f89 	.word	0x00085f89
   85ba8:	00084951 	.word	0x00084951
   85bac:	00084119 	.word	0x00084119
   85bb0:	000847e9 	.word	0x000847e9
   85bb4:	00084351 	.word	0x00084351
   85bb8:	20075b84 	.word	0x20075b84
   85bbc:	00084e71 	.word	0x00084e71
   85bc0:	000840a1 	.word	0x000840a1

00085bc4 <delete_task_command>:
/*-----------------------------------------------------------*/

static portBASE_TYPE delete_task_command(int8_t *pcWriteBuffer,
		size_t xWriteBufferLen,
		const int8_t *pcCommandString)
{
   85bc4:	b510      	push	{r4, lr}
	/* Remove compile time warnings about unused parameters, and check the
	write buffer is not NULL.  NOTE - for simplicity, this example assumes the
	write buffer length is adequate, so does not check for buffer overflows. */
	(void) pcCommandString;
	(void) xWriteBufferLen;
	configASSERT(pcWriteBuffer);
   85bc6:	4604      	mov	r4, r0
   85bc8:	b920      	cbnz	r0, 85bd4 <delete_task_command+0x10>
   85bca:	480f      	ldr	r0, [pc, #60]	; (85c08 <delete_task_command+0x44>)
   85bcc:	f240 11b1 	movw	r1, #433	; 0x1b1
   85bd0:	4b0e      	ldr	r3, [pc, #56]	; (85c0c <delete_task_command+0x48>)
   85bd2:	4798      	blx	r3

	/* See if the task is running. */
	if (created_task_handle != NULL) {
   85bd4:	4b0e      	ldr	r3, [pc, #56]	; (85c10 <delete_task_command+0x4c>)
   85bd6:	6818      	ldr	r0, [r3, #0]
   85bd8:	b170      	cbz	r0, 85bf8 <delete_task_command+0x34>
		vTaskDelete(created_task_handle);
   85bda:	4b0e      	ldr	r3, [pc, #56]	; (85c14 <delete_task_command+0x50>)
   85bdc:	4798      	blx	r3
		created_task_handle = NULL;
   85bde:	2200      	movs	r2, #0
   85be0:	4b0b      	ldr	r3, [pc, #44]	; (85c10 <delete_task_command+0x4c>)
   85be2:	601a      	str	r2, [r3, #0]
		strcpy((char *) pcWriteBuffer, (const char *) success_message);
   85be4:	4b0c      	ldr	r3, [pc, #48]	; (85c18 <delete_task_command+0x54>)
   85be6:	cb07      	ldmia	r3!, {r0, r1, r2}
   85be8:	6020      	str	r0, [r4, #0]
   85bea:	6061      	str	r1, [r4, #4]
   85bec:	60a2      	str	r2, [r4, #8]
   85bee:	881a      	ldrh	r2, [r3, #0]
   85bf0:	789b      	ldrb	r3, [r3, #2]
   85bf2:	81a2      	strh	r2, [r4, #12]
   85bf4:	73a3      	strb	r3, [r4, #14]
   85bf6:	e004      	b.n	85c02 <delete_task_command+0x3e>
	} else {
		strcpy((char *) pcWriteBuffer, (const char *) failure_message);
   85bf8:	4620      	mov	r0, r4
   85bfa:	4908      	ldr	r1, [pc, #32]	; (85c1c <delete_task_command+0x58>)
   85bfc:	2244      	movs	r2, #68	; 0x44
   85bfe:	4b08      	ldr	r3, [pc, #32]	; (85c20 <delete_task_command+0x5c>)
   85c00:	4798      	blx	r3
	}

	/* There is no more data to return after this single string, so return
	 * pdFALSE. */
	return pdFALSE;
}
   85c02:	2000      	movs	r0, #0
   85c04:	bd10      	pop	{r4, pc}
   85c06:	bf00      	nop
   85c08:	0008c734 	.word	0x0008c734
   85c0c:	00085f89 	.word	0x00085f89
   85c10:	20075bbc 	.word	0x20075bbc
   85c14:	00084d45 	.word	0x00084d45
   85c18:	0008c758 	.word	0x0008c758
   85c1c:	0008c768 	.word	0x0008c768
   85c20:	000862d5 	.word	0x000862d5

00085c24 <create_task_command>:
/*-----------------------------------------------------------*/

static portBASE_TYPE create_task_command(int8_t *pcWriteBuffer,
		size_t xWriteBufferLen,
		const int8_t *pcCommandString)
{
   85c24:	b530      	push	{r4, r5, lr}
   85c26:	b087      	sub	sp, #28
   85c28:	4615      	mov	r5, r2

	/* Remove compile time warnings about unused parameters, and check the
	write buffer is not NULL.  NOTE - for simplicity, this example assumes the
	write buffer length is adequate, so does not check for buffer overflows. */
	(void) xWriteBufferLen;
	configASSERT(pcWriteBuffer);
   85c2a:	4604      	mov	r4, r0
   85c2c:	b920      	cbnz	r0, 85c38 <create_task_command+0x14>
   85c2e:	481d      	ldr	r0, [pc, #116]	; (85ca4 <create_task_command+0x80>)
   85c30:	f240 1181 	movw	r1, #385	; 0x181
   85c34:	4b1c      	ldr	r3, [pc, #112]	; (85ca8 <create_task_command+0x84>)
   85c36:	4798      	blx	r3

	/* Obtain the parameter string. */
	parameter_string = (int8_t *) FreeRTOS_CLIGetParameter(
   85c38:	4628      	mov	r0, r5
   85c3a:	2101      	movs	r1, #1
   85c3c:	aa05      	add	r2, sp, #20
   85c3e:	4b1b      	ldr	r3, [pc, #108]	; (85cac <create_task_command+0x88>)
   85c40:	4798      	blx	r3
									1,						/* Return the first parameter. */
									&parameter_string_length	/* Store the parameter string length. */
								);

	/* Turn the parameter into a number. */
	parameter_value = (int32_t) atol((const char *) parameter_string);
   85c42:	4b1b      	ldr	r3, [pc, #108]	; (85cb0 <create_task_command+0x8c>)
   85c44:	4798      	blx	r3
   85c46:	4603      	mov	r3, r0

	/* Attempt to create the task. */
	if (created_task_handle != NULL) {
   85c48:	4a1a      	ldr	r2, [pc, #104]	; (85cb4 <create_task_command+0x90>)
   85c4a:	6812      	ldr	r2, [r2, #0]
   85c4c:	b12a      	cbz	r2, 85c5a <create_task_command+0x36>
		strcpy((char *) pcWriteBuffer,
   85c4e:	4620      	mov	r0, r4
   85c50:	4919      	ldr	r1, [pc, #100]	; (85cb8 <create_task_command+0x94>)
   85c52:	224c      	movs	r2, #76	; 0x4c
   85c54:	4b19      	ldr	r3, [pc, #100]	; (85cbc <create_task_command+0x98>)
   85c56:	4798      	blx	r3
   85c58:	e020      	b.n	85c9c <create_task_command+0x78>
				(const char *) task_already_created_message);
	} else {
		if (xTaskCreate(created_task, (const signed char *) "Created",
   85c5a:	2200      	movs	r2, #0
   85c5c:	9200      	str	r2, [sp, #0]
   85c5e:	4915      	ldr	r1, [pc, #84]	; (85cb4 <create_task_command+0x90>)
   85c60:	9101      	str	r1, [sp, #4]
   85c62:	9202      	str	r2, [sp, #8]
   85c64:	9203      	str	r2, [sp, #12]
   85c66:	4816      	ldr	r0, [pc, #88]	; (85cc0 <create_task_command+0x9c>)
   85c68:	4916      	ldr	r1, [pc, #88]	; (85cc4 <create_task_command+0xa0>)
   85c6a:	22a0      	movs	r2, #160	; 0xa0
   85c6c:	4d16      	ldr	r5, [pc, #88]	; (85cc8 <create_task_command+0xa4>)
   85c6e:	47a8      	blx	r5
   85c70:	2801      	cmp	r0, #1
   85c72:	d109      	bne.n	85c88 <create_task_command+0x64>
				configMINIMAL_STACK_SIZE,
				(void *) parameter_value, tskIDLE_PRIORITY,
				&created_task_handle) == pdPASS) {
			strcpy((char *) pcWriteBuffer,
   85c74:	4b15      	ldr	r3, [pc, #84]	; (85ccc <create_task_command+0xa8>)
   85c76:	cb07      	ldmia	r3!, {r0, r1, r2}
   85c78:	6020      	str	r0, [r4, #0]
   85c7a:	6061      	str	r1, [r4, #4]
   85c7c:	60a2      	str	r2, [r4, #8]
   85c7e:	881a      	ldrh	r2, [r3, #0]
   85c80:	789b      	ldrb	r3, [r3, #2]
   85c82:	81a2      	strh	r2, [r4, #12]
   85c84:	73a3      	strb	r3, [r4, #14]
   85c86:	e009      	b.n	85c9c <create_task_command+0x78>
					(const char *) success_message);
		} else {
			strcpy((char *) pcWriteBuffer,
   85c88:	4d11      	ldr	r5, [pc, #68]	; (85cd0 <create_task_command+0xac>)
   85c8a:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
   85c8c:	6020      	str	r0, [r4, #0]
   85c8e:	6061      	str	r1, [r4, #4]
   85c90:	60a2      	str	r2, [r4, #8]
   85c92:	60e3      	str	r3, [r4, #12]
   85c94:	882a      	ldrh	r2, [r5, #0]
   85c96:	78ab      	ldrb	r3, [r5, #2]
   85c98:	8222      	strh	r2, [r4, #16]
   85c9a:	74a3      	strb	r3, [r4, #18]
	}

	/* There is no more data to return after this single string, so return
	pdFALSE. */
	return pdFALSE;
}
   85c9c:	2000      	movs	r0, #0
   85c9e:	b007      	add	sp, #28
   85ca0:	bd30      	pop	{r4, r5, pc}
   85ca2:	bf00      	nop
   85ca4:	0008c734 	.word	0x0008c734
   85ca8:	00085f89 	.word	0x00085f89
   85cac:	00083fb1 	.word	0x00083fb1
   85cb0:	00086215 	.word	0x00086215
   85cb4:	20075bbc 	.word	0x20075bbc
   85cb8:	0008c7ac 	.word	0x0008c7ac
   85cbc:	000862d5 	.word	0x000862d5
   85cc0:	00085ec9 	.word	0x00085ec9
   85cc4:	0008c7f8 	.word	0x0008c7f8
   85cc8:	00084b31 	.word	0x00084b31
   85ccc:	0008c800 	.word	0x0008c800
   85cd0:	0008c810 	.word	0x0008c810

00085cd4 <multi_parameter_echo_command>:
/*-----------------------------------------------------------*/

static portBASE_TYPE multi_parameter_echo_command(int8_t *pcWriteBuffer,
		size_t xWriteBufferLen,
		const int8_t *pcCommandString)
{
   85cd4:	b5f0      	push	{r4, r5, r6, r7, lr}
   85cd6:	b083      	sub	sp, #12
   85cd8:	460e      	mov	r6, r1
   85cda:	4615      	mov	r5, r2
	/* Remove compile time warnings about unused parameters, and check the
	write buffer is not NULL.  NOTE - for simplicity, this example assumes the
	write buffer length is adequate, so does not check for buffer overflows. */
	(void) pcCommandString;
	(void) xWriteBufferLen;
	configASSERT(pcWriteBuffer);
   85cdc:	4604      	mov	r4, r0
   85cde:	b920      	cbnz	r0, 85cea <multi_parameter_echo_command+0x16>
   85ce0:	4820      	ldr	r0, [pc, #128]	; (85d64 <multi_parameter_echo_command+0x90>)
   85ce2:	f240 113f 	movw	r1, #319	; 0x13f
   85ce6:	4b20      	ldr	r3, [pc, #128]	; (85d68 <multi_parameter_echo_command+0x94>)
   85ce8:	4798      	blx	r3

	if (parameter_number == 0) {
   85cea:	4b20      	ldr	r3, [pc, #128]	; (85d6c <multi_parameter_echo_command+0x98>)
   85cec:	6819      	ldr	r1, [r3, #0]
   85cee:	b979      	cbnz	r1, 85d10 <multi_parameter_echo_command+0x3c>
		/* The first time the function is called after the command has been
		entered just a header string is returned. */
		sprintf((char *) pcWriteBuffer, "The parameters were:\r\n");
   85cf0:	4d1f      	ldr	r5, [pc, #124]	; (85d70 <multi_parameter_echo_command+0x9c>)
   85cf2:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
   85cf4:	6020      	str	r0, [r4, #0]
   85cf6:	6061      	str	r1, [r4, #4]
   85cf8:	60a2      	str	r2, [r4, #8]
   85cfa:	60e3      	str	r3, [r4, #12]
   85cfc:	6828      	ldr	r0, [r5, #0]
   85cfe:	6120      	str	r0, [r4, #16]
   85d00:	88aa      	ldrh	r2, [r5, #4]
   85d02:	79ab      	ldrb	r3, [r5, #6]
   85d04:	82a2      	strh	r2, [r4, #20]
   85d06:	75a3      	strb	r3, [r4, #22]

		/* Next time the function is called the first parameter will be echoed
		back. */
		parameter_number = 1L;
   85d08:	2001      	movs	r0, #1
   85d0a:	4b18      	ldr	r3, [pc, #96]	; (85d6c <multi_parameter_echo_command+0x98>)
   85d0c:	6018      	str	r0, [r3, #0]
   85d0e:	e027      	b.n	85d60 <multi_parameter_echo_command+0x8c>
		/* There is more data to be returned as no parameters have been echoed
		back yet. */
		return_value = pdPASS;
	} else {
		/* Obtain the parameter string. */
		parameter_string = (int8_t *) FreeRTOS_CLIGetParameter
   85d10:	4628      	mov	r0, r5
   85d12:	aa01      	add	r2, sp, #4
   85d14:	4b17      	ldr	r3, [pc, #92]	; (85d74 <multi_parameter_echo_command+0xa0>)
   85d16:	4798      	blx	r3
										pcCommandString,		/* The command string itself. */
										parameter_number,		/* Return the next parameter. */
										&parameter_string_length	/* Store the parameter string length. */
									);

		if (parameter_string != NULL) {
   85d18:	4607      	mov	r7, r0
   85d1a:	b1e8      	cbz	r0, 85d58 <multi_parameter_echo_command+0x84>
			/* Return the parameter string. */
			memset(pcWriteBuffer, 0x00, xWriteBufferLen);
   85d1c:	4620      	mov	r0, r4
   85d1e:	2100      	movs	r1, #0
   85d20:	4632      	mov	r2, r6
   85d22:	4b15      	ldr	r3, [pc, #84]	; (85d78 <multi_parameter_echo_command+0xa4>)
   85d24:	4798      	blx	r3
			sprintf((char *) pcWriteBuffer, "%ld: ", parameter_number);
   85d26:	4d11      	ldr	r5, [pc, #68]	; (85d6c <multi_parameter_echo_command+0x98>)
   85d28:	4620      	mov	r0, r4
   85d2a:	4914      	ldr	r1, [pc, #80]	; (85d7c <multi_parameter_echo_command+0xa8>)
   85d2c:	682a      	ldr	r2, [r5, #0]
   85d2e:	4b14      	ldr	r3, [pc, #80]	; (85d80 <multi_parameter_echo_command+0xac>)
   85d30:	4798      	blx	r3
			strncat((char *) pcWriteBuffer, (const char *) parameter_string, parameter_string_length);
   85d32:	4620      	mov	r0, r4
   85d34:	4639      	mov	r1, r7
   85d36:	9a01      	ldr	r2, [sp, #4]
   85d38:	4b12      	ldr	r3, [pc, #72]	; (85d84 <multi_parameter_echo_command+0xb0>)
   85d3a:	4798      	blx	r3
			strncat((char *) pcWriteBuffer, "\r\n", strlen("\r\n"));
   85d3c:	4620      	mov	r0, r4
   85d3e:	4b12      	ldr	r3, [pc, #72]	; (85d88 <multi_parameter_echo_command+0xb4>)
   85d40:	4798      	blx	r3
   85d42:	1822      	adds	r2, r4, r0
   85d44:	4b11      	ldr	r3, [pc, #68]	; (85d8c <multi_parameter_echo_command+0xb8>)
   85d46:	8819      	ldrh	r1, [r3, #0]
   85d48:	789b      	ldrb	r3, [r3, #2]
   85d4a:	5221      	strh	r1, [r4, r0]
   85d4c:	7093      	strb	r3, [r2, #2]

			/* There might be more parameters to return after this one. */
			return_value = pdTRUE;
			parameter_number++;
   85d4e:	682b      	ldr	r3, [r5, #0]
   85d50:	3301      	adds	r3, #1
   85d52:	602b      	str	r3, [r5, #0]
			sprintf((char *) pcWriteBuffer, "%ld: ", parameter_number);
			strncat((char *) pcWriteBuffer, (const char *) parameter_string, parameter_string_length);
			strncat((char *) pcWriteBuffer, "\r\n", strlen("\r\n"));

			/* There might be more parameters to return after this one. */
			return_value = pdTRUE;
   85d54:	2001      	movs	r0, #1
   85d56:	e003      	b.n	85d60 <multi_parameter_echo_command+0x8c>
			parameter_number++;
		} else {
			/* No more parameters were found.  Make sure the write buffer does
			not contain a valid string. */
			pcWriteBuffer[0] = 0x00;
   85d58:	2000      	movs	r0, #0
   85d5a:	7020      	strb	r0, [r4, #0]

			/* No more data to return. */
			return_value = pdFALSE;

			/* Start over the next time this command is executed. */
			parameter_number = 0;
   85d5c:	4b03      	ldr	r3, [pc, #12]	; (85d6c <multi_parameter_echo_command+0x98>)
   85d5e:	6018      	str	r0, [r3, #0]
		}
	}

	return return_value;
}
   85d60:	b003      	add	sp, #12
   85d62:	bdf0      	pop	{r4, r5, r6, r7, pc}
   85d64:	0008c734 	.word	0x0008c734
   85d68:	00085f89 	.word	0x00085f89
   85d6c:	20075bc4 	.word	0x20075bc4
   85d70:	0008c824 	.word	0x0008c824
   85d74:	00083fb1 	.word	0x00083fb1
   85d78:	000863c1 	.word	0x000863c1
   85d7c:	0008c83c 	.word	0x0008c83c
   85d80:	00086455 	.word	0x00086455
   85d84:	00086845 	.word	0x00086845
   85d88:	000867e5 	.word	0x000867e5
   85d8c:	0008c998 	.word	0x0008c998

00085d90 <three_parameter_echo_command>:
/*-----------------------------------------------------------*/

static portBASE_TYPE three_parameter_echo_command(int8_t *pcWriteBuffer,
		size_t xWriteBufferLen,
		const int8_t *pcCommandString)
{
   85d90:	b570      	push	{r4, r5, r6, lr}
   85d92:	b082      	sub	sp, #8
   85d94:	460d      	mov	r5, r1
   85d96:	4616      	mov	r6, r2
	/* Remove compile time warnings about unused parameters, and check the
	write buffer is not NULL.  NOTE - for simplicity, this example assumes the
	write buffer length is adequate, so does not check for buffer overflows. */
	(void) pcCommandString;
	(void) xWriteBufferLen;
	configASSERT(pcWriteBuffer);
   85d98:	4604      	mov	r4, r0
   85d9a:	b918      	cbnz	r0, 85da4 <three_parameter_echo_command+0x14>
   85d9c:	4823      	ldr	r0, [pc, #140]	; (85e2c <three_parameter_echo_command+0x9c>)
   85d9e:	21fd      	movs	r1, #253	; 0xfd
   85da0:	4b23      	ldr	r3, [pc, #140]	; (85e30 <three_parameter_echo_command+0xa0>)
   85da2:	4798      	blx	r3

	if (parameter_number == 0) {
   85da4:	4b23      	ldr	r3, [pc, #140]	; (85e34 <three_parameter_echo_command+0xa4>)
   85da6:	6819      	ldr	r1, [r3, #0]
   85da8:	b979      	cbnz	r1, 85dca <three_parameter_echo_command+0x3a>
		/* The first time the function is called after the command has been
		entered just a header string is returned. */
		sprintf((char *) pcWriteBuffer,
   85daa:	4d23      	ldr	r5, [pc, #140]	; (85e38 <three_parameter_echo_command+0xa8>)
   85dac:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
   85dae:	6020      	str	r0, [r4, #0]
   85db0:	6061      	str	r1, [r4, #4]
   85db2:	60a2      	str	r2, [r4, #8]
   85db4:	60e3      	str	r3, [r4, #12]
   85db6:	cd07      	ldmia	r5!, {r0, r1, r2}
   85db8:	6120      	str	r0, [r4, #16]
   85dba:	6161      	str	r1, [r4, #20]
   85dbc:	61a2      	str	r2, [r4, #24]
   85dbe:	782b      	ldrb	r3, [r5, #0]
   85dc0:	7723      	strb	r3, [r4, #28]
				"The three parameters were:\r\n");

		/* Next time the function is called the first parameter will be echoed
		back. */
		parameter_number = 1L;
   85dc2:	2001      	movs	r0, #1
   85dc4:	4b1b      	ldr	r3, [pc, #108]	; (85e34 <three_parameter_echo_command+0xa4>)
   85dc6:	6018      	str	r0, [r3, #0]
   85dc8:	e02d      	b.n	85e26 <three_parameter_echo_command+0x96>
		/* There is more data to be returned as no parameters have been echoed
		back yet. */
		return_value = pdPASS;
	} else {
		/* Obtain the parameter string. */
		parameter_string = (int8_t *) FreeRTOS_CLIGetParameter
   85dca:	4630      	mov	r0, r6
   85dcc:	aa01      	add	r2, sp, #4
   85dce:	4b1b      	ldr	r3, [pc, #108]	; (85e3c <three_parameter_echo_command+0xac>)
   85dd0:	4798      	blx	r3
										parameter_number,		/* Return the next parameter. */
										&parameter_string_length	/* Store the parameter string length. */
									);

		/* Sanity check something was returned. */
		configASSERT(parameter_string);
   85dd2:	4606      	mov	r6, r0
   85dd4:	b920      	cbnz	r0, 85de0 <three_parameter_echo_command+0x50>
   85dd6:	4815      	ldr	r0, [pc, #84]	; (85e2c <three_parameter_echo_command+0x9c>)
   85dd8:	f44f 718b 	mov.w	r1, #278	; 0x116
   85ddc:	4b14      	ldr	r3, [pc, #80]	; (85e30 <three_parameter_echo_command+0xa0>)
   85dde:	4798      	blx	r3

		/* Return the parameter string. */
		memset(pcWriteBuffer, 0x00, xWriteBufferLen);
   85de0:	4620      	mov	r0, r4
   85de2:	2100      	movs	r1, #0
   85de4:	462a      	mov	r2, r5
   85de6:	4b16      	ldr	r3, [pc, #88]	; (85e40 <three_parameter_echo_command+0xb0>)
   85de8:	4798      	blx	r3
		sprintf((char *) pcWriteBuffer, "%ld: ", parameter_number);
   85dea:	4d12      	ldr	r5, [pc, #72]	; (85e34 <three_parameter_echo_command+0xa4>)
   85dec:	4620      	mov	r0, r4
   85dee:	4915      	ldr	r1, [pc, #84]	; (85e44 <three_parameter_echo_command+0xb4>)
   85df0:	682a      	ldr	r2, [r5, #0]
   85df2:	4b15      	ldr	r3, [pc, #84]	; (85e48 <three_parameter_echo_command+0xb8>)
   85df4:	4798      	blx	r3
		strncat((char *) pcWriteBuffer, (const char *) parameter_string,
   85df6:	4620      	mov	r0, r4
   85df8:	4631      	mov	r1, r6
   85dfa:	9a01      	ldr	r2, [sp, #4]
   85dfc:	4b13      	ldr	r3, [pc, #76]	; (85e4c <three_parameter_echo_command+0xbc>)
   85dfe:	4798      	blx	r3
				parameter_string_length);
		strncat((char *) pcWriteBuffer, "\r\n", strlen("\r\n"));
   85e00:	4620      	mov	r0, r4
   85e02:	4b13      	ldr	r3, [pc, #76]	; (85e50 <three_parameter_echo_command+0xc0>)
   85e04:	4798      	blx	r3
   85e06:	1822      	adds	r2, r4, r0
   85e08:	4b12      	ldr	r3, [pc, #72]	; (85e54 <three_parameter_echo_command+0xc4>)
   85e0a:	8819      	ldrh	r1, [r3, #0]
   85e0c:	789b      	ldrb	r3, [r3, #2]
   85e0e:	5221      	strh	r1, [r4, r0]
   85e10:	7093      	strb	r3, [r2, #2]

		/* If this is the last of the three parameters then there are no more
		strings to return after this one. */
		if (parameter_number == 3L) {
   85e12:	682b      	ldr	r3, [r5, #0]
   85e14:	2b03      	cmp	r3, #3
   85e16:	d102      	bne.n	85e1e <three_parameter_echo_command+0x8e>
			/* If this is the last of the three parameters then there are no more
			strings to return after this one. */
			return_value = pdFALSE;
			parameter_number = 0L;
   85e18:	2000      	movs	r0, #0
   85e1a:	6028      	str	r0, [r5, #0]
   85e1c:	e003      	b.n	85e26 <three_parameter_echo_command+0x96>
		} else {
			/* There are more parameters to return after this one. */
			return_value = pdTRUE;
			parameter_number++;
   85e1e:	3301      	adds	r3, #1
   85e20:	4a04      	ldr	r2, [pc, #16]	; (85e34 <three_parameter_echo_command+0xa4>)
   85e22:	6013      	str	r3, [r2, #0]
			strings to return after this one. */
			return_value = pdFALSE;
			parameter_number = 0L;
		} else {
			/* There are more parameters to return after this one. */
			return_value = pdTRUE;
   85e24:	2001      	movs	r0, #1
			parameter_number++;
		}
	}

	return return_value;
}
   85e26:	b002      	add	sp, #8
   85e28:	bd70      	pop	{r4, r5, r6, pc}
   85e2a:	bf00      	nop
   85e2c:	0008c734 	.word	0x0008c734
   85e30:	00085f89 	.word	0x00085f89
   85e34:	20075bc0 	.word	0x20075bc0
   85e38:	0008c844 	.word	0x0008c844
   85e3c:	00083fb1 	.word	0x00083fb1
   85e40:	000863c1 	.word	0x000863c1
   85e44:	0008c83c 	.word	0x0008c83c
   85e48:	00086455 	.word	0x00086455
   85e4c:	00086845 	.word	0x00086845
   85e50:	000867e5 	.word	0x000867e5
   85e54:	0008c998 	.word	0x0008c998

00085e58 <run_time_stats_command>:
/*-----------------------------------------------------------*/

static portBASE_TYPE run_time_stats_command(int8_t *pcWriteBuffer,
		size_t xWriteBufferLen,
		const int8_t *pcCommandString)
{
   85e58:	b510      	push	{r4, lr}
	/* Remove compile time warnings about unused parameters, and check the
	write buffer is not NULL.  NOTE - for simplicity, this example assumes the
	write buffer length is adequate, so does not check for buffer overflows. */
	(void) pcCommandString;
	(void) xWriteBufferLen;
	configASSERT(pcWriteBuffer);
   85e5a:	4604      	mov	r4, r0
   85e5c:	b918      	cbnz	r0, 85e66 <run_time_stats_command+0xe>
   85e5e:	4807      	ldr	r0, [pc, #28]	; (85e7c <run_time_stats_command+0x24>)
   85e60:	21e2      	movs	r1, #226	; 0xe2
   85e62:	4b07      	ldr	r3, [pc, #28]	; (85e80 <run_time_stats_command+0x28>)
   85e64:	4798      	blx	r3

	/* Generate a table of task stats. */
	strcpy((char *) pcWriteBuffer, (char *) stats_table_header);
   85e66:	4620      	mov	r0, r4
   85e68:	4906      	ldr	r1, [pc, #24]	; (85e84 <run_time_stats_command+0x2c>)
   85e6a:	2251      	movs	r2, #81	; 0x51
   85e6c:	4b06      	ldr	r3, [pc, #24]	; (85e88 <run_time_stats_command+0x30>)
   85e6e:	4798      	blx	r3
	vTaskGetRunTimeStats(pcWriteBuffer + strlen(
   85e70:	f104 0050 	add.w	r0, r4, #80	; 0x50
   85e74:	4b05      	ldr	r3, [pc, #20]	; (85e8c <run_time_stats_command+0x34>)
   85e76:	4798      	blx	r3
			(char *) stats_table_header));

	/* There is no more data to return after this single string, so return
	pdFALSE. */
	return pdFALSE;
}
   85e78:	2000      	movs	r0, #0
   85e7a:	bd10      	pop	{r4, pc}
   85e7c:	0008c734 	.word	0x0008c734
   85e80:	00085f89 	.word	0x00085f89
   85e84:	0008c864 	.word	0x0008c864
   85e88:	000862d5 	.word	0x000862d5
   85e8c:	000852b1 	.word	0x000852b1

00085e90 <task_stats_command>:
/*-----------------------------------------------------------*/

static portBASE_TYPE task_stats_command(int8_t *pcWriteBuffer,
		size_t xWriteBufferLen,
		const int8_t *pcCommandString)
{
   85e90:	b510      	push	{r4, lr}
	/* Remove compile time warnings about unused parameters, and check the
	write buffer is not NULL.  NOTE - for simplicity, this example assumes the
	write buffer length is adequate, so does not check for buffer overflows. */
	(void) pcCommandString;
	(void) xWriteBufferLen;
	configASSERT(pcWriteBuffer);
   85e92:	4604      	mov	r4, r0
   85e94:	b918      	cbnz	r0, 85e9e <task_stats_command+0xe>
   85e96:	4807      	ldr	r0, [pc, #28]	; (85eb4 <task_stats_command+0x24>)
   85e98:	21ca      	movs	r1, #202	; 0xca
   85e9a:	4b07      	ldr	r3, [pc, #28]	; (85eb8 <task_stats_command+0x28>)
   85e9c:	4798      	blx	r3

	/* Generate a table of task stats. */
	strcpy((char *) pcWriteBuffer, (char *) task_table_header);
   85e9e:	4620      	mov	r0, r4
   85ea0:	4906      	ldr	r1, [pc, #24]	; (85ebc <task_stats_command+0x2c>)
   85ea2:	225b      	movs	r2, #91	; 0x5b
   85ea4:	4b06      	ldr	r3, [pc, #24]	; (85ec0 <task_stats_command+0x30>)
   85ea6:	4798      	blx	r3
	vTaskList(pcWriteBuffer + strlen((char *) task_table_header));
   85ea8:	f104 005a 	add.w	r0, r4, #90	; 0x5a
   85eac:	4b05      	ldr	r3, [pc, #20]	; (85ec4 <task_stats_command+0x34>)
   85eae:	4798      	blx	r3

	/* There is no more data to return after this single string, so return
	pdFALSE. */
	return pdFALSE;
}
   85eb0:	2000      	movs	r0, #0
   85eb2:	bd10      	pop	{r4, pc}
   85eb4:	0008c734 	.word	0x0008c734
   85eb8:	00085f89 	.word	0x00085f89
   85ebc:	0008c8b8 	.word	0x0008c8b8
   85ec0:	000862d5 	.word	0x000862d5
   85ec4:	000851e1 	.word	0x000851e1

00085ec8 <created_task>:
}

/*-----------------------------------------------------------*/

void created_task(void *pvParameters)
{
   85ec8:	b538      	push	{r3, r4, r5, lr}
   85eca:	4605      	mov	r5, r0
	static uint8_t local_buffer[60];

	/* Cast the parameter to an appropriate type. */
	parameter_value = (int32_t)pvParameters;

	memset((void *) local_buffer, 0x00, sizeof(local_buffer));
   85ecc:	4c09      	ldr	r4, [pc, #36]	; (85ef4 <created_task+0x2c>)
   85ece:	4620      	mov	r0, r4
   85ed0:	2100      	movs	r1, #0
   85ed2:	223c      	movs	r2, #60	; 0x3c
   85ed4:	4b08      	ldr	r3, [pc, #32]	; (85ef8 <created_task+0x30>)
   85ed6:	4798      	blx	r3
	sprintf((char *) local_buffer,
   85ed8:	4620      	mov	r0, r4
   85eda:	4908      	ldr	r1, [pc, #32]	; (85efc <created_task+0x34>)
   85edc:	462a      	mov	r2, r5
   85ede:	4b08      	ldr	r3, [pc, #32]	; (85f00 <created_task+0x38>)
   85ee0:	4798      	blx	r3
#if (defined confINCLUDE_USART_CLI)
	usart_cli_output(local_buffer);
#endif

#if (defined confINCLUDE_CDC_CLI)
	cdc_cli_output(local_buffer);
   85ee2:	4620      	mov	r0, r4
   85ee4:	4b07      	ldr	r3, [pc, #28]	; (85f04 <created_task+0x3c>)
   85ee6:	4798      	blx	r3
#endif

	for (;;) {
		vTaskDelay(portMAX_DELAY);
   85ee8:	f04f 35ff 	mov.w	r5, #4294967295
   85eec:	4c06      	ldr	r4, [pc, #24]	; (85f08 <created_task+0x40>)
   85eee:	4628      	mov	r0, r5
   85ef0:	47a0      	blx	r4
   85ef2:	e7fc      	b.n	85eee <created_task+0x26>
   85ef4:	20075bc8 	.word	0x20075bc8
   85ef8:	000863c1 	.word	0x000863c1
   85efc:	0008c914 	.word	0x0008c914
   85f00:	00086455 	.word	0x00086455
   85f04:	00083d5d 	.word	0x00083d5d
   85f08:	000850f9 	.word	0x000850f9

00085f0c <vRegisterCLICommands>:
};

/*-----------------------------------------------------------*/

void vRegisterCLICommands(void)
{
   85f0c:	b510      	push	{r4, lr}
	/* Register all the command line commands defined immediately above. */
	FreeRTOS_CLIRegisterCommand(&task_stats_command_definition);
   85f0e:	4807      	ldr	r0, [pc, #28]	; (85f2c <vRegisterCLICommands+0x20>)
   85f10:	4c07      	ldr	r4, [pc, #28]	; (85f30 <vRegisterCLICommands+0x24>)
   85f12:	47a0      	blx	r4
	FreeRTOS_CLIRegisterCommand(&run_time_stats_command_definition);
   85f14:	4807      	ldr	r0, [pc, #28]	; (85f34 <vRegisterCLICommands+0x28>)
   85f16:	47a0      	blx	r4
	FreeRTOS_CLIRegisterCommand(&three_parameter_echo_command_definition);
   85f18:	4807      	ldr	r0, [pc, #28]	; (85f38 <vRegisterCLICommands+0x2c>)
   85f1a:	47a0      	blx	r4
	FreeRTOS_CLIRegisterCommand(&multi_parameter_echo_command_definition);
   85f1c:	4807      	ldr	r0, [pc, #28]	; (85f3c <vRegisterCLICommands+0x30>)
   85f1e:	47a0      	blx	r4
	FreeRTOS_CLIRegisterCommand(&create_task_command_definition);
   85f20:	4807      	ldr	r0, [pc, #28]	; (85f40 <vRegisterCLICommands+0x34>)
   85f22:	47a0      	blx	r4
	FreeRTOS_CLIRegisterCommand(&delete_task_command_definition);
   85f24:	4807      	ldr	r0, [pc, #28]	; (85f44 <vRegisterCLICommands+0x38>)
   85f26:	47a0      	blx	r4
   85f28:	bd10      	pop	{r4, pc}
   85f2a:	bf00      	nop
   85f2c:	0008cbb8 	.word	0x0008cbb8
   85f30:	00083e5d 	.word	0x00083e5d
   85f34:	0008c724 	.word	0x0008c724
   85f38:	0008cbc8 	.word	0x0008cbc8
   85f3c:	0008c704 	.word	0x0008c704
   85f40:	0008c6f4 	.word	0x0008c6f4
   85f44:	0008c714 	.word	0x0008c714

00085f48 <prvLEDTimerCallback>:
}

/*-----------------------------------------------------------*/

static void prvLEDTimerCallback(void *pvParameters)
{
   85f48:	b508      	push	{r3, lr}
	(void) pvParameters;

	/* Check other tasks. */
	#if (defined confINCLUDE_USART_ECHO_TASKS)
	{
		if (are_usart_echo_tasks_still_running() != pdPASS) {
   85f4a:	4b06      	ldr	r3, [pc, #24]	; (85f64 <prvLEDTimerCallback+0x1c>)
   85f4c:	4798      	blx	r3
		}
	}
	#endif /* configINCLUDE_TWI_EEPROM_TASK */

	/* If an error has been detected, turn the error LED on. */
	if (xStatus != pdPASS) {
   85f4e:	2801      	cmp	r0, #1
   85f50:	d003      	beq.n	85f5a <prvLEDTimerCallback+0x12>
		vParTestSetLED(mainERROR_LED, pdTRUE);
   85f52:	2001      	movs	r0, #1
   85f54:	4601      	mov	r1, r0
   85f56:	4b04      	ldr	r3, [pc, #16]	; (85f68 <prvLEDTimerCallback+0x20>)
   85f58:	4798      	blx	r3
	}

	/* Toggle an LED to show the system is executing. */
	vParTestToggleLED(mainSOFTWARE_TIMER_LED);
   85f5a:	2000      	movs	r0, #0
   85f5c:	4b03      	ldr	r3, [pc, #12]	; (85f6c <prvLEDTimerCallback+0x24>)
   85f5e:	4798      	blx	r3
   85f60:	bd08      	pop	{r3, pc}
   85f62:	bf00      	nop
   85f64:	00083b45 	.word	0x00083b45
   85f68:	00086061 	.word	0x00086061
   85f6c:	0008616d 	.word	0x0008616d

00085f70 <vApplicationMallocFailedHook>:
}

/*-----------------------------------------------------------*/

void vApplicationMallocFailedHook(void)
{
   85f70:	b508      	push	{r3, lr}
	demo application.  If heap_1.c or heap_2.c are used, then the size of the
	heap available to pvPortMalloc() is defined by configTOTAL_HEAP_SIZE in
	FreeRTOSConfig.h, and the xPortGetFreeHeapSize() API function can be used
	to query the size of free heap space that remains (although it does not
	provide information on how the remaining heap might be fragmented). */
	taskDISABLE_INTERRUPTS();
   85f72:	4b01      	ldr	r3, [pc, #4]	; (85f78 <vApplicationMallocFailedHook+0x8>)
   85f74:	4798      	blx	r3
   85f76:	e7fe      	b.n	85f76 <vApplicationMallocFailedHook+0x6>
   85f78:	00084129 	.word	0x00084129

00085f7c <vApplicationStackOverflowHook>:

/*-----------------------------------------------------------*/

void vApplicationStackOverflowHook(xTaskHandle pxTask,
		signed char *pcTaskName)
{
   85f7c:	b508      	push	{r3, lr}
	(void) pxTask;

	/* Run time stack overflow checking is performed if
	configCHECK_FOR_STACK_OVERFLOW is defined to 1 or 2.  This hook
	function is called if a stack overflow is detected. */
	taskDISABLE_INTERRUPTS();
   85f7e:	4b01      	ldr	r3, [pc, #4]	; (85f84 <vApplicationStackOverflowHook+0x8>)
   85f80:	4798      	blx	r3
   85f82:	e7fe      	b.n	85f82 <vApplicationStackOverflowHook+0x6>
   85f84:	00084129 	.word	0x00084129

00085f88 <assert_triggered>:
}

/*-----------------------------------------------------------*/

void assert_triggered(const char *file, uint32_t line)
{
   85f88:	b500      	push	{lr}
   85f8a:	b083      	sub	sp, #12
	volatile uint32_t block_var = 0, line_in;
   85f8c:	2300      	movs	r3, #0
   85f8e:	9301      	str	r3, [sp, #4]
	const char *file_in;

	/* These assignments are made to prevent the compiler optimizing the
	values away. */
	file_in = file;
	line_in = line;
   85f90:	9100      	str	r1, [sp, #0]
	(void) file_in;
	(void) line_in;
   85f92:	9b00      	ldr	r3, [sp, #0]

	taskENTER_CRITICAL();
   85f94:	4b04      	ldr	r3, [pc, #16]	; (85fa8 <assert_triggered+0x20>)
   85f96:	4798      	blx	r3
	{
		while (block_var == 0) {
   85f98:	9b01      	ldr	r3, [sp, #4]
   85f9a:	2b00      	cmp	r3, #0
   85f9c:	d0fc      	beq.n	85f98 <assert_triggered+0x10>
			/* Set block_var to a non-zero value in the debugger to
			step out of this function. */
		}
	}
	taskEXIT_CRITICAL();
   85f9e:	4b03      	ldr	r3, [pc, #12]	; (85fac <assert_triggered+0x24>)
   85fa0:	4798      	blx	r3
}
   85fa2:	b003      	add	sp, #12
   85fa4:	f85d fb04 	ldr.w	pc, [sp], #4
   85fa8:	00084139 	.word	0x00084139
   85fac:	00084159 	.word	0x00084159

00085fb0 <main>:
void vApplicationTickHook(void);

/*-----------------------------------------------------------*/

int main(void)
{
   85fb0:	b530      	push	{r4, r5, lr}
   85fb2:	b083      	sub	sp, #12
/*-----------------------------------------------------------*/

static void prvSetupHardware(void)
{
	/* ASF function to setup clocking. */
	sysclk_init();
   85fb4:	4b1b      	ldr	r3, [pc, #108]	; (86024 <main+0x74>)
   85fb6:	4798      	blx	r3
__STATIC_INLINE void NVIC_SetPriorityGrouping(uint32_t PriorityGroup)
{
  uint32_t reg_value;
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07);               /* only values 0..7 are used          */

  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
   85fb8:	4a1b      	ldr	r2, [pc, #108]	; (86028 <main+0x78>)
   85fba:	68d3      	ldr	r3, [r2, #12]
  reg_value &= ~(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk);             /* clear bits to change               */
   85fbc:	f423 63e0 	bic.w	r3, r3, #1792	; 0x700
   85fc0:	041b      	lsls	r3, r3, #16
   85fc2:	0c1b      	lsrs	r3, r3, #16
  reg_value  =  (reg_value                                 |
   85fc4:	f043 63bf 	orr.w	r3, r3, #100139008	; 0x5f80000
   85fc8:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
                ((uint32_t)0x5FA << SCB_AIRCR_VECTKEY_Pos) |
                (PriorityGroupTmp << 8));                                     /* Insert write key and priorty group */
  SCB->AIRCR =  reg_value;
   85fcc:	60d3      	str	r3, [r2, #12]

	/* Ensure all priority bits are assigned as preemption priority bits. */
	NVIC_SetPriorityGrouping(0);

	/* Atmel library function to setup for the evaluation kit being used. */
	board_init();
   85fce:	4b17      	ldr	r3, [pc, #92]	; (8602c <main+0x7c>)
   85fd0:	4798      	blx	r3

	/* Perform any initialisation required by the partest LED IO functions. */
	vParTestInitialise();
   85fd2:	4b17      	ldr	r3, [pc, #92]	; (86030 <main+0x80>)
   85fd4:	4798      	blx	r3
	/* Prepare the hardware to run this demo. */
	prvSetupHardware();

	/* Create the timer that toggles an LED to show that the system is running,
	and that the other tasks are behaving as expected. */
	xLEDTimer = xTimerCreate((const signed char * const) "LED timer",/* A text name, purely to help debugging. */
   85fd6:	4b17      	ldr	r3, [pc, #92]	; (86034 <main+0x84>)
   85fd8:	9300      	str	r3, [sp, #0]
   85fda:	4817      	ldr	r0, [pc, #92]	; (86038 <main+0x88>)
   85fdc:	21c8      	movs	r1, #200	; 0xc8
   85fde:	2201      	movs	r2, #1
   85fe0:	2300      	movs	r3, #0
   85fe2:	4c16      	ldr	r4, [pc, #88]	; (8603c <main+0x8c>)
   85fe4:	47a0      	blx	r4
							prvLEDTimerCallback			/* The function that is called each time the timer expires. */
							);

	/* Sanity check the timer's creation, then start the timer.  The timer
	will not actually start until the FreeRTOS kernel is started. */
	configASSERT(xLEDTimer);
   85fe6:	4605      	mov	r5, r0
   85fe8:	b920      	cbnz	r0, 85ff4 <main+0x44>
   85fea:	4815      	ldr	r0, [pc, #84]	; (86040 <main+0x90>)
   85fec:	f44f 71bc 	mov.w	r1, #376	; 0x178
   85ff0:	4b14      	ldr	r3, [pc, #80]	; (86044 <main+0x94>)
   85ff2:	4798      	blx	r3
	xTimerStart(xLEDTimer, mainDONT_BLOCK);
   85ff4:	4b14      	ldr	r3, [pc, #80]	; (86048 <main+0x98>)
   85ff6:	4798      	blx	r3
   85ff8:	4602      	mov	r2, r0
   85ffa:	2400      	movs	r4, #0
   85ffc:	9400      	str	r4, [sp, #0]
   85ffe:	4628      	mov	r0, r5
   86000:	4621      	mov	r1, r4
   86002:	4623      	mov	r3, r4
   86004:	4d11      	ldr	r5, [pc, #68]	; (8604c <main+0x9c>)
   86006:	47a8      	blx	r5
	}
	#endif /* confINCLUDE_USART_CLI */

	#if (defined confINCLUDE_USART_ECHO_TASKS)
	{
		create_usart_echo_test_tasks(BOARD_USART,
   86008:	4811      	ldr	r0, [pc, #68]	; (86050 <main+0xa0>)
   8600a:	21a0      	movs	r1, #160	; 0xa0
   8600c:	4622      	mov	r2, r4
   8600e:	4b11      	ldr	r3, [pc, #68]	; (86054 <main+0xa4>)
   86010:	4798      	blx	r3
	}
	#endif /* confINCLUDE_USART_CLI */

	#if (defined confINCLUDE_CDC_CLI)
	{
		create_usb_cdc_cli_task(mainCDC_CLI_TASK_STACK_SIZE,
   86012:	f44f 70a0 	mov.w	r0, #320	; 0x140
   86016:	2101      	movs	r1, #1
   86018:	4b0f      	ldr	r3, [pc, #60]	; (86058 <main+0xa8>)
   8601a:	4798      	blx	r3
				mainDEMONSTRATE_ASYNCHRONOUS_API);
	}
	#endif /* confINCLUDE_TWI_EEPROM_TASK */

	/* Start the RTOS scheduler. */
	vTaskStartScheduler();
   8601c:	4b0f      	ldr	r3, [pc, #60]	; (8605c <main+0xac>)
   8601e:	4798      	blx	r3
   86020:	e7fe      	b.n	86020 <main+0x70>
   86022:	bf00      	nop
   86024:	00080169 	.word	0x00080169
   86028:	e000ed00 	.word	0xe000ed00
   8602c:	00081e05 	.word	0x00081e05
   86030:	0008611d 	.word	0x0008611d
   86034:	00085f49 	.word	0x00085f49
   86038:	0008cbd8 	.word	0x0008cbd8
   8603c:	000858dd 	.word	0x000858dd
   86040:	0008cbe4 	.word	0x0008cbe4
   86044:	00085f89 	.word	0x00085f89
   86048:	00084e81 	.word	0x00084e81
   8604c:	00085935 	.word	0x00085935
   86050:	40098000 	.word	0x40098000
   86054:	00083aad 	.word	0x00083aad
   86058:	00083cd1 	.word	0x00083cd1
   8605c:	00084df5 	.word	0x00084df5

00086060 <vParTestSetLED>:
}

/*-----------------------------------------------------------*/

void vParTestSetLED(unsigned portBASE_TYPE uxLED, signed portBASE_TYPE xValue)
{
   86060:	b510      	push	{r4, lr}
   86062:	4604      	mov	r4, r0
	if (uxLED < partestNUM_LEDS) {
   86064:	2802      	cmp	r0, #2
   86066:	d84f      	bhi.n	86108 <vParTestSetLED+0xa8>
		if (xValue != pdFALSE) {
   86068:	b339      	cbz	r1, 860ba <vParTestSetLED+0x5a>
			/* Turn the LED on. */
			taskENTER_CRITICAL();
   8606a:	4b28      	ldr	r3, [pc, #160]	; (8610c <vParTestSetLED+0xac>)
   8606c:	4798      	blx	r3
			{
				if (xActiveStates[ uxLED ] == 0) {
   8606e:	4b28      	ldr	r3, [pc, #160]	; (86110 <vParTestSetLED+0xb0>)
   86070:	f853 3024 	ldr.w	r3, [r3, r4, lsl #2]
   86074:	b97b      	cbnz	r3, 86096 <vParTestSetLED+0x36>
					ioport_set_pin_level(ulLED[ uxLED ], IOPORT_PIN_LEVEL_LOW);
   86076:	4b27      	ldr	r3, [pc, #156]	; (86114 <vParTestSetLED+0xb4>)
   86078:	f853 2024 	ldr.w	r2, [r3, r4, lsl #2]
typedef uint32_t ioport_port_t;
typedef uint32_t ioport_port_mask_t;

__always_inline static ioport_port_t arch_ioport_pin_to_port_id(ioport_pin_t pin)
{
	return pin >> 5;
   8607c:	0953      	lsrs	r3, r2, #5
	} else {
		return (Pio *)((uintptr_t)IOPORT_BASE_ADDRESS +
		       (IOPORT_PIO_OFFSET * port));
	}
#else
	return (Pio *)((uintptr_t)IOPORT_BASE_ADDRESS +
   8607e:	f503 1300 	add.w	r3, r3, #2097152	; 0x200000
   86082:	f203 7307 	addw	r3, r3, #1799	; 0x707
   86086:	025b      	lsls	r3, r3, #9
	return arch_ioport_port_to_base(arch_ioport_pin_to_port_id(pin));
}

__always_inline static ioport_port_mask_t arch_ioport_pin_to_mask(ioport_pin_t pin)
{
	return 1U << (pin & 0x1F);
   86088:	f002 021f 	and.w	r2, r2, #31
   8608c:	2101      	movs	r1, #1
   8608e:	fa01 f202 	lsl.w	r2, r1, r2
	Pio *base = arch_ioport_pin_to_base(pin);

	if (level) {
		base->PIO_SODR = arch_ioport_pin_to_mask(pin);
	} else {
		base->PIO_CODR = arch_ioport_pin_to_mask(pin);
   86092:	635a      	str	r2, [r3, #52]	; 0x34
   86094:	e00e      	b.n	860b4 <vParTestSetLED+0x54>
				} else {
					ioport_set_pin_level(ulLED[ uxLED ], IOPORT_PIN_LEVEL_HIGH);
   86096:	4b1f      	ldr	r3, [pc, #124]	; (86114 <vParTestSetLED+0xb4>)
   86098:	f853 2024 	ldr.w	r2, [r3, r4, lsl #2]
typedef uint32_t ioport_port_t;
typedef uint32_t ioport_port_mask_t;

__always_inline static ioport_port_t arch_ioport_pin_to_port_id(ioport_pin_t pin)
{
	return pin >> 5;
   8609c:	0953      	lsrs	r3, r2, #5
	} else {
		return (Pio *)((uintptr_t)IOPORT_BASE_ADDRESS +
		       (IOPORT_PIO_OFFSET * port));
	}
#else
	return (Pio *)((uintptr_t)IOPORT_BASE_ADDRESS +
   8609e:	f503 1300 	add.w	r3, r3, #2097152	; 0x200000
   860a2:	f203 7307 	addw	r3, r3, #1799	; 0x707
   860a6:	025b      	lsls	r3, r3, #9
	return arch_ioport_port_to_base(arch_ioport_pin_to_port_id(pin));
}

__always_inline static ioport_port_mask_t arch_ioport_pin_to_mask(ioport_pin_t pin)
{
	return 1U << (pin & 0x1F);
   860a8:	f002 021f 	and.w	r2, r2, #31
   860ac:	2101      	movs	r1, #1
   860ae:	fa01 f202 	lsl.w	r2, r1, r2
		bool level)
{
	Pio *base = arch_ioport_pin_to_base(pin);

	if (level) {
		base->PIO_SODR = arch_ioport_pin_to_mask(pin);
   860b2:	631a      	str	r2, [r3, #48]	; 0x30
				}
			}
			taskEXIT_CRITICAL();
   860b4:	4b18      	ldr	r3, [pc, #96]	; (86118 <vParTestSetLED+0xb8>)
   860b6:	4798      	blx	r3
   860b8:	bd10      	pop	{r4, pc}
		} else {
			/* Turn the LED off. */
			taskENTER_CRITICAL();
   860ba:	4b14      	ldr	r3, [pc, #80]	; (8610c <vParTestSetLED+0xac>)
   860bc:	4798      	blx	r3
			{
				if (xActiveStates[ uxLED ] == 0) {
   860be:	4b14      	ldr	r3, [pc, #80]	; (86110 <vParTestSetLED+0xb0>)
   860c0:	f853 3024 	ldr.w	r3, [r3, r4, lsl #2]
   860c4:	b97b      	cbnz	r3, 860e6 <vParTestSetLED+0x86>
					ioport_set_pin_level(ulLED[ uxLED ], IOPORT_PIN_LEVEL_HIGH);
   860c6:	4b13      	ldr	r3, [pc, #76]	; (86114 <vParTestSetLED+0xb4>)
   860c8:	f853 2024 	ldr.w	r2, [r3, r4, lsl #2]
typedef uint32_t ioport_port_t;
typedef uint32_t ioport_port_mask_t;

__always_inline static ioport_port_t arch_ioport_pin_to_port_id(ioport_pin_t pin)
{
	return pin >> 5;
   860cc:	0953      	lsrs	r3, r2, #5
	} else {
		return (Pio *)((uintptr_t)IOPORT_BASE_ADDRESS +
		       (IOPORT_PIO_OFFSET * port));
	}
#else
	return (Pio *)((uintptr_t)IOPORT_BASE_ADDRESS +
   860ce:	f503 1300 	add.w	r3, r3, #2097152	; 0x200000
   860d2:	f203 7307 	addw	r3, r3, #1799	; 0x707
   860d6:	025b      	lsls	r3, r3, #9
	return arch_ioport_port_to_base(arch_ioport_pin_to_port_id(pin));
}

__always_inline static ioport_port_mask_t arch_ioport_pin_to_mask(ioport_pin_t pin)
{
	return 1U << (pin & 0x1F);
   860d8:	f002 021f 	and.w	r2, r2, #31
   860dc:	2101      	movs	r1, #1
   860de:	fa01 f202 	lsl.w	r2, r1, r2
		bool level)
{
	Pio *base = arch_ioport_pin_to_base(pin);

	if (level) {
		base->PIO_SODR = arch_ioport_pin_to_mask(pin);
   860e2:	631a      	str	r2, [r3, #48]	; 0x30
   860e4:	e00e      	b.n	86104 <vParTestSetLED+0xa4>
				} else {
					ioport_set_pin_level(ulLED[ uxLED ], IOPORT_PIN_LEVEL_LOW);
   860e6:	4b0b      	ldr	r3, [pc, #44]	; (86114 <vParTestSetLED+0xb4>)
   860e8:	f853 2024 	ldr.w	r2, [r3, r4, lsl #2]
typedef uint32_t ioport_port_t;
typedef uint32_t ioport_port_mask_t;

__always_inline static ioport_port_t arch_ioport_pin_to_port_id(ioport_pin_t pin)
{
	return pin >> 5;
   860ec:	0953      	lsrs	r3, r2, #5
	} else {
		return (Pio *)((uintptr_t)IOPORT_BASE_ADDRESS +
		       (IOPORT_PIO_OFFSET * port));
	}
#else
	return (Pio *)((uintptr_t)IOPORT_BASE_ADDRESS +
   860ee:	f503 1300 	add.w	r3, r3, #2097152	; 0x200000
   860f2:	f203 7307 	addw	r3, r3, #1799	; 0x707
   860f6:	025b      	lsls	r3, r3, #9
	return arch_ioport_port_to_base(arch_ioport_pin_to_port_id(pin));
}

__always_inline static ioport_port_mask_t arch_ioport_pin_to_mask(ioport_pin_t pin)
{
	return 1U << (pin & 0x1F);
   860f8:	f002 021f 	and.w	r2, r2, #31
   860fc:	2101      	movs	r1, #1
   860fe:	fa01 f202 	lsl.w	r2, r1, r2
	Pio *base = arch_ioport_pin_to_base(pin);

	if (level) {
		base->PIO_SODR = arch_ioport_pin_to_mask(pin);
	} else {
		base->PIO_CODR = arch_ioport_pin_to_mask(pin);
   86102:	635a      	str	r2, [r3, #52]	; 0x34
				}
			}
			taskEXIT_CRITICAL();
   86104:	4b04      	ldr	r3, [pc, #16]	; (86118 <vParTestSetLED+0xb8>)
   86106:	4798      	blx	r3
   86108:	bd10      	pop	{r4, pc}
   8610a:	bf00      	nop
   8610c:	00084139 	.word	0x00084139
   86110:	0008cbf4 	.word	0x0008cbf4
   86114:	0008cc00 	.word	0x0008cc00
   86118:	00084159 	.word	0x00084159

0008611c <vParTestInitialise>:
	= {LED0_ACTIVE_LEVEL, LED1_ACTIVE_LEVEL, LED2_ACTIVE_LEVEL};

/*-----------------------------------------------------------*/

void vParTestInitialise(void)
{
   8611c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   86120:	2400      	movs	r4, #0
	unsigned long ul;

	for (ul = 0; ul < partestNUM_LEDS; ul++) {
   86122:	4625      	mov	r5, r4
		/* Configure the LED, before ensuring it starts in the off
		state. */
		ioport_set_pin_dir(ulLED[ ul ], IOPORT_DIR_OUTPUT);
   86124:	f8df 8040 	ldr.w	r8, [pc, #64]	; 86168 <vParTestInitialise+0x4c>
        ioport_set_pin_level(ulLED[ ul ], IOPORT_PIN_LEVEL_HIGH);
		vParTestSetLED(ul, xActiveStates[ ul ]);
   86128:	4f0d      	ldr	r7, [pc, #52]	; (86160 <vParTestInitialise+0x44>)
   8612a:	4e0e      	ldr	r6, [pc, #56]	; (86164 <vParTestInitialise+0x48>)
	unsigned long ul;

	for (ul = 0; ul < partestNUM_LEDS; ul++) {
		/* Configure the LED, before ensuring it starts in the off
		state. */
		ioport_set_pin_dir(ulLED[ ul ], IOPORT_DIR_OUTPUT);
   8612c:	f854 2008 	ldr.w	r2, [r4, r8]
typedef uint32_t ioport_port_t;
typedef uint32_t ioport_port_mask_t;

__always_inline static ioport_port_t arch_ioport_pin_to_port_id(ioport_pin_t pin)
{
	return pin >> 5;
   86130:	0953      	lsrs	r3, r2, #5
	} else {
		return (Pio *)((uintptr_t)IOPORT_BASE_ADDRESS +
		       (IOPORT_PIO_OFFSET * port));
	}
#else
	return (Pio *)((uintptr_t)IOPORT_BASE_ADDRESS +
   86132:	f503 1300 	add.w	r3, r3, #2097152	; 0x200000
   86136:	f203 7307 	addw	r3, r3, #1799	; 0x707
   8613a:	025b      	lsls	r3, r3, #9
	return arch_ioport_port_to_base(arch_ioport_pin_to_port_id(pin));
}

__always_inline static ioport_port_mask_t arch_ioport_pin_to_mask(ioport_pin_t pin)
{
	return 1U << (pin & 0x1F);
   8613c:	f002 021f 	and.w	r2, r2, #31
   86140:	2101      	movs	r1, #1
   86142:	fa01 f202 	lsl.w	r2, r1, r2
		enum ioport_direction dir)
{
	Pio *base = arch_ioport_pin_to_base(pin);

	if (dir == IOPORT_DIR_OUTPUT) {
		base->PIO_OER = arch_ioport_pin_to_mask(pin);
   86146:	611a      	str	r2, [r3, #16]
	} else if (dir == IOPORT_DIR_INPUT) {
		base->PIO_ODR = arch_ioport_pin_to_mask(pin);
	}

	base->PIO_OWER = arch_ioport_pin_to_mask(pin);
   86148:	f8c3 20a0 	str.w	r2, [r3, #160]	; 0xa0
		bool level)
{
	Pio *base = arch_ioport_pin_to_base(pin);

	if (level) {
		base->PIO_SODR = arch_ioport_pin_to_mask(pin);
   8614c:	631a      	str	r2, [r3, #48]	; 0x30
        ioport_set_pin_level(ulLED[ ul ], IOPORT_PIN_LEVEL_HIGH);
		vParTestSetLED(ul, xActiveStates[ ul ]);
   8614e:	4628      	mov	r0, r5
   86150:	5939      	ldr	r1, [r7, r4]
   86152:	47b0      	blx	r6

void vParTestInitialise(void)
{
	unsigned long ul;

	for (ul = 0; ul < partestNUM_LEDS; ul++) {
   86154:	3501      	adds	r5, #1
   86156:	3404      	adds	r4, #4
   86158:	2d03      	cmp	r5, #3
   8615a:	d1e7      	bne.n	8612c <vParTestInitialise+0x10>
		state. */
		ioport_set_pin_dir(ulLED[ ul ], IOPORT_DIR_OUTPUT);
        ioport_set_pin_level(ulLED[ ul ], IOPORT_PIN_LEVEL_HIGH);
		vParTestSetLED(ul, xActiveStates[ ul ]);
	}
}
   8615c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   86160:	0008cbf4 	.word	0x0008cbf4
   86164:	00086061 	.word	0x00086061
   86168:	0008cc00 	.word	0x0008cc00

0008616c <vParTestToggleLED>:
}

/*-----------------------------------------------------------*/

void vParTestToggleLED(unsigned portBASE_TYPE uxLED)
{
   8616c:	b510      	push	{r4, lr}
   8616e:	4604      	mov	r4, r0
	if (uxLED < partestNUM_LEDS) {
   86170:	2802      	cmp	r0, #2
   86172:	d816      	bhi.n	861a2 <vParTestToggleLED+0x36>
		taskENTER_CRITICAL();
   86174:	4b0b      	ldr	r3, [pc, #44]	; (861a4 <vParTestToggleLED+0x38>)
   86176:	4798      	blx	r3
		{
			ioport_toggle_pin_level(ulLED[ uxLED ]);
   86178:	4b0b      	ldr	r3, [pc, #44]	; (861a8 <vParTestToggleLED+0x3c>)
   8617a:	f853 2024 	ldr.w	r2, [r3, r4, lsl #2]
typedef uint32_t ioport_port_t;
typedef uint32_t ioport_port_mask_t;

__always_inline static ioport_port_t arch_ioport_pin_to_port_id(ioport_pin_t pin)
{
	return pin >> 5;
   8617e:	0953      	lsrs	r3, r2, #5
	} else {
		return (Pio *)((uintptr_t)IOPORT_BASE_ADDRESS +
		       (IOPORT_PIO_OFFSET * port));
	}
#else
	return (Pio *)((uintptr_t)IOPORT_BASE_ADDRESS +
   86180:	f503 1300 	add.w	r3, r3, #2097152	; 0x200000
   86184:	f203 7307 	addw	r3, r3, #1799	; 0x707
   86188:	025b      	lsls	r3, r3, #9
	return arch_ioport_port_to_base(arch_ioport_pin_to_port_id(pin));
}

__always_inline static ioport_port_mask_t arch_ioport_pin_to_mask(ioport_pin_t pin)
{
	return 1U << (pin & 0x1F);
   8618a:	f002 021f 	and.w	r2, r2, #31
   8618e:	2101      	movs	r1, #1
   86190:	fa01 f202 	lsl.w	r2, r1, r2
__always_inline static void arch_ioport_toggle_pin_level(ioport_pin_t pin)
{
	Pio *port = arch_ioport_pin_to_base(pin);
	ioport_port_mask_t mask = arch_ioport_pin_to_mask(pin);

	if (port->PIO_PDSR & arch_ioport_pin_to_mask(pin)) {
   86194:	6bd9      	ldr	r1, [r3, #60]	; 0x3c
   86196:	420a      	tst	r2, r1
		port->PIO_CODR = mask;
   86198:	bf14      	ite	ne
   8619a:	635a      	strne	r2, [r3, #52]	; 0x34
	} else {
		port->PIO_SODR = mask;
   8619c:	631a      	streq	r2, [r3, #48]	; 0x30
		}
		taskEXIT_CRITICAL();
   8619e:	4b03      	ldr	r3, [pc, #12]	; (861ac <vParTestToggleLED+0x40>)
   861a0:	4798      	blx	r3
   861a2:	bd10      	pop	{r4, pc}
   861a4:	00084139 	.word	0x00084139
   861a8:	0008cc00 	.word	0x0008cc00
   861ac:	00084159 	.word	0x00084159

000861b0 <configure_timer_for_run_time_stats>:
/*-----------------------------------------------------------*/

void configure_timer_for_run_time_stats(void)
{
	/* How many clocks are there per tenth of a millisecond? */
	clocks_per_10th_ms = configCPU_CLOCK_HZ / 10000UL;
   861b0:	f242 02d0 	movw	r2, #8400	; 0x20d0
   861b4:	4b01      	ldr	r3, [pc, #4]	; (861bc <configure_timer_for_run_time_stats+0xc>)
   861b6:	601a      	str	r2, [r3, #0]
   861b8:	4770      	bx	lr
   861ba:	bf00      	nop
   861bc:	20075c04 	.word	0x20075c04

000861c0 <get_run_time_counter_value>:
}

/*-----------------------------------------------------------*/

uint32_t get_run_time_counter_value(void)
{
   861c0:	b538      	push	{r3, r4, r5, lr}
	used anyway to keep the examples simple, and to avoid reliance on a
	separate timer peripheral. */

	/* The SysTick is a down counter.  How many clocks have passed since it
	was last reloaded? */
	sys_tick_counts = sys_tick_reload_value - *current_sys_tick_count;
   861c2:	4b0f      	ldr	r3, [pc, #60]	; (86200 <get_run_time_counter_value+0x40>)
   861c4:	681d      	ldr	r5, [r3, #0]

	/* How many times has it overflowed? */
	tick_count = xTaskGetTickCountFromISR();
   861c6:	4a0f      	ldr	r2, [pc, #60]	; (86204 <get_run_time_counter_value+0x44>)
   861c8:	4790      	blx	r2
   861ca:	4604      	mov	r4, r0

	/* This is called from the context switch, so will be called from a
	critical section.  xTaskGetTickCountFromISR() contains its own critical
	section, and the ISR safe critical sections are not designed to nest,
	so reset the critical section. */
	ulReturn = portSET_INTERRUPT_MASK_FROM_ISR();
   861cc:	4a0e      	ldr	r2, [pc, #56]	; (86208 <get_run_time_counter_value+0x48>)
   861ce:	4790      	blx	r2
	(void) ulReturn;

	/* Is there a SysTick interrupt pending? */
	if ((*interrupt_ctrl_statee & sys_tick_pending_bit) != 0UL) {
   861d0:	4a0e      	ldr	r2, [pc, #56]	; (8620c <get_run_time_counter_value+0x4c>)
   861d2:	6812      	ldr	r2, [r2, #0]
   861d4:	f012 6f80 	tst.w	r2, #67108864	; 0x4000000
   861d8:	d103      	bne.n	861e2 <get_run_time_counter_value+0x22>
	used anyway to keep the examples simple, and to avoid reliance on a
	separate timer peripheral. */

	/* The SysTick is a down counter.  How many clocks have passed since it
	was last reloaded? */
	sys_tick_counts = sys_tick_reload_value - *current_sys_tick_count;
   861da:	f5c5 33a4 	rsb	r3, r5, #83968	; 0x14800
   861de:	331f      	adds	r3, #31
   861e0:	e005      	b.n	861ee <get_run_time_counter_value+0x2e>

	/* Is there a SysTick interrupt pending? */
	if ((*interrupt_ctrl_statee & sys_tick_pending_bit) != 0UL) {
		/* There is a SysTick interrupt pending, so the SysTick has overflowed
		but the tick count not yet incremented. */
		tick_count++;
   861e2:	3401      	adds	r4, #1

		/* Read the SysTick again, as the overflow might have occurred since
		it was read last. */
		sys_tick_counts = sys_tick_reload_value -
				*current_sys_tick_count;
   861e4:	4b06      	ldr	r3, [pc, #24]	; (86200 <get_run_time_counter_value+0x40>)
   861e6:	681b      	ldr	r3, [r3, #0]
		but the tick count not yet incremented. */
		tick_count++;

		/* Read the SysTick again, as the overflow might have occurred since
		it was read last. */
		sys_tick_counts = sys_tick_reload_value -
   861e8:	f5c3 33a4 	rsb	r3, r3, #83968	; 0x14800
   861ec:	331f      	adds	r3, #31
				*current_sys_tick_count;
	}

	/* Convert the tick count into tenths of a millisecond.  THIS ASSUMES
	configTICK_RATE_HZ is 1000! */
	ulReturn = (tick_count * 10UL);
   861ee:	eb04 0484 	add.w	r4, r4, r4, lsl #2

	/* Add on the number of tenths of a millisecond that have passed since
	the tick count last got updated. */
	ulReturn += (sys_tick_counts / clocks_per_10th_ms);
   861f2:	4a07      	ldr	r2, [pc, #28]	; (86210 <get_run_time_counter_value+0x50>)
   861f4:	6812      	ldr	r2, [r2, #0]
   861f6:	fbb3 f0f2 	udiv	r0, r3, r2

	return ulReturn;
}
   861fa:	eb00 0044 	add.w	r0, r0, r4, lsl #1
   861fe:	bd38      	pop	{r3, r4, r5, pc}
   86200:	e000e018 	.word	0xe000e018
   86204:	00084ea1 	.word	0x00084ea1
   86208:	00084129 	.word	0x00084129
   8620c:	e000ed04 	.word	0xe000ed04
   86210:	20075c04 	.word	0x20075c04

00086214 <atol>:
   86214:	2100      	movs	r1, #0
   86216:	220a      	movs	r2, #10
   86218:	f000 bc5c 	b.w	86ad4 <strtol>

0008621c <__libc_init_array>:
   8621c:	b570      	push	{r4, r5, r6, lr}
   8621e:	4e0f      	ldr	r6, [pc, #60]	; (8625c <__libc_init_array+0x40>)
   86220:	4d0f      	ldr	r5, [pc, #60]	; (86260 <__libc_init_array+0x44>)
   86222:	1b76      	subs	r6, r6, r5
   86224:	10b6      	asrs	r6, r6, #2
   86226:	d007      	beq.n	86238 <__libc_init_array+0x1c>
   86228:	3d04      	subs	r5, #4
   8622a:	2400      	movs	r4, #0
   8622c:	3401      	adds	r4, #1
   8622e:	f855 3f04 	ldr.w	r3, [r5, #4]!
   86232:	4798      	blx	r3
   86234:	42a6      	cmp	r6, r4
   86236:	d1f9      	bne.n	8622c <__libc_init_array+0x10>
   86238:	4e0a      	ldr	r6, [pc, #40]	; (86264 <__libc_init_array+0x48>)
   8623a:	4d0b      	ldr	r5, [pc, #44]	; (86268 <__libc_init_array+0x4c>)
   8623c:	f006 fe2a 	bl	8ce94 <_init>
   86240:	1b76      	subs	r6, r6, r5
   86242:	10b6      	asrs	r6, r6, #2
   86244:	d008      	beq.n	86258 <__libc_init_array+0x3c>
   86246:	3d04      	subs	r5, #4
   86248:	2400      	movs	r4, #0
   8624a:	3401      	adds	r4, #1
   8624c:	f855 3f04 	ldr.w	r3, [r5, #4]!
   86250:	4798      	blx	r3
   86252:	42a6      	cmp	r6, r4
   86254:	d1f9      	bne.n	8624a <__libc_init_array+0x2e>
   86256:	bd70      	pop	{r4, r5, r6, pc}
   86258:	bd70      	pop	{r4, r5, r6, pc}
   8625a:	bf00      	nop
   8625c:	0008cea0 	.word	0x0008cea0
   86260:	0008cea0 	.word	0x0008cea0
   86264:	0008cea8 	.word	0x0008cea8
   86268:	0008cea0 	.word	0x0008cea0

0008626c <memcmp>:
   8626c:	2a03      	cmp	r2, #3
   8626e:	b470      	push	{r4, r5, r6}
   86270:	d928      	bls.n	862c4 <memcmp+0x58>
   86272:	ea40 0301 	orr.w	r3, r0, r1
   86276:	079b      	lsls	r3, r3, #30
   86278:	d013      	beq.n	862a2 <memcmp+0x36>
   8627a:	7805      	ldrb	r5, [r0, #0]
   8627c:	780c      	ldrb	r4, [r1, #0]
   8627e:	42a5      	cmp	r5, r4
   86280:	d124      	bne.n	862cc <memcmp+0x60>
   86282:	3a01      	subs	r2, #1
   86284:	2300      	movs	r3, #0
   86286:	e005      	b.n	86294 <memcmp+0x28>
   86288:	f810 5f01 	ldrb.w	r5, [r0, #1]!
   8628c:	f811 4f01 	ldrb.w	r4, [r1, #1]!
   86290:	42a5      	cmp	r5, r4
   86292:	d11b      	bne.n	862cc <memcmp+0x60>
   86294:	4293      	cmp	r3, r2
   86296:	f103 0301 	add.w	r3, r3, #1
   8629a:	d1f5      	bne.n	86288 <memcmp+0x1c>
   8629c:	2000      	movs	r0, #0
   8629e:	bc70      	pop	{r4, r5, r6}
   862a0:	4770      	bx	lr
   862a2:	460c      	mov	r4, r1
   862a4:	4603      	mov	r3, r0
   862a6:	6825      	ldr	r5, [r4, #0]
   862a8:	681e      	ldr	r6, [r3, #0]
   862aa:	4621      	mov	r1, r4
   862ac:	42ae      	cmp	r6, r5
   862ae:	4618      	mov	r0, r3
   862b0:	f104 0404 	add.w	r4, r4, #4
   862b4:	f103 0304 	add.w	r3, r3, #4
   862b8:	d104      	bne.n	862c4 <memcmp+0x58>
   862ba:	3a04      	subs	r2, #4
   862bc:	2a03      	cmp	r2, #3
   862be:	4618      	mov	r0, r3
   862c0:	4621      	mov	r1, r4
   862c2:	d8f0      	bhi.n	862a6 <memcmp+0x3a>
   862c4:	2a00      	cmp	r2, #0
   862c6:	d1d8      	bne.n	8627a <memcmp+0xe>
   862c8:	4610      	mov	r0, r2
   862ca:	e7e8      	b.n	8629e <memcmp+0x32>
   862cc:	1b28      	subs	r0, r5, r4
   862ce:	bc70      	pop	{r4, r5, r6}
   862d0:	4770      	bx	lr
   862d2:	bf00      	nop

000862d4 <memcpy>:
   862d4:	4684      	mov	ip, r0
   862d6:	ea41 0300 	orr.w	r3, r1, r0
   862da:	f013 0303 	ands.w	r3, r3, #3
   862de:	d149      	bne.n	86374 <memcpy+0xa0>
   862e0:	3a40      	subs	r2, #64	; 0x40
   862e2:	d323      	bcc.n	8632c <memcpy+0x58>
   862e4:	680b      	ldr	r3, [r1, #0]
   862e6:	6003      	str	r3, [r0, #0]
   862e8:	684b      	ldr	r3, [r1, #4]
   862ea:	6043      	str	r3, [r0, #4]
   862ec:	688b      	ldr	r3, [r1, #8]
   862ee:	6083      	str	r3, [r0, #8]
   862f0:	68cb      	ldr	r3, [r1, #12]
   862f2:	60c3      	str	r3, [r0, #12]
   862f4:	690b      	ldr	r3, [r1, #16]
   862f6:	6103      	str	r3, [r0, #16]
   862f8:	694b      	ldr	r3, [r1, #20]
   862fa:	6143      	str	r3, [r0, #20]
   862fc:	698b      	ldr	r3, [r1, #24]
   862fe:	6183      	str	r3, [r0, #24]
   86300:	69cb      	ldr	r3, [r1, #28]
   86302:	61c3      	str	r3, [r0, #28]
   86304:	6a0b      	ldr	r3, [r1, #32]
   86306:	6203      	str	r3, [r0, #32]
   86308:	6a4b      	ldr	r3, [r1, #36]	; 0x24
   8630a:	6243      	str	r3, [r0, #36]	; 0x24
   8630c:	6a8b      	ldr	r3, [r1, #40]	; 0x28
   8630e:	6283      	str	r3, [r0, #40]	; 0x28
   86310:	6acb      	ldr	r3, [r1, #44]	; 0x2c
   86312:	62c3      	str	r3, [r0, #44]	; 0x2c
   86314:	6b0b      	ldr	r3, [r1, #48]	; 0x30
   86316:	6303      	str	r3, [r0, #48]	; 0x30
   86318:	6b4b      	ldr	r3, [r1, #52]	; 0x34
   8631a:	6343      	str	r3, [r0, #52]	; 0x34
   8631c:	6b8b      	ldr	r3, [r1, #56]	; 0x38
   8631e:	6383      	str	r3, [r0, #56]	; 0x38
   86320:	6bcb      	ldr	r3, [r1, #60]	; 0x3c
   86322:	63c3      	str	r3, [r0, #60]	; 0x3c
   86324:	3040      	adds	r0, #64	; 0x40
   86326:	3140      	adds	r1, #64	; 0x40
   86328:	3a40      	subs	r2, #64	; 0x40
   8632a:	d2db      	bcs.n	862e4 <memcpy+0x10>
   8632c:	3230      	adds	r2, #48	; 0x30
   8632e:	d30b      	bcc.n	86348 <memcpy+0x74>
   86330:	680b      	ldr	r3, [r1, #0]
   86332:	6003      	str	r3, [r0, #0]
   86334:	684b      	ldr	r3, [r1, #4]
   86336:	6043      	str	r3, [r0, #4]
   86338:	688b      	ldr	r3, [r1, #8]
   8633a:	6083      	str	r3, [r0, #8]
   8633c:	68cb      	ldr	r3, [r1, #12]
   8633e:	60c3      	str	r3, [r0, #12]
   86340:	3010      	adds	r0, #16
   86342:	3110      	adds	r1, #16
   86344:	3a10      	subs	r2, #16
   86346:	d2f3      	bcs.n	86330 <memcpy+0x5c>
   86348:	320c      	adds	r2, #12
   8634a:	d305      	bcc.n	86358 <memcpy+0x84>
   8634c:	f851 3b04 	ldr.w	r3, [r1], #4
   86350:	f840 3b04 	str.w	r3, [r0], #4
   86354:	3a04      	subs	r2, #4
   86356:	d2f9      	bcs.n	8634c <memcpy+0x78>
   86358:	3204      	adds	r2, #4
   8635a:	d008      	beq.n	8636e <memcpy+0x9a>
   8635c:	07d2      	lsls	r2, r2, #31
   8635e:	bf1c      	itt	ne
   86360:	f811 3b01 	ldrbne.w	r3, [r1], #1
   86364:	f800 3b01 	strbne.w	r3, [r0], #1
   86368:	d301      	bcc.n	8636e <memcpy+0x9a>
   8636a:	880b      	ldrh	r3, [r1, #0]
   8636c:	8003      	strh	r3, [r0, #0]
   8636e:	4660      	mov	r0, ip
   86370:	4770      	bx	lr
   86372:	bf00      	nop
   86374:	2a08      	cmp	r2, #8
   86376:	d313      	bcc.n	863a0 <memcpy+0xcc>
   86378:	078b      	lsls	r3, r1, #30
   8637a:	d0b1      	beq.n	862e0 <memcpy+0xc>
   8637c:	f010 0303 	ands.w	r3, r0, #3
   86380:	d0ae      	beq.n	862e0 <memcpy+0xc>
   86382:	f1c3 0304 	rsb	r3, r3, #4
   86386:	1ad2      	subs	r2, r2, r3
   86388:	07db      	lsls	r3, r3, #31
   8638a:	bf1c      	itt	ne
   8638c:	f811 3b01 	ldrbne.w	r3, [r1], #1
   86390:	f800 3b01 	strbne.w	r3, [r0], #1
   86394:	d3a4      	bcc.n	862e0 <memcpy+0xc>
   86396:	f831 3b02 	ldrh.w	r3, [r1], #2
   8639a:	f820 3b02 	strh.w	r3, [r0], #2
   8639e:	e79f      	b.n	862e0 <memcpy+0xc>
   863a0:	3a04      	subs	r2, #4
   863a2:	d3d9      	bcc.n	86358 <memcpy+0x84>
   863a4:	3a01      	subs	r2, #1
   863a6:	f811 3b01 	ldrb.w	r3, [r1], #1
   863aa:	f800 3b01 	strb.w	r3, [r0], #1
   863ae:	d2f9      	bcs.n	863a4 <memcpy+0xd0>
   863b0:	780b      	ldrb	r3, [r1, #0]
   863b2:	7003      	strb	r3, [r0, #0]
   863b4:	784b      	ldrb	r3, [r1, #1]
   863b6:	7043      	strb	r3, [r0, #1]
   863b8:	788b      	ldrb	r3, [r1, #2]
   863ba:	7083      	strb	r3, [r0, #2]
   863bc:	4660      	mov	r0, ip
   863be:	4770      	bx	lr

000863c0 <memset>:
   863c0:	b4f0      	push	{r4, r5, r6, r7}
   863c2:	0784      	lsls	r4, r0, #30
   863c4:	d043      	beq.n	8644e <memset+0x8e>
   863c6:	1e54      	subs	r4, r2, #1
   863c8:	2a00      	cmp	r2, #0
   863ca:	d03e      	beq.n	8644a <memset+0x8a>
   863cc:	b2cd      	uxtb	r5, r1
   863ce:	4603      	mov	r3, r0
   863d0:	e003      	b.n	863da <memset+0x1a>
   863d2:	1e62      	subs	r2, r4, #1
   863d4:	2c00      	cmp	r4, #0
   863d6:	d038      	beq.n	8644a <memset+0x8a>
   863d8:	4614      	mov	r4, r2
   863da:	f803 5b01 	strb.w	r5, [r3], #1
   863de:	079a      	lsls	r2, r3, #30
   863e0:	d1f7      	bne.n	863d2 <memset+0x12>
   863e2:	2c03      	cmp	r4, #3
   863e4:	d92a      	bls.n	8643c <memset+0x7c>
   863e6:	b2cd      	uxtb	r5, r1
   863e8:	ea45 2505 	orr.w	r5, r5, r5, lsl #8
   863ec:	2c0f      	cmp	r4, #15
   863ee:	ea45 4505 	orr.w	r5, r5, r5, lsl #16
   863f2:	d915      	bls.n	86420 <memset+0x60>
   863f4:	f1a4 0710 	sub.w	r7, r4, #16
   863f8:	093f      	lsrs	r7, r7, #4
   863fa:	f103 0610 	add.w	r6, r3, #16
   863fe:	eb06 1607 	add.w	r6, r6, r7, lsl #4
   86402:	461a      	mov	r2, r3
   86404:	6015      	str	r5, [r2, #0]
   86406:	6055      	str	r5, [r2, #4]
   86408:	6095      	str	r5, [r2, #8]
   8640a:	60d5      	str	r5, [r2, #12]
   8640c:	3210      	adds	r2, #16
   8640e:	42b2      	cmp	r2, r6
   86410:	d1f8      	bne.n	86404 <memset+0x44>
   86412:	f004 040f 	and.w	r4, r4, #15
   86416:	3701      	adds	r7, #1
   86418:	2c03      	cmp	r4, #3
   8641a:	eb03 1307 	add.w	r3, r3, r7, lsl #4
   8641e:	d90d      	bls.n	8643c <memset+0x7c>
   86420:	461e      	mov	r6, r3
   86422:	4622      	mov	r2, r4
   86424:	3a04      	subs	r2, #4
   86426:	2a03      	cmp	r2, #3
   86428:	f846 5b04 	str.w	r5, [r6], #4
   8642c:	d8fa      	bhi.n	86424 <memset+0x64>
   8642e:	1f22      	subs	r2, r4, #4
   86430:	f022 0203 	bic.w	r2, r2, #3
   86434:	3204      	adds	r2, #4
   86436:	4413      	add	r3, r2
   86438:	f004 0403 	and.w	r4, r4, #3
   8643c:	b12c      	cbz	r4, 8644a <memset+0x8a>
   8643e:	b2c9      	uxtb	r1, r1
   86440:	441c      	add	r4, r3
   86442:	f803 1b01 	strb.w	r1, [r3], #1
   86446:	42a3      	cmp	r3, r4
   86448:	d1fb      	bne.n	86442 <memset+0x82>
   8644a:	bcf0      	pop	{r4, r5, r6, r7}
   8644c:	4770      	bx	lr
   8644e:	4614      	mov	r4, r2
   86450:	4603      	mov	r3, r0
   86452:	e7c6      	b.n	863e2 <memset+0x22>

00086454 <sprintf>:
   86454:	b40e      	push	{r1, r2, r3}
   86456:	b5f0      	push	{r4, r5, r6, r7, lr}
   86458:	b09c      	sub	sp, #112	; 0x70
   8645a:	ac21      	add	r4, sp, #132	; 0x84
   8645c:	f854 2b04 	ldr.w	r2, [r4], #4
   86460:	490e      	ldr	r1, [pc, #56]	; (8649c <sprintf+0x48>)
   86462:	4606      	mov	r6, r0
   86464:	4623      	mov	r3, r4
   86466:	f44f 7e02 	mov.w	lr, #520	; 0x208
   8646a:	f06f 4500 	mvn.w	r5, #2147483648	; 0x80000000
   8646e:	6808      	ldr	r0, [r1, #0]
   86470:	f64f 77ff 	movw	r7, #65535	; 0xffff
   86474:	a902      	add	r1, sp, #8
   86476:	9602      	str	r6, [sp, #8]
   86478:	9606      	str	r6, [sp, #24]
   8647a:	9401      	str	r4, [sp, #4]
   8647c:	f8ad e014 	strh.w	lr, [sp, #20]
   86480:	9504      	str	r5, [sp, #16]
   86482:	9507      	str	r5, [sp, #28]
   86484:	f8ad 7016 	strh.w	r7, [sp, #22]
   86488:	f000 fb30 	bl	86aec <_svfprintf_r>
   8648c:	9b02      	ldr	r3, [sp, #8]
   8648e:	2200      	movs	r2, #0
   86490:	701a      	strb	r2, [r3, #0]
   86492:	b01c      	add	sp, #112	; 0x70
   86494:	e8bd 40f0 	ldmia.w	sp!, {r4, r5, r6, r7, lr}
   86498:	b003      	add	sp, #12
   8649a:	4770      	bx	lr
   8649c:	20070890 	.word	0x20070890

000864a0 <strcat>:
   864a0:	0783      	lsls	r3, r0, #30
   864a2:	b570      	push	{r4, r5, r6, lr}
   864a4:	4606      	mov	r6, r0
   864a6:	d11f      	bne.n	864e8 <strcat+0x48>
   864a8:	6803      	ldr	r3, [r0, #0]
   864aa:	f1a3 3201 	sub.w	r2, r3, #16843009	; 0x1010101
   864ae:	ea22 0303 	bic.w	r3, r2, r3
   864b2:	f013 3f80 	tst.w	r3, #2155905152	; 0x80808080
   864b6:	bf08      	it	eq
   864b8:	1d03      	addeq	r3, r0, #4
   864ba:	d115      	bne.n	864e8 <strcat+0x48>
   864bc:	4618      	mov	r0, r3
   864be:	f853 4b04 	ldr.w	r4, [r3], #4
   864c2:	f1a4 3501 	sub.w	r5, r4, #16843009	; 0x1010101
   864c6:	ea25 0404 	bic.w	r4, r5, r4
   864ca:	f014 3f80 	tst.w	r4, #2155905152	; 0x80808080
   864ce:	d0f5      	beq.n	864bc <strcat+0x1c>
   864d0:	7803      	ldrb	r3, [r0, #0]
   864d2:	b12b      	cbz	r3, 864e0 <strcat+0x40>
   864d4:	1c43      	adds	r3, r0, #1
   864d6:	781c      	ldrb	r4, [r3, #0]
   864d8:	4618      	mov	r0, r3
   864da:	3301      	adds	r3, #1
   864dc:	2c00      	cmp	r4, #0
   864de:	d1fa      	bne.n	864d6 <strcat+0x36>
   864e0:	f000 f922 	bl	86728 <strcpy>
   864e4:	4630      	mov	r0, r6
   864e6:	bd70      	pop	{r4, r5, r6, pc}
   864e8:	4630      	mov	r0, r6
   864ea:	e7f1      	b.n	864d0 <strcat+0x30>

000864ec <strcmp>:
   864ec:	ea40 0c01 	orr.w	ip, r0, r1
   864f0:	f01c 0f07 	tst.w	ip, #7
   864f4:	d127      	bne.n	86546 <strcmp+0x5a>
   864f6:	f1bd 0d10 	subs.w	sp, sp, #16
   864fa:	e9cd 4502 	strd	r4, r5, [sp, #8]
   864fe:	e9cd 6700 	strd	r6, r7, [sp]
   86502:	f06f 0600 	mvn.w	r6, #0
   86506:	f04f 0700 	mov.w	r7, #0
   8650a:	bf00      	nop
   8650c:	e8f0 2302 	ldrd	r2, r3, [r0], #8
   86510:	e8f1 4502 	ldrd	r4, r5, [r1], #8
   86514:	42a2      	cmp	r2, r4
   86516:	f1a2 3c01 	sub.w	ip, r2, #16843009	; 0x1010101
   8651a:	ea2c 0c02 	bic.w	ip, ip, r2
   8651e:	f00c 3c80 	and.w	ip, ip, #2155905152	; 0x80808080
   86522:	bf08      	it	eq
   86524:	f1bc 0f00 	cmpeq.w	ip, #0
   86528:	f040 80e5 	bne.w	866f6 <strcmp+0x20a>
   8652c:	42ab      	cmp	r3, r5
   8652e:	f1a3 3c01 	sub.w	ip, r3, #16843009	; 0x1010101
   86532:	ea2c 0c03 	bic.w	ip, ip, r3
   86536:	f00c 3c80 	and.w	ip, ip, #2155905152	; 0x80808080
   8653a:	bf08      	it	eq
   8653c:	f1bc 0f00 	cmpeq.w	ip, #0
   86540:	f040 80d6 	bne.w	866f0 <strcmp+0x204>
   86544:	e7e2      	b.n	8650c <strcmp+0x20>
   86546:	f010 0c03 	ands.w	ip, r0, #3
   8654a:	d021      	beq.n	86590 <strcmp+0xa4>
   8654c:	f020 0003 	bic.w	r0, r0, #3
   86550:	f850 2b04 	ldr.w	r2, [r0], #4
   86554:	ea5f 7ccc 	movs.w	ip, ip, lsl #31
   86558:	d008      	beq.n	8656c <strcmp+0x80>
   8655a:	d20f      	bcs.n	8657c <strcmp+0x90>
   8655c:	f811 cb01 	ldrb.w	ip, [r1], #1
   86560:	fa5f f392 	uxtb.w	r3, r2, ror #8
   86564:	ebb3 0c0c 	subs.w	ip, r3, ip
   86568:	d110      	bne.n	8658c <strcmp+0xa0>
   8656a:	b17b      	cbz	r3, 8658c <strcmp+0xa0>
   8656c:	f811 cb01 	ldrb.w	ip, [r1], #1
   86570:	fa5f f3a2 	uxtb.w	r3, r2, ror #16
   86574:	ebb3 0c0c 	subs.w	ip, r3, ip
   86578:	d108      	bne.n	8658c <strcmp+0xa0>
   8657a:	b13b      	cbz	r3, 8658c <strcmp+0xa0>
   8657c:	f811 cb01 	ldrb.w	ip, [r1], #1
   86580:	fa5f f3b2 	uxtb.w	r3, r2, ror #24
   86584:	ebb3 0c0c 	subs.w	ip, r3, ip
   86588:	d100      	bne.n	8658c <strcmp+0xa0>
   8658a:	b90b      	cbnz	r3, 86590 <strcmp+0xa4>
   8658c:	4660      	mov	r0, ip
   8658e:	4770      	bx	lr
   86590:	f1bd 0d10 	subs.w	sp, sp, #16
   86594:	e9cd 4502 	strd	r4, r5, [sp, #8]
   86598:	e9cd 6700 	strd	r6, r7, [sp]
   8659c:	f06f 0600 	mvn.w	r6, #0
   865a0:	f04f 0700 	mov.w	r7, #0
   865a4:	f011 0c03 	ands.w	ip, r1, #3
   865a8:	d133      	bne.n	86612 <strcmp+0x126>
   865aa:	f010 0f04 	tst.w	r0, #4
   865ae:	d00f      	beq.n	865d0 <strcmp+0xe4>
   865b0:	f850 2b04 	ldr.w	r2, [r0], #4
   865b4:	f851 4b04 	ldr.w	r4, [r1], #4
   865b8:	42a2      	cmp	r2, r4
   865ba:	f1a2 3c01 	sub.w	ip, r2, #16843009	; 0x1010101
   865be:	ea2c 0c02 	bic.w	ip, ip, r2
   865c2:	f00c 3c80 	and.w	ip, ip, #2155905152	; 0x80808080
   865c6:	bf08      	it	eq
   865c8:	f1bc 0f00 	cmpeq.w	ip, #0
   865cc:	f040 8093 	bne.w	866f6 <strcmp+0x20a>
   865d0:	f011 0f04 	tst.w	r1, #4
   865d4:	d099      	beq.n	8650a <strcmp+0x1e>
   865d6:	f851 5b04 	ldr.w	r5, [r1], #4
   865da:	bf00      	nop
   865dc:	e8f0 2302 	ldrd	r2, r3, [r0], #8
   865e0:	42aa      	cmp	r2, r5
   865e2:	f1a2 3c01 	sub.w	ip, r2, #16843009	; 0x1010101
   865e6:	ea2c 0c02 	bic.w	ip, ip, r2
   865ea:	f00c 3c80 	and.w	ip, ip, #2155905152	; 0x80808080
   865ee:	bf08      	it	eq
   865f0:	f1bc 0f00 	cmpeq.w	ip, #0
   865f4:	d179      	bne.n	866ea <strcmp+0x1fe>
   865f6:	e8f1 4502 	ldrd	r4, r5, [r1], #8
   865fa:	42a3      	cmp	r3, r4
   865fc:	f1a3 3c01 	sub.w	ip, r3, #16843009	; 0x1010101
   86600:	ea2c 0c03 	bic.w	ip, ip, r3
   86604:	f00c 3c80 	and.w	ip, ip, #2155905152	; 0x80808080
   86608:	bf08      	it	eq
   8660a:	f1bc 0f00 	cmpeq.w	ip, #0
   8660e:	d169      	bne.n	866e4 <strcmp+0x1f8>
   86610:	e7e4      	b.n	865dc <strcmp+0xf0>
   86612:	f021 0103 	bic.w	r1, r1, #3
   86616:	f1bc 0f02 	cmp.w	ip, #2
   8661a:	d020      	beq.n	8665e <strcmp+0x172>
   8661c:	da3f      	bge.n	8669e <strcmp+0x1b2>
   8661e:	f851 5b04 	ldr.w	r5, [r1], #4
   86622:	bf00      	nop
   86624:	f850 3b04 	ldr.w	r3, [r0], #4
   86628:	ea4f 2515 	mov.w	r5, r5, lsr #8
   8662c:	f1a3 3c01 	sub.w	ip, r3, #16843009	; 0x1010101
   86630:	ea2c 0c03 	bic.w	ip, ip, r3
   86634:	f00c 3c80 	and.w	ip, ip, #2155905152	; 0x80808080
   86638:	ebb7 2f0c 	cmp.w	r7, ip, lsl #8
   8663c:	ea03 2216 	and.w	r2, r3, r6, lsr #8
   86640:	bf08      	it	eq
   86642:	42aa      	cmpeq	r2, r5
   86644:	d151      	bne.n	866ea <strcmp+0x1fe>
   86646:	f851 5b04 	ldr.w	r5, [r1], #4
   8664a:	f1bc 0f00 	cmp.w	ip, #0
   8664e:	ea82 0303 	eor.w	r3, r2, r3
   86652:	ea4f 6205 	mov.w	r2, r5, lsl #24
   86656:	bf08      	it	eq
   86658:	4293      	cmpeq	r3, r2
   8665a:	d140      	bne.n	866de <strcmp+0x1f2>
   8665c:	e7e2      	b.n	86624 <strcmp+0x138>
   8665e:	f851 5b04 	ldr.w	r5, [r1], #4
   86662:	bf00      	nop
   86664:	f850 3b04 	ldr.w	r3, [r0], #4
   86668:	ea4f 4515 	mov.w	r5, r5, lsr #16
   8666c:	f1a3 3c01 	sub.w	ip, r3, #16843009	; 0x1010101
   86670:	ea2c 0c03 	bic.w	ip, ip, r3
   86674:	f00c 3c80 	and.w	ip, ip, #2155905152	; 0x80808080
   86678:	ebb7 4f0c 	cmp.w	r7, ip, lsl #16
   8667c:	ea03 4216 	and.w	r2, r3, r6, lsr #16
   86680:	bf08      	it	eq
   86682:	42aa      	cmpeq	r2, r5
   86684:	d131      	bne.n	866ea <strcmp+0x1fe>
   86686:	f851 5b04 	ldr.w	r5, [r1], #4
   8668a:	f1bc 0f00 	cmp.w	ip, #0
   8668e:	ea82 0303 	eor.w	r3, r2, r3
   86692:	ea4f 4205 	mov.w	r2, r5, lsl #16
   86696:	bf08      	it	eq
   86698:	4293      	cmpeq	r3, r2
   8669a:	d120      	bne.n	866de <strcmp+0x1f2>
   8669c:	e7e2      	b.n	86664 <strcmp+0x178>
   8669e:	f851 5b04 	ldr.w	r5, [r1], #4
   866a2:	bf00      	nop
   866a4:	f850 3b04 	ldr.w	r3, [r0], #4
   866a8:	ea4f 6515 	mov.w	r5, r5, lsr #24
   866ac:	f1a3 3c01 	sub.w	ip, r3, #16843009	; 0x1010101
   866b0:	ea2c 0c03 	bic.w	ip, ip, r3
   866b4:	f00c 3c80 	and.w	ip, ip, #2155905152	; 0x80808080
   866b8:	ebb7 6f0c 	cmp.w	r7, ip, lsl #24
   866bc:	ea03 6216 	and.w	r2, r3, r6, lsr #24
   866c0:	bf08      	it	eq
   866c2:	42aa      	cmpeq	r2, r5
   866c4:	d111      	bne.n	866ea <strcmp+0x1fe>
   866c6:	f851 5b04 	ldr.w	r5, [r1], #4
   866ca:	f1bc 0f00 	cmp.w	ip, #0
   866ce:	ea82 0303 	eor.w	r3, r2, r3
   866d2:	ea4f 2205 	mov.w	r2, r5, lsl #8
   866d6:	bf08      	it	eq
   866d8:	4293      	cmpeq	r3, r2
   866da:	d100      	bne.n	866de <strcmp+0x1f2>
   866dc:	e7e2      	b.n	866a4 <strcmp+0x1b8>
   866de:	ba19      	rev	r1, r3
   866e0:	ba12      	rev	r2, r2
   866e2:	e00a      	b.n	866fa <strcmp+0x20e>
   866e4:	ba19      	rev	r1, r3
   866e6:	ba22      	rev	r2, r4
   866e8:	e007      	b.n	866fa <strcmp+0x20e>
   866ea:	ba11      	rev	r1, r2
   866ec:	ba2a      	rev	r2, r5
   866ee:	e004      	b.n	866fa <strcmp+0x20e>
   866f0:	ba19      	rev	r1, r3
   866f2:	ba2a      	rev	r2, r5
   866f4:	e001      	b.n	866fa <strcmp+0x20e>
   866f6:	ba11      	rev	r1, r2
   866f8:	ba22      	rev	r2, r4
   866fa:	fa9c f08c 	rev.w	r0, ip
   866fe:	e9dd 6700 	ldrd	r6, r7, [sp]
   86702:	e9dd 4502 	ldrd	r4, r5, [sp, #8]
   86706:	f11d 0d10 	adds.w	sp, sp, #16
   8670a:	b138      	cbz	r0, 8671c <strcmp+0x230>
   8670c:	fab0 f080 	clz	r0, r0
   86710:	f1c0 0018 	rsb	r0, r0, #24
   86714:	fa21 f100 	lsr.w	r1, r1, r0
   86718:	fa22 f200 	lsr.w	r2, r2, r0
   8671c:	2001      	movs	r0, #1
   8671e:	4291      	cmp	r1, r2
   86720:	bf98      	it	ls
   86722:	4180      	sbcls	r0, r0
   86724:	4770      	bx	lr
   86726:	bf00      	nop

00086728 <strcpy>:
   86728:	ea80 0201 	eor.w	r2, r0, r1
   8672c:	4684      	mov	ip, r0
   8672e:	f012 0f03 	tst.w	r2, #3
   86732:	d14f      	bne.n	867d4 <strcpy+0xac>
   86734:	f011 0f03 	tst.w	r1, #3
   86738:	d132      	bne.n	867a0 <strcpy+0x78>
   8673a:	f84d 4d04 	str.w	r4, [sp, #-4]!
   8673e:	f011 0f04 	tst.w	r1, #4
   86742:	f851 3b04 	ldr.w	r3, [r1], #4
   86746:	d00b      	beq.n	86760 <strcpy+0x38>
   86748:	f1a3 3201 	sub.w	r2, r3, #16843009	; 0x1010101
   8674c:	439a      	bics	r2, r3
   8674e:	f012 3f80 	tst.w	r2, #2155905152	; 0x80808080
   86752:	bf04      	itt	eq
   86754:	f84c 3b04 	streq.w	r3, [ip], #4
   86758:	f851 3b04 	ldreq.w	r3, [r1], #4
   8675c:	d116      	bne.n	8678c <strcpy+0x64>
   8675e:	bf00      	nop
   86760:	f851 4b04 	ldr.w	r4, [r1], #4
   86764:	f1a3 3201 	sub.w	r2, r3, #16843009	; 0x1010101
   86768:	439a      	bics	r2, r3
   8676a:	f012 3f80 	tst.w	r2, #2155905152	; 0x80808080
   8676e:	f1a4 3201 	sub.w	r2, r4, #16843009	; 0x1010101
   86772:	d10b      	bne.n	8678c <strcpy+0x64>
   86774:	f84c 3b04 	str.w	r3, [ip], #4
   86778:	43a2      	bics	r2, r4
   8677a:	f012 3f80 	tst.w	r2, #2155905152	; 0x80808080
   8677e:	bf04      	itt	eq
   86780:	f851 3b04 	ldreq.w	r3, [r1], #4
   86784:	f84c 4b04 	streq.w	r4, [ip], #4
   86788:	d0ea      	beq.n	86760 <strcpy+0x38>
   8678a:	4623      	mov	r3, r4
   8678c:	f80c 3b01 	strb.w	r3, [ip], #1
   86790:	f013 0fff 	tst.w	r3, #255	; 0xff
   86794:	ea4f 2333 	mov.w	r3, r3, ror #8
   86798:	d1f8      	bne.n	8678c <strcpy+0x64>
   8679a:	f85d 4b04 	ldr.w	r4, [sp], #4
   8679e:	4770      	bx	lr
   867a0:	f011 0f01 	tst.w	r1, #1
   867a4:	d006      	beq.n	867b4 <strcpy+0x8c>
   867a6:	f811 2b01 	ldrb.w	r2, [r1], #1
   867aa:	f80c 2b01 	strb.w	r2, [ip], #1
   867ae:	2a00      	cmp	r2, #0
   867b0:	bf08      	it	eq
   867b2:	4770      	bxeq	lr
   867b4:	f011 0f02 	tst.w	r1, #2
   867b8:	d0bf      	beq.n	8673a <strcpy+0x12>
   867ba:	f831 2b02 	ldrh.w	r2, [r1], #2
   867be:	f012 0fff 	tst.w	r2, #255	; 0xff
   867c2:	bf16      	itet	ne
   867c4:	f82c 2b02 	strhne.w	r2, [ip], #2
   867c8:	f88c 2000 	strbeq.w	r2, [ip]
   867cc:	f412 4f7f 	tstne.w	r2, #65280	; 0xff00
   867d0:	d1b3      	bne.n	8673a <strcpy+0x12>
   867d2:	4770      	bx	lr
   867d4:	f811 2b01 	ldrb.w	r2, [r1], #1
   867d8:	f80c 2b01 	strb.w	r2, [ip], #1
   867dc:	2a00      	cmp	r2, #0
   867de:	d1f9      	bne.n	867d4 <strcpy+0xac>
   867e0:	4770      	bx	lr
   867e2:	bf00      	nop

000867e4 <strlen>:
   867e4:	f020 0103 	bic.w	r1, r0, #3
   867e8:	f010 0003 	ands.w	r0, r0, #3
   867ec:	f1c0 0000 	rsb	r0, r0, #0
   867f0:	f851 3b04 	ldr.w	r3, [r1], #4
   867f4:	f100 0c04 	add.w	ip, r0, #4
   867f8:	ea4f 0ccc 	mov.w	ip, ip, lsl #3
   867fc:	f06f 0200 	mvn.w	r2, #0
   86800:	bf1c      	itt	ne
   86802:	fa22 f20c 	lsrne.w	r2, r2, ip
   86806:	4313      	orrne	r3, r2
   86808:	f04f 0c01 	mov.w	ip, #1
   8680c:	ea4c 2c0c 	orr.w	ip, ip, ip, lsl #8
   86810:	ea4c 4c0c 	orr.w	ip, ip, ip, lsl #16
   86814:	eba3 020c 	sub.w	r2, r3, ip
   86818:	ea22 0203 	bic.w	r2, r2, r3
   8681c:	ea12 12cc 	ands.w	r2, r2, ip, lsl #7
   86820:	bf04      	itt	eq
   86822:	f851 3b04 	ldreq.w	r3, [r1], #4
   86826:	3004      	addeq	r0, #4
   86828:	d0f4      	beq.n	86814 <strlen+0x30>
   8682a:	f013 0fff 	tst.w	r3, #255	; 0xff
   8682e:	bf1f      	itttt	ne
   86830:	3001      	addne	r0, #1
   86832:	f413 4f7f 	tstne.w	r3, #65280	; 0xff00
   86836:	3001      	addne	r0, #1
   86838:	f413 0f7f 	tstne.w	r3, #16711680	; 0xff0000
   8683c:	bf18      	it	ne
   8683e:	3001      	addne	r0, #1
   86840:	4770      	bx	lr
   86842:	bf00      	nop

00086844 <strncat>:
   86844:	0783      	lsls	r3, r0, #30
   86846:	b470      	push	{r4, r5, r6}
   86848:	d12a      	bne.n	868a0 <strncat+0x5c>
   8684a:	6803      	ldr	r3, [r0, #0]
   8684c:	f1a3 3401 	sub.w	r4, r3, #16843009	; 0x1010101
   86850:	ea24 0303 	bic.w	r3, r4, r3
   86854:	f013 3f80 	tst.w	r3, #2155905152	; 0x80808080
   86858:	bf08      	it	eq
   8685a:	1d03      	addeq	r3, r0, #4
   8685c:	d120      	bne.n	868a0 <strncat+0x5c>
   8685e:	461c      	mov	r4, r3
   86860:	f853 5b04 	ldr.w	r5, [r3], #4
   86864:	f1a5 3601 	sub.w	r6, r5, #16843009	; 0x1010101
   86868:	ea26 0505 	bic.w	r5, r6, r5
   8686c:	f015 3f80 	tst.w	r5, #2155905152	; 0x80808080
   86870:	d0f5      	beq.n	8685e <strncat+0x1a>
   86872:	7823      	ldrb	r3, [r4, #0]
   86874:	b12b      	cbz	r3, 86882 <strncat+0x3e>
   86876:	1c63      	adds	r3, r4, #1
   86878:	781d      	ldrb	r5, [r3, #0]
   8687a:	461c      	mov	r4, r3
   8687c:	3301      	adds	r3, #1
   8687e:	2d00      	cmp	r5, #0
   86880:	d1fa      	bne.n	86878 <strncat+0x34>
   86882:	3c01      	subs	r4, #1
   86884:	188d      	adds	r5, r1, r2
   86886:	e005      	b.n	86894 <strncat+0x50>
   86888:	f811 3b01 	ldrb.w	r3, [r1], #1
   8688c:	f804 3f01 	strb.w	r3, [r4, #1]!
   86890:	b123      	cbz	r3, 8689c <strncat+0x58>
   86892:	b13a      	cbz	r2, 868a4 <strncat+0x60>
   86894:	42a9      	cmp	r1, r5
   86896:	f102 32ff 	add.w	r2, r2, #4294967295
   8689a:	d1f5      	bne.n	86888 <strncat+0x44>
   8689c:	bc70      	pop	{r4, r5, r6}
   8689e:	4770      	bx	lr
   868a0:	4604      	mov	r4, r0
   868a2:	e7e6      	b.n	86872 <strncat+0x2e>
   868a4:	7062      	strb	r2, [r4, #1]
   868a6:	e7f5      	b.n	86894 <strncat+0x50>

000868a8 <strncmp>:
   868a8:	b430      	push	{r4, r5}
   868aa:	2a00      	cmp	r2, #0
   868ac:	d04a      	beq.n	86944 <strncmp+0x9c>
   868ae:	ea40 0301 	orr.w	r3, r0, r1
   868b2:	f013 0303 	ands.w	r3, r3, #3
   868b6:	d12d      	bne.n	86914 <strncmp+0x6c>
   868b8:	2a03      	cmp	r2, #3
   868ba:	d92b      	bls.n	86914 <strncmp+0x6c>
   868bc:	6804      	ldr	r4, [r0, #0]
   868be:	680d      	ldr	r5, [r1, #0]
   868c0:	42ac      	cmp	r4, r5
   868c2:	d127      	bne.n	86914 <strncmp+0x6c>
   868c4:	3a04      	subs	r2, #4
   868c6:	d03d      	beq.n	86944 <strncmp+0x9c>
   868c8:	f1a4 3501 	sub.w	r5, r4, #16843009	; 0x1010101
   868cc:	ea25 0404 	bic.w	r4, r5, r4
   868d0:	f014 3f80 	tst.w	r4, #2155905152	; 0x80808080
   868d4:	d13c      	bne.n	86950 <strncmp+0xa8>
   868d6:	460c      	mov	r4, r1
   868d8:	4603      	mov	r3, r0
   868da:	e00e      	b.n	868fa <strncmp+0x52>
   868dc:	685b      	ldr	r3, [r3, #4]
   868de:	6864      	ldr	r4, [r4, #4]
   868e0:	f1a3 3501 	sub.w	r5, r3, #16843009	; 0x1010101
   868e4:	42a3      	cmp	r3, r4
   868e6:	ea25 0503 	bic.w	r5, r5, r3
   868ea:	d113      	bne.n	86914 <strncmp+0x6c>
   868ec:	3a04      	subs	r2, #4
   868ee:	d029      	beq.n	86944 <strncmp+0x9c>
   868f0:	f015 3f80 	tst.w	r5, #2155905152	; 0x80808080
   868f4:	d129      	bne.n	8694a <strncmp+0xa2>
   868f6:	4603      	mov	r3, r0
   868f8:	460c      	mov	r4, r1
   868fa:	2a03      	cmp	r2, #3
   868fc:	f100 0004 	add.w	r0, r0, #4
   86900:	f101 0104 	add.w	r1, r1, #4
   86904:	d8ea      	bhi.n	868dc <strncmp+0x34>
   86906:	1e55      	subs	r5, r2, #1
   86908:	b92a      	cbnz	r2, 86916 <strncmp+0x6e>
   8690a:	7918      	ldrb	r0, [r3, #4]
   8690c:	7922      	ldrb	r2, [r4, #4]
   8690e:	1a80      	subs	r0, r0, r2
   86910:	bc30      	pop	{r4, r5}
   86912:	4770      	bx	lr
   86914:	1e55      	subs	r5, r2, #1
   86916:	7803      	ldrb	r3, [r0, #0]
   86918:	780a      	ldrb	r2, [r1, #0]
   8691a:	4293      	cmp	r3, r2
   8691c:	d11a      	bne.n	86954 <strncmp+0xac>
   8691e:	b1dd      	cbz	r5, 86958 <strncmp+0xb0>
   86920:	b1b3      	cbz	r3, 86950 <strncmp+0xa8>
   86922:	1c6c      	adds	r4, r5, #1
   86924:	440c      	add	r4, r1
   86926:	1c8b      	adds	r3, r1, #2
   86928:	4601      	mov	r1, r0
   8692a:	e004      	b.n	86936 <strncmp+0x8e>
   8692c:	42a3      	cmp	r3, r4
   8692e:	d00c      	beq.n	8694a <strncmp+0xa2>
   86930:	3301      	adds	r3, #1
   86932:	2800      	cmp	r0, #0
   86934:	d0ec      	beq.n	86910 <strncmp+0x68>
   86936:	f811 0f01 	ldrb.w	r0, [r1, #1]!
   8693a:	f813 2c01 	ldrb.w	r2, [r3, #-1]
   8693e:	4290      	cmp	r0, r2
   86940:	d0f4      	beq.n	8692c <strncmp+0x84>
   86942:	e7e4      	b.n	8690e <strncmp+0x66>
   86944:	4610      	mov	r0, r2
   86946:	bc30      	pop	{r4, r5}
   86948:	4770      	bx	lr
   8694a:	2000      	movs	r0, #0
   8694c:	bc30      	pop	{r4, r5}
   8694e:	4770      	bx	lr
   86950:	4618      	mov	r0, r3
   86952:	e7dd      	b.n	86910 <strncmp+0x68>
   86954:	4618      	mov	r0, r3
   86956:	e7da      	b.n	8690e <strncmp+0x66>
   86958:	4628      	mov	r0, r5
   8695a:	e7d9      	b.n	86910 <strncmp+0x68>

0008695c <strncpy>:
   8695c:	ea40 0301 	orr.w	r3, r0, r1
   86960:	079b      	lsls	r3, r3, #30
   86962:	b470      	push	{r4, r5, r6}
   86964:	d12a      	bne.n	869bc <strncpy+0x60>
   86966:	2a03      	cmp	r2, #3
   86968:	d928      	bls.n	869bc <strncpy+0x60>
   8696a:	460c      	mov	r4, r1
   8696c:	4603      	mov	r3, r0
   8696e:	4621      	mov	r1, r4
   86970:	f854 5b04 	ldr.w	r5, [r4], #4
   86974:	f1a5 3601 	sub.w	r6, r5, #16843009	; 0x1010101
   86978:	ea26 0605 	bic.w	r6, r6, r5
   8697c:	f016 3f80 	tst.w	r6, #2155905152	; 0x80808080
   86980:	d105      	bne.n	8698e <strncpy+0x32>
   86982:	3a04      	subs	r2, #4
   86984:	2a03      	cmp	r2, #3
   86986:	f843 5b04 	str.w	r5, [r3], #4
   8698a:	4621      	mov	r1, r4
   8698c:	d8ef      	bhi.n	8696e <strncpy+0x12>
   8698e:	b19a      	cbz	r2, 869b8 <strncpy+0x5c>
   86990:	780c      	ldrb	r4, [r1, #0]
   86992:	3a01      	subs	r2, #1
   86994:	701c      	strb	r4, [r3, #0]
   86996:	3301      	adds	r3, #1
   86998:	b13c      	cbz	r4, 869aa <strncpy+0x4e>
   8699a:	b16a      	cbz	r2, 869b8 <strncpy+0x5c>
   8699c:	f811 4f01 	ldrb.w	r4, [r1, #1]!
   869a0:	3a01      	subs	r2, #1
   869a2:	f803 4b01 	strb.w	r4, [r3], #1
   869a6:	2c00      	cmp	r4, #0
   869a8:	d1f7      	bne.n	8699a <strncpy+0x3e>
   869aa:	b12a      	cbz	r2, 869b8 <strncpy+0x5c>
   869ac:	441a      	add	r2, r3
   869ae:	2100      	movs	r1, #0
   869b0:	f803 1b01 	strb.w	r1, [r3], #1
   869b4:	4293      	cmp	r3, r2
   869b6:	d1fb      	bne.n	869b0 <strncpy+0x54>
   869b8:	bc70      	pop	{r4, r5, r6}
   869ba:	4770      	bx	lr
   869bc:	4603      	mov	r3, r0
   869be:	e7e6      	b.n	8698e <strncpy+0x32>

000869c0 <_strtol_r>:
   869c0:	e92d 0ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp}
   869c4:	4c42      	ldr	r4, [pc, #264]	; (86ad0 <_strtol_r+0x110>)
   869c6:	b082      	sub	sp, #8
   869c8:	f8d4 c000 	ldr.w	ip, [r4]
   869cc:	9001      	str	r0, [sp, #4]
   869ce:	460e      	mov	r6, r1
   869d0:	e000      	b.n	869d4 <_strtol_r+0x14>
   869d2:	4626      	mov	r6, r4
   869d4:	4634      	mov	r4, r6
   869d6:	f814 5b01 	ldrb.w	r5, [r4], #1
   869da:	eb0c 0005 	add.w	r0, ip, r5
   869de:	7840      	ldrb	r0, [r0, #1]
   869e0:	f000 0008 	and.w	r0, r0, #8
   869e4:	f000 0aff 	and.w	sl, r0, #255	; 0xff
   869e8:	2800      	cmp	r0, #0
   869ea:	d1f2      	bne.n	869d2 <_strtol_r+0x12>
   869ec:	2d2d      	cmp	r5, #45	; 0x2d
   869ee:	d05b      	beq.n	86aa8 <_strtol_r+0xe8>
   869f0:	2d2b      	cmp	r5, #43	; 0x2b
   869f2:	bf04      	itt	eq
   869f4:	7875      	ldrbeq	r5, [r6, #1]
   869f6:	1cb4      	addeq	r4, r6, #2
   869f8:	f033 0010 	bics.w	r0, r3, #16
   869fc:	d03c      	beq.n	86a78 <_strtol_r+0xb8>
   869fe:	4699      	mov	r9, r3
   86a00:	f1ba 0f00 	cmp.w	sl, #0
   86a04:	bf0c      	ite	eq
   86a06:	f06f 4b00 	mvneq.w	fp, #2147483648	; 0x80000000
   86a0a:	f04f 4b00 	movne.w	fp, #2147483648	; 0x80000000
   86a0e:	fbbb f8f9 	udiv	r8, fp, r9
   86a12:	2700      	movs	r7, #0
   86a14:	fb09 bb18 	mls	fp, r9, r8, fp
   86a18:	4638      	mov	r0, r7
   86a1a:	e00c      	b.n	86a36 <_strtol_r+0x76>
   86a1c:	3d30      	subs	r5, #48	; 0x30
   86a1e:	42ab      	cmp	r3, r5
   86a20:	dd19      	ble.n	86a56 <_strtol_r+0x96>
   86a22:	1c7e      	adds	r6, r7, #1
   86a24:	d005      	beq.n	86a32 <_strtol_r+0x72>
   86a26:	4540      	cmp	r0, r8
   86a28:	d823      	bhi.n	86a72 <_strtol_r+0xb2>
   86a2a:	d020      	beq.n	86a6e <_strtol_r+0xae>
   86a2c:	fb09 5000 	mla	r0, r9, r0, r5
   86a30:	2701      	movs	r7, #1
   86a32:	f814 5b01 	ldrb.w	r5, [r4], #1
   86a36:	eb0c 0605 	add.w	r6, ip, r5
   86a3a:	7876      	ldrb	r6, [r6, #1]
   86a3c:	f016 0f04 	tst.w	r6, #4
   86a40:	d1ec      	bne.n	86a1c <_strtol_r+0x5c>
   86a42:	f016 0603 	ands.w	r6, r6, #3
   86a46:	d006      	beq.n	86a56 <_strtol_r+0x96>
   86a48:	2e01      	cmp	r6, #1
   86a4a:	bf14      	ite	ne
   86a4c:	2657      	movne	r6, #87	; 0x57
   86a4e:	2637      	moveq	r6, #55	; 0x37
   86a50:	1bad      	subs	r5, r5, r6
   86a52:	42ab      	cmp	r3, r5
   86a54:	dce5      	bgt.n	86a22 <_strtol_r+0x62>
   86a56:	1c7b      	adds	r3, r7, #1
   86a58:	d015      	beq.n	86a86 <_strtol_r+0xc6>
   86a5a:	f1ba 0f00 	cmp.w	sl, #0
   86a5e:	d121      	bne.n	86aa4 <_strtol_r+0xe4>
   86a60:	b10a      	cbz	r2, 86a66 <_strtol_r+0xa6>
   86a62:	b9ef      	cbnz	r7, 86aa0 <_strtol_r+0xe0>
   86a64:	6011      	str	r1, [r2, #0]
   86a66:	b002      	add	sp, #8
   86a68:	e8bd 0ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp}
   86a6c:	4770      	bx	lr
   86a6e:	455d      	cmp	r5, fp
   86a70:	dddc      	ble.n	86a2c <_strtol_r+0x6c>
   86a72:	f04f 37ff 	mov.w	r7, #4294967295
   86a76:	e7dc      	b.n	86a32 <_strtol_r+0x72>
   86a78:	2d30      	cmp	r5, #48	; 0x30
   86a7a:	d01a      	beq.n	86ab2 <_strtol_r+0xf2>
   86a7c:	2b00      	cmp	r3, #0
   86a7e:	d1be      	bne.n	869fe <_strtol_r+0x3e>
   86a80:	230a      	movs	r3, #10
   86a82:	4699      	mov	r9, r3
   86a84:	e7bc      	b.n	86a00 <_strtol_r+0x40>
   86a86:	9901      	ldr	r1, [sp, #4]
   86a88:	f1ba 0f00 	cmp.w	sl, #0
   86a8c:	f04f 0322 	mov.w	r3, #34	; 0x22
   86a90:	bf0c      	ite	eq
   86a92:	f06f 4000 	mvneq.w	r0, #2147483648	; 0x80000000
   86a96:	f04f 4000 	movne.w	r0, #2147483648	; 0x80000000
   86a9a:	600b      	str	r3, [r1, #0]
   86a9c:	2a00      	cmp	r2, #0
   86a9e:	d0e2      	beq.n	86a66 <_strtol_r+0xa6>
   86aa0:	1e61      	subs	r1, r4, #1
   86aa2:	e7df      	b.n	86a64 <_strtol_r+0xa4>
   86aa4:	4240      	negs	r0, r0
   86aa6:	e7db      	b.n	86a60 <_strtol_r+0xa0>
   86aa8:	1cb4      	adds	r4, r6, #2
   86aaa:	7875      	ldrb	r5, [r6, #1]
   86aac:	f04f 0a01 	mov.w	sl, #1
   86ab0:	e7a2      	b.n	869f8 <_strtol_r+0x38>
   86ab2:	7820      	ldrb	r0, [r4, #0]
   86ab4:	f000 00df 	and.w	r0, r0, #223	; 0xdf
   86ab8:	2858      	cmp	r0, #88	; 0x58
   86aba:	d003      	beq.n	86ac4 <_strtol_r+0x104>
   86abc:	2b00      	cmp	r3, #0
   86abe:	d19e      	bne.n	869fe <_strtol_r+0x3e>
   86ac0:	2308      	movs	r3, #8
   86ac2:	e79c      	b.n	869fe <_strtol_r+0x3e>
   86ac4:	2310      	movs	r3, #16
   86ac6:	7865      	ldrb	r5, [r4, #1]
   86ac8:	4699      	mov	r9, r3
   86aca:	3402      	adds	r4, #2
   86acc:	e798      	b.n	86a00 <_strtol_r+0x40>
   86ace:	bf00      	nop
   86ad0:	20070894 	.word	0x20070894

00086ad4 <strtol>:
   86ad4:	b430      	push	{r4, r5}
   86ad6:	4c04      	ldr	r4, [pc, #16]	; (86ae8 <strtol+0x14>)
   86ad8:	460d      	mov	r5, r1
   86ada:	4613      	mov	r3, r2
   86adc:	4601      	mov	r1, r0
   86ade:	462a      	mov	r2, r5
   86ae0:	6820      	ldr	r0, [r4, #0]
   86ae2:	bc30      	pop	{r4, r5}
   86ae4:	f7ff bf6c 	b.w	869c0 <_strtol_r>
   86ae8:	20070890 	.word	0x20070890

00086aec <_svfprintf_r>:
   86aec:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   86af0:	b0c9      	sub	sp, #292	; 0x124
   86af2:	9310      	str	r3, [sp, #64]	; 0x40
   86af4:	910c      	str	r1, [sp, #48]	; 0x30
   86af6:	4691      	mov	r9, r2
   86af8:	900d      	str	r0, [sp, #52]	; 0x34
   86afa:	f002 fb5f 	bl	891bc <_localeconv_r>
   86afe:	6800      	ldr	r0, [r0, #0]
   86b00:	9015      	str	r0, [sp, #84]	; 0x54
   86b02:	f7ff fe6f 	bl	867e4 <strlen>
   86b06:	9c0c      	ldr	r4, [sp, #48]	; 0x30
   86b08:	9018      	str	r0, [sp, #96]	; 0x60
   86b0a:	89a3      	ldrh	r3, [r4, #12]
   86b0c:	061e      	lsls	r6, r3, #24
   86b0e:	d503      	bpl.n	86b18 <_svfprintf_r+0x2c>
   86b10:	6923      	ldr	r3, [r4, #16]
   86b12:	2b00      	cmp	r3, #0
   86b14:	f001 8081 	beq.w	87c1a <_svfprintf_r+0x112e>
   86b18:	ac38      	add	r4, sp, #224	; 0xe0
   86b1a:	46a4      	mov	ip, r4
   86b1c:	9408      	str	r4, [sp, #32]
   86b1e:	942b      	str	r4, [sp, #172]	; 0xac
   86b20:	2500      	movs	r5, #0
   86b22:	2400      	movs	r4, #0
   86b24:	e9cd 4516 	strd	r4, r5, [sp, #88]	; 0x58
   86b28:	2300      	movs	r3, #0
   86b2a:	9311      	str	r3, [sp, #68]	; 0x44
   86b2c:	932d      	str	r3, [sp, #180]	; 0xb4
   86b2e:	932c      	str	r3, [sp, #176]	; 0xb0
   86b30:	931a      	str	r3, [sp, #104]	; 0x68
   86b32:	9319      	str	r3, [sp, #100]	; 0x64
   86b34:	930e      	str	r3, [sp, #56]	; 0x38
   86b36:	4666      	mov	r6, ip
   86b38:	f899 3000 	ldrb.w	r3, [r9]
   86b3c:	2b00      	cmp	r3, #0
   86b3e:	f000 80f8 	beq.w	86d32 <_svfprintf_r+0x246>
   86b42:	2b25      	cmp	r3, #37	; 0x25
   86b44:	f000 80f5 	beq.w	86d32 <_svfprintf_r+0x246>
   86b48:	f109 0201 	add.w	r2, r9, #1
   86b4c:	e001      	b.n	86b52 <_svfprintf_r+0x66>
   86b4e:	2b25      	cmp	r3, #37	; 0x25
   86b50:	d004      	beq.n	86b5c <_svfprintf_r+0x70>
   86b52:	7813      	ldrb	r3, [r2, #0]
   86b54:	4614      	mov	r4, r2
   86b56:	3201      	adds	r2, #1
   86b58:	2b00      	cmp	r3, #0
   86b5a:	d1f8      	bne.n	86b4e <_svfprintf_r+0x62>
   86b5c:	ebc9 0504 	rsb	r5, r9, r4
   86b60:	b17d      	cbz	r5, 86b82 <_svfprintf_r+0x96>
   86b62:	9b2c      	ldr	r3, [sp, #176]	; 0xb0
   86b64:	9a2d      	ldr	r2, [sp, #180]	; 0xb4
   86b66:	3301      	adds	r3, #1
   86b68:	442a      	add	r2, r5
   86b6a:	2b07      	cmp	r3, #7
   86b6c:	f8c6 9000 	str.w	r9, [r6]
   86b70:	6075      	str	r5, [r6, #4]
   86b72:	922d      	str	r2, [sp, #180]	; 0xb4
   86b74:	932c      	str	r3, [sp, #176]	; 0xb0
   86b76:	f300 80c2 	bgt.w	86cfe <_svfprintf_r+0x212>
   86b7a:	3608      	adds	r6, #8
   86b7c:	980e      	ldr	r0, [sp, #56]	; 0x38
   86b7e:	4428      	add	r0, r5
   86b80:	900e      	str	r0, [sp, #56]	; 0x38
   86b82:	7823      	ldrb	r3, [r4, #0]
   86b84:	2b00      	cmp	r3, #0
   86b86:	f000 80c2 	beq.w	86d0e <_svfprintf_r+0x222>
   86b8a:	2300      	movs	r3, #0
   86b8c:	f894 8001 	ldrb.w	r8, [r4, #1]
   86b90:	461a      	mov	r2, r3
   86b92:	f88d 308f 	strb.w	r3, [sp, #143]	; 0x8f
   86b96:	930f      	str	r3, [sp, #60]	; 0x3c
   86b98:	9309      	str	r3, [sp, #36]	; 0x24
   86b9a:	f104 0901 	add.w	r9, r4, #1
   86b9e:	f04f 34ff 	mov.w	r4, #4294967295
   86ba2:	940a      	str	r4, [sp, #40]	; 0x28
   86ba4:	f109 0901 	add.w	r9, r9, #1
   86ba8:	f1a8 0320 	sub.w	r3, r8, #32
   86bac:	2b58      	cmp	r3, #88	; 0x58
   86bae:	f200 83c5 	bhi.w	8733c <_svfprintf_r+0x850>
   86bb2:	e8df f013 	tbh	[pc, r3, lsl #1]
   86bb6:	026a      	.short	0x026a
   86bb8:	03c303c3 	.word	0x03c303c3
   86bbc:	03c30271 	.word	0x03c30271
   86bc0:	03c303c3 	.word	0x03c303c3
   86bc4:	03c303c3 	.word	0x03c303c3
   86bc8:	031403c3 	.word	0x031403c3
   86bcc:	03c30366 	.word	0x03c30366
   86bd0:	00c0009d 	.word	0x00c0009d
   86bd4:	027803c3 	.word	0x027803c3
   86bd8:	027f027f 	.word	0x027f027f
   86bdc:	027f027f 	.word	0x027f027f
   86be0:	027f027f 	.word	0x027f027f
   86be4:	027f027f 	.word	0x027f027f
   86be8:	03c3027f 	.word	0x03c3027f
   86bec:	03c303c3 	.word	0x03c303c3
   86bf0:	03c303c3 	.word	0x03c303c3
   86bf4:	03c303c3 	.word	0x03c303c3
   86bf8:	03c303c3 	.word	0x03c303c3
   86bfc:	029003c3 	.word	0x029003c3
   86c00:	03c30371 	.word	0x03c30371
   86c04:	03c30371 	.word	0x03c30371
   86c08:	03c303c3 	.word	0x03c303c3
   86c0c:	036a03c3 	.word	0x036a03c3
   86c10:	03c303c3 	.word	0x03c303c3
   86c14:	03c30078 	.word	0x03c30078
   86c18:	03c303c3 	.word	0x03c303c3
   86c1c:	03c303c3 	.word	0x03c303c3
   86c20:	03c30059 	.word	0x03c30059
   86c24:	02af03c3 	.word	0x02af03c3
   86c28:	03c303c3 	.word	0x03c303c3
   86c2c:	03c303c3 	.word	0x03c303c3
   86c30:	03c303c3 	.word	0x03c303c3
   86c34:	03c303c3 	.word	0x03c303c3
   86c38:	03c303c3 	.word	0x03c303c3
   86c3c:	03480337 	.word	0x03480337
   86c40:	03710371 	.word	0x03710371
   86c44:	02ff0371 	.word	0x02ff0371
   86c48:	03c30348 	.word	0x03c30348
   86c4c:	030803c3 	.word	0x030803c3
   86c50:	02c503c3 	.word	0x02c503c3
   86c54:	0320007c 	.word	0x0320007c
   86c58:	03c303a3 	.word	0x03c303a3
   86c5c:	03c302d9 	.word	0x03c302d9
   86c60:	03c3005f 	.word	0x03c3005f
   86c64:	00de03c3 	.word	0x00de03c3
   86c68:	f8dd c024 	ldr.w	ip, [sp, #36]	; 0x24
   86c6c:	f04c 0c10 	orr.w	ip, ip, #16
   86c70:	f8cd c024 	str.w	ip, [sp, #36]	; 0x24
   86c74:	9c09      	ldr	r4, [sp, #36]	; 0x24
   86c76:	06a2      	lsls	r2, r4, #26
   86c78:	f100 8354 	bmi.w	87324 <_svfprintf_r+0x838>
   86c7c:	9c09      	ldr	r4, [sp, #36]	; 0x24
   86c7e:	06e3      	lsls	r3, r4, #27
   86c80:	f100 85bd 	bmi.w	877fe <_svfprintf_r+0xd12>
   86c84:	f8dd c024 	ldr.w	ip, [sp, #36]	; 0x24
   86c88:	f01c 0f40 	tst.w	ip, #64	; 0x40
   86c8c:	f000 85b7 	beq.w	877fe <_svfprintf_r+0xd12>
   86c90:	f8dd c040 	ldr.w	ip, [sp, #64]	; 0x40
   86c94:	2500      	movs	r5, #0
   86c96:	f8bc 4000 	ldrh.w	r4, [ip]
   86c9a:	f10c 0c04 	add.w	ip, ip, #4
   86c9e:	2301      	movs	r3, #1
   86ca0:	f8cd c040 	str.w	ip, [sp, #64]	; 0x40
   86ca4:	e08c      	b.n	86dc0 <_svfprintf_r+0x2d4>
   86ca6:	9d09      	ldr	r5, [sp, #36]	; 0x24
   86ca8:	f045 0510 	orr.w	r5, r5, #16
   86cac:	9509      	str	r5, [sp, #36]	; 0x24
   86cae:	f8dd c024 	ldr.w	ip, [sp, #36]	; 0x24
   86cb2:	f01c 0320 	ands.w	r3, ip, #32
   86cb6:	f040 832a 	bne.w	8730e <_svfprintf_r+0x822>
   86cba:	f8dd c024 	ldr.w	ip, [sp, #36]	; 0x24
   86cbe:	f01c 0210 	ands.w	r2, ip, #16
   86cc2:	f040 85a4 	bne.w	8780e <_svfprintf_r+0xd22>
   86cc6:	f8dd c024 	ldr.w	ip, [sp, #36]	; 0x24
   86cca:	f01c 0340 	ands.w	r3, ip, #64	; 0x40
   86cce:	f000 859e 	beq.w	8780e <_svfprintf_r+0xd22>
   86cd2:	f8dd c040 	ldr.w	ip, [sp, #64]	; 0x40
   86cd6:	4613      	mov	r3, r2
   86cd8:	f8bc 4000 	ldrh.w	r4, [ip]
   86cdc:	f10c 0c04 	add.w	ip, ip, #4
   86ce0:	2500      	movs	r5, #0
   86ce2:	f8cd c040 	str.w	ip, [sp, #64]	; 0x40
   86ce6:	e06b      	b.n	86dc0 <_svfprintf_r+0x2d4>
   86ce8:	9c0f      	ldr	r4, [sp, #60]	; 0x3c
   86cea:	9310      	str	r3, [sp, #64]	; 0x40
   86cec:	4264      	negs	r4, r4
   86cee:	940f      	str	r4, [sp, #60]	; 0x3c
   86cf0:	9d09      	ldr	r5, [sp, #36]	; 0x24
   86cf2:	f045 0504 	orr.w	r5, r5, #4
   86cf6:	9509      	str	r5, [sp, #36]	; 0x24
   86cf8:	f899 8000 	ldrb.w	r8, [r9]
   86cfc:	e752      	b.n	86ba4 <_svfprintf_r+0xb8>
   86cfe:	980d      	ldr	r0, [sp, #52]	; 0x34
   86d00:	990c      	ldr	r1, [sp, #48]	; 0x30
   86d02:	aa2b      	add	r2, sp, #172	; 0xac
   86d04:	f003 fad2 	bl	8a2ac <__ssprint_r>
   86d08:	b940      	cbnz	r0, 86d1c <_svfprintf_r+0x230>
   86d0a:	ae38      	add	r6, sp, #224	; 0xe0
   86d0c:	e736      	b.n	86b7c <_svfprintf_r+0x90>
   86d0e:	9b2d      	ldr	r3, [sp, #180]	; 0xb4
   86d10:	b123      	cbz	r3, 86d1c <_svfprintf_r+0x230>
   86d12:	980d      	ldr	r0, [sp, #52]	; 0x34
   86d14:	990c      	ldr	r1, [sp, #48]	; 0x30
   86d16:	aa2b      	add	r2, sp, #172	; 0xac
   86d18:	f003 fac8 	bl	8a2ac <__ssprint_r>
   86d1c:	9c0c      	ldr	r4, [sp, #48]	; 0x30
   86d1e:	980e      	ldr	r0, [sp, #56]	; 0x38
   86d20:	89a3      	ldrh	r3, [r4, #12]
   86d22:	f013 0f40 	tst.w	r3, #64	; 0x40
   86d26:	bf18      	it	ne
   86d28:	f04f 30ff 	movne.w	r0, #4294967295
   86d2c:	b049      	add	sp, #292	; 0x124
   86d2e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   86d32:	464c      	mov	r4, r9
   86d34:	e725      	b.n	86b82 <_svfprintf_r+0x96>
   86d36:	f899 8000 	ldrb.w	r8, [r9]
   86d3a:	f109 0001 	add.w	r0, r9, #1
   86d3e:	f1b8 0f2a 	cmp.w	r8, #42	; 0x2a
   86d42:	f001 810c 	beq.w	87f5e <_svfprintf_r+0x1472>
   86d46:	f1a8 0330 	sub.w	r3, r8, #48	; 0x30
   86d4a:	2b09      	cmp	r3, #9
   86d4c:	bf98      	it	ls
   86d4e:	2100      	movls	r1, #0
   86d50:	f201 806b 	bhi.w	87e2a <_svfprintf_r+0x133e>
   86d54:	f810 8b01 	ldrb.w	r8, [r0], #1
   86d58:	eb01 0181 	add.w	r1, r1, r1, lsl #2
   86d5c:	eb03 0141 	add.w	r1, r3, r1, lsl #1
   86d60:	f1a8 0330 	sub.w	r3, r8, #48	; 0x30
   86d64:	2b09      	cmp	r3, #9
   86d66:	d9f5      	bls.n	86d54 <_svfprintf_r+0x268>
   86d68:	ea41 71e1 	orr.w	r1, r1, r1, asr #31
   86d6c:	910a      	str	r1, [sp, #40]	; 0x28
   86d6e:	4681      	mov	r9, r0
   86d70:	e71a      	b.n	86ba8 <_svfprintf_r+0xbc>
   86d72:	9d09      	ldr	r5, [sp, #36]	; 0x24
   86d74:	4ca1      	ldr	r4, [pc, #644]	; (86ffc <_svfprintf_r+0x510>)
   86d76:	06af      	lsls	r7, r5, #26
   86d78:	941a      	str	r4, [sp, #104]	; 0x68
   86d7a:	f88d 208f 	strb.w	r2, [sp, #143]	; 0x8f
   86d7e:	f140 81d1 	bpl.w	87124 <_svfprintf_r+0x638>
   86d82:	f8dd c040 	ldr.w	ip, [sp, #64]	; 0x40
   86d86:	f10c 0307 	add.w	r3, ip, #7
   86d8a:	f023 0307 	bic.w	r3, r3, #7
   86d8e:	f103 0408 	add.w	r4, r3, #8
   86d92:	9410      	str	r4, [sp, #64]	; 0x40
   86d94:	e9d3 4500 	ldrd	r4, r5, [r3]
   86d98:	f8dd c024 	ldr.w	ip, [sp, #36]	; 0x24
   86d9c:	f01c 0f01 	tst.w	ip, #1
   86da0:	f000 8462 	beq.w	87668 <_svfprintf_r+0xb7c>
   86da4:	ea54 0005 	orrs.w	r0, r4, r5
   86da8:	f000 845e 	beq.w	87668 <_svfprintf_r+0xb7c>
   86dac:	2330      	movs	r3, #48	; 0x30
   86dae:	f04c 0c02 	orr.w	ip, ip, #2
   86db2:	f88d 3090 	strb.w	r3, [sp, #144]	; 0x90
   86db6:	f88d 8091 	strb.w	r8, [sp, #145]	; 0x91
   86dba:	f8cd c024 	str.w	ip, [sp, #36]	; 0x24
   86dbe:	2302      	movs	r3, #2
   86dc0:	f04f 0a00 	mov.w	sl, #0
   86dc4:	f88d a08f 	strb.w	sl, [sp, #143]	; 0x8f
   86dc8:	990a      	ldr	r1, [sp, #40]	; 0x28
   86dca:	2900      	cmp	r1, #0
   86dcc:	db05      	blt.n	86dda <_svfprintf_r+0x2ee>
   86dce:	f8dd c024 	ldr.w	ip, [sp, #36]	; 0x24
   86dd2:	f02c 0c80 	bic.w	ip, ip, #128	; 0x80
   86dd6:	f8cd c024 	str.w	ip, [sp, #36]	; 0x24
   86dda:	ea54 0005 	orrs.w	r0, r4, r5
   86dde:	f040 82c5 	bne.w	8736c <_svfprintf_r+0x880>
   86de2:	990a      	ldr	r1, [sp, #40]	; 0x28
   86de4:	2900      	cmp	r1, #0
   86de6:	f040 82c1 	bne.w	8736c <_svfprintf_r+0x880>
   86dea:	2b00      	cmp	r3, #0
   86dec:	f040 8438 	bne.w	87660 <_svfprintf_r+0xb74>
   86df0:	f8dd c024 	ldr.w	ip, [sp, #36]	; 0x24
   86df4:	f01c 0f01 	tst.w	ip, #1
   86df8:	f000 8432 	beq.w	87660 <_svfprintf_r+0xb74>
   86dfc:	af48      	add	r7, sp, #288	; 0x120
   86dfe:	2330      	movs	r3, #48	; 0x30
   86e00:	9d08      	ldr	r5, [sp, #32]
   86e02:	f807 3d41 	strb.w	r3, [r7, #-65]!
   86e06:	1bec      	subs	r4, r5, r7
   86e08:	f8dd c028 	ldr.w	ip, [sp, #40]	; 0x28
   86e0c:	2500      	movs	r5, #0
   86e0e:	4564      	cmp	r4, ip
   86e10:	bfa8      	it	ge
   86e12:	46a4      	movge	ip, r4
   86e14:	f8cd c02c 	str.w	ip, [sp, #44]	; 0x2c
   86e18:	9514      	str	r5, [sp, #80]	; 0x50
   86e1a:	f1ba 0f00 	cmp.w	sl, #0
   86e1e:	d002      	beq.n	86e26 <_svfprintf_r+0x33a>
   86e20:	9d0b      	ldr	r5, [sp, #44]	; 0x2c
   86e22:	3501      	adds	r5, #1
   86e24:	950b      	str	r5, [sp, #44]	; 0x2c
   86e26:	9b09      	ldr	r3, [sp, #36]	; 0x24
   86e28:	f013 0302 	ands.w	r3, r3, #2
   86e2c:	9312      	str	r3, [sp, #72]	; 0x48
   86e2e:	d002      	beq.n	86e36 <_svfprintf_r+0x34a>
   86e30:	9d0b      	ldr	r5, [sp, #44]	; 0x2c
   86e32:	3502      	adds	r5, #2
   86e34:	950b      	str	r5, [sp, #44]	; 0x2c
   86e36:	f8dd c024 	ldr.w	ip, [sp, #36]	; 0x24
   86e3a:	f01c 0c84 	ands.w	ip, ip, #132	; 0x84
   86e3e:	f8cd c04c 	str.w	ip, [sp, #76]	; 0x4c
   86e42:	f040 8290 	bne.w	87366 <_svfprintf_r+0x87a>
   86e46:	9d0f      	ldr	r5, [sp, #60]	; 0x3c
   86e48:	f8dd c02c 	ldr.w	ip, [sp, #44]	; 0x2c
   86e4c:	ebcc 0b05 	rsb	fp, ip, r5
   86e50:	f1bb 0f00 	cmp.w	fp, #0
   86e54:	f340 8287 	ble.w	87366 <_svfprintf_r+0x87a>
   86e58:	f1bb 0f10 	cmp.w	fp, #16
   86e5c:	992d      	ldr	r1, [sp, #180]	; 0xb4
   86e5e:	9a2c      	ldr	r2, [sp, #176]	; 0xb0
   86e60:	f8df a1a0 	ldr.w	sl, [pc, #416]	; 87004 <_svfprintf_r+0x518>
   86e64:	dd2c      	ble.n	86ec0 <_svfprintf_r+0x3d4>
   86e66:	971b      	str	r7, [sp, #108]	; 0x6c
   86e68:	4630      	mov	r0, r6
   86e6a:	4657      	mov	r7, sl
   86e6c:	2510      	movs	r5, #16
   86e6e:	46ca      	mov	sl, r9
   86e70:	9e0c      	ldr	r6, [sp, #48]	; 0x30
   86e72:	46a1      	mov	r9, r4
   86e74:	9c0d      	ldr	r4, [sp, #52]	; 0x34
   86e76:	e006      	b.n	86e86 <_svfprintf_r+0x39a>
   86e78:	f1ab 0b10 	sub.w	fp, fp, #16
   86e7c:	f1bb 0f10 	cmp.w	fp, #16
   86e80:	f100 0008 	add.w	r0, r0, #8
   86e84:	dd17      	ble.n	86eb6 <_svfprintf_r+0x3ca>
   86e86:	3201      	adds	r2, #1
   86e88:	3110      	adds	r1, #16
   86e8a:	2a07      	cmp	r2, #7
   86e8c:	912d      	str	r1, [sp, #180]	; 0xb4
   86e8e:	922c      	str	r2, [sp, #176]	; 0xb0
   86e90:	6007      	str	r7, [r0, #0]
   86e92:	6045      	str	r5, [r0, #4]
   86e94:	ddf0      	ble.n	86e78 <_svfprintf_r+0x38c>
   86e96:	4620      	mov	r0, r4
   86e98:	4631      	mov	r1, r6
   86e9a:	aa2b      	add	r2, sp, #172	; 0xac
   86e9c:	f003 fa06 	bl	8a2ac <__ssprint_r>
   86ea0:	2800      	cmp	r0, #0
   86ea2:	f47f af3b 	bne.w	86d1c <_svfprintf_r+0x230>
   86ea6:	f1ab 0b10 	sub.w	fp, fp, #16
   86eaa:	f1bb 0f10 	cmp.w	fp, #16
   86eae:	992d      	ldr	r1, [sp, #180]	; 0xb4
   86eb0:	9a2c      	ldr	r2, [sp, #176]	; 0xb0
   86eb2:	a838      	add	r0, sp, #224	; 0xe0
   86eb4:	dce7      	bgt.n	86e86 <_svfprintf_r+0x39a>
   86eb6:	464c      	mov	r4, r9
   86eb8:	46d1      	mov	r9, sl
   86eba:	46ba      	mov	sl, r7
   86ebc:	9f1b      	ldr	r7, [sp, #108]	; 0x6c
   86ebe:	4606      	mov	r6, r0
   86ec0:	3201      	adds	r2, #1
   86ec2:	eb0b 0c01 	add.w	ip, fp, r1
   86ec6:	2a07      	cmp	r2, #7
   86ec8:	f8cd c0b4 	str.w	ip, [sp, #180]	; 0xb4
   86ecc:	922c      	str	r2, [sp, #176]	; 0xb0
   86ece:	e886 0c00 	stmia.w	r6, {sl, fp}
   86ed2:	f300 841a 	bgt.w	8770a <_svfprintf_r+0xc1e>
   86ed6:	f89d a08f 	ldrb.w	sl, [sp, #143]	; 0x8f
   86eda:	3608      	adds	r6, #8
   86edc:	f1ba 0f00 	cmp.w	sl, #0
   86ee0:	d00f      	beq.n	86f02 <_svfprintf_r+0x416>
   86ee2:	9b2c      	ldr	r3, [sp, #176]	; 0xb0
   86ee4:	f10c 0c01 	add.w	ip, ip, #1
   86ee8:	3301      	adds	r3, #1
   86eea:	f10d 018f 	add.w	r1, sp, #143	; 0x8f
   86eee:	2201      	movs	r2, #1
   86ef0:	2b07      	cmp	r3, #7
   86ef2:	f8cd c0b4 	str.w	ip, [sp, #180]	; 0xb4
   86ef6:	932c      	str	r3, [sp, #176]	; 0xb0
   86ef8:	e886 0006 	stmia.w	r6, {r1, r2}
   86efc:	f300 83a4 	bgt.w	87648 <_svfprintf_r+0xb5c>
   86f00:	3608      	adds	r6, #8
   86f02:	9b12      	ldr	r3, [sp, #72]	; 0x48
   86f04:	b173      	cbz	r3, 86f24 <_svfprintf_r+0x438>
   86f06:	9b2c      	ldr	r3, [sp, #176]	; 0xb0
   86f08:	f10c 0c02 	add.w	ip, ip, #2
   86f0c:	3301      	adds	r3, #1
   86f0e:	a924      	add	r1, sp, #144	; 0x90
   86f10:	2202      	movs	r2, #2
   86f12:	2b07      	cmp	r3, #7
   86f14:	f8cd c0b4 	str.w	ip, [sp, #180]	; 0xb4
   86f18:	932c      	str	r3, [sp, #176]	; 0xb0
   86f1a:	e886 0006 	stmia.w	r6, {r1, r2}
   86f1e:	f300 8387 	bgt.w	87630 <_svfprintf_r+0xb44>
   86f22:	3608      	adds	r6, #8
   86f24:	9d13      	ldr	r5, [sp, #76]	; 0x4c
   86f26:	2d80      	cmp	r5, #128	; 0x80
   86f28:	f000 82ca 	beq.w	874c0 <_svfprintf_r+0x9d4>
   86f2c:	9d0a      	ldr	r5, [sp, #40]	; 0x28
   86f2e:	ebc4 0a05 	rsb	sl, r4, r5
   86f32:	f1ba 0f00 	cmp.w	sl, #0
   86f36:	dd3b      	ble.n	86fb0 <_svfprintf_r+0x4c4>
   86f38:	f1ba 0f10 	cmp.w	sl, #16
   86f3c:	9b2c      	ldr	r3, [sp, #176]	; 0xb0
   86f3e:	4d30      	ldr	r5, [pc, #192]	; (87000 <_svfprintf_r+0x514>)
   86f40:	dd2b      	ble.n	86f9a <_svfprintf_r+0x4ae>
   86f42:	940a      	str	r4, [sp, #40]	; 0x28
   86f44:	4632      	mov	r2, r6
   86f46:	f04f 0b10 	mov.w	fp, #16
   86f4a:	462e      	mov	r6, r5
   86f4c:	4661      	mov	r1, ip
   86f4e:	9c0d      	ldr	r4, [sp, #52]	; 0x34
   86f50:	9d0c      	ldr	r5, [sp, #48]	; 0x30
   86f52:	e006      	b.n	86f62 <_svfprintf_r+0x476>
   86f54:	f1aa 0a10 	sub.w	sl, sl, #16
   86f58:	f1ba 0f10 	cmp.w	sl, #16
   86f5c:	f102 0208 	add.w	r2, r2, #8
   86f60:	dd17      	ble.n	86f92 <_svfprintf_r+0x4a6>
   86f62:	3301      	adds	r3, #1
   86f64:	3110      	adds	r1, #16
   86f66:	2b07      	cmp	r3, #7
   86f68:	912d      	str	r1, [sp, #180]	; 0xb4
   86f6a:	932c      	str	r3, [sp, #176]	; 0xb0
   86f6c:	e882 0840 	stmia.w	r2, {r6, fp}
   86f70:	ddf0      	ble.n	86f54 <_svfprintf_r+0x468>
   86f72:	4620      	mov	r0, r4
   86f74:	4629      	mov	r1, r5
   86f76:	aa2b      	add	r2, sp, #172	; 0xac
   86f78:	f003 f998 	bl	8a2ac <__ssprint_r>
   86f7c:	2800      	cmp	r0, #0
   86f7e:	f47f aecd 	bne.w	86d1c <_svfprintf_r+0x230>
   86f82:	f1aa 0a10 	sub.w	sl, sl, #16
   86f86:	f1ba 0f10 	cmp.w	sl, #16
   86f8a:	992d      	ldr	r1, [sp, #180]	; 0xb4
   86f8c:	9b2c      	ldr	r3, [sp, #176]	; 0xb0
   86f8e:	aa38      	add	r2, sp, #224	; 0xe0
   86f90:	dce7      	bgt.n	86f62 <_svfprintf_r+0x476>
   86f92:	9c0a      	ldr	r4, [sp, #40]	; 0x28
   86f94:	4635      	mov	r5, r6
   86f96:	468c      	mov	ip, r1
   86f98:	4616      	mov	r6, r2
   86f9a:	3301      	adds	r3, #1
   86f9c:	44d4      	add	ip, sl
   86f9e:	2b07      	cmp	r3, #7
   86fa0:	f8cd c0b4 	str.w	ip, [sp, #180]	; 0xb4
   86fa4:	932c      	str	r3, [sp, #176]	; 0xb0
   86fa6:	e886 0420 	stmia.w	r6, {r5, sl}
   86faa:	f300 8335 	bgt.w	87618 <_svfprintf_r+0xb2c>
   86fae:	3608      	adds	r6, #8
   86fb0:	9d09      	ldr	r5, [sp, #36]	; 0x24
   86fb2:	05ed      	lsls	r5, r5, #23
   86fb4:	f100 8224 	bmi.w	87400 <_svfprintf_r+0x914>
   86fb8:	9b2c      	ldr	r3, [sp, #176]	; 0xb0
   86fba:	44a4      	add	ip, r4
   86fbc:	3301      	adds	r3, #1
   86fbe:	2b07      	cmp	r3, #7
   86fc0:	f8cd c0b4 	str.w	ip, [sp, #180]	; 0xb4
   86fc4:	6037      	str	r7, [r6, #0]
   86fc6:	6074      	str	r4, [r6, #4]
   86fc8:	932c      	str	r3, [sp, #176]	; 0xb0
   86fca:	f300 830f 	bgt.w	875ec <_svfprintf_r+0xb00>
   86fce:	3608      	adds	r6, #8
   86fd0:	9c09      	ldr	r4, [sp, #36]	; 0x24
   86fd2:	0763      	lsls	r3, r4, #29
   86fd4:	d549      	bpl.n	8706a <_svfprintf_r+0x57e>
   86fd6:	9d0f      	ldr	r5, [sp, #60]	; 0x3c
   86fd8:	980b      	ldr	r0, [sp, #44]	; 0x2c
   86fda:	1a2c      	subs	r4, r5, r0
   86fdc:	2c00      	cmp	r4, #0
   86fde:	dd44      	ble.n	8706a <_svfprintf_r+0x57e>
   86fe0:	2c10      	cmp	r4, #16
   86fe2:	9b2c      	ldr	r3, [sp, #176]	; 0xb0
   86fe4:	f8df a01c 	ldr.w	sl, [pc, #28]	; 87004 <_svfprintf_r+0x518>
   86fe8:	dd2b      	ble.n	87042 <_svfprintf_r+0x556>
   86fea:	4657      	mov	r7, sl
   86fec:	2510      	movs	r5, #16
   86fee:	4662      	mov	r2, ip
   86ff0:	f8dd 8030 	ldr.w	r8, [sp, #48]	; 0x30
   86ff4:	f8dd a034 	ldr.w	sl, [sp, #52]	; 0x34
   86ff8:	e00b      	b.n	87012 <_svfprintf_r+0x526>
   86ffa:	bf00      	nop
   86ffc:	0008cc48 	.word	0x0008cc48
   87000:	0008cc14 	.word	0x0008cc14
   87004:	0008cc68 	.word	0x0008cc68
   87008:	3c10      	subs	r4, #16
   8700a:	2c10      	cmp	r4, #16
   8700c:	f106 0608 	add.w	r6, r6, #8
   87010:	dd15      	ble.n	8703e <_svfprintf_r+0x552>
   87012:	3301      	adds	r3, #1
   87014:	3210      	adds	r2, #16
   87016:	2b07      	cmp	r3, #7
   87018:	922d      	str	r2, [sp, #180]	; 0xb4
   8701a:	932c      	str	r3, [sp, #176]	; 0xb0
   8701c:	6037      	str	r7, [r6, #0]
   8701e:	6075      	str	r5, [r6, #4]
   87020:	ddf2      	ble.n	87008 <_svfprintf_r+0x51c>
   87022:	4650      	mov	r0, sl
   87024:	4641      	mov	r1, r8
   87026:	aa2b      	add	r2, sp, #172	; 0xac
   87028:	f003 f940 	bl	8a2ac <__ssprint_r>
   8702c:	2800      	cmp	r0, #0
   8702e:	f47f ae75 	bne.w	86d1c <_svfprintf_r+0x230>
   87032:	3c10      	subs	r4, #16
   87034:	2c10      	cmp	r4, #16
   87036:	9a2d      	ldr	r2, [sp, #180]	; 0xb4
   87038:	9b2c      	ldr	r3, [sp, #176]	; 0xb0
   8703a:	ae38      	add	r6, sp, #224	; 0xe0
   8703c:	dce9      	bgt.n	87012 <_svfprintf_r+0x526>
   8703e:	4694      	mov	ip, r2
   87040:	46ba      	mov	sl, r7
   87042:	3301      	adds	r3, #1
   87044:	44a4      	add	ip, r4
   87046:	2b07      	cmp	r3, #7
   87048:	f8cd c0b4 	str.w	ip, [sp, #180]	; 0xb4
   8704c:	932c      	str	r3, [sp, #176]	; 0xb0
   8704e:	f8c6 a000 	str.w	sl, [r6]
   87052:	6074      	str	r4, [r6, #4]
   87054:	dd09      	ble.n	8706a <_svfprintf_r+0x57e>
   87056:	980d      	ldr	r0, [sp, #52]	; 0x34
   87058:	990c      	ldr	r1, [sp, #48]	; 0x30
   8705a:	aa2b      	add	r2, sp, #172	; 0xac
   8705c:	f003 f926 	bl	8a2ac <__ssprint_r>
   87060:	2800      	cmp	r0, #0
   87062:	f47f ae5b 	bne.w	86d1c <_svfprintf_r+0x230>
   87066:	f8dd c0b4 	ldr.w	ip, [sp, #180]	; 0xb4
   8706a:	9c0e      	ldr	r4, [sp, #56]	; 0x38
   8706c:	980b      	ldr	r0, [sp, #44]	; 0x2c
   8706e:	9d0f      	ldr	r5, [sp, #60]	; 0x3c
   87070:	42a8      	cmp	r0, r5
   87072:	bfac      	ite	ge
   87074:	1824      	addge	r4, r4, r0
   87076:	1964      	addlt	r4, r4, r5
   87078:	940e      	str	r4, [sp, #56]	; 0x38
   8707a:	f1bc 0f00 	cmp.w	ip, #0
   8707e:	f040 82c1 	bne.w	87604 <_svfprintf_r+0xb18>
   87082:	2300      	movs	r3, #0
   87084:	932c      	str	r3, [sp, #176]	; 0xb0
   87086:	ae38      	add	r6, sp, #224	; 0xe0
   87088:	e556      	b.n	86b38 <_svfprintf_r+0x4c>
   8708a:	f899 8000 	ldrb.w	r8, [r9]
   8708e:	2a00      	cmp	r2, #0
   87090:	f47f ad88 	bne.w	86ba4 <_svfprintf_r+0xb8>
   87094:	2220      	movs	r2, #32
   87096:	e585      	b.n	86ba4 <_svfprintf_r+0xb8>
   87098:	9d09      	ldr	r5, [sp, #36]	; 0x24
   8709a:	f045 0501 	orr.w	r5, r5, #1
   8709e:	9509      	str	r5, [sp, #36]	; 0x24
   870a0:	f899 8000 	ldrb.w	r8, [r9]
   870a4:	e57e      	b.n	86ba4 <_svfprintf_r+0xb8>
   870a6:	9d09      	ldr	r5, [sp, #36]	; 0x24
   870a8:	f045 0580 	orr.w	r5, r5, #128	; 0x80
   870ac:	9509      	str	r5, [sp, #36]	; 0x24
   870ae:	f899 8000 	ldrb.w	r8, [r9]
   870b2:	e577      	b.n	86ba4 <_svfprintf_r+0xb8>
   870b4:	2400      	movs	r4, #0
   870b6:	f1a8 0330 	sub.w	r3, r8, #48	; 0x30
   870ba:	940f      	str	r4, [sp, #60]	; 0x3c
   870bc:	4621      	mov	r1, r4
   870be:	f819 8b01 	ldrb.w	r8, [r9], #1
   870c2:	eb01 0181 	add.w	r1, r1, r1, lsl #2
   870c6:	eb03 0141 	add.w	r1, r3, r1, lsl #1
   870ca:	f1a8 0330 	sub.w	r3, r8, #48	; 0x30
   870ce:	2b09      	cmp	r3, #9
   870d0:	d9f5      	bls.n	870be <_svfprintf_r+0x5d2>
   870d2:	910f      	str	r1, [sp, #60]	; 0x3c
   870d4:	e568      	b.n	86ba8 <_svfprintf_r+0xbc>
   870d6:	f8dd c024 	ldr.w	ip, [sp, #36]	; 0x24
   870da:	f88d 208f 	strb.w	r2, [sp, #143]	; 0x8f
   870de:	f04c 0c10 	orr.w	ip, ip, #16
   870e2:	f8cd c024 	str.w	ip, [sp, #36]	; 0x24
   870e6:	9c09      	ldr	r4, [sp, #36]	; 0x24
   870e8:	06a5      	lsls	r5, r4, #26
   870ea:	f140 80b2 	bpl.w	87252 <_svfprintf_r+0x766>
   870ee:	9d10      	ldr	r5, [sp, #64]	; 0x40
   870f0:	1de9      	adds	r1, r5, #7
   870f2:	f021 0107 	bic.w	r1, r1, #7
   870f6:	e9d1 2300 	ldrd	r2, r3, [r1]
   870fa:	3108      	adds	r1, #8
   870fc:	9110      	str	r1, [sp, #64]	; 0x40
   870fe:	4614      	mov	r4, r2
   87100:	461d      	mov	r5, r3
   87102:	2a00      	cmp	r2, #0
   87104:	f173 0c00 	sbcs.w	ip, r3, #0
   87108:	f2c0 8394 	blt.w	87834 <_svfprintf_r+0xd48>
   8710c:	f89d a08f 	ldrb.w	sl, [sp, #143]	; 0x8f
   87110:	2301      	movs	r3, #1
   87112:	e659      	b.n	86dc8 <_svfprintf_r+0x2dc>
   87114:	9d09      	ldr	r5, [sp, #36]	; 0x24
   87116:	4cb6      	ldr	r4, [pc, #728]	; (873f0 <_svfprintf_r+0x904>)
   87118:	06af      	lsls	r7, r5, #26
   8711a:	f88d 208f 	strb.w	r2, [sp, #143]	; 0x8f
   8711e:	941a      	str	r4, [sp, #104]	; 0x68
   87120:	f53f ae2f 	bmi.w	86d82 <_svfprintf_r+0x296>
   87124:	9d09      	ldr	r5, [sp, #36]	; 0x24
   87126:	06ed      	lsls	r5, r5, #27
   87128:	f140 8443 	bpl.w	879b2 <_svfprintf_r+0xec6>
   8712c:	f8dd c040 	ldr.w	ip, [sp, #64]	; 0x40
   87130:	2500      	movs	r5, #0
   87132:	f8dc 4000 	ldr.w	r4, [ip]
   87136:	f10c 0c04 	add.w	ip, ip, #4
   8713a:	f8cd c040 	str.w	ip, [sp, #64]	; 0x40
   8713e:	e62b      	b.n	86d98 <_svfprintf_r+0x2ac>
   87140:	f8dd c024 	ldr.w	ip, [sp, #36]	; 0x24
   87144:	f88d 208f 	strb.w	r2, [sp, #143]	; 0x8f
   87148:	f01c 0f20 	tst.w	ip, #32
   8714c:	f000 8440 	beq.w	879d0 <_svfprintf_r+0xee4>
   87150:	9c10      	ldr	r4, [sp, #64]	; 0x40
   87152:	6821      	ldr	r1, [r4, #0]
   87154:	9c0e      	ldr	r4, [sp, #56]	; 0x38
   87156:	17e5      	asrs	r5, r4, #31
   87158:	462b      	mov	r3, r5
   8715a:	9d10      	ldr	r5, [sp, #64]	; 0x40
   8715c:	4622      	mov	r2, r4
   8715e:	3504      	adds	r5, #4
   87160:	9510      	str	r5, [sp, #64]	; 0x40
   87162:	e9c1 2300 	strd	r2, r3, [r1]
   87166:	e4e7      	b.n	86b38 <_svfprintf_r+0x4c>
   87168:	9c10      	ldr	r4, [sp, #64]	; 0x40
   8716a:	f04f 0a00 	mov.w	sl, #0
   8716e:	6827      	ldr	r7, [r4, #0]
   87170:	f88d a08f 	strb.w	sl, [sp, #143]	; 0x8f
   87174:	1d25      	adds	r5, r4, #4
   87176:	2f00      	cmp	r7, #0
   87178:	f000 85e9 	beq.w	87d4e <_svfprintf_r+0x1262>
   8717c:	9c0a      	ldr	r4, [sp, #40]	; 0x28
   8717e:	4638      	mov	r0, r7
   87180:	2c00      	cmp	r4, #0
   87182:	f2c0 859b 	blt.w	87cbc <_svfprintf_r+0x11d0>
   87186:	4651      	mov	r1, sl
   87188:	4622      	mov	r2, r4
   8718a:	f002 fab7 	bl	896fc <memchr>
   8718e:	2800      	cmp	r0, #0
   87190:	f000 8613 	beq.w	87dba <_svfprintf_r+0x12ce>
   87194:	9c0a      	ldr	r4, [sp, #40]	; 0x28
   87196:	1bc0      	subs	r0, r0, r7
   87198:	42a0      	cmp	r0, r4
   8719a:	bfb8      	it	lt
   8719c:	4604      	movlt	r4, r0
   8719e:	9510      	str	r5, [sp, #64]	; 0x40
   871a0:	ea24 75e4 	bic.w	r5, r4, r4, asr #31
   871a4:	f8cd a028 	str.w	sl, [sp, #40]	; 0x28
   871a8:	f8cd a050 	str.w	sl, [sp, #80]	; 0x50
   871ac:	950b      	str	r5, [sp, #44]	; 0x2c
   871ae:	f89d a08f 	ldrb.w	sl, [sp, #143]	; 0x8f
   871b2:	e632      	b.n	86e1a <_svfprintf_r+0x32e>
   871b4:	f8dd c024 	ldr.w	ip, [sp, #36]	; 0x24
   871b8:	f04c 0c40 	orr.w	ip, ip, #64	; 0x40
   871bc:	f8cd c024 	str.w	ip, [sp, #36]	; 0x24
   871c0:	f899 8000 	ldrb.w	r8, [r9]
   871c4:	e4ee      	b.n	86ba4 <_svfprintf_r+0xb8>
   871c6:	f899 8000 	ldrb.w	r8, [r9]
   871ca:	464b      	mov	r3, r9
   871cc:	f1b8 0f6c 	cmp.w	r8, #108	; 0x6c
   871d0:	f000 847f 	beq.w	87ad2 <_svfprintf_r+0xfe6>
   871d4:	9d09      	ldr	r5, [sp, #36]	; 0x24
   871d6:	f045 0510 	orr.w	r5, r5, #16
   871da:	9509      	str	r5, [sp, #36]	; 0x24
   871dc:	e4e2      	b.n	86ba4 <_svfprintf_r+0xb8>
   871de:	9c10      	ldr	r4, [sp, #64]	; 0x40
   871e0:	9d10      	ldr	r5, [sp, #64]	; 0x40
   871e2:	6824      	ldr	r4, [r4, #0]
   871e4:	1d2b      	adds	r3, r5, #4
   871e6:	2c00      	cmp	r4, #0
   871e8:	940f      	str	r4, [sp, #60]	; 0x3c
   871ea:	f6ff ad7d 	blt.w	86ce8 <_svfprintf_r+0x1fc>
   871ee:	9310      	str	r3, [sp, #64]	; 0x40
   871f0:	f899 8000 	ldrb.w	r8, [r9]
   871f4:	e4d6      	b.n	86ba4 <_svfprintf_r+0xb8>
   871f6:	9b10      	ldr	r3, [sp, #64]	; 0x40
   871f8:	f8dd c024 	ldr.w	ip, [sp, #36]	; 0x24
   871fc:	9d10      	ldr	r5, [sp, #64]	; 0x40
   871fe:	487d      	ldr	r0, [pc, #500]	; (873f4 <_svfprintf_r+0x908>)
   87200:	3504      	adds	r5, #4
   87202:	681c      	ldr	r4, [r3, #0]
   87204:	f04f 0878 	mov.w	r8, #120	; 0x78
   87208:	2330      	movs	r3, #48	; 0x30
   8720a:	f04c 0c02 	orr.w	ip, ip, #2
   8720e:	9510      	str	r5, [sp, #64]	; 0x40
   87210:	f88d 3090 	strb.w	r3, [sp, #144]	; 0x90
   87214:	f8cd c024 	str.w	ip, [sp, #36]	; 0x24
   87218:	2500      	movs	r5, #0
   8721a:	f88d 8091 	strb.w	r8, [sp, #145]	; 0x91
   8721e:	901a      	str	r0, [sp, #104]	; 0x68
   87220:	2302      	movs	r3, #2
   87222:	e5cd      	b.n	86dc0 <_svfprintf_r+0x2d4>
   87224:	9b10      	ldr	r3, [sp, #64]	; 0x40
   87226:	9d10      	ldr	r5, [sp, #64]	; 0x40
   87228:	681a      	ldr	r2, [r3, #0]
   8722a:	2401      	movs	r4, #1
   8722c:	2300      	movs	r3, #0
   8722e:	3504      	adds	r5, #4
   87230:	469a      	mov	sl, r3
   87232:	940b      	str	r4, [sp, #44]	; 0x2c
   87234:	f88d 20b8 	strb.w	r2, [sp, #184]	; 0xb8
   87238:	9510      	str	r5, [sp, #64]	; 0x40
   8723a:	f88d 308f 	strb.w	r3, [sp, #143]	; 0x8f
   8723e:	930a      	str	r3, [sp, #40]	; 0x28
   87240:	9314      	str	r3, [sp, #80]	; 0x50
   87242:	af2e      	add	r7, sp, #184	; 0xb8
   87244:	e5ef      	b.n	86e26 <_svfprintf_r+0x33a>
   87246:	9c09      	ldr	r4, [sp, #36]	; 0x24
   87248:	f88d 208f 	strb.w	r2, [sp, #143]	; 0x8f
   8724c:	06a5      	lsls	r5, r4, #26
   8724e:	f53f af4e 	bmi.w	870ee <_svfprintf_r+0x602>
   87252:	f8dd c024 	ldr.w	ip, [sp, #36]	; 0x24
   87256:	f01c 0f10 	tst.w	ip, #16
   8725a:	f040 82df 	bne.w	8781c <_svfprintf_r+0xd30>
   8725e:	f8dd c024 	ldr.w	ip, [sp, #36]	; 0x24
   87262:	f01c 0f40 	tst.w	ip, #64	; 0x40
   87266:	f000 82d9 	beq.w	8781c <_svfprintf_r+0xd30>
   8726a:	f8dd c040 	ldr.w	ip, [sp, #64]	; 0x40
   8726e:	f9bc 4000 	ldrsh.w	r4, [ip]
   87272:	f10c 0c04 	add.w	ip, ip, #4
   87276:	17e5      	asrs	r5, r4, #31
   87278:	4622      	mov	r2, r4
   8727a:	462b      	mov	r3, r5
   8727c:	f8cd c040 	str.w	ip, [sp, #64]	; 0x40
   87280:	e73f      	b.n	87102 <_svfprintf_r+0x616>
   87282:	f899 8000 	ldrb.w	r8, [r9]
   87286:	222b      	movs	r2, #43	; 0x2b
   87288:	e48c      	b.n	86ba4 <_svfprintf_r+0xb8>
   8728a:	9d09      	ldr	r5, [sp, #36]	; 0x24
   8728c:	f045 0508 	orr.w	r5, r5, #8
   87290:	9509      	str	r5, [sp, #36]	; 0x24
   87292:	f899 8000 	ldrb.w	r8, [r9]
   87296:	e485      	b.n	86ba4 <_svfprintf_r+0xb8>
   87298:	9d10      	ldr	r5, [sp, #64]	; 0x40
   8729a:	f88d 208f 	strb.w	r2, [sp, #143]	; 0x8f
   8729e:	1deb      	adds	r3, r5, #7
   872a0:	f023 0307 	bic.w	r3, r3, #7
   872a4:	f103 0c08 	add.w	ip, r3, #8
   872a8:	f8cd c040 	str.w	ip, [sp, #64]	; 0x40
   872ac:	e9d3 4500 	ldrd	r4, r5, [r3]
   872b0:	e9cd 4516 	strd	r4, r5, [sp, #88]	; 0x58
   872b4:	e9dd 0116 	ldrd	r0, r1, [sp, #88]	; 0x58
   872b8:	f002 ffbe 	bl	8a238 <__fpclassifyd>
   872bc:	2801      	cmp	r0, #1
   872be:	e9dd 0116 	ldrd	r0, r1, [sp, #88]	; 0x58
   872c2:	f040 835c 	bne.w	8797e <_svfprintf_r+0xe92>
   872c6:	2200      	movs	r2, #0
   872c8:	2300      	movs	r3, #0
   872ca:	f003 fd1d 	bl	8ad08 <__aeabi_dcmplt>
   872ce:	2800      	cmp	r0, #0
   872d0:	f040 8563 	bne.w	87d9a <_svfprintf_r+0x12ae>
   872d4:	f89d a08f 	ldrb.w	sl, [sp, #143]	; 0x8f
   872d8:	2503      	movs	r5, #3
   872da:	950b      	str	r5, [sp, #44]	; 0x2c
   872dc:	9d09      	ldr	r5, [sp, #36]	; 0x24
   872de:	4f46      	ldr	r7, [pc, #280]	; (873f8 <_svfprintf_r+0x90c>)
   872e0:	f025 0580 	bic.w	r5, r5, #128	; 0x80
   872e4:	4b45      	ldr	r3, [pc, #276]	; (873fc <_svfprintf_r+0x910>)
   872e6:	2400      	movs	r4, #0
   872e8:	9509      	str	r5, [sp, #36]	; 0x24
   872ea:	2500      	movs	r5, #0
   872ec:	940a      	str	r4, [sp, #40]	; 0x28
   872ee:	f1b8 0f47 	cmp.w	r8, #71	; 0x47
   872f2:	bfd8      	it	le
   872f4:	461f      	movle	r7, r3
   872f6:	2403      	movs	r4, #3
   872f8:	9514      	str	r5, [sp, #80]	; 0x50
   872fa:	e58e      	b.n	86e1a <_svfprintf_r+0x32e>
   872fc:	f8dd c024 	ldr.w	ip, [sp, #36]	; 0x24
   87300:	f04c 0c20 	orr.w	ip, ip, #32
   87304:	f8cd c024 	str.w	ip, [sp, #36]	; 0x24
   87308:	f899 8000 	ldrb.w	r8, [r9]
   8730c:	e44a      	b.n	86ba4 <_svfprintf_r+0xb8>
   8730e:	9c10      	ldr	r4, [sp, #64]	; 0x40
   87310:	1de3      	adds	r3, r4, #7
   87312:	f023 0307 	bic.w	r3, r3, #7
   87316:	f103 0508 	add.w	r5, r3, #8
   8731a:	9510      	str	r5, [sp, #64]	; 0x40
   8731c:	e9d3 4500 	ldrd	r4, r5, [r3]
   87320:	2300      	movs	r3, #0
   87322:	e54d      	b.n	86dc0 <_svfprintf_r+0x2d4>
   87324:	9d10      	ldr	r5, [sp, #64]	; 0x40
   87326:	1deb      	adds	r3, r5, #7
   87328:	f023 0307 	bic.w	r3, r3, #7
   8732c:	f103 0c08 	add.w	ip, r3, #8
   87330:	e9d3 4500 	ldrd	r4, r5, [r3]
   87334:	f8cd c040 	str.w	ip, [sp, #64]	; 0x40
   87338:	2301      	movs	r3, #1
   8733a:	e541      	b.n	86dc0 <_svfprintf_r+0x2d4>
   8733c:	f88d 208f 	strb.w	r2, [sp, #143]	; 0x8f
   87340:	f1b8 0f00 	cmp.w	r8, #0
   87344:	f43f ace3 	beq.w	86d0e <_svfprintf_r+0x222>
   87348:	2300      	movs	r3, #0
   8734a:	f04f 0c01 	mov.w	ip, #1
   8734e:	469a      	mov	sl, r3
   87350:	f8cd c02c 	str.w	ip, [sp, #44]	; 0x2c
   87354:	f88d 80b8 	strb.w	r8, [sp, #184]	; 0xb8
   87358:	f88d 308f 	strb.w	r3, [sp, #143]	; 0x8f
   8735c:	930a      	str	r3, [sp, #40]	; 0x28
   8735e:	9314      	str	r3, [sp, #80]	; 0x50
   87360:	4664      	mov	r4, ip
   87362:	af2e      	add	r7, sp, #184	; 0xb8
   87364:	e55f      	b.n	86e26 <_svfprintf_r+0x33a>
   87366:	f8dd c0b4 	ldr.w	ip, [sp, #180]	; 0xb4
   8736a:	e5b7      	b.n	86edc <_svfprintf_r+0x3f0>
   8736c:	2b01      	cmp	r3, #1
   8736e:	f000 80ec 	beq.w	8754a <_svfprintf_r+0xa5e>
   87372:	2b02      	cmp	r3, #2
   87374:	f10d 03df 	add.w	r3, sp, #223	; 0xdf
   87378:	d118      	bne.n	873ac <_svfprintf_r+0x8c0>
   8737a:	f8dd c068 	ldr.w	ip, [sp, #104]	; 0x68
   8737e:	4619      	mov	r1, r3
   87380:	f004 000f 	and.w	r0, r4, #15
   87384:	0922      	lsrs	r2, r4, #4
   87386:	f81c 0000 	ldrb.w	r0, [ip, r0]
   8738a:	ea42 7205 	orr.w	r2, r2, r5, lsl #28
   8738e:	092b      	lsrs	r3, r5, #4
   87390:	7008      	strb	r0, [r1, #0]
   87392:	ea52 0003 	orrs.w	r0, r2, r3
   87396:	460f      	mov	r7, r1
   87398:	4614      	mov	r4, r2
   8739a:	461d      	mov	r5, r3
   8739c:	f101 31ff 	add.w	r1, r1, #4294967295
   873a0:	d1ee      	bne.n	87380 <_svfprintf_r+0x894>
   873a2:	9d08      	ldr	r5, [sp, #32]
   873a4:	e9cd 231e 	strd	r2, r3, [sp, #120]	; 0x78
   873a8:	1bec      	subs	r4, r5, r7
   873aa:	e52d      	b.n	86e08 <_svfprintf_r+0x31c>
   873ac:	08e0      	lsrs	r0, r4, #3
   873ae:	ea40 7045 	orr.w	r0, r0, r5, lsl #29
   873b2:	f004 0207 	and.w	r2, r4, #7
   873b6:	08e9      	lsrs	r1, r5, #3
   873b8:	3230      	adds	r2, #48	; 0x30
   873ba:	ea50 0c01 	orrs.w	ip, r0, r1
   873be:	461f      	mov	r7, r3
   873c0:	701a      	strb	r2, [r3, #0]
   873c2:	4604      	mov	r4, r0
   873c4:	460d      	mov	r5, r1
   873c6:	f103 33ff 	add.w	r3, r3, #4294967295
   873ca:	d1ef      	bne.n	873ac <_svfprintf_r+0x8c0>
   873cc:	9c09      	ldr	r4, [sp, #36]	; 0x24
   873ce:	e9cd 011c 	strd	r0, r1, [sp, #112]	; 0x70
   873d2:	07e0      	lsls	r0, r4, #31
   873d4:	4639      	mov	r1, r7
   873d6:	f140 80c1 	bpl.w	8755c <_svfprintf_r+0xa70>
   873da:	2a30      	cmp	r2, #48	; 0x30
   873dc:	f000 80be 	beq.w	8755c <_svfprintf_r+0xa70>
   873e0:	9d08      	ldr	r5, [sp, #32]
   873e2:	461f      	mov	r7, r3
   873e4:	2330      	movs	r3, #48	; 0x30
   873e6:	1bec      	subs	r4, r5, r7
   873e8:	f801 3c01 	strb.w	r3, [r1, #-1]
   873ec:	e50c      	b.n	86e08 <_svfprintf_r+0x31c>
   873ee:	bf00      	nop
   873f0:	0008cc34 	.word	0x0008cc34
   873f4:	0008cc48 	.word	0x0008cc48
   873f8:	0008cc28 	.word	0x0008cc28
   873fc:	0008cc24 	.word	0x0008cc24
   87400:	f1b8 0f65 	cmp.w	r8, #101	; 0x65
   87404:	f340 80ad 	ble.w	87562 <_svfprintf_r+0xa76>
   87408:	e9dd 0116 	ldrd	r0, r1, [sp, #88]	; 0x58
   8740c:	2200      	movs	r2, #0
   8740e:	2300      	movs	r3, #0
   87410:	f8cd c01c 	str.w	ip, [sp, #28]
   87414:	f003 fc6e 	bl	8acf4 <__aeabi_dcmpeq>
   87418:	f8dd c01c 	ldr.w	ip, [sp, #28]
   8741c:	2800      	cmp	r0, #0
   8741e:	f000 8126 	beq.w	8766e <_svfprintf_r+0xb82>
   87422:	9b2c      	ldr	r3, [sp, #176]	; 0xb0
   87424:	49aa      	ldr	r1, [pc, #680]	; (876d0 <_svfprintf_r+0xbe4>)
   87426:	3301      	adds	r3, #1
   87428:	f10c 0c01 	add.w	ip, ip, #1
   8742c:	2201      	movs	r2, #1
   8742e:	2b07      	cmp	r3, #7
   87430:	f8cd c0b4 	str.w	ip, [sp, #180]	; 0xb4
   87434:	932c      	str	r3, [sp, #176]	; 0xb0
   87436:	e886 0006 	stmia.w	r6, {r1, r2}
   8743a:	f300 82ed 	bgt.w	87a18 <_svfprintf_r+0xf2c>
   8743e:	3608      	adds	r6, #8
   87440:	9b25      	ldr	r3, [sp, #148]	; 0x94
   87442:	9c11      	ldr	r4, [sp, #68]	; 0x44
   87444:	42a3      	cmp	r3, r4
   87446:	db03      	blt.n	87450 <_svfprintf_r+0x964>
   87448:	9d09      	ldr	r5, [sp, #36]	; 0x24
   8744a:	07ec      	lsls	r4, r5, #31
   8744c:	f57f adc0 	bpl.w	86fd0 <_svfprintf_r+0x4e4>
   87450:	9b2c      	ldr	r3, [sp, #176]	; 0xb0
   87452:	9c18      	ldr	r4, [sp, #96]	; 0x60
   87454:	3301      	adds	r3, #1
   87456:	9d15      	ldr	r5, [sp, #84]	; 0x54
   87458:	44a4      	add	ip, r4
   8745a:	2b07      	cmp	r3, #7
   8745c:	f8cd c0b4 	str.w	ip, [sp, #180]	; 0xb4
   87460:	6035      	str	r5, [r6, #0]
   87462:	6074      	str	r4, [r6, #4]
   87464:	932c      	str	r3, [sp, #176]	; 0xb0
   87466:	f300 833e 	bgt.w	87ae6 <_svfprintf_r+0xffa>
   8746a:	3608      	adds	r6, #8
   8746c:	9d11      	ldr	r5, [sp, #68]	; 0x44
   8746e:	1e6c      	subs	r4, r5, #1
   87470:	2c00      	cmp	r4, #0
   87472:	f77f adad 	ble.w	86fd0 <_svfprintf_r+0x4e4>
   87476:	2c10      	cmp	r4, #16
   87478:	9b2c      	ldr	r3, [sp, #176]	; 0xb0
   8747a:	4d96      	ldr	r5, [pc, #600]	; (876d4 <_svfprintf_r+0xbe8>)
   8747c:	f340 8197 	ble.w	877ae <_svfprintf_r+0xcc2>
   87480:	2710      	movs	r7, #16
   87482:	4662      	mov	r2, ip
   87484:	f8dd 8034 	ldr.w	r8, [sp, #52]	; 0x34
   87488:	f8dd a030 	ldr.w	sl, [sp, #48]	; 0x30
   8748c:	e004      	b.n	87498 <_svfprintf_r+0x9ac>
   8748e:	3608      	adds	r6, #8
   87490:	3c10      	subs	r4, #16
   87492:	2c10      	cmp	r4, #16
   87494:	f340 818a 	ble.w	877ac <_svfprintf_r+0xcc0>
   87498:	3301      	adds	r3, #1
   8749a:	3210      	adds	r2, #16
   8749c:	2b07      	cmp	r3, #7
   8749e:	922d      	str	r2, [sp, #180]	; 0xb4
   874a0:	932c      	str	r3, [sp, #176]	; 0xb0
   874a2:	e886 00a0 	stmia.w	r6, {r5, r7}
   874a6:	ddf2      	ble.n	8748e <_svfprintf_r+0x9a2>
   874a8:	4640      	mov	r0, r8
   874aa:	4651      	mov	r1, sl
   874ac:	aa2b      	add	r2, sp, #172	; 0xac
   874ae:	f002 fefd 	bl	8a2ac <__ssprint_r>
   874b2:	2800      	cmp	r0, #0
   874b4:	f47f ac32 	bne.w	86d1c <_svfprintf_r+0x230>
   874b8:	9a2d      	ldr	r2, [sp, #180]	; 0xb4
   874ba:	9b2c      	ldr	r3, [sp, #176]	; 0xb0
   874bc:	ae38      	add	r6, sp, #224	; 0xe0
   874be:	e7e7      	b.n	87490 <_svfprintf_r+0x9a4>
   874c0:	9d0f      	ldr	r5, [sp, #60]	; 0x3c
   874c2:	980b      	ldr	r0, [sp, #44]	; 0x2c
   874c4:	ebc0 0a05 	rsb	sl, r0, r5
   874c8:	f1ba 0f00 	cmp.w	sl, #0
   874cc:	f77f ad2e 	ble.w	86f2c <_svfprintf_r+0x440>
   874d0:	f1ba 0f10 	cmp.w	sl, #16
   874d4:	9b2c      	ldr	r3, [sp, #176]	; 0xb0
   874d6:	4d7f      	ldr	r5, [pc, #508]	; (876d4 <_svfprintf_r+0xbe8>)
   874d8:	dd2b      	ble.n	87532 <_svfprintf_r+0xa46>
   874da:	9412      	str	r4, [sp, #72]	; 0x48
   874dc:	4632      	mov	r2, r6
   874de:	f04f 0b10 	mov.w	fp, #16
   874e2:	462e      	mov	r6, r5
   874e4:	4661      	mov	r1, ip
   874e6:	9c0d      	ldr	r4, [sp, #52]	; 0x34
   874e8:	9d0c      	ldr	r5, [sp, #48]	; 0x30
   874ea:	e006      	b.n	874fa <_svfprintf_r+0xa0e>
   874ec:	f1aa 0a10 	sub.w	sl, sl, #16
   874f0:	f1ba 0f10 	cmp.w	sl, #16
   874f4:	f102 0208 	add.w	r2, r2, #8
   874f8:	dd17      	ble.n	8752a <_svfprintf_r+0xa3e>
   874fa:	3301      	adds	r3, #1
   874fc:	3110      	adds	r1, #16
   874fe:	2b07      	cmp	r3, #7
   87500:	912d      	str	r1, [sp, #180]	; 0xb4
   87502:	932c      	str	r3, [sp, #176]	; 0xb0
   87504:	e882 0840 	stmia.w	r2, {r6, fp}
   87508:	ddf0      	ble.n	874ec <_svfprintf_r+0xa00>
   8750a:	4620      	mov	r0, r4
   8750c:	4629      	mov	r1, r5
   8750e:	aa2b      	add	r2, sp, #172	; 0xac
   87510:	f002 fecc 	bl	8a2ac <__ssprint_r>
   87514:	2800      	cmp	r0, #0
   87516:	f47f ac01 	bne.w	86d1c <_svfprintf_r+0x230>
   8751a:	f1aa 0a10 	sub.w	sl, sl, #16
   8751e:	f1ba 0f10 	cmp.w	sl, #16
   87522:	992d      	ldr	r1, [sp, #180]	; 0xb4
   87524:	9b2c      	ldr	r3, [sp, #176]	; 0xb0
   87526:	aa38      	add	r2, sp, #224	; 0xe0
   87528:	dce7      	bgt.n	874fa <_svfprintf_r+0xa0e>
   8752a:	9c12      	ldr	r4, [sp, #72]	; 0x48
   8752c:	4635      	mov	r5, r6
   8752e:	468c      	mov	ip, r1
   87530:	4616      	mov	r6, r2
   87532:	3301      	adds	r3, #1
   87534:	44d4      	add	ip, sl
   87536:	2b07      	cmp	r3, #7
   87538:	f8cd c0b4 	str.w	ip, [sp, #180]	; 0xb4
   8753c:	932c      	str	r3, [sp, #176]	; 0xb0
   8753e:	e886 0420 	stmia.w	r6, {r5, sl}
   87542:	f300 820f 	bgt.w	87964 <_svfprintf_r+0xe78>
   87546:	3608      	adds	r6, #8
   87548:	e4f0      	b.n	86f2c <_svfprintf_r+0x440>
   8754a:	2d00      	cmp	r5, #0
   8754c:	bf08      	it	eq
   8754e:	2c0a      	cmpeq	r4, #10
   87550:	f080 8138 	bcs.w	877c4 <_svfprintf_r+0xcd8>
   87554:	3430      	adds	r4, #48	; 0x30
   87556:	af48      	add	r7, sp, #288	; 0x120
   87558:	f807 4d41 	strb.w	r4, [r7, #-65]!
   8755c:	9d08      	ldr	r5, [sp, #32]
   8755e:	1bec      	subs	r4, r5, r7
   87560:	e452      	b.n	86e08 <_svfprintf_r+0x31c>
   87562:	9c11      	ldr	r4, [sp, #68]	; 0x44
   87564:	2c01      	cmp	r4, #1
   87566:	9c2c      	ldr	r4, [sp, #176]	; 0xb0
   87568:	f340 81d2 	ble.w	87910 <_svfprintf_r+0xe24>
   8756c:	3401      	adds	r4, #1
   8756e:	f10c 0301 	add.w	r3, ip, #1
   87572:	2201      	movs	r2, #1
   87574:	2c07      	cmp	r4, #7
   87576:	932d      	str	r3, [sp, #180]	; 0xb4
   87578:	6037      	str	r7, [r6, #0]
   8757a:	942c      	str	r4, [sp, #176]	; 0xb0
   8757c:	6072      	str	r2, [r6, #4]
   8757e:	f300 81d8 	bgt.w	87932 <_svfprintf_r+0xe46>
   87582:	3608      	adds	r6, #8
   87584:	9d15      	ldr	r5, [sp, #84]	; 0x54
   87586:	f8dd 8060 	ldr.w	r8, [sp, #96]	; 0x60
   8758a:	3401      	adds	r4, #1
   8758c:	6035      	str	r5, [r6, #0]
   8758e:	9d18      	ldr	r5, [sp, #96]	; 0x60
   87590:	4498      	add	r8, r3
   87592:	2c07      	cmp	r4, #7
   87594:	f8cd 80b4 	str.w	r8, [sp, #180]	; 0xb4
   87598:	942c      	str	r4, [sp, #176]	; 0xb0
   8759a:	6075      	str	r5, [r6, #4]
   8759c:	f300 81d5 	bgt.w	8794a <_svfprintf_r+0xe5e>
   875a0:	3608      	adds	r6, #8
   875a2:	e9dd 0116 	ldrd	r0, r1, [sp, #88]	; 0x58
   875a6:	2200      	movs	r2, #0
   875a8:	2300      	movs	r3, #0
   875aa:	f003 fba3 	bl	8acf4 <__aeabi_dcmpeq>
   875ae:	9d11      	ldr	r5, [sp, #68]	; 0x44
   875b0:	2800      	cmp	r0, #0
   875b2:	f040 80b9 	bne.w	87728 <_svfprintf_r+0xc3c>
   875b6:	1e6b      	subs	r3, r5, #1
   875b8:	3401      	adds	r4, #1
   875ba:	3701      	adds	r7, #1
   875bc:	4498      	add	r8, r3
   875be:	2c07      	cmp	r4, #7
   875c0:	942c      	str	r4, [sp, #176]	; 0xb0
   875c2:	f8cd 80b4 	str.w	r8, [sp, #180]	; 0xb4
   875c6:	6037      	str	r7, [r6, #0]
   875c8:	6073      	str	r3, [r6, #4]
   875ca:	f300 80e2 	bgt.w	87792 <_svfprintf_r+0xca6>
   875ce:	3608      	adds	r6, #8
   875d0:	f8dd c064 	ldr.w	ip, [sp, #100]	; 0x64
   875d4:	3401      	adds	r4, #1
   875d6:	9d19      	ldr	r5, [sp, #100]	; 0x64
   875d8:	44c4      	add	ip, r8
   875da:	ab27      	add	r3, sp, #156	; 0x9c
   875dc:	2c07      	cmp	r4, #7
   875de:	f8cd c0b4 	str.w	ip, [sp, #180]	; 0xb4
   875e2:	942c      	str	r4, [sp, #176]	; 0xb0
   875e4:	e886 0028 	stmia.w	r6, {r3, r5}
   875e8:	f77f acf1 	ble.w	86fce <_svfprintf_r+0x4e2>
   875ec:	980d      	ldr	r0, [sp, #52]	; 0x34
   875ee:	990c      	ldr	r1, [sp, #48]	; 0x30
   875f0:	aa2b      	add	r2, sp, #172	; 0xac
   875f2:	f002 fe5b 	bl	8a2ac <__ssprint_r>
   875f6:	2800      	cmp	r0, #0
   875f8:	f47f ab90 	bne.w	86d1c <_svfprintf_r+0x230>
   875fc:	f8dd c0b4 	ldr.w	ip, [sp, #180]	; 0xb4
   87600:	ae38      	add	r6, sp, #224	; 0xe0
   87602:	e4e5      	b.n	86fd0 <_svfprintf_r+0x4e4>
   87604:	980d      	ldr	r0, [sp, #52]	; 0x34
   87606:	990c      	ldr	r1, [sp, #48]	; 0x30
   87608:	aa2b      	add	r2, sp, #172	; 0xac
   8760a:	f002 fe4f 	bl	8a2ac <__ssprint_r>
   8760e:	2800      	cmp	r0, #0
   87610:	f43f ad37 	beq.w	87082 <_svfprintf_r+0x596>
   87614:	f7ff bb82 	b.w	86d1c <_svfprintf_r+0x230>
   87618:	980d      	ldr	r0, [sp, #52]	; 0x34
   8761a:	990c      	ldr	r1, [sp, #48]	; 0x30
   8761c:	aa2b      	add	r2, sp, #172	; 0xac
   8761e:	f002 fe45 	bl	8a2ac <__ssprint_r>
   87622:	2800      	cmp	r0, #0
   87624:	f47f ab7a 	bne.w	86d1c <_svfprintf_r+0x230>
   87628:	f8dd c0b4 	ldr.w	ip, [sp, #180]	; 0xb4
   8762c:	ae38      	add	r6, sp, #224	; 0xe0
   8762e:	e4bf      	b.n	86fb0 <_svfprintf_r+0x4c4>
   87630:	980d      	ldr	r0, [sp, #52]	; 0x34
   87632:	990c      	ldr	r1, [sp, #48]	; 0x30
   87634:	aa2b      	add	r2, sp, #172	; 0xac
   87636:	f002 fe39 	bl	8a2ac <__ssprint_r>
   8763a:	2800      	cmp	r0, #0
   8763c:	f47f ab6e 	bne.w	86d1c <_svfprintf_r+0x230>
   87640:	f8dd c0b4 	ldr.w	ip, [sp, #180]	; 0xb4
   87644:	ae38      	add	r6, sp, #224	; 0xe0
   87646:	e46d      	b.n	86f24 <_svfprintf_r+0x438>
   87648:	980d      	ldr	r0, [sp, #52]	; 0x34
   8764a:	990c      	ldr	r1, [sp, #48]	; 0x30
   8764c:	aa2b      	add	r2, sp, #172	; 0xac
   8764e:	f002 fe2d 	bl	8a2ac <__ssprint_r>
   87652:	2800      	cmp	r0, #0
   87654:	f47f ab62 	bne.w	86d1c <_svfprintf_r+0x230>
   87658:	f8dd c0b4 	ldr.w	ip, [sp, #180]	; 0xb4
   8765c:	ae38      	add	r6, sp, #224	; 0xe0
   8765e:	e450      	b.n	86f02 <_svfprintf_r+0x416>
   87660:	9c0a      	ldr	r4, [sp, #40]	; 0x28
   87662:	af38      	add	r7, sp, #224	; 0xe0
   87664:	f7ff bbd0 	b.w	86e08 <_svfprintf_r+0x31c>
   87668:	2302      	movs	r3, #2
   8766a:	f7ff bba9 	b.w	86dc0 <_svfprintf_r+0x2d4>
   8766e:	9b25      	ldr	r3, [sp, #148]	; 0x94
   87670:	2b00      	cmp	r3, #0
   87672:	f340 81dd 	ble.w	87a30 <_svfprintf_r+0xf44>
   87676:	9c11      	ldr	r4, [sp, #68]	; 0x44
   87678:	9d14      	ldr	r5, [sp, #80]	; 0x50
   8767a:	f8dd a044 	ldr.w	sl, [sp, #68]	; 0x44
   8767e:	42ac      	cmp	r4, r5
   87680:	bfa8      	it	ge
   87682:	462c      	movge	r4, r5
   87684:	2c00      	cmp	r4, #0
   87686:	44ba      	add	sl, r7
   87688:	dd0b      	ble.n	876a2 <_svfprintf_r+0xbb6>
   8768a:	9b2c      	ldr	r3, [sp, #176]	; 0xb0
   8768c:	44a4      	add	ip, r4
   8768e:	3301      	adds	r3, #1
   87690:	2b07      	cmp	r3, #7
   87692:	f8cd c0b4 	str.w	ip, [sp, #180]	; 0xb4
   87696:	6037      	str	r7, [r6, #0]
   87698:	6074      	str	r4, [r6, #4]
   8769a:	932c      	str	r3, [sp, #176]	; 0xb0
   8769c:	f300 831e 	bgt.w	87cdc <_svfprintf_r+0x11f0>
   876a0:	3608      	adds	r6, #8
   876a2:	9d14      	ldr	r5, [sp, #80]	; 0x50
   876a4:	ea24 74e4 	bic.w	r4, r4, r4, asr #31
   876a8:	1b2c      	subs	r4, r5, r4
   876aa:	2c00      	cmp	r4, #0
   876ac:	f340 80d7 	ble.w	8785e <_svfprintf_r+0xd72>
   876b0:	2c10      	cmp	r4, #16
   876b2:	9b2c      	ldr	r3, [sp, #176]	; 0xb0
   876b4:	4d07      	ldr	r5, [pc, #28]	; (876d4 <_svfprintf_r+0xbe8>)
   876b6:	f340 81a3 	ble.w	87a00 <_svfprintf_r+0xf14>
   876ba:	970a      	str	r7, [sp, #40]	; 0x28
   876bc:	f04f 0810 	mov.w	r8, #16
   876c0:	462f      	mov	r7, r5
   876c2:	4662      	mov	r2, ip
   876c4:	4625      	mov	r5, r4
   876c6:	f8dd b034 	ldr.w	fp, [sp, #52]	; 0x34
   876ca:	9c0c      	ldr	r4, [sp, #48]	; 0x30
   876cc:	e009      	b.n	876e2 <_svfprintf_r+0xbf6>
   876ce:	bf00      	nop
   876d0:	0008cc64 	.word	0x0008cc64
   876d4:	0008cc14 	.word	0x0008cc14
   876d8:	3608      	adds	r6, #8
   876da:	3d10      	subs	r5, #16
   876dc:	2d10      	cmp	r5, #16
   876de:	f340 818b 	ble.w	879f8 <_svfprintf_r+0xf0c>
   876e2:	3301      	adds	r3, #1
   876e4:	3210      	adds	r2, #16
   876e6:	2b07      	cmp	r3, #7
   876e8:	922d      	str	r2, [sp, #180]	; 0xb4
   876ea:	932c      	str	r3, [sp, #176]	; 0xb0
   876ec:	e886 0180 	stmia.w	r6, {r7, r8}
   876f0:	ddf2      	ble.n	876d8 <_svfprintf_r+0xbec>
   876f2:	4658      	mov	r0, fp
   876f4:	4621      	mov	r1, r4
   876f6:	aa2b      	add	r2, sp, #172	; 0xac
   876f8:	f002 fdd8 	bl	8a2ac <__ssprint_r>
   876fc:	2800      	cmp	r0, #0
   876fe:	f47f ab0d 	bne.w	86d1c <_svfprintf_r+0x230>
   87702:	9a2d      	ldr	r2, [sp, #180]	; 0xb4
   87704:	9b2c      	ldr	r3, [sp, #176]	; 0xb0
   87706:	ae38      	add	r6, sp, #224	; 0xe0
   87708:	e7e7      	b.n	876da <_svfprintf_r+0xbee>
   8770a:	980d      	ldr	r0, [sp, #52]	; 0x34
   8770c:	990c      	ldr	r1, [sp, #48]	; 0x30
   8770e:	aa2b      	add	r2, sp, #172	; 0xac
   87710:	f002 fdcc 	bl	8a2ac <__ssprint_r>
   87714:	2800      	cmp	r0, #0
   87716:	f47f ab01 	bne.w	86d1c <_svfprintf_r+0x230>
   8771a:	f89d a08f 	ldrb.w	sl, [sp, #143]	; 0x8f
   8771e:	f8dd c0b4 	ldr.w	ip, [sp, #180]	; 0xb4
   87722:	ae38      	add	r6, sp, #224	; 0xe0
   87724:	f7ff bbda 	b.w	86edc <_svfprintf_r+0x3f0>
   87728:	1e6f      	subs	r7, r5, #1
   8772a:	2f00      	cmp	r7, #0
   8772c:	f77f af50 	ble.w	875d0 <_svfprintf_r+0xae4>
   87730:	2f10      	cmp	r7, #16
   87732:	4dae      	ldr	r5, [pc, #696]	; (879ec <_svfprintf_r+0xf00>)
   87734:	dd23      	ble.n	8777e <_svfprintf_r+0xc92>
   87736:	4643      	mov	r3, r8
   87738:	f04f 0a10 	mov.w	sl, #16
   8773c:	f8dd 8034 	ldr.w	r8, [sp, #52]	; 0x34
   87740:	f8dd b030 	ldr.w	fp, [sp, #48]	; 0x30
   87744:	e004      	b.n	87750 <_svfprintf_r+0xc64>
   87746:	3f10      	subs	r7, #16
   87748:	2f10      	cmp	r7, #16
   8774a:	f106 0608 	add.w	r6, r6, #8
   8774e:	dd15      	ble.n	8777c <_svfprintf_r+0xc90>
   87750:	3401      	adds	r4, #1
   87752:	3310      	adds	r3, #16
   87754:	2c07      	cmp	r4, #7
   87756:	932d      	str	r3, [sp, #180]	; 0xb4
   87758:	942c      	str	r4, [sp, #176]	; 0xb0
   8775a:	e886 0420 	stmia.w	r6, {r5, sl}
   8775e:	ddf2      	ble.n	87746 <_svfprintf_r+0xc5a>
   87760:	4640      	mov	r0, r8
   87762:	4659      	mov	r1, fp
   87764:	aa2b      	add	r2, sp, #172	; 0xac
   87766:	f002 fda1 	bl	8a2ac <__ssprint_r>
   8776a:	2800      	cmp	r0, #0
   8776c:	f47f aad6 	bne.w	86d1c <_svfprintf_r+0x230>
   87770:	3f10      	subs	r7, #16
   87772:	2f10      	cmp	r7, #16
   87774:	9b2d      	ldr	r3, [sp, #180]	; 0xb4
   87776:	9c2c      	ldr	r4, [sp, #176]	; 0xb0
   87778:	ae38      	add	r6, sp, #224	; 0xe0
   8777a:	dce9      	bgt.n	87750 <_svfprintf_r+0xc64>
   8777c:	4698      	mov	r8, r3
   8777e:	3401      	adds	r4, #1
   87780:	44b8      	add	r8, r7
   87782:	2c07      	cmp	r4, #7
   87784:	f8cd 80b4 	str.w	r8, [sp, #180]	; 0xb4
   87788:	942c      	str	r4, [sp, #176]	; 0xb0
   8778a:	e886 00a0 	stmia.w	r6, {r5, r7}
   8778e:	f77f af1e 	ble.w	875ce <_svfprintf_r+0xae2>
   87792:	980d      	ldr	r0, [sp, #52]	; 0x34
   87794:	990c      	ldr	r1, [sp, #48]	; 0x30
   87796:	aa2b      	add	r2, sp, #172	; 0xac
   87798:	f002 fd88 	bl	8a2ac <__ssprint_r>
   8779c:	2800      	cmp	r0, #0
   8779e:	f47f aabd 	bne.w	86d1c <_svfprintf_r+0x230>
   877a2:	f8dd 80b4 	ldr.w	r8, [sp, #180]	; 0xb4
   877a6:	9c2c      	ldr	r4, [sp, #176]	; 0xb0
   877a8:	ae38      	add	r6, sp, #224	; 0xe0
   877aa:	e711      	b.n	875d0 <_svfprintf_r+0xae4>
   877ac:	4694      	mov	ip, r2
   877ae:	3301      	adds	r3, #1
   877b0:	44a4      	add	ip, r4
   877b2:	2b07      	cmp	r3, #7
   877b4:	f8cd c0b4 	str.w	ip, [sp, #180]	; 0xb4
   877b8:	932c      	str	r3, [sp, #176]	; 0xb0
   877ba:	6035      	str	r5, [r6, #0]
   877bc:	6074      	str	r4, [r6, #4]
   877be:	f77f ac06 	ble.w	86fce <_svfprintf_r+0x4e2>
   877c2:	e713      	b.n	875ec <_svfprintf_r+0xb00>
   877c4:	f10d 0bdf 	add.w	fp, sp, #223	; 0xdf
   877c8:	4620      	mov	r0, r4
   877ca:	4629      	mov	r1, r5
   877cc:	220a      	movs	r2, #10
   877ce:	2300      	movs	r3, #0
   877d0:	f003 faea 	bl	8ada8 <__aeabi_uldivmod>
   877d4:	3230      	adds	r2, #48	; 0x30
   877d6:	f88b 2000 	strb.w	r2, [fp]
   877da:	4620      	mov	r0, r4
   877dc:	4629      	mov	r1, r5
   877de:	220a      	movs	r2, #10
   877e0:	2300      	movs	r3, #0
   877e2:	f003 fae1 	bl	8ada8 <__aeabi_uldivmod>
   877e6:	4604      	mov	r4, r0
   877e8:	460d      	mov	r5, r1
   877ea:	ea54 0c05 	orrs.w	ip, r4, r5
   877ee:	465f      	mov	r7, fp
   877f0:	f10b 3bff 	add.w	fp, fp, #4294967295
   877f4:	d1e8      	bne.n	877c8 <_svfprintf_r+0xcdc>
   877f6:	9d08      	ldr	r5, [sp, #32]
   877f8:	1bec      	subs	r4, r5, r7
   877fa:	f7ff bb05 	b.w	86e08 <_svfprintf_r+0x31c>
   877fe:	9d10      	ldr	r5, [sp, #64]	; 0x40
   87800:	2301      	movs	r3, #1
   87802:	682c      	ldr	r4, [r5, #0]
   87804:	3504      	adds	r5, #4
   87806:	9510      	str	r5, [sp, #64]	; 0x40
   87808:	2500      	movs	r5, #0
   8780a:	f7ff bad9 	b.w	86dc0 <_svfprintf_r+0x2d4>
   8780e:	9d10      	ldr	r5, [sp, #64]	; 0x40
   87810:	682c      	ldr	r4, [r5, #0]
   87812:	3504      	adds	r5, #4
   87814:	9510      	str	r5, [sp, #64]	; 0x40
   87816:	2500      	movs	r5, #0
   87818:	f7ff bad2 	b.w	86dc0 <_svfprintf_r+0x2d4>
   8781c:	9d10      	ldr	r5, [sp, #64]	; 0x40
   8781e:	682c      	ldr	r4, [r5, #0]
   87820:	3504      	adds	r5, #4
   87822:	9510      	str	r5, [sp, #64]	; 0x40
   87824:	17e5      	asrs	r5, r4, #31
   87826:	4622      	mov	r2, r4
   87828:	462b      	mov	r3, r5
   8782a:	2a00      	cmp	r2, #0
   8782c:	f173 0c00 	sbcs.w	ip, r3, #0
   87830:	f6bf ac6c 	bge.w	8710c <_svfprintf_r+0x620>
   87834:	f04f 0a2d 	mov.w	sl, #45	; 0x2d
   87838:	4264      	negs	r4, r4
   8783a:	eb65 0545 	sbc.w	r5, r5, r5, lsl #1
   8783e:	f88d a08f 	strb.w	sl, [sp, #143]	; 0x8f
   87842:	2301      	movs	r3, #1
   87844:	f7ff bac0 	b.w	86dc8 <_svfprintf_r+0x2dc>
   87848:	980d      	ldr	r0, [sp, #52]	; 0x34
   8784a:	990c      	ldr	r1, [sp, #48]	; 0x30
   8784c:	aa2b      	add	r2, sp, #172	; 0xac
   8784e:	f002 fd2d 	bl	8a2ac <__ssprint_r>
   87852:	2800      	cmp	r0, #0
   87854:	f47f aa62 	bne.w	86d1c <_svfprintf_r+0x230>
   87858:	f8dd c0b4 	ldr.w	ip, [sp, #180]	; 0xb4
   8785c:	ae38      	add	r6, sp, #224	; 0xe0
   8785e:	9d14      	ldr	r5, [sp, #80]	; 0x50
   87860:	9c25      	ldr	r4, [sp, #148]	; 0x94
   87862:	442f      	add	r7, r5
   87864:	9d11      	ldr	r5, [sp, #68]	; 0x44
   87866:	42ac      	cmp	r4, r5
   87868:	db42      	blt.n	878f0 <_svfprintf_r+0xe04>
   8786a:	9d09      	ldr	r5, [sp, #36]	; 0x24
   8786c:	07e9      	lsls	r1, r5, #31
   8786e:	d43f      	bmi.n	878f0 <_svfprintf_r+0xe04>
   87870:	9811      	ldr	r0, [sp, #68]	; 0x44
   87872:	ebc7 050a 	rsb	r5, r7, sl
   87876:	1b04      	subs	r4, r0, r4
   87878:	42ac      	cmp	r4, r5
   8787a:	bfb8      	it	lt
   8787c:	4625      	movlt	r5, r4
   8787e:	2d00      	cmp	r5, #0
   87880:	dd0b      	ble.n	8789a <_svfprintf_r+0xdae>
   87882:	9b2c      	ldr	r3, [sp, #176]	; 0xb0
   87884:	44ac      	add	ip, r5
   87886:	3301      	adds	r3, #1
   87888:	2b07      	cmp	r3, #7
   8788a:	f8cd c0b4 	str.w	ip, [sp, #180]	; 0xb4
   8788e:	6037      	str	r7, [r6, #0]
   87890:	6075      	str	r5, [r6, #4]
   87892:	932c      	str	r3, [sp, #176]	; 0xb0
   87894:	f300 824c 	bgt.w	87d30 <_svfprintf_r+0x1244>
   87898:	3608      	adds	r6, #8
   8789a:	ea25 75e5 	bic.w	r5, r5, r5, asr #31
   8789e:	1b64      	subs	r4, r4, r5
   878a0:	2c00      	cmp	r4, #0
   878a2:	f77f ab95 	ble.w	86fd0 <_svfprintf_r+0x4e4>
   878a6:	2c10      	cmp	r4, #16
   878a8:	9b2c      	ldr	r3, [sp, #176]	; 0xb0
   878aa:	4d50      	ldr	r5, [pc, #320]	; (879ec <_svfprintf_r+0xf00>)
   878ac:	f77f af7f 	ble.w	877ae <_svfprintf_r+0xcc2>
   878b0:	2710      	movs	r7, #16
   878b2:	4662      	mov	r2, ip
   878b4:	f8dd 8034 	ldr.w	r8, [sp, #52]	; 0x34
   878b8:	f8dd a030 	ldr.w	sl, [sp, #48]	; 0x30
   878bc:	e004      	b.n	878c8 <_svfprintf_r+0xddc>
   878be:	3608      	adds	r6, #8
   878c0:	3c10      	subs	r4, #16
   878c2:	2c10      	cmp	r4, #16
   878c4:	f77f af72 	ble.w	877ac <_svfprintf_r+0xcc0>
   878c8:	3301      	adds	r3, #1
   878ca:	3210      	adds	r2, #16
   878cc:	2b07      	cmp	r3, #7
   878ce:	922d      	str	r2, [sp, #180]	; 0xb4
   878d0:	932c      	str	r3, [sp, #176]	; 0xb0
   878d2:	e886 00a0 	stmia.w	r6, {r5, r7}
   878d6:	ddf2      	ble.n	878be <_svfprintf_r+0xdd2>
   878d8:	4640      	mov	r0, r8
   878da:	4651      	mov	r1, sl
   878dc:	aa2b      	add	r2, sp, #172	; 0xac
   878de:	f002 fce5 	bl	8a2ac <__ssprint_r>
   878e2:	2800      	cmp	r0, #0
   878e4:	f47f aa1a 	bne.w	86d1c <_svfprintf_r+0x230>
   878e8:	9a2d      	ldr	r2, [sp, #180]	; 0xb4
   878ea:	9b2c      	ldr	r3, [sp, #176]	; 0xb0
   878ec:	ae38      	add	r6, sp, #224	; 0xe0
   878ee:	e7e7      	b.n	878c0 <_svfprintf_r+0xdd4>
   878f0:	9d18      	ldr	r5, [sp, #96]	; 0x60
   878f2:	9b2c      	ldr	r3, [sp, #176]	; 0xb0
   878f4:	44ac      	add	ip, r5
   878f6:	9d15      	ldr	r5, [sp, #84]	; 0x54
   878f8:	3301      	adds	r3, #1
   878fa:	6035      	str	r5, [r6, #0]
   878fc:	9d18      	ldr	r5, [sp, #96]	; 0x60
   878fe:	2b07      	cmp	r3, #7
   87900:	f8cd c0b4 	str.w	ip, [sp, #180]	; 0xb4
   87904:	6075      	str	r5, [r6, #4]
   87906:	932c      	str	r3, [sp, #176]	; 0xb0
   87908:	f300 81f4 	bgt.w	87cf4 <_svfprintf_r+0x1208>
   8790c:	3608      	adds	r6, #8
   8790e:	e7af      	b.n	87870 <_svfprintf_r+0xd84>
   87910:	9d09      	ldr	r5, [sp, #36]	; 0x24
   87912:	07ea      	lsls	r2, r5, #31
   87914:	f53f ae2a 	bmi.w	8756c <_svfprintf_r+0xa80>
   87918:	3401      	adds	r4, #1
   8791a:	f10c 0801 	add.w	r8, ip, #1
   8791e:	2301      	movs	r3, #1
   87920:	2c07      	cmp	r4, #7
   87922:	f8cd 80b4 	str.w	r8, [sp, #180]	; 0xb4
   87926:	942c      	str	r4, [sp, #176]	; 0xb0
   87928:	6037      	str	r7, [r6, #0]
   8792a:	6073      	str	r3, [r6, #4]
   8792c:	f77f ae4f 	ble.w	875ce <_svfprintf_r+0xae2>
   87930:	e72f      	b.n	87792 <_svfprintf_r+0xca6>
   87932:	980d      	ldr	r0, [sp, #52]	; 0x34
   87934:	990c      	ldr	r1, [sp, #48]	; 0x30
   87936:	aa2b      	add	r2, sp, #172	; 0xac
   87938:	f002 fcb8 	bl	8a2ac <__ssprint_r>
   8793c:	2800      	cmp	r0, #0
   8793e:	f47f a9ed 	bne.w	86d1c <_svfprintf_r+0x230>
   87942:	9b2d      	ldr	r3, [sp, #180]	; 0xb4
   87944:	9c2c      	ldr	r4, [sp, #176]	; 0xb0
   87946:	ae38      	add	r6, sp, #224	; 0xe0
   87948:	e61c      	b.n	87584 <_svfprintf_r+0xa98>
   8794a:	980d      	ldr	r0, [sp, #52]	; 0x34
   8794c:	990c      	ldr	r1, [sp, #48]	; 0x30
   8794e:	aa2b      	add	r2, sp, #172	; 0xac
   87950:	f002 fcac 	bl	8a2ac <__ssprint_r>
   87954:	2800      	cmp	r0, #0
   87956:	f47f a9e1 	bne.w	86d1c <_svfprintf_r+0x230>
   8795a:	f8dd 80b4 	ldr.w	r8, [sp, #180]	; 0xb4
   8795e:	9c2c      	ldr	r4, [sp, #176]	; 0xb0
   87960:	ae38      	add	r6, sp, #224	; 0xe0
   87962:	e61e      	b.n	875a2 <_svfprintf_r+0xab6>
   87964:	980d      	ldr	r0, [sp, #52]	; 0x34
   87966:	990c      	ldr	r1, [sp, #48]	; 0x30
   87968:	aa2b      	add	r2, sp, #172	; 0xac
   8796a:	f002 fc9f 	bl	8a2ac <__ssprint_r>
   8796e:	2800      	cmp	r0, #0
   87970:	f47f a9d4 	bne.w	86d1c <_svfprintf_r+0x230>
   87974:	f8dd c0b4 	ldr.w	ip, [sp, #180]	; 0xb4
   87978:	ae38      	add	r6, sp, #224	; 0xe0
   8797a:	f7ff bad7 	b.w	86f2c <_svfprintf_r+0x440>
   8797e:	f002 fc5b 	bl	8a238 <__fpclassifyd>
   87982:	2800      	cmp	r0, #0
   87984:	f040 80bb 	bne.w	87afe <_svfprintf_r+0x1012>
   87988:	9c09      	ldr	r4, [sp, #36]	; 0x24
   8798a:	4f19      	ldr	r7, [pc, #100]	; (879f0 <_svfprintf_r+0xf04>)
   8798c:	4b19      	ldr	r3, [pc, #100]	; (879f4 <_svfprintf_r+0xf08>)
   8798e:	f04f 0c03 	mov.w	ip, #3
   87992:	f024 0480 	bic.w	r4, r4, #128	; 0x80
   87996:	9409      	str	r4, [sp, #36]	; 0x24
   87998:	900a      	str	r0, [sp, #40]	; 0x28
   8799a:	f8cd c02c 	str.w	ip, [sp, #44]	; 0x2c
   8799e:	9014      	str	r0, [sp, #80]	; 0x50
   879a0:	f1b8 0f47 	cmp.w	r8, #71	; 0x47
   879a4:	bfd8      	it	le
   879a6:	461f      	movle	r7, r3
   879a8:	4664      	mov	r4, ip
   879aa:	f89d a08f 	ldrb.w	sl, [sp, #143]	; 0x8f
   879ae:	f7ff ba34 	b.w	86e1a <_svfprintf_r+0x32e>
   879b2:	9c09      	ldr	r4, [sp, #36]	; 0x24
   879b4:	0664      	lsls	r4, r4, #25
   879b6:	f140 8150 	bpl.w	87c5a <_svfprintf_r+0x116e>
   879ba:	f8dd c040 	ldr.w	ip, [sp, #64]	; 0x40
   879be:	2500      	movs	r5, #0
   879c0:	f8bc 4000 	ldrh.w	r4, [ip]
   879c4:	f10c 0c04 	add.w	ip, ip, #4
   879c8:	f8cd c040 	str.w	ip, [sp, #64]	; 0x40
   879cc:	f7ff b9e4 	b.w	86d98 <_svfprintf_r+0x2ac>
   879d0:	f8dd c024 	ldr.w	ip, [sp, #36]	; 0x24
   879d4:	f01c 0f10 	tst.w	ip, #16
   879d8:	f000 8146 	beq.w	87c68 <_svfprintf_r+0x117c>
   879dc:	9c10      	ldr	r4, [sp, #64]	; 0x40
   879de:	9d0e      	ldr	r5, [sp, #56]	; 0x38
   879e0:	6823      	ldr	r3, [r4, #0]
   879e2:	3404      	adds	r4, #4
   879e4:	9410      	str	r4, [sp, #64]	; 0x40
   879e6:	601d      	str	r5, [r3, #0]
   879e8:	f7ff b8a6 	b.w	86b38 <_svfprintf_r+0x4c>
   879ec:	0008cc14 	.word	0x0008cc14
   879f0:	0008cc30 	.word	0x0008cc30
   879f4:	0008cc2c 	.word	0x0008cc2c
   879f8:	462c      	mov	r4, r5
   879fa:	463d      	mov	r5, r7
   879fc:	9f0a      	ldr	r7, [sp, #40]	; 0x28
   879fe:	4694      	mov	ip, r2
   87a00:	3301      	adds	r3, #1
   87a02:	44a4      	add	ip, r4
   87a04:	2b07      	cmp	r3, #7
   87a06:	f8cd c0b4 	str.w	ip, [sp, #180]	; 0xb4
   87a0a:	932c      	str	r3, [sp, #176]	; 0xb0
   87a0c:	6035      	str	r5, [r6, #0]
   87a0e:	6074      	str	r4, [r6, #4]
   87a10:	f73f af1a 	bgt.w	87848 <_svfprintf_r+0xd5c>
   87a14:	3608      	adds	r6, #8
   87a16:	e722      	b.n	8785e <_svfprintf_r+0xd72>
   87a18:	980d      	ldr	r0, [sp, #52]	; 0x34
   87a1a:	990c      	ldr	r1, [sp, #48]	; 0x30
   87a1c:	aa2b      	add	r2, sp, #172	; 0xac
   87a1e:	f002 fc45 	bl	8a2ac <__ssprint_r>
   87a22:	2800      	cmp	r0, #0
   87a24:	f47f a97a 	bne.w	86d1c <_svfprintf_r+0x230>
   87a28:	f8dd c0b4 	ldr.w	ip, [sp, #180]	; 0xb4
   87a2c:	ae38      	add	r6, sp, #224	; 0xe0
   87a2e:	e507      	b.n	87440 <_svfprintf_r+0x954>
   87a30:	9a2c      	ldr	r2, [sp, #176]	; 0xb0
   87a32:	49b7      	ldr	r1, [pc, #732]	; (87d10 <_svfprintf_r+0x1224>)
   87a34:	3201      	adds	r2, #1
   87a36:	f10c 0c01 	add.w	ip, ip, #1
   87a3a:	2001      	movs	r0, #1
   87a3c:	2a07      	cmp	r2, #7
   87a3e:	f8cd c0b4 	str.w	ip, [sp, #180]	; 0xb4
   87a42:	922c      	str	r2, [sp, #176]	; 0xb0
   87a44:	6031      	str	r1, [r6, #0]
   87a46:	6070      	str	r0, [r6, #4]
   87a48:	f300 80f7 	bgt.w	87c3a <_svfprintf_r+0x114e>
   87a4c:	3608      	adds	r6, #8
   87a4e:	461c      	mov	r4, r3
   87a50:	b92c      	cbnz	r4, 87a5e <_svfprintf_r+0xf72>
   87a52:	9d11      	ldr	r5, [sp, #68]	; 0x44
   87a54:	b91d      	cbnz	r5, 87a5e <_svfprintf_r+0xf72>
   87a56:	9d09      	ldr	r5, [sp, #36]	; 0x24
   87a58:	07e8      	lsls	r0, r5, #31
   87a5a:	f57f aab9 	bpl.w	86fd0 <_svfprintf_r+0x4e4>
   87a5e:	9b2c      	ldr	r3, [sp, #176]	; 0xb0
   87a60:	9d15      	ldr	r5, [sp, #84]	; 0x54
   87a62:	9918      	ldr	r1, [sp, #96]	; 0x60
   87a64:	3301      	adds	r3, #1
   87a66:	6035      	str	r5, [r6, #0]
   87a68:	9d18      	ldr	r5, [sp, #96]	; 0x60
   87a6a:	4461      	add	r1, ip
   87a6c:	2b07      	cmp	r3, #7
   87a6e:	912d      	str	r1, [sp, #180]	; 0xb4
   87a70:	6075      	str	r5, [r6, #4]
   87a72:	932c      	str	r3, [sp, #176]	; 0xb0
   87a74:	f300 81de 	bgt.w	87e34 <_svfprintf_r+0x1348>
   87a78:	f106 0208 	add.w	r2, r6, #8
   87a7c:	4264      	negs	r4, r4
   87a7e:	2c00      	cmp	r4, #0
   87a80:	f340 810b 	ble.w	87c9a <_svfprintf_r+0x11ae>
   87a84:	2c10      	cmp	r4, #16
   87a86:	4da3      	ldr	r5, [pc, #652]	; (87d14 <_svfprintf_r+0x1228>)
   87a88:	f340 8148 	ble.w	87d1c <_svfprintf_r+0x1230>
   87a8c:	46a3      	mov	fp, r4
   87a8e:	2610      	movs	r6, #16
   87a90:	460c      	mov	r4, r1
   87a92:	f8dd 8034 	ldr.w	r8, [sp, #52]	; 0x34
   87a96:	f8dd a030 	ldr.w	sl, [sp, #48]	; 0x30
   87a9a:	e006      	b.n	87aaa <_svfprintf_r+0xfbe>
   87a9c:	3208      	adds	r2, #8
   87a9e:	f1ab 0b10 	sub.w	fp, fp, #16
   87aa2:	f1bb 0f10 	cmp.w	fp, #16
   87aa6:	f340 8137 	ble.w	87d18 <_svfprintf_r+0x122c>
   87aaa:	3301      	adds	r3, #1
   87aac:	3410      	adds	r4, #16
   87aae:	2b07      	cmp	r3, #7
   87ab0:	942d      	str	r4, [sp, #180]	; 0xb4
   87ab2:	932c      	str	r3, [sp, #176]	; 0xb0
   87ab4:	e882 0060 	stmia.w	r2, {r5, r6}
   87ab8:	ddf0      	ble.n	87a9c <_svfprintf_r+0xfb0>
   87aba:	4640      	mov	r0, r8
   87abc:	4651      	mov	r1, sl
   87abe:	aa2b      	add	r2, sp, #172	; 0xac
   87ac0:	f002 fbf4 	bl	8a2ac <__ssprint_r>
   87ac4:	2800      	cmp	r0, #0
   87ac6:	f47f a929 	bne.w	86d1c <_svfprintf_r+0x230>
   87aca:	9c2d      	ldr	r4, [sp, #180]	; 0xb4
   87acc:	9b2c      	ldr	r3, [sp, #176]	; 0xb0
   87ace:	aa38      	add	r2, sp, #224	; 0xe0
   87ad0:	e7e5      	b.n	87a9e <_svfprintf_r+0xfb2>
   87ad2:	9c09      	ldr	r4, [sp, #36]	; 0x24
   87ad4:	f109 0901 	add.w	r9, r9, #1
   87ad8:	f044 0420 	orr.w	r4, r4, #32
   87adc:	9409      	str	r4, [sp, #36]	; 0x24
   87ade:	f893 8001 	ldrb.w	r8, [r3, #1]
   87ae2:	f7ff b85f 	b.w	86ba4 <_svfprintf_r+0xb8>
   87ae6:	980d      	ldr	r0, [sp, #52]	; 0x34
   87ae8:	990c      	ldr	r1, [sp, #48]	; 0x30
   87aea:	aa2b      	add	r2, sp, #172	; 0xac
   87aec:	f002 fbde 	bl	8a2ac <__ssprint_r>
   87af0:	2800      	cmp	r0, #0
   87af2:	f47f a913 	bne.w	86d1c <_svfprintf_r+0x230>
   87af6:	f8dd c0b4 	ldr.w	ip, [sp, #180]	; 0xb4
   87afa:	ae38      	add	r6, sp, #224	; 0xe0
   87afc:	e4b6      	b.n	8746c <_svfprintf_r+0x980>
   87afe:	9d0a      	ldr	r5, [sp, #40]	; 0x28
   87b00:	f028 0a20 	bic.w	sl, r8, #32
   87b04:	3501      	adds	r5, #1
   87b06:	f000 80a5 	beq.w	87c54 <_svfprintf_r+0x1168>
   87b0a:	f1ba 0f47 	cmp.w	sl, #71	; 0x47
   87b0e:	d104      	bne.n	87b1a <_svfprintf_r+0x102e>
   87b10:	9d0a      	ldr	r5, [sp, #40]	; 0x28
   87b12:	2d00      	cmp	r5, #0
   87b14:	bf08      	it	eq
   87b16:	2501      	moveq	r5, #1
   87b18:	950a      	str	r5, [sp, #40]	; 0x28
   87b1a:	f8dd c024 	ldr.w	ip, [sp, #36]	; 0x24
   87b1e:	e9dd 2316 	ldrd	r2, r3, [sp, #88]	; 0x58
   87b22:	f44c 7c80 	orr.w	ip, ip, #256	; 0x100
   87b26:	2b00      	cmp	r3, #0
   87b28:	f8cd c048 	str.w	ip, [sp, #72]	; 0x48
   87b2c:	f2c0 819c 	blt.w	87e68 <_svfprintf_r+0x137c>
   87b30:	e9dd 4516 	ldrd	r4, r5, [sp, #88]	; 0x58
   87b34:	e9cd 4520 	strd	r4, r5, [sp, #128]	; 0x80
   87b38:	f04f 0b00 	mov.w	fp, #0
   87b3c:	f1b8 0f66 	cmp.w	r8, #102	; 0x66
   87b40:	f000 819b 	beq.w	87e7a <_svfprintf_r+0x138e>
   87b44:	f1b8 0f46 	cmp.w	r8, #70	; 0x46
   87b48:	f000 81a9 	beq.w	87e9e <_svfprintf_r+0x13b2>
   87b4c:	f1ba 0f45 	cmp.w	sl, #69	; 0x45
   87b50:	bf0a      	itet	eq
   87b52:	9c0a      	ldreq	r4, [sp, #40]	; 0x28
   87b54:	9d0a      	ldrne	r5, [sp, #40]	; 0x28
   87b56:	1c65      	addeq	r5, r4, #1
   87b58:	2002      	movs	r0, #2
   87b5a:	a925      	add	r1, sp, #148	; 0x94
   87b5c:	aa26      	add	r2, sp, #152	; 0x98
   87b5e:	ab29      	add	r3, sp, #164	; 0xa4
   87b60:	e88d 0021 	stmia.w	sp, {r0, r5}
   87b64:	9203      	str	r2, [sp, #12]
   87b66:	9304      	str	r3, [sp, #16]
   87b68:	9102      	str	r1, [sp, #8]
   87b6a:	980d      	ldr	r0, [sp, #52]	; 0x34
   87b6c:	e9dd 2320 	ldrd	r2, r3, [sp, #128]	; 0x80
   87b70:	f000 fad6 	bl	88120 <_dtoa_r>
   87b74:	f1b8 0f67 	cmp.w	r8, #103	; 0x67
   87b78:	4607      	mov	r7, r0
   87b7a:	d002      	beq.n	87b82 <_svfprintf_r+0x1096>
   87b7c:	f1b8 0f47 	cmp.w	r8, #71	; 0x47
   87b80:	d105      	bne.n	87b8e <_svfprintf_r+0x10a2>
   87b82:	f8dd c024 	ldr.w	ip, [sp, #36]	; 0x24
   87b86:	f01c 0f01 	tst.w	ip, #1
   87b8a:	f000 819c 	beq.w	87ec6 <_svfprintf_r+0x13da>
   87b8e:	f1ba 0f46 	cmp.w	sl, #70	; 0x46
   87b92:	eb07 0405 	add.w	r4, r7, r5
   87b96:	f000 811c 	beq.w	87dd2 <_svfprintf_r+0x12e6>
   87b9a:	e9dd 0120 	ldrd	r0, r1, [sp, #128]	; 0x80
   87b9e:	2200      	movs	r2, #0
   87ba0:	2300      	movs	r3, #0
   87ba2:	f003 f8a7 	bl	8acf4 <__aeabi_dcmpeq>
   87ba6:	2800      	cmp	r0, #0
   87ba8:	f040 8105 	bne.w	87db6 <_svfprintf_r+0x12ca>
   87bac:	9b29      	ldr	r3, [sp, #164]	; 0xa4
   87bae:	429c      	cmp	r4, r3
   87bb0:	d906      	bls.n	87bc0 <_svfprintf_r+0x10d4>
   87bb2:	2130      	movs	r1, #48	; 0x30
   87bb4:	1c5a      	adds	r2, r3, #1
   87bb6:	9229      	str	r2, [sp, #164]	; 0xa4
   87bb8:	7019      	strb	r1, [r3, #0]
   87bba:	9b29      	ldr	r3, [sp, #164]	; 0xa4
   87bbc:	429c      	cmp	r4, r3
   87bbe:	d8f9      	bhi.n	87bb4 <_svfprintf_r+0x10c8>
   87bc0:	1bdb      	subs	r3, r3, r7
   87bc2:	f1ba 0f47 	cmp.w	sl, #71	; 0x47
   87bc6:	9311      	str	r3, [sp, #68]	; 0x44
   87bc8:	f000 80ed 	beq.w	87da6 <_svfprintf_r+0x12ba>
   87bcc:	f1b8 0f65 	cmp.w	r8, #101	; 0x65
   87bd0:	f340 81f2 	ble.w	87fb8 <_svfprintf_r+0x14cc>
   87bd4:	f1b8 0f66 	cmp.w	r8, #102	; 0x66
   87bd8:	f000 8168 	beq.w	87eac <_svfprintf_r+0x13c0>
   87bdc:	9c25      	ldr	r4, [sp, #148]	; 0x94
   87bde:	9414      	str	r4, [sp, #80]	; 0x50
   87be0:	9c11      	ldr	r4, [sp, #68]	; 0x44
   87be2:	9d14      	ldr	r5, [sp, #80]	; 0x50
   87be4:	42ac      	cmp	r4, r5
   87be6:	f300 8132 	bgt.w	87e4e <_svfprintf_r+0x1362>
   87bea:	f8dd c024 	ldr.w	ip, [sp, #36]	; 0x24
   87bee:	f01c 0f01 	tst.w	ip, #1
   87bf2:	f040 81ad 	bne.w	87f50 <_svfprintf_r+0x1464>
   87bf6:	ea25 73e5 	bic.w	r3, r5, r5, asr #31
   87bfa:	462c      	mov	r4, r5
   87bfc:	f04f 0867 	mov.w	r8, #103	; 0x67
   87c00:	f1bb 0f00 	cmp.w	fp, #0
   87c04:	f040 80b2 	bne.w	87d6c <_svfprintf_r+0x1280>
   87c08:	9d12      	ldr	r5, [sp, #72]	; 0x48
   87c0a:	930b      	str	r3, [sp, #44]	; 0x2c
   87c0c:	9509      	str	r5, [sp, #36]	; 0x24
   87c0e:	f8cd b028 	str.w	fp, [sp, #40]	; 0x28
   87c12:	f89d a08f 	ldrb.w	sl, [sp, #143]	; 0x8f
   87c16:	f7ff b900 	b.w	86e1a <_svfprintf_r+0x32e>
   87c1a:	980d      	ldr	r0, [sp, #52]	; 0x34
   87c1c:	2140      	movs	r1, #64	; 0x40
   87c1e:	f001 fad1 	bl	891c4 <_malloc_r>
   87c22:	6020      	str	r0, [r4, #0]
   87c24:	6120      	str	r0, [r4, #16]
   87c26:	2800      	cmp	r0, #0
   87c28:	f000 81bf 	beq.w	87faa <_svfprintf_r+0x14be>
   87c2c:	f8dd c030 	ldr.w	ip, [sp, #48]	; 0x30
   87c30:	2340      	movs	r3, #64	; 0x40
   87c32:	f8cc 3014 	str.w	r3, [ip, #20]
   87c36:	f7fe bf6f 	b.w	86b18 <_svfprintf_r+0x2c>
   87c3a:	980d      	ldr	r0, [sp, #52]	; 0x34
   87c3c:	990c      	ldr	r1, [sp, #48]	; 0x30
   87c3e:	aa2b      	add	r2, sp, #172	; 0xac
   87c40:	f002 fb34 	bl	8a2ac <__ssprint_r>
   87c44:	2800      	cmp	r0, #0
   87c46:	f47f a869 	bne.w	86d1c <_svfprintf_r+0x230>
   87c4a:	9c25      	ldr	r4, [sp, #148]	; 0x94
   87c4c:	f8dd c0b4 	ldr.w	ip, [sp, #180]	; 0xb4
   87c50:	ae38      	add	r6, sp, #224	; 0xe0
   87c52:	e6fd      	b.n	87a50 <_svfprintf_r+0xf64>
   87c54:	2406      	movs	r4, #6
   87c56:	940a      	str	r4, [sp, #40]	; 0x28
   87c58:	e75f      	b.n	87b1a <_svfprintf_r+0x102e>
   87c5a:	9d10      	ldr	r5, [sp, #64]	; 0x40
   87c5c:	682c      	ldr	r4, [r5, #0]
   87c5e:	3504      	adds	r5, #4
   87c60:	9510      	str	r5, [sp, #64]	; 0x40
   87c62:	2500      	movs	r5, #0
   87c64:	f7ff b898 	b.w	86d98 <_svfprintf_r+0x2ac>
   87c68:	f8dd c024 	ldr.w	ip, [sp, #36]	; 0x24
   87c6c:	f01c 0f40 	tst.w	ip, #64	; 0x40
   87c70:	f000 8087 	beq.w	87d82 <_svfprintf_r+0x1296>
   87c74:	9c10      	ldr	r4, [sp, #64]	; 0x40
   87c76:	9d0e      	ldr	r5, [sp, #56]	; 0x38
   87c78:	6823      	ldr	r3, [r4, #0]
   87c7a:	3404      	adds	r4, #4
   87c7c:	9410      	str	r4, [sp, #64]	; 0x40
   87c7e:	801d      	strh	r5, [r3, #0]
   87c80:	f7fe bf5a 	b.w	86b38 <_svfprintf_r+0x4c>
   87c84:	980d      	ldr	r0, [sp, #52]	; 0x34
   87c86:	990c      	ldr	r1, [sp, #48]	; 0x30
   87c88:	aa2b      	add	r2, sp, #172	; 0xac
   87c8a:	f002 fb0f 	bl	8a2ac <__ssprint_r>
   87c8e:	2800      	cmp	r0, #0
   87c90:	f47f a844 	bne.w	86d1c <_svfprintf_r+0x230>
   87c94:	992d      	ldr	r1, [sp, #180]	; 0xb4
   87c96:	9b2c      	ldr	r3, [sp, #176]	; 0xb0
   87c98:	aa38      	add	r2, sp, #224	; 0xe0
   87c9a:	f8dd c044 	ldr.w	ip, [sp, #68]	; 0x44
   87c9e:	3301      	adds	r3, #1
   87ca0:	9c11      	ldr	r4, [sp, #68]	; 0x44
   87ca2:	448c      	add	ip, r1
   87ca4:	2b07      	cmp	r3, #7
   87ca6:	f8cd c0b4 	str.w	ip, [sp, #180]	; 0xb4
   87caa:	932c      	str	r3, [sp, #176]	; 0xb0
   87cac:	6017      	str	r7, [r2, #0]
   87cae:	6054      	str	r4, [r2, #4]
   87cb0:	f73f ac9c 	bgt.w	875ec <_svfprintf_r+0xb00>
   87cb4:	f102 0608 	add.w	r6, r2, #8
   87cb8:	f7ff b98a 	b.w	86fd0 <_svfprintf_r+0x4e4>
   87cbc:	f8cd a028 	str.w	sl, [sp, #40]	; 0x28
   87cc0:	f7fe fd90 	bl	867e4 <strlen>
   87cc4:	9510      	str	r5, [sp, #64]	; 0x40
   87cc6:	9d0a      	ldr	r5, [sp, #40]	; 0x28
   87cc8:	ea20 7ce0 	bic.w	ip, r0, r0, asr #31
   87ccc:	4604      	mov	r4, r0
   87cce:	f8cd c02c 	str.w	ip, [sp, #44]	; 0x2c
   87cd2:	9514      	str	r5, [sp, #80]	; 0x50
   87cd4:	f89d a08f 	ldrb.w	sl, [sp, #143]	; 0x8f
   87cd8:	f7ff b89f 	b.w	86e1a <_svfprintf_r+0x32e>
   87cdc:	980d      	ldr	r0, [sp, #52]	; 0x34
   87cde:	990c      	ldr	r1, [sp, #48]	; 0x30
   87ce0:	aa2b      	add	r2, sp, #172	; 0xac
   87ce2:	f002 fae3 	bl	8a2ac <__ssprint_r>
   87ce6:	2800      	cmp	r0, #0
   87ce8:	f47f a818 	bne.w	86d1c <_svfprintf_r+0x230>
   87cec:	f8dd c0b4 	ldr.w	ip, [sp, #180]	; 0xb4
   87cf0:	ae38      	add	r6, sp, #224	; 0xe0
   87cf2:	e4d6      	b.n	876a2 <_svfprintf_r+0xbb6>
   87cf4:	980d      	ldr	r0, [sp, #52]	; 0x34
   87cf6:	990c      	ldr	r1, [sp, #48]	; 0x30
   87cf8:	aa2b      	add	r2, sp, #172	; 0xac
   87cfa:	f002 fad7 	bl	8a2ac <__ssprint_r>
   87cfe:	2800      	cmp	r0, #0
   87d00:	f47f a80c 	bne.w	86d1c <_svfprintf_r+0x230>
   87d04:	9c25      	ldr	r4, [sp, #148]	; 0x94
   87d06:	f8dd c0b4 	ldr.w	ip, [sp, #180]	; 0xb4
   87d0a:	ae38      	add	r6, sp, #224	; 0xe0
   87d0c:	e5b0      	b.n	87870 <_svfprintf_r+0xd84>
   87d0e:	bf00      	nop
   87d10:	0008cc64 	.word	0x0008cc64
   87d14:	0008cc14 	.word	0x0008cc14
   87d18:	4621      	mov	r1, r4
   87d1a:	465c      	mov	r4, fp
   87d1c:	3301      	adds	r3, #1
   87d1e:	4421      	add	r1, r4
   87d20:	2b07      	cmp	r3, #7
   87d22:	912d      	str	r1, [sp, #180]	; 0xb4
   87d24:	932c      	str	r3, [sp, #176]	; 0xb0
   87d26:	6015      	str	r5, [r2, #0]
   87d28:	6054      	str	r4, [r2, #4]
   87d2a:	dcab      	bgt.n	87c84 <_svfprintf_r+0x1198>
   87d2c:	3208      	adds	r2, #8
   87d2e:	e7b4      	b.n	87c9a <_svfprintf_r+0x11ae>
   87d30:	980d      	ldr	r0, [sp, #52]	; 0x34
   87d32:	990c      	ldr	r1, [sp, #48]	; 0x30
   87d34:	aa2b      	add	r2, sp, #172	; 0xac
   87d36:	f002 fab9 	bl	8a2ac <__ssprint_r>
   87d3a:	2800      	cmp	r0, #0
   87d3c:	f47e afee 	bne.w	86d1c <_svfprintf_r+0x230>
   87d40:	9c25      	ldr	r4, [sp, #148]	; 0x94
   87d42:	9911      	ldr	r1, [sp, #68]	; 0x44
   87d44:	f8dd c0b4 	ldr.w	ip, [sp, #180]	; 0xb4
   87d48:	1b0c      	subs	r4, r1, r4
   87d4a:	ae38      	add	r6, sp, #224	; 0xe0
   87d4c:	e5a5      	b.n	8789a <_svfprintf_r+0xdae>
   87d4e:	9c0a      	ldr	r4, [sp, #40]	; 0x28
   87d50:	46ba      	mov	sl, r7
   87d52:	2c06      	cmp	r4, #6
   87d54:	bf28      	it	cs
   87d56:	2406      	movcs	r4, #6
   87d58:	ea24 7ce4 	bic.w	ip, r4, r4, asr #31
   87d5c:	970a      	str	r7, [sp, #40]	; 0x28
   87d5e:	9714      	str	r7, [sp, #80]	; 0x50
   87d60:	9510      	str	r5, [sp, #64]	; 0x40
   87d62:	f8cd c02c 	str.w	ip, [sp, #44]	; 0x2c
   87d66:	4f97      	ldr	r7, [pc, #604]	; (87fc4 <_svfprintf_r+0x14d8>)
   87d68:	f7ff b857 	b.w	86e1a <_svfprintf_r+0x32e>
   87d6c:	9d12      	ldr	r5, [sp, #72]	; 0x48
   87d6e:	f04f 0a2d 	mov.w	sl, #45	; 0x2d
   87d72:	9509      	str	r5, [sp, #36]	; 0x24
   87d74:	2500      	movs	r5, #0
   87d76:	930b      	str	r3, [sp, #44]	; 0x2c
   87d78:	f88d a08f 	strb.w	sl, [sp, #143]	; 0x8f
   87d7c:	950a      	str	r5, [sp, #40]	; 0x28
   87d7e:	f7ff b84f 	b.w	86e20 <_svfprintf_r+0x334>
   87d82:	f8dd c040 	ldr.w	ip, [sp, #64]	; 0x40
   87d86:	9c0e      	ldr	r4, [sp, #56]	; 0x38
   87d88:	f8dc 3000 	ldr.w	r3, [ip]
   87d8c:	f10c 0c04 	add.w	ip, ip, #4
   87d90:	f8cd c040 	str.w	ip, [sp, #64]	; 0x40
   87d94:	601c      	str	r4, [r3, #0]
   87d96:	f7fe becf 	b.w	86b38 <_svfprintf_r+0x4c>
   87d9a:	f04f 0a2d 	mov.w	sl, #45	; 0x2d
   87d9e:	f88d a08f 	strb.w	sl, [sp, #143]	; 0x8f
   87da2:	f7ff ba99 	b.w	872d8 <_svfprintf_r+0x7ec>
   87da6:	9b25      	ldr	r3, [sp, #148]	; 0x94
   87da8:	1cdc      	adds	r4, r3, #3
   87daa:	db19      	blt.n	87de0 <_svfprintf_r+0x12f4>
   87dac:	9c0a      	ldr	r4, [sp, #40]	; 0x28
   87dae:	429c      	cmp	r4, r3
   87db0:	db16      	blt.n	87de0 <_svfprintf_r+0x12f4>
   87db2:	9314      	str	r3, [sp, #80]	; 0x50
   87db4:	e714      	b.n	87be0 <_svfprintf_r+0x10f4>
   87db6:	4623      	mov	r3, r4
   87db8:	e702      	b.n	87bc0 <_svfprintf_r+0x10d4>
   87dba:	ea24 7ce4 	bic.w	ip, r4, r4, asr #31
   87dbe:	f8cd c02c 	str.w	ip, [sp, #44]	; 0x2c
   87dc2:	9c0a      	ldr	r4, [sp, #40]	; 0x28
   87dc4:	9510      	str	r5, [sp, #64]	; 0x40
   87dc6:	900a      	str	r0, [sp, #40]	; 0x28
   87dc8:	9014      	str	r0, [sp, #80]	; 0x50
   87dca:	f89d a08f 	ldrb.w	sl, [sp, #143]	; 0x8f
   87dce:	f7ff b824 	b.w	86e1a <_svfprintf_r+0x32e>
   87dd2:	783b      	ldrb	r3, [r7, #0]
   87dd4:	2b30      	cmp	r3, #48	; 0x30
   87dd6:	f000 80ad 	beq.w	87f34 <_svfprintf_r+0x1448>
   87dda:	9d25      	ldr	r5, [sp, #148]	; 0x94
   87ddc:	442c      	add	r4, r5
   87dde:	e6dc      	b.n	87b9a <_svfprintf_r+0x10ae>
   87de0:	f1a8 0802 	sub.w	r8, r8, #2
   87de4:	1e59      	subs	r1, r3, #1
   87de6:	2900      	cmp	r1, #0
   87de8:	9125      	str	r1, [sp, #148]	; 0x94
   87dea:	bfba      	itte	lt
   87dec:	4249      	neglt	r1, r1
   87dee:	232d      	movlt	r3, #45	; 0x2d
   87df0:	232b      	movge	r3, #43	; 0x2b
   87df2:	2909      	cmp	r1, #9
   87df4:	f88d 809c 	strb.w	r8, [sp, #156]	; 0x9c
   87df8:	f88d 309d 	strb.w	r3, [sp, #157]	; 0x9d
   87dfc:	dc65      	bgt.n	87eca <_svfprintf_r+0x13de>
   87dfe:	2330      	movs	r3, #48	; 0x30
   87e00:	3130      	adds	r1, #48	; 0x30
   87e02:	f88d 309e 	strb.w	r3, [sp, #158]	; 0x9e
   87e06:	f88d 109f 	strb.w	r1, [sp, #159]	; 0x9f
   87e0a:	ab28      	add	r3, sp, #160	; 0xa0
   87e0c:	9d11      	ldr	r5, [sp, #68]	; 0x44
   87e0e:	aa27      	add	r2, sp, #156	; 0x9c
   87e10:	9c11      	ldr	r4, [sp, #68]	; 0x44
   87e12:	1a9a      	subs	r2, r3, r2
   87e14:	2d01      	cmp	r5, #1
   87e16:	9219      	str	r2, [sp, #100]	; 0x64
   87e18:	4414      	add	r4, r2
   87e1a:	f340 80b7 	ble.w	87f8c <_svfprintf_r+0x14a0>
   87e1e:	3401      	adds	r4, #1
   87e20:	2500      	movs	r5, #0
   87e22:	ea24 73e4 	bic.w	r3, r4, r4, asr #31
   87e26:	9514      	str	r5, [sp, #80]	; 0x50
   87e28:	e6ea      	b.n	87c00 <_svfprintf_r+0x1114>
   87e2a:	2400      	movs	r4, #0
   87e2c:	4681      	mov	r9, r0
   87e2e:	940a      	str	r4, [sp, #40]	; 0x28
   87e30:	f7fe beba 	b.w	86ba8 <_svfprintf_r+0xbc>
   87e34:	980d      	ldr	r0, [sp, #52]	; 0x34
   87e36:	990c      	ldr	r1, [sp, #48]	; 0x30
   87e38:	aa2b      	add	r2, sp, #172	; 0xac
   87e3a:	f002 fa37 	bl	8a2ac <__ssprint_r>
   87e3e:	2800      	cmp	r0, #0
   87e40:	f47e af6c 	bne.w	86d1c <_svfprintf_r+0x230>
   87e44:	9c25      	ldr	r4, [sp, #148]	; 0x94
   87e46:	992d      	ldr	r1, [sp, #180]	; 0xb4
   87e48:	9b2c      	ldr	r3, [sp, #176]	; 0xb0
   87e4a:	aa38      	add	r2, sp, #224	; 0xe0
   87e4c:	e616      	b.n	87a7c <_svfprintf_r+0xf90>
   87e4e:	9c14      	ldr	r4, [sp, #80]	; 0x50
   87e50:	9d11      	ldr	r5, [sp, #68]	; 0x44
   87e52:	2c00      	cmp	r4, #0
   87e54:	bfd4      	ite	le
   87e56:	f1c4 0402 	rsble	r4, r4, #2
   87e5a:	2401      	movgt	r4, #1
   87e5c:	442c      	add	r4, r5
   87e5e:	ea24 73e4 	bic.w	r3, r4, r4, asr #31
   87e62:	f04f 0867 	mov.w	r8, #103	; 0x67
   87e66:	e6cb      	b.n	87c00 <_svfprintf_r+0x1114>
   87e68:	9917      	ldr	r1, [sp, #92]	; 0x5c
   87e6a:	9816      	ldr	r0, [sp, #88]	; 0x58
   87e6c:	f101 4100 	add.w	r1, r1, #2147483648	; 0x80000000
   87e70:	9020      	str	r0, [sp, #128]	; 0x80
   87e72:	9121      	str	r1, [sp, #132]	; 0x84
   87e74:	f04f 0b2d 	mov.w	fp, #45	; 0x2d
   87e78:	e660      	b.n	87b3c <_svfprintf_r+0x1050>
   87e7a:	9d0a      	ldr	r5, [sp, #40]	; 0x28
   87e7c:	2003      	movs	r0, #3
   87e7e:	a925      	add	r1, sp, #148	; 0x94
   87e80:	aa26      	add	r2, sp, #152	; 0x98
   87e82:	ab29      	add	r3, sp, #164	; 0xa4
   87e84:	9501      	str	r5, [sp, #4]
   87e86:	9000      	str	r0, [sp, #0]
   87e88:	9203      	str	r2, [sp, #12]
   87e8a:	9304      	str	r3, [sp, #16]
   87e8c:	9102      	str	r1, [sp, #8]
   87e8e:	980d      	ldr	r0, [sp, #52]	; 0x34
   87e90:	e9dd 2320 	ldrd	r2, r3, [sp, #128]	; 0x80
   87e94:	f000 f944 	bl	88120 <_dtoa_r>
   87e98:	9d0a      	ldr	r5, [sp, #40]	; 0x28
   87e9a:	4607      	mov	r7, r0
   87e9c:	e677      	b.n	87b8e <_svfprintf_r+0x10a2>
   87e9e:	9c0a      	ldr	r4, [sp, #40]	; 0x28
   87ea0:	2003      	movs	r0, #3
   87ea2:	a925      	add	r1, sp, #148	; 0x94
   87ea4:	aa26      	add	r2, sp, #152	; 0x98
   87ea6:	ab29      	add	r3, sp, #164	; 0xa4
   87ea8:	9401      	str	r4, [sp, #4]
   87eaa:	e7ec      	b.n	87e86 <_svfprintf_r+0x139a>
   87eac:	9d25      	ldr	r5, [sp, #148]	; 0x94
   87eae:	9c0a      	ldr	r4, [sp, #40]	; 0x28
   87eb0:	2d00      	cmp	r5, #0
   87eb2:	9514      	str	r5, [sp, #80]	; 0x50
   87eb4:	dd63      	ble.n	87f7e <_svfprintf_r+0x1492>
   87eb6:	bbb4      	cbnz	r4, 87f26 <_svfprintf_r+0x143a>
   87eb8:	9d09      	ldr	r5, [sp, #36]	; 0x24
   87eba:	07e8      	lsls	r0, r5, #31
   87ebc:	d433      	bmi.n	87f26 <_svfprintf_r+0x143a>
   87ebe:	9c14      	ldr	r4, [sp, #80]	; 0x50
   87ec0:	ea24 73e4 	bic.w	r3, r4, r4, asr #31
   87ec4:	e69c      	b.n	87c00 <_svfprintf_r+0x1114>
   87ec6:	9b29      	ldr	r3, [sp, #164]	; 0xa4
   87ec8:	e67a      	b.n	87bc0 <_svfprintf_r+0x10d4>
   87eca:	f10d 02aa 	add.w	r2, sp, #170	; 0xaa
   87ece:	4d3e      	ldr	r5, [pc, #248]	; (87fc8 <_svfprintf_r+0x14dc>)
   87ed0:	17cb      	asrs	r3, r1, #31
   87ed2:	fb85 5001 	smull	r5, r0, r5, r1
   87ed6:	ebc3 00a0 	rsb	r0, r3, r0, asr #2
   87eda:	eb00 0380 	add.w	r3, r0, r0, lsl #2
   87ede:	eba1 0143 	sub.w	r1, r1, r3, lsl #1
   87ee2:	2809      	cmp	r0, #9
   87ee4:	4613      	mov	r3, r2
   87ee6:	f101 0230 	add.w	r2, r1, #48	; 0x30
   87eea:	701a      	strb	r2, [r3, #0]
   87eec:	4601      	mov	r1, r0
   87eee:	f103 32ff 	add.w	r2, r3, #4294967295
   87ef2:	dcec      	bgt.n	87ece <_svfprintf_r+0x13e2>
   87ef4:	f100 0130 	add.w	r1, r0, #48	; 0x30
   87ef8:	f10d 04ab 	add.w	r4, sp, #171	; 0xab
   87efc:	b2c9      	uxtb	r1, r1
   87efe:	4294      	cmp	r4, r2
   87f00:	f803 1c01 	strb.w	r1, [r3, #-1]
   87f04:	d95a      	bls.n	87fbc <_svfprintf_r+0x14d0>
   87f06:	f10d 009d 	add.w	r0, sp, #157	; 0x9d
   87f0a:	461a      	mov	r2, r3
   87f0c:	e001      	b.n	87f12 <_svfprintf_r+0x1426>
   87f0e:	f812 1b01 	ldrb.w	r1, [r2], #1
   87f12:	42a2      	cmp	r2, r4
   87f14:	f800 1f01 	strb.w	r1, [r0, #1]!
   87f18:	d1f9      	bne.n	87f0e <_svfprintf_r+0x1422>
   87f1a:	f50d 7c90 	add.w	ip, sp, #288	; 0x120
   87f1e:	ebc3 034c 	rsb	r3, r3, ip, lsl #1
   87f22:	3bf6      	subs	r3, #246	; 0xf6
   87f24:	e772      	b.n	87e0c <_svfprintf_r+0x1320>
   87f26:	9d0a      	ldr	r5, [sp, #40]	; 0x28
   87f28:	1c6c      	adds	r4, r5, #1
   87f2a:	9d14      	ldr	r5, [sp, #80]	; 0x50
   87f2c:	442c      	add	r4, r5
   87f2e:	ea24 73e4 	bic.w	r3, r4, r4, asr #31
   87f32:	e665      	b.n	87c00 <_svfprintf_r+0x1114>
   87f34:	e9dd 0120 	ldrd	r0, r1, [sp, #128]	; 0x80
   87f38:	2200      	movs	r2, #0
   87f3a:	2300      	movs	r3, #0
   87f3c:	f002 feda 	bl	8acf4 <__aeabi_dcmpeq>
   87f40:	2800      	cmp	r0, #0
   87f42:	f47f af4a 	bne.w	87dda <_svfprintf_r+0x12ee>
   87f46:	f1c5 0501 	rsb	r5, r5, #1
   87f4a:	9525      	str	r5, [sp, #148]	; 0x94
   87f4c:	442c      	add	r4, r5
   87f4e:	e624      	b.n	87b9a <_svfprintf_r+0x10ae>
   87f50:	9d14      	ldr	r5, [sp, #80]	; 0x50
   87f52:	f04f 0867 	mov.w	r8, #103	; 0x67
   87f56:	1c6c      	adds	r4, r5, #1
   87f58:	ea24 73e4 	bic.w	r3, r4, r4, asr #31
   87f5c:	e650      	b.n	87c00 <_svfprintf_r+0x1114>
   87f5e:	9d10      	ldr	r5, [sp, #64]	; 0x40
   87f60:	f8dd c040 	ldr.w	ip, [sp, #64]	; 0x40
   87f64:	682d      	ldr	r5, [r5, #0]
   87f66:	f10c 0304 	add.w	r3, ip, #4
   87f6a:	2d00      	cmp	r5, #0
   87f6c:	f899 8001 	ldrb.w	r8, [r9, #1]
   87f70:	950a      	str	r5, [sp, #40]	; 0x28
   87f72:	9310      	str	r3, [sp, #64]	; 0x40
   87f74:	4681      	mov	r9, r0
   87f76:	f6be ae15 	bge.w	86ba4 <_svfprintf_r+0xb8>
   87f7a:	f7fe be10 	b.w	86b9e <_svfprintf_r+0xb2>
   87f7e:	b97c      	cbnz	r4, 87fa0 <_svfprintf_r+0x14b4>
   87f80:	9d09      	ldr	r5, [sp, #36]	; 0x24
   87f82:	07e9      	lsls	r1, r5, #31
   87f84:	d40c      	bmi.n	87fa0 <_svfprintf_r+0x14b4>
   87f86:	2301      	movs	r3, #1
   87f88:	461c      	mov	r4, r3
   87f8a:	e639      	b.n	87c00 <_svfprintf_r+0x1114>
   87f8c:	f8dd c024 	ldr.w	ip, [sp, #36]	; 0x24
   87f90:	f01c 0301 	ands.w	r3, ip, #1
   87f94:	f47f af43 	bne.w	87e1e <_svfprintf_r+0x1332>
   87f98:	9314      	str	r3, [sp, #80]	; 0x50
   87f9a:	ea24 73e4 	bic.w	r3, r4, r4, asr #31
   87f9e:	e62f      	b.n	87c00 <_svfprintf_r+0x1114>
   87fa0:	9d0a      	ldr	r5, [sp, #40]	; 0x28
   87fa2:	1cac      	adds	r4, r5, #2
   87fa4:	ea24 73e4 	bic.w	r3, r4, r4, asr #31
   87fa8:	e62a      	b.n	87c00 <_svfprintf_r+0x1114>
   87faa:	9d0d      	ldr	r5, [sp, #52]	; 0x34
   87fac:	230c      	movs	r3, #12
   87fae:	602b      	str	r3, [r5, #0]
   87fb0:	f04f 30ff 	mov.w	r0, #4294967295
   87fb4:	f7fe beba 	b.w	86d2c <_svfprintf_r+0x240>
   87fb8:	9b25      	ldr	r3, [sp, #148]	; 0x94
   87fba:	e713      	b.n	87de4 <_svfprintf_r+0x12f8>
   87fbc:	f10d 039e 	add.w	r3, sp, #158	; 0x9e
   87fc0:	e724      	b.n	87e0c <_svfprintf_r+0x1320>
   87fc2:	bf00      	nop
   87fc4:	0008cc5c 	.word	0x0008cc5c
   87fc8:	66666667 	.word	0x66666667

00087fcc <register_fini>:
   87fcc:	4b02      	ldr	r3, [pc, #8]	; (87fd8 <register_fini+0xc>)
   87fce:	b113      	cbz	r3, 87fd6 <register_fini+0xa>
   87fd0:	4802      	ldr	r0, [pc, #8]	; (87fdc <register_fini+0x10>)
   87fd2:	f000 b805 	b.w	87fe0 <atexit>
   87fd6:	4770      	bx	lr
   87fd8:	00000000 	.word	0x00000000
   87fdc:	00088f59 	.word	0x00088f59

00087fe0 <atexit>:
   87fe0:	4601      	mov	r1, r0
   87fe2:	2000      	movs	r0, #0
   87fe4:	4602      	mov	r2, r0
   87fe6:	4603      	mov	r3, r0
   87fe8:	f002 b9e0 	b.w	8a3ac <__register_exitproc>

00087fec <quorem>:
   87fec:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   87ff0:	6903      	ldr	r3, [r0, #16]
   87ff2:	690d      	ldr	r5, [r1, #16]
   87ff4:	b083      	sub	sp, #12
   87ff6:	429d      	cmp	r5, r3
   87ff8:	4683      	mov	fp, r0
   87ffa:	f300 808c 	bgt.w	88116 <quorem+0x12a>
   87ffe:	3d01      	subs	r5, #1
   88000:	f101 0414 	add.w	r4, r1, #20
   88004:	f100 0a14 	add.w	sl, r0, #20
   88008:	f854 2025 	ldr.w	r2, [r4, r5, lsl #2]
   8800c:	f85a 3025 	ldr.w	r3, [sl, r5, lsl #2]
   88010:	3201      	adds	r2, #1
   88012:	fbb3 f8f2 	udiv	r8, r3, r2
   88016:	00aa      	lsls	r2, r5, #2
   88018:	4691      	mov	r9, r2
   8801a:	9200      	str	r2, [sp, #0]
   8801c:	4452      	add	r2, sl
   8801e:	44a1      	add	r9, r4
   88020:	9201      	str	r2, [sp, #4]
   88022:	f1b8 0f00 	cmp.w	r8, #0
   88026:	d03e      	beq.n	880a6 <quorem+0xba>
   88028:	2600      	movs	r6, #0
   8802a:	4630      	mov	r0, r6
   8802c:	4622      	mov	r2, r4
   8802e:	4653      	mov	r3, sl
   88030:	468c      	mov	ip, r1
   88032:	f852 7b04 	ldr.w	r7, [r2], #4
   88036:	6819      	ldr	r1, [r3, #0]
   88038:	fa1f fe87 	uxth.w	lr, r7
   8803c:	0c3f      	lsrs	r7, r7, #16
   8803e:	fb0e 6e08 	mla	lr, lr, r8, r6
   88042:	fb07 f608 	mul.w	r6, r7, r8
   88046:	eb06 461e 	add.w	r6, r6, lr, lsr #16
   8804a:	fa1f fe8e 	uxth.w	lr, lr
   8804e:	ebce 0e00 	rsb	lr, lr, r0
   88052:	b28f      	uxth	r7, r1
   88054:	b2b0      	uxth	r0, r6
   88056:	4477      	add	r7, lr
   88058:	ebc0 4011 	rsb	r0, r0, r1, lsr #16
   8805c:	eb00 4027 	add.w	r0, r0, r7, asr #16
   88060:	b2bf      	uxth	r7, r7
   88062:	ea47 4700 	orr.w	r7, r7, r0, lsl #16
   88066:	4591      	cmp	r9, r2
   88068:	f843 7b04 	str.w	r7, [r3], #4
   8806c:	ea4f 4020 	mov.w	r0, r0, asr #16
   88070:	ea4f 4616 	mov.w	r6, r6, lsr #16
   88074:	d2dd      	bcs.n	88032 <quorem+0x46>
   88076:	9a00      	ldr	r2, [sp, #0]
   88078:	4661      	mov	r1, ip
   8807a:	f85a 3002 	ldr.w	r3, [sl, r2]
   8807e:	b993      	cbnz	r3, 880a6 <quorem+0xba>
   88080:	9a01      	ldr	r2, [sp, #4]
   88082:	1f13      	subs	r3, r2, #4
   88084:	459a      	cmp	sl, r3
   88086:	d20c      	bcs.n	880a2 <quorem+0xb6>
   88088:	f852 3c04 	ldr.w	r3, [r2, #-4]
   8808c:	b94b      	cbnz	r3, 880a2 <quorem+0xb6>
   8808e:	f1a2 0308 	sub.w	r3, r2, #8
   88092:	e002      	b.n	8809a <quorem+0xae>
   88094:	681a      	ldr	r2, [r3, #0]
   88096:	3b04      	subs	r3, #4
   88098:	b91a      	cbnz	r2, 880a2 <quorem+0xb6>
   8809a:	459a      	cmp	sl, r3
   8809c:	f105 35ff 	add.w	r5, r5, #4294967295
   880a0:	d3f8      	bcc.n	88094 <quorem+0xa8>
   880a2:	f8cb 5010 	str.w	r5, [fp, #16]
   880a6:	4658      	mov	r0, fp
   880a8:	f001 fdf8 	bl	89c9c <__mcmp>
   880ac:	2800      	cmp	r0, #0
   880ae:	db2e      	blt.n	8810e <quorem+0x122>
   880b0:	f108 0801 	add.w	r8, r8, #1
   880b4:	4653      	mov	r3, sl
   880b6:	2200      	movs	r2, #0
   880b8:	f854 6b04 	ldr.w	r6, [r4], #4
   880bc:	6818      	ldr	r0, [r3, #0]
   880be:	b2b1      	uxth	r1, r6
   880c0:	1a51      	subs	r1, r2, r1
   880c2:	b287      	uxth	r7, r0
   880c4:	0c36      	lsrs	r6, r6, #16
   880c6:	4439      	add	r1, r7
   880c8:	ebc6 4010 	rsb	r0, r6, r0, lsr #16
   880cc:	eb00 4221 	add.w	r2, r0, r1, asr #16
   880d0:	b289      	uxth	r1, r1
   880d2:	ea41 4102 	orr.w	r1, r1, r2, lsl #16
   880d6:	45a1      	cmp	r9, r4
   880d8:	f843 1b04 	str.w	r1, [r3], #4
   880dc:	ea4f 4222 	mov.w	r2, r2, asr #16
   880e0:	d2ea      	bcs.n	880b8 <quorem+0xcc>
   880e2:	f85a 2025 	ldr.w	r2, [sl, r5, lsl #2]
   880e6:	eb0a 0385 	add.w	r3, sl, r5, lsl #2
   880ea:	b982      	cbnz	r2, 8810e <quorem+0x122>
   880ec:	1f1a      	subs	r2, r3, #4
   880ee:	4592      	cmp	sl, r2
   880f0:	d20b      	bcs.n	8810a <quorem+0x11e>
   880f2:	f853 2c04 	ldr.w	r2, [r3, #-4]
   880f6:	b942      	cbnz	r2, 8810a <quorem+0x11e>
   880f8:	3b08      	subs	r3, #8
   880fa:	e002      	b.n	88102 <quorem+0x116>
   880fc:	681a      	ldr	r2, [r3, #0]
   880fe:	3b04      	subs	r3, #4
   88100:	b91a      	cbnz	r2, 8810a <quorem+0x11e>
   88102:	459a      	cmp	sl, r3
   88104:	f105 35ff 	add.w	r5, r5, #4294967295
   88108:	d3f8      	bcc.n	880fc <quorem+0x110>
   8810a:	f8cb 5010 	str.w	r5, [fp, #16]
   8810e:	4640      	mov	r0, r8
   88110:	b003      	add	sp, #12
   88112:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   88116:	2000      	movs	r0, #0
   88118:	b003      	add	sp, #12
   8811a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   8811e:	bf00      	nop

00088120 <_dtoa_r>:
   88120:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   88124:	6c01      	ldr	r1, [r0, #64]	; 0x40
   88126:	b09b      	sub	sp, #108	; 0x6c
   88128:	4604      	mov	r4, r0
   8812a:	4692      	mov	sl, r2
   8812c:	469b      	mov	fp, r3
   8812e:	9d27      	ldr	r5, [sp, #156]	; 0x9c
   88130:	b141      	cbz	r1, 88144 <_dtoa_r+0x24>
   88132:	6c43      	ldr	r3, [r0, #68]	; 0x44
   88134:	2201      	movs	r2, #1
   88136:	409a      	lsls	r2, r3
   88138:	604b      	str	r3, [r1, #4]
   8813a:	608a      	str	r2, [r1, #8]
   8813c:	f001 fbb8 	bl	898b0 <_Bfree>
   88140:	2300      	movs	r3, #0
   88142:	6423      	str	r3, [r4, #64]	; 0x40
   88144:	f1bb 0f00 	cmp.w	fp, #0
   88148:	46d9      	mov	r9, fp
   8814a:	db33      	blt.n	881b4 <_dtoa_r+0x94>
   8814c:	2300      	movs	r3, #0
   8814e:	602b      	str	r3, [r5, #0]
   88150:	4ba5      	ldr	r3, [pc, #660]	; (883e8 <_dtoa_r+0x2c8>)
   88152:	461a      	mov	r2, r3
   88154:	ea09 0303 	and.w	r3, r9, r3
   88158:	4293      	cmp	r3, r2
   8815a:	d014      	beq.n	88186 <_dtoa_r+0x66>
   8815c:	4650      	mov	r0, sl
   8815e:	4659      	mov	r1, fp
   88160:	2200      	movs	r2, #0
   88162:	2300      	movs	r3, #0
   88164:	f002 fdc6 	bl	8acf4 <__aeabi_dcmpeq>
   88168:	4680      	mov	r8, r0
   8816a:	b348      	cbz	r0, 881c0 <_dtoa_r+0xa0>
   8816c:	9e26      	ldr	r6, [sp, #152]	; 0x98
   8816e:	9d28      	ldr	r5, [sp, #160]	; 0xa0
   88170:	2301      	movs	r3, #1
   88172:	6033      	str	r3, [r6, #0]
   88174:	2d00      	cmp	r5, #0
   88176:	f000 80ca 	beq.w	8830e <_dtoa_r+0x1ee>
   8817a:	489c      	ldr	r0, [pc, #624]	; (883ec <_dtoa_r+0x2cc>)
   8817c:	6028      	str	r0, [r5, #0]
   8817e:	3801      	subs	r0, #1
   88180:	b01b      	add	sp, #108	; 0x6c
   88182:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   88186:	9d26      	ldr	r5, [sp, #152]	; 0x98
   88188:	f242 730f 	movw	r3, #9999	; 0x270f
   8818c:	602b      	str	r3, [r5, #0]
   8818e:	f1ba 0f00 	cmp.w	sl, #0
   88192:	f000 80a5 	beq.w	882e0 <_dtoa_r+0x1c0>
   88196:	4896      	ldr	r0, [pc, #600]	; (883f0 <_dtoa_r+0x2d0>)
   88198:	9e28      	ldr	r6, [sp, #160]	; 0xa0
   8819a:	2e00      	cmp	r6, #0
   8819c:	d0f0      	beq.n	88180 <_dtoa_r+0x60>
   8819e:	78c3      	ldrb	r3, [r0, #3]
   881a0:	2b00      	cmp	r3, #0
   881a2:	f000 80b6 	beq.w	88312 <_dtoa_r+0x1f2>
   881a6:	f100 0308 	add.w	r3, r0, #8
   881aa:	9d28      	ldr	r5, [sp, #160]	; 0xa0
   881ac:	602b      	str	r3, [r5, #0]
   881ae:	b01b      	add	sp, #108	; 0x6c
   881b0:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   881b4:	2301      	movs	r3, #1
   881b6:	f02b 4900 	bic.w	r9, fp, #2147483648	; 0x80000000
   881ba:	602b      	str	r3, [r5, #0]
   881bc:	46cb      	mov	fp, r9
   881be:	e7c7      	b.n	88150 <_dtoa_r+0x30>
   881c0:	aa19      	add	r2, sp, #100	; 0x64
   881c2:	ab18      	add	r3, sp, #96	; 0x60
   881c4:	e88d 000c 	stmia.w	sp, {r2, r3}
   881c8:	4620      	mov	r0, r4
   881ca:	4652      	mov	r2, sl
   881cc:	465b      	mov	r3, fp
   881ce:	f001 fdf5 	bl	89dbc <__d2b>
   881d2:	ea5f 5519 	movs.w	r5, r9, lsr #20
   881d6:	900a      	str	r0, [sp, #40]	; 0x28
   881d8:	f040 808b 	bne.w	882f2 <_dtoa_r+0x1d2>
   881dc:	9f18      	ldr	r7, [sp, #96]	; 0x60
   881de:	9d19      	ldr	r5, [sp, #100]	; 0x64
   881e0:	f46f 6382 	mvn.w	r3, #1040	; 0x410
   881e4:	443d      	add	r5, r7
   881e6:	429d      	cmp	r5, r3
   881e8:	f2c0 8295 	blt.w	88716 <_dtoa_r+0x5f6>
   881ec:	331f      	adds	r3, #31
   881ee:	f205 4212 	addw	r2, r5, #1042	; 0x412
   881f2:	1b5b      	subs	r3, r3, r5
   881f4:	fa09 f303 	lsl.w	r3, r9, r3
   881f8:	fa2a f202 	lsr.w	r2, sl, r2
   881fc:	ea43 0002 	orr.w	r0, r3, r2
   88200:	f002 fa9a 	bl	8a738 <__aeabi_ui2d>
   88204:	2601      	movs	r6, #1
   88206:	3d01      	subs	r5, #1
   88208:	46b8      	mov	r8, r7
   8820a:	f1a1 71f8 	sub.w	r1, r1, #32505856	; 0x1f00000
   8820e:	9616      	str	r6, [sp, #88]	; 0x58
   88210:	2200      	movs	r2, #0
   88212:	4b78      	ldr	r3, [pc, #480]	; (883f4 <_dtoa_r+0x2d4>)
   88214:	f002 f952 	bl	8a4bc <__aeabi_dsub>
   88218:	a36d      	add	r3, pc, #436	; (adr r3, 883d0 <_dtoa_r+0x2b0>)
   8821a:	e9d3 2300 	ldrd	r2, r3, [r3]
   8821e:	f002 fb01 	bl	8a824 <__aeabi_dmul>
   88222:	a36d      	add	r3, pc, #436	; (adr r3, 883d8 <_dtoa_r+0x2b8>)
   88224:	e9d3 2300 	ldrd	r2, r3, [r3]
   88228:	f002 f94a 	bl	8a4c0 <__adddf3>
   8822c:	4606      	mov	r6, r0
   8822e:	4628      	mov	r0, r5
   88230:	460f      	mov	r7, r1
   88232:	f002 fa91 	bl	8a758 <__aeabi_i2d>
   88236:	a36a      	add	r3, pc, #424	; (adr r3, 883e0 <_dtoa_r+0x2c0>)
   88238:	e9d3 2300 	ldrd	r2, r3, [r3]
   8823c:	f002 faf2 	bl	8a824 <__aeabi_dmul>
   88240:	4602      	mov	r2, r0
   88242:	460b      	mov	r3, r1
   88244:	4630      	mov	r0, r6
   88246:	4639      	mov	r1, r7
   88248:	f002 f93a 	bl	8a4c0 <__adddf3>
   8824c:	4606      	mov	r6, r0
   8824e:	460f      	mov	r7, r1
   88250:	f002 fd82 	bl	8ad58 <__aeabi_d2iz>
   88254:	4639      	mov	r1, r7
   88256:	9007      	str	r0, [sp, #28]
   88258:	2200      	movs	r2, #0
   8825a:	4630      	mov	r0, r6
   8825c:	2300      	movs	r3, #0
   8825e:	f002 fd53 	bl	8ad08 <__aeabi_dcmplt>
   88262:	2800      	cmp	r0, #0
   88264:	f040 8229 	bne.w	886ba <_dtoa_r+0x59a>
   88268:	9e07      	ldr	r6, [sp, #28]
   8826a:	2e16      	cmp	r6, #22
   8826c:	f200 8222 	bhi.w	886b4 <_dtoa_r+0x594>
   88270:	4961      	ldr	r1, [pc, #388]	; (883f8 <_dtoa_r+0x2d8>)
   88272:	4652      	mov	r2, sl
   88274:	eb01 01c6 	add.w	r1, r1, r6, lsl #3
   88278:	465b      	mov	r3, fp
   8827a:	e9d1 0100 	ldrd	r0, r1, [r1]
   8827e:	f002 fd61 	bl	8ad44 <__aeabi_dcmpgt>
   88282:	2800      	cmp	r0, #0
   88284:	f000 824c 	beq.w	88720 <_dtoa_r+0x600>
   88288:	3e01      	subs	r6, #1
   8828a:	9607      	str	r6, [sp, #28]
   8828c:	2600      	movs	r6, #0
   8828e:	960e      	str	r6, [sp, #56]	; 0x38
   88290:	ebc5 0508 	rsb	r5, r5, r8
   88294:	3d01      	subs	r5, #1
   88296:	9506      	str	r5, [sp, #24]
   88298:	f100 8226 	bmi.w	886e8 <_dtoa_r+0x5c8>
   8829c:	2500      	movs	r5, #0
   8829e:	9508      	str	r5, [sp, #32]
   882a0:	9e07      	ldr	r6, [sp, #28]
   882a2:	2e00      	cmp	r6, #0
   882a4:	f2c0 8217 	blt.w	886d6 <_dtoa_r+0x5b6>
   882a8:	9d06      	ldr	r5, [sp, #24]
   882aa:	960d      	str	r6, [sp, #52]	; 0x34
   882ac:	4435      	add	r5, r6
   882ae:	2600      	movs	r6, #0
   882b0:	9506      	str	r5, [sp, #24]
   882b2:	960c      	str	r6, [sp, #48]	; 0x30
   882b4:	9d24      	ldr	r5, [sp, #144]	; 0x90
   882b6:	2d09      	cmp	r5, #9
   882b8:	d82d      	bhi.n	88316 <_dtoa_r+0x1f6>
   882ba:	2d05      	cmp	r5, #5
   882bc:	bfc4      	itt	gt
   882be:	3d04      	subgt	r5, #4
   882c0:	9524      	strgt	r5, [sp, #144]	; 0x90
   882c2:	9e24      	ldr	r6, [sp, #144]	; 0x90
   882c4:	bfc8      	it	gt
   882c6:	2500      	movgt	r5, #0
   882c8:	f1a6 0302 	sub.w	r3, r6, #2
   882cc:	bfd8      	it	le
   882ce:	2501      	movle	r5, #1
   882d0:	2b03      	cmp	r3, #3
   882d2:	d822      	bhi.n	8831a <_dtoa_r+0x1fa>
   882d4:	e8df f013 	tbh	[pc, r3, lsl #1]
   882d8:	029e03b7 	.word	0x029e03b7
   882dc:	049a03c0 	.word	0x049a03c0
   882e0:	4a46      	ldr	r2, [pc, #280]	; (883fc <_dtoa_r+0x2dc>)
   882e2:	4b43      	ldr	r3, [pc, #268]	; (883f0 <_dtoa_r+0x2d0>)
   882e4:	f3c9 0013 	ubfx	r0, r9, #0, #20
   882e8:	2800      	cmp	r0, #0
   882ea:	bf0c      	ite	eq
   882ec:	4610      	moveq	r0, r2
   882ee:	4618      	movne	r0, r3
   882f0:	e752      	b.n	88198 <_dtoa_r+0x78>
   882f2:	f3cb 0313 	ubfx	r3, fp, #0, #20
   882f6:	f043 517f 	orr.w	r1, r3, #1069547520	; 0x3fc00000
   882fa:	f8cd 8058 	str.w	r8, [sp, #88]	; 0x58
   882fe:	4650      	mov	r0, sl
   88300:	f2a5 35ff 	subw	r5, r5, #1023	; 0x3ff
   88304:	f441 1140 	orr.w	r1, r1, #3145728	; 0x300000
   88308:	f8dd 8060 	ldr.w	r8, [sp, #96]	; 0x60
   8830c:	e780      	b.n	88210 <_dtoa_r+0xf0>
   8830e:	483c      	ldr	r0, [pc, #240]	; (88400 <_dtoa_r+0x2e0>)
   88310:	e736      	b.n	88180 <_dtoa_r+0x60>
   88312:	1cc3      	adds	r3, r0, #3
   88314:	e749      	b.n	881aa <_dtoa_r+0x8a>
   88316:	2500      	movs	r5, #0
   88318:	9524      	str	r5, [sp, #144]	; 0x90
   8831a:	2500      	movs	r5, #0
   8831c:	6465      	str	r5, [r4, #68]	; 0x44
   8831e:	4629      	mov	r1, r5
   88320:	4620      	mov	r0, r4
   88322:	f001 fa9f 	bl	89864 <_Balloc>
   88326:	f04f 39ff 	mov.w	r9, #4294967295
   8832a:	2601      	movs	r6, #1
   8832c:	9009      	str	r0, [sp, #36]	; 0x24
   8832e:	9525      	str	r5, [sp, #148]	; 0x94
   88330:	6420      	str	r0, [r4, #64]	; 0x40
   88332:	f8cd 903c 	str.w	r9, [sp, #60]	; 0x3c
   88336:	960b      	str	r6, [sp, #44]	; 0x2c
   88338:	9b19      	ldr	r3, [sp, #100]	; 0x64
   8833a:	2b00      	cmp	r3, #0
   8833c:	f2c0 80d2 	blt.w	884e4 <_dtoa_r+0x3c4>
   88340:	9e07      	ldr	r6, [sp, #28]
   88342:	2e0e      	cmp	r6, #14
   88344:	f300 80ce 	bgt.w	884e4 <_dtoa_r+0x3c4>
   88348:	4b2b      	ldr	r3, [pc, #172]	; (883f8 <_dtoa_r+0x2d8>)
   8834a:	eb03 03c6 	add.w	r3, r3, r6, lsl #3
   8834e:	e9d3 0100 	ldrd	r0, r1, [r3]
   88352:	e9cd 0104 	strd	r0, r1, [sp, #16]
   88356:	9925      	ldr	r1, [sp, #148]	; 0x94
   88358:	2900      	cmp	r1, #0
   8835a:	f2c0 8380 	blt.w	88a5e <_dtoa_r+0x93e>
   8835e:	e9dd 2304 	ldrd	r2, r3, [sp, #16]
   88362:	4659      	mov	r1, fp
   88364:	4650      	mov	r0, sl
   88366:	f002 fb87 	bl	8aa78 <__aeabi_ddiv>
   8836a:	f002 fcf5 	bl	8ad58 <__aeabi_d2iz>
   8836e:	4605      	mov	r5, r0
   88370:	f002 f9f2 	bl	8a758 <__aeabi_i2d>
   88374:	e9dd 2304 	ldrd	r2, r3, [sp, #16]
   88378:	f002 fa54 	bl	8a824 <__aeabi_dmul>
   8837c:	4602      	mov	r2, r0
   8837e:	460b      	mov	r3, r1
   88380:	4650      	mov	r0, sl
   88382:	4659      	mov	r1, fp
   88384:	f002 f89a 	bl	8a4bc <__aeabi_dsub>
   88388:	9a09      	ldr	r2, [sp, #36]	; 0x24
   8838a:	f105 0330 	add.w	r3, r5, #48	; 0x30
   8838e:	f1b9 0f01 	cmp.w	r9, #1
   88392:	4606      	mov	r6, r0
   88394:	460f      	mov	r7, r1
   88396:	7013      	strb	r3, [r2, #0]
   88398:	f102 0b01 	add.w	fp, r2, #1
   8839c:	d064      	beq.n	88468 <_dtoa_r+0x348>
   8839e:	2200      	movs	r2, #0
   883a0:	4b18      	ldr	r3, [pc, #96]	; (88404 <_dtoa_r+0x2e4>)
   883a2:	f002 fa3f 	bl	8a824 <__aeabi_dmul>
   883a6:	2200      	movs	r2, #0
   883a8:	2300      	movs	r3, #0
   883aa:	4606      	mov	r6, r0
   883ac:	460f      	mov	r7, r1
   883ae:	f002 fca1 	bl	8acf4 <__aeabi_dcmpeq>
   883b2:	2800      	cmp	r0, #0
   883b4:	f040 8081 	bne.w	884ba <_dtoa_r+0x39a>
   883b8:	f8dd 8024 	ldr.w	r8, [sp, #36]	; 0x24
   883bc:	9d09      	ldr	r5, [sp, #36]	; 0x24
   883be:	44c8      	add	r8, r9
   883c0:	e9dd ab04 	ldrd	sl, fp, [sp, #16]
   883c4:	f105 0902 	add.w	r9, r5, #2
   883c8:	9403      	str	r4, [sp, #12]
   883ca:	e028      	b.n	8841e <_dtoa_r+0x2fe>
   883cc:	f3af 8000 	nop.w
   883d0:	636f4361 	.word	0x636f4361
   883d4:	3fd287a7 	.word	0x3fd287a7
   883d8:	8b60c8b3 	.word	0x8b60c8b3
   883dc:	3fc68a28 	.word	0x3fc68a28
   883e0:	509f79fb 	.word	0x509f79fb
   883e4:	3fd34413 	.word	0x3fd34413
   883e8:	7ff00000 	.word	0x7ff00000
   883ec:	0008cc65 	.word	0x0008cc65
   883f0:	0008cd88 	.word	0x0008cd88
   883f4:	3ff80000 	.word	0x3ff80000
   883f8:	0008cd98 	.word	0x0008cd98
   883fc:	0008cd7c 	.word	0x0008cd7c
   88400:	0008cc64 	.word	0x0008cc64
   88404:	40240000 	.word	0x40240000
   88408:	f002 fa0c 	bl	8a824 <__aeabi_dmul>
   8840c:	2200      	movs	r2, #0
   8840e:	2300      	movs	r3, #0
   88410:	4606      	mov	r6, r0
   88412:	460f      	mov	r7, r1
   88414:	f002 fc6e 	bl	8acf4 <__aeabi_dcmpeq>
   88418:	2800      	cmp	r0, #0
   8841a:	f040 83c1 	bne.w	88ba0 <_dtoa_r+0xa80>
   8841e:	4652      	mov	r2, sl
   88420:	465b      	mov	r3, fp
   88422:	4630      	mov	r0, r6
   88424:	4639      	mov	r1, r7
   88426:	f002 fb27 	bl	8aa78 <__aeabi_ddiv>
   8842a:	f002 fc95 	bl	8ad58 <__aeabi_d2iz>
   8842e:	4605      	mov	r5, r0
   88430:	f002 f992 	bl	8a758 <__aeabi_i2d>
   88434:	4652      	mov	r2, sl
   88436:	465b      	mov	r3, fp
   88438:	f002 f9f4 	bl	8a824 <__aeabi_dmul>
   8843c:	4602      	mov	r2, r0
   8843e:	460b      	mov	r3, r1
   88440:	4630      	mov	r0, r6
   88442:	4639      	mov	r1, r7
   88444:	f002 f83a 	bl	8a4bc <__aeabi_dsub>
   88448:	f105 0e30 	add.w	lr, r5, #48	; 0x30
   8844c:	45c1      	cmp	r9, r8
   8844e:	f809 ec01 	strb.w	lr, [r9, #-1]
   88452:	464c      	mov	r4, r9
   88454:	4606      	mov	r6, r0
   88456:	460f      	mov	r7, r1
   88458:	f04f 0200 	mov.w	r2, #0
   8845c:	4ba7      	ldr	r3, [pc, #668]	; (886fc <_dtoa_r+0x5dc>)
   8845e:	f109 0901 	add.w	r9, r9, #1
   88462:	d1d1      	bne.n	88408 <_dtoa_r+0x2e8>
   88464:	46a3      	mov	fp, r4
   88466:	9c03      	ldr	r4, [sp, #12]
   88468:	4632      	mov	r2, r6
   8846a:	463b      	mov	r3, r7
   8846c:	4630      	mov	r0, r6
   8846e:	4639      	mov	r1, r7
   88470:	f002 f826 	bl	8a4c0 <__adddf3>
   88474:	4606      	mov	r6, r0
   88476:	460f      	mov	r7, r1
   88478:	4632      	mov	r2, r6
   8847a:	e9dd 0104 	ldrd	r0, r1, [sp, #16]
   8847e:	463b      	mov	r3, r7
   88480:	f002 fc42 	bl	8ad08 <__aeabi_dcmplt>
   88484:	b940      	cbnz	r0, 88498 <_dtoa_r+0x378>
   88486:	e9dd 0104 	ldrd	r0, r1, [sp, #16]
   8848a:	4632      	mov	r2, r6
   8848c:	463b      	mov	r3, r7
   8848e:	f002 fc31 	bl	8acf4 <__aeabi_dcmpeq>
   88492:	b190      	cbz	r0, 884ba <_dtoa_r+0x39a>
   88494:	07eb      	lsls	r3, r5, #31
   88496:	d510      	bpl.n	884ba <_dtoa_r+0x39a>
   88498:	f81b 5c01 	ldrb.w	r5, [fp, #-1]
   8849c:	9a09      	ldr	r2, [sp, #36]	; 0x24
   8849e:	e005      	b.n	884ac <_dtoa_r+0x38c>
   884a0:	429a      	cmp	r2, r3
   884a2:	f000 8429 	beq.w	88cf8 <_dtoa_r+0xbd8>
   884a6:	f813 5c01 	ldrb.w	r5, [r3, #-1]
   884aa:	469b      	mov	fp, r3
   884ac:	2d39      	cmp	r5, #57	; 0x39
   884ae:	f10b 33ff 	add.w	r3, fp, #4294967295
   884b2:	d0f5      	beq.n	884a0 <_dtoa_r+0x380>
   884b4:	1c6a      	adds	r2, r5, #1
   884b6:	b2d2      	uxtb	r2, r2
   884b8:	701a      	strb	r2, [r3, #0]
   884ba:	4620      	mov	r0, r4
   884bc:	990a      	ldr	r1, [sp, #40]	; 0x28
   884be:	f001 f9f7 	bl	898b0 <_Bfree>
   884c2:	9e07      	ldr	r6, [sp, #28]
   884c4:	9d26      	ldr	r5, [sp, #152]	; 0x98
   884c6:	1c73      	adds	r3, r6, #1
   884c8:	9e28      	ldr	r6, [sp, #160]	; 0xa0
   884ca:	2200      	movs	r2, #0
   884cc:	f88b 2000 	strb.w	r2, [fp]
   884d0:	602b      	str	r3, [r5, #0]
   884d2:	2e00      	cmp	r6, #0
   884d4:	f000 8325 	beq.w	88b22 <_dtoa_r+0xa02>
   884d8:	9809      	ldr	r0, [sp, #36]	; 0x24
   884da:	f8c6 b000 	str.w	fp, [r6]
   884de:	b01b      	add	sp, #108	; 0x6c
   884e0:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   884e4:	9d0b      	ldr	r5, [sp, #44]	; 0x2c
   884e6:	2d00      	cmp	r5, #0
   884e8:	f000 8103 	beq.w	886f2 <_dtoa_r+0x5d2>
   884ec:	9e24      	ldr	r6, [sp, #144]	; 0x90
   884ee:	2e01      	cmp	r6, #1
   884f0:	f340 82dc 	ble.w	88aac <_dtoa_r+0x98c>
   884f4:	9e0c      	ldr	r6, [sp, #48]	; 0x30
   884f6:	f109 37ff 	add.w	r7, r9, #4294967295
   884fa:	42be      	cmp	r6, r7
   884fc:	f2c0 8389 	blt.w	88c12 <_dtoa_r+0xaf2>
   88500:	1bf7      	subs	r7, r6, r7
   88502:	f1b9 0f00 	cmp.w	r9, #0
   88506:	f2c0 8487 	blt.w	88e18 <_dtoa_r+0xcf8>
   8850a:	9d08      	ldr	r5, [sp, #32]
   8850c:	464b      	mov	r3, r9
   8850e:	9e08      	ldr	r6, [sp, #32]
   88510:	4620      	mov	r0, r4
   88512:	441e      	add	r6, r3
   88514:	9608      	str	r6, [sp, #32]
   88516:	9e06      	ldr	r6, [sp, #24]
   88518:	2101      	movs	r1, #1
   8851a:	441e      	add	r6, r3
   8851c:	9606      	str	r6, [sp, #24]
   8851e:	f001 fa69 	bl	899f4 <__i2b>
   88522:	4606      	mov	r6, r0
   88524:	b165      	cbz	r5, 88540 <_dtoa_r+0x420>
   88526:	9806      	ldr	r0, [sp, #24]
   88528:	2800      	cmp	r0, #0
   8852a:	dd09      	ble.n	88540 <_dtoa_r+0x420>
   8852c:	4603      	mov	r3, r0
   8852e:	9908      	ldr	r1, [sp, #32]
   88530:	42ab      	cmp	r3, r5
   88532:	bfa8      	it	ge
   88534:	462b      	movge	r3, r5
   88536:	1ac9      	subs	r1, r1, r3
   88538:	1ac0      	subs	r0, r0, r3
   8853a:	9108      	str	r1, [sp, #32]
   8853c:	1aed      	subs	r5, r5, r3
   8853e:	9006      	str	r0, [sp, #24]
   88540:	9a0c      	ldr	r2, [sp, #48]	; 0x30
   88542:	2a00      	cmp	r2, #0
   88544:	dd1d      	ble.n	88582 <_dtoa_r+0x462>
   88546:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
   88548:	2b00      	cmp	r3, #0
   8854a:	f000 8358 	beq.w	88bfe <_dtoa_r+0xade>
   8854e:	2f00      	cmp	r7, #0
   88550:	dd11      	ble.n	88576 <_dtoa_r+0x456>
   88552:	4631      	mov	r1, r6
   88554:	463a      	mov	r2, r7
   88556:	4620      	mov	r0, r4
   88558:	f001 faf4 	bl	89b44 <__pow5mult>
   8855c:	4606      	mov	r6, r0
   8855e:	4631      	mov	r1, r6
   88560:	9a0a      	ldr	r2, [sp, #40]	; 0x28
   88562:	4620      	mov	r0, r4
   88564:	f001 fa50 	bl	89a08 <__multiply>
   88568:	990a      	ldr	r1, [sp, #40]	; 0x28
   8856a:	4680      	mov	r8, r0
   8856c:	4620      	mov	r0, r4
   8856e:	f001 f99f 	bl	898b0 <_Bfree>
   88572:	f8cd 8028 	str.w	r8, [sp, #40]	; 0x28
   88576:	f8dd e030 	ldr.w	lr, [sp, #48]	; 0x30
   8857a:	ebbe 0207 	subs.w	r2, lr, r7
   8857e:	f040 828f 	bne.w	88aa0 <_dtoa_r+0x980>
   88582:	4620      	mov	r0, r4
   88584:	2101      	movs	r1, #1
   88586:	f001 fa35 	bl	899f4 <__i2b>
   8858a:	4680      	mov	r8, r0
   8858c:	980d      	ldr	r0, [sp, #52]	; 0x34
   8858e:	2800      	cmp	r0, #0
   88590:	dd05      	ble.n	8859e <_dtoa_r+0x47e>
   88592:	4641      	mov	r1, r8
   88594:	4620      	mov	r0, r4
   88596:	9a0d      	ldr	r2, [sp, #52]	; 0x34
   88598:	f001 fad4 	bl	89b44 <__pow5mult>
   8859c:	4680      	mov	r8, r0
   8859e:	9924      	ldr	r1, [sp, #144]	; 0x90
   885a0:	2901      	cmp	r1, #1
   885a2:	f340 82c1 	ble.w	88b28 <_dtoa_r+0xa08>
   885a6:	2700      	movs	r7, #0
   885a8:	980d      	ldr	r0, [sp, #52]	; 0x34
   885aa:	2800      	cmp	r0, #0
   885ac:	f040 82af 	bne.w	88b0e <_dtoa_r+0x9ee>
   885b0:	2001      	movs	r0, #1
   885b2:	9b06      	ldr	r3, [sp, #24]
   885b4:	4403      	add	r3, r0
   885b6:	f013 031f 	ands.w	r3, r3, #31
   885ba:	f000 80a1 	beq.w	88700 <_dtoa_r+0x5e0>
   885be:	f1c3 0220 	rsb	r2, r3, #32
   885c2:	2a04      	cmp	r2, #4
   885c4:	f340 84b7 	ble.w	88f36 <_dtoa_r+0xe16>
   885c8:	9908      	ldr	r1, [sp, #32]
   885ca:	9a06      	ldr	r2, [sp, #24]
   885cc:	f1c3 031c 	rsb	r3, r3, #28
   885d0:	4419      	add	r1, r3
   885d2:	441a      	add	r2, r3
   885d4:	9108      	str	r1, [sp, #32]
   885d6:	441d      	add	r5, r3
   885d8:	9206      	str	r2, [sp, #24]
   885da:	9908      	ldr	r1, [sp, #32]
   885dc:	2900      	cmp	r1, #0
   885de:	dd05      	ble.n	885ec <_dtoa_r+0x4cc>
   885e0:	990a      	ldr	r1, [sp, #40]	; 0x28
   885e2:	9a08      	ldr	r2, [sp, #32]
   885e4:	4620      	mov	r0, r4
   885e6:	f001 fafb 	bl	89be0 <__lshift>
   885ea:	900a      	str	r0, [sp, #40]	; 0x28
   885ec:	9a06      	ldr	r2, [sp, #24]
   885ee:	2a00      	cmp	r2, #0
   885f0:	dd04      	ble.n	885fc <_dtoa_r+0x4dc>
   885f2:	4641      	mov	r1, r8
   885f4:	4620      	mov	r0, r4
   885f6:	f001 faf3 	bl	89be0 <__lshift>
   885fa:	4680      	mov	r8, r0
   885fc:	9b0e      	ldr	r3, [sp, #56]	; 0x38
   885fe:	2b00      	cmp	r3, #0
   88600:	f040 826a 	bne.w	88ad8 <_dtoa_r+0x9b8>
   88604:	f1b9 0f00 	cmp.w	r9, #0
   88608:	f340 82a6 	ble.w	88b58 <_dtoa_r+0xa38>
   8860c:	980b      	ldr	r0, [sp, #44]	; 0x2c
   8860e:	2800      	cmp	r0, #0
   88610:	f040 8088 	bne.w	88724 <_dtoa_r+0x604>
   88614:	9d0b      	ldr	r5, [sp, #44]	; 0x2c
   88616:	9f0a      	ldr	r7, [sp, #40]	; 0x28
   88618:	f8dd b024 	ldr.w	fp, [sp, #36]	; 0x24
   8861c:	e006      	b.n	8862c <_dtoa_r+0x50c>
   8861e:	4639      	mov	r1, r7
   88620:	4620      	mov	r0, r4
   88622:	220a      	movs	r2, #10
   88624:	2300      	movs	r3, #0
   88626:	f001 f94d 	bl	898c4 <__multadd>
   8862a:	4607      	mov	r7, r0
   8862c:	4638      	mov	r0, r7
   8862e:	4641      	mov	r1, r8
   88630:	f7ff fcdc 	bl	87fec <quorem>
   88634:	3030      	adds	r0, #48	; 0x30
   88636:	f80b 0005 	strb.w	r0, [fp, r5]
   8863a:	3501      	adds	r5, #1
   8863c:	45a9      	cmp	r9, r5
   8863e:	dcee      	bgt.n	8861e <_dtoa_r+0x4fe>
   88640:	f8dd b024 	ldr.w	fp, [sp, #36]	; 0x24
   88644:	4682      	mov	sl, r0
   88646:	970a      	str	r7, [sp, #40]	; 0x28
   88648:	f1b9 0f01 	cmp.w	r9, #1
   8864c:	bfac      	ite	ge
   8864e:	44cb      	addge	fp, r9
   88650:	f10b 0b01 	addlt.w	fp, fp, #1
   88654:	2500      	movs	r5, #0
   88656:	990a      	ldr	r1, [sp, #40]	; 0x28
   88658:	2201      	movs	r2, #1
   8865a:	4620      	mov	r0, r4
   8865c:	f001 fac0 	bl	89be0 <__lshift>
   88660:	4641      	mov	r1, r8
   88662:	900a      	str	r0, [sp, #40]	; 0x28
   88664:	f001 fb1a 	bl	89c9c <__mcmp>
   88668:	2800      	cmp	r0, #0
   8866a:	f340 8309 	ble.w	88c80 <_dtoa_r+0xb60>
   8866e:	f81b 2c01 	ldrb.w	r2, [fp, #-1]
   88672:	9909      	ldr	r1, [sp, #36]	; 0x24
   88674:	e005      	b.n	88682 <_dtoa_r+0x562>
   88676:	4299      	cmp	r1, r3
   88678:	f000 828b 	beq.w	88b92 <_dtoa_r+0xa72>
   8867c:	f813 2c01 	ldrb.w	r2, [r3, #-1]
   88680:	469b      	mov	fp, r3
   88682:	2a39      	cmp	r2, #57	; 0x39
   88684:	f10b 33ff 	add.w	r3, fp, #4294967295
   88688:	d0f5      	beq.n	88676 <_dtoa_r+0x556>
   8868a:	3201      	adds	r2, #1
   8868c:	701a      	strb	r2, [r3, #0]
   8868e:	4641      	mov	r1, r8
   88690:	4620      	mov	r0, r4
   88692:	f001 f90d 	bl	898b0 <_Bfree>
   88696:	2e00      	cmp	r6, #0
   88698:	f43f af0f 	beq.w	884ba <_dtoa_r+0x39a>
   8869c:	b12d      	cbz	r5, 886aa <_dtoa_r+0x58a>
   8869e:	42b5      	cmp	r5, r6
   886a0:	d003      	beq.n	886aa <_dtoa_r+0x58a>
   886a2:	4629      	mov	r1, r5
   886a4:	4620      	mov	r0, r4
   886a6:	f001 f903 	bl	898b0 <_Bfree>
   886aa:	4631      	mov	r1, r6
   886ac:	4620      	mov	r0, r4
   886ae:	f001 f8ff 	bl	898b0 <_Bfree>
   886b2:	e702      	b.n	884ba <_dtoa_r+0x39a>
   886b4:	2601      	movs	r6, #1
   886b6:	960e      	str	r6, [sp, #56]	; 0x38
   886b8:	e5ea      	b.n	88290 <_dtoa_r+0x170>
   886ba:	9807      	ldr	r0, [sp, #28]
   886bc:	f002 f84c 	bl	8a758 <__aeabi_i2d>
   886c0:	4632      	mov	r2, r6
   886c2:	463b      	mov	r3, r7
   886c4:	f002 fb16 	bl	8acf4 <__aeabi_dcmpeq>
   886c8:	2800      	cmp	r0, #0
   886ca:	f47f adcd 	bne.w	88268 <_dtoa_r+0x148>
   886ce:	9e07      	ldr	r6, [sp, #28]
   886d0:	3e01      	subs	r6, #1
   886d2:	9607      	str	r6, [sp, #28]
   886d4:	e5c8      	b.n	88268 <_dtoa_r+0x148>
   886d6:	9e07      	ldr	r6, [sp, #28]
   886d8:	9d08      	ldr	r5, [sp, #32]
   886da:	1bad      	subs	r5, r5, r6
   886dc:	9508      	str	r5, [sp, #32]
   886de:	4275      	negs	r5, r6
   886e0:	2600      	movs	r6, #0
   886e2:	950c      	str	r5, [sp, #48]	; 0x30
   886e4:	960d      	str	r6, [sp, #52]	; 0x34
   886e6:	e5e5      	b.n	882b4 <_dtoa_r+0x194>
   886e8:	426d      	negs	r5, r5
   886ea:	2600      	movs	r6, #0
   886ec:	9508      	str	r5, [sp, #32]
   886ee:	9606      	str	r6, [sp, #24]
   886f0:	e5d6      	b.n	882a0 <_dtoa_r+0x180>
   886f2:	9f0c      	ldr	r7, [sp, #48]	; 0x30
   886f4:	9d08      	ldr	r5, [sp, #32]
   886f6:	9e0b      	ldr	r6, [sp, #44]	; 0x2c
   886f8:	e714      	b.n	88524 <_dtoa_r+0x404>
   886fa:	bf00      	nop
   886fc:	40240000 	.word	0x40240000
   88700:	231c      	movs	r3, #28
   88702:	f8dd e020 	ldr.w	lr, [sp, #32]
   88706:	9806      	ldr	r0, [sp, #24]
   88708:	449e      	add	lr, r3
   8870a:	4418      	add	r0, r3
   8870c:	f8cd e020 	str.w	lr, [sp, #32]
   88710:	441d      	add	r5, r3
   88712:	9006      	str	r0, [sp, #24]
   88714:	e761      	b.n	885da <_dtoa_r+0x4ba>
   88716:	48a7      	ldr	r0, [pc, #668]	; (889b4 <_dtoa_r+0x894>)
   88718:	1b40      	subs	r0, r0, r5
   8871a:	fa0a f000 	lsl.w	r0, sl, r0
   8871e:	e56f      	b.n	88200 <_dtoa_r+0xe0>
   88720:	900e      	str	r0, [sp, #56]	; 0x38
   88722:	e5b5      	b.n	88290 <_dtoa_r+0x170>
   88724:	2d00      	cmp	r5, #0
   88726:	dd05      	ble.n	88734 <_dtoa_r+0x614>
   88728:	4631      	mov	r1, r6
   8872a:	462a      	mov	r2, r5
   8872c:	4620      	mov	r0, r4
   8872e:	f001 fa57 	bl	89be0 <__lshift>
   88732:	4606      	mov	r6, r0
   88734:	2f00      	cmp	r7, #0
   88736:	f040 82e9 	bne.w	88d0c <_dtoa_r+0xbec>
   8873a:	4637      	mov	r7, r6
   8873c:	9d09      	ldr	r5, [sp, #36]	; 0x24
   8873e:	9809      	ldr	r0, [sp, #36]	; 0x24
   88740:	444d      	add	r5, r9
   88742:	9508      	str	r5, [sp, #32]
   88744:	f00a 0501 	and.w	r5, sl, #1
   88748:	950b      	str	r5, [sp, #44]	; 0x2c
   8874a:	f8dd 9028 	ldr.w	r9, [sp, #40]	; 0x28
   8874e:	1c45      	adds	r5, r0, #1
   88750:	e00a      	b.n	88768 <_dtoa_r+0x648>
   88752:	f001 f8b7 	bl	898c4 <__multadd>
   88756:	4639      	mov	r1, r7
   88758:	4606      	mov	r6, r0
   8875a:	220a      	movs	r2, #10
   8875c:	4620      	mov	r0, r4
   8875e:	2300      	movs	r3, #0
   88760:	f001 f8b0 	bl	898c4 <__multadd>
   88764:	4607      	mov	r7, r0
   88766:	3501      	adds	r5, #1
   88768:	4641      	mov	r1, r8
   8876a:	4648      	mov	r0, r9
   8876c:	f7ff fc3e 	bl	87fec <quorem>
   88770:	4631      	mov	r1, r6
   88772:	4683      	mov	fp, r0
   88774:	4648      	mov	r0, r9
   88776:	f001 fa91 	bl	89c9c <__mcmp>
   8877a:	4641      	mov	r1, r8
   8877c:	9003      	str	r0, [sp, #12]
   8877e:	463a      	mov	r2, r7
   88780:	4620      	mov	r0, r4
   88782:	f001 faaf 	bl	89ce4 <__mdiff>
   88786:	68c2      	ldr	r2, [r0, #12]
   88788:	1e69      	subs	r1, r5, #1
   8878a:	4603      	mov	r3, r0
   8878c:	f10b 0a30 	add.w	sl, fp, #48	; 0x30
   88790:	9106      	str	r1, [sp, #24]
   88792:	2a00      	cmp	r2, #0
   88794:	f040 8193 	bne.w	88abe <_dtoa_r+0x99e>
   88798:	4619      	mov	r1, r3
   8879a:	4648      	mov	r0, r9
   8879c:	9302      	str	r3, [sp, #8]
   8879e:	f001 fa7d 	bl	89c9c <__mcmp>
   887a2:	9b02      	ldr	r3, [sp, #8]
   887a4:	4602      	mov	r2, r0
   887a6:	4619      	mov	r1, r3
   887a8:	4620      	mov	r0, r4
   887aa:	9202      	str	r2, [sp, #8]
   887ac:	f001 f880 	bl	898b0 <_Bfree>
   887b0:	9a02      	ldr	r2, [sp, #8]
   887b2:	b92a      	cbnz	r2, 887c0 <_dtoa_r+0x6a0>
   887b4:	9b24      	ldr	r3, [sp, #144]	; 0x90
   887b6:	b91b      	cbnz	r3, 887c0 <_dtoa_r+0x6a0>
   887b8:	980b      	ldr	r0, [sp, #44]	; 0x2c
   887ba:	2800      	cmp	r0, #0
   887bc:	f000 8393 	beq.w	88ee6 <_dtoa_r+0xdc6>
   887c0:	9b03      	ldr	r3, [sp, #12]
   887c2:	2b00      	cmp	r3, #0
   887c4:	f2c0 8234 	blt.w	88c30 <_dtoa_r+0xb10>
   887c8:	d105      	bne.n	887d6 <_dtoa_r+0x6b6>
   887ca:	9824      	ldr	r0, [sp, #144]	; 0x90
   887cc:	b918      	cbnz	r0, 887d6 <_dtoa_r+0x6b6>
   887ce:	990b      	ldr	r1, [sp, #44]	; 0x2c
   887d0:	2900      	cmp	r1, #0
   887d2:	f000 822d 	beq.w	88c30 <_dtoa_r+0xb10>
   887d6:	2a00      	cmp	r2, #0
   887d8:	f300 82ac 	bgt.w	88d34 <_dtoa_r+0xc14>
   887dc:	f8dd e020 	ldr.w	lr, [sp, #32]
   887e0:	f805 ac01 	strb.w	sl, [r5, #-1]
   887e4:	4575      	cmp	r5, lr
   887e6:	46ab      	mov	fp, r5
   887e8:	f000 82b4 	beq.w	88d54 <_dtoa_r+0xc34>
   887ec:	4649      	mov	r1, r9
   887ee:	220a      	movs	r2, #10
   887f0:	2300      	movs	r3, #0
   887f2:	4620      	mov	r0, r4
   887f4:	f001 f866 	bl	898c4 <__multadd>
   887f8:	42be      	cmp	r6, r7
   887fa:	4681      	mov	r9, r0
   887fc:	4631      	mov	r1, r6
   887fe:	4620      	mov	r0, r4
   88800:	f04f 020a 	mov.w	r2, #10
   88804:	f04f 0300 	mov.w	r3, #0
   88808:	d1a3      	bne.n	88752 <_dtoa_r+0x632>
   8880a:	f001 f85b 	bl	898c4 <__multadd>
   8880e:	4606      	mov	r6, r0
   88810:	4607      	mov	r7, r0
   88812:	e7a8      	b.n	88766 <_dtoa_r+0x646>
   88814:	2600      	movs	r6, #0
   88816:	960b      	str	r6, [sp, #44]	; 0x2c
   88818:	9e07      	ldr	r6, [sp, #28]
   8881a:	f8dd e094 	ldr.w	lr, [sp, #148]	; 0x94
   8881e:	44b6      	add	lr, r6
   88820:	f10e 0901 	add.w	r9, lr, #1
   88824:	f1b9 0f00 	cmp.w	r9, #0
   88828:	f8cd e03c 	str.w	lr, [sp, #60]	; 0x3c
   8882c:	464e      	mov	r6, r9
   8882e:	f340 8150 	ble.w	88ad2 <_dtoa_r+0x9b2>
   88832:	2100      	movs	r1, #0
   88834:	2e17      	cmp	r6, #23
   88836:	6461      	str	r1, [r4, #68]	; 0x44
   88838:	d90a      	bls.n	88850 <_dtoa_r+0x730>
   8883a:	2201      	movs	r2, #1
   8883c:	2304      	movs	r3, #4
   8883e:	005b      	lsls	r3, r3, #1
   88840:	f103 0014 	add.w	r0, r3, #20
   88844:	42b0      	cmp	r0, r6
   88846:	4611      	mov	r1, r2
   88848:	f102 0201 	add.w	r2, r2, #1
   8884c:	d9f7      	bls.n	8883e <_dtoa_r+0x71e>
   8884e:	6461      	str	r1, [r4, #68]	; 0x44
   88850:	4620      	mov	r0, r4
   88852:	f001 f807 	bl	89864 <_Balloc>
   88856:	2e0e      	cmp	r6, #14
   88858:	9009      	str	r0, [sp, #36]	; 0x24
   8885a:	6420      	str	r0, [r4, #64]	; 0x40
   8885c:	f63f ad6c 	bhi.w	88338 <_dtoa_r+0x218>
   88860:	2d00      	cmp	r5, #0
   88862:	f43f ad69 	beq.w	88338 <_dtoa_r+0x218>
   88866:	9d07      	ldr	r5, [sp, #28]
   88868:	e9cd ab12 	strd	sl, fp, [sp, #72]	; 0x48
   8886c:	2d00      	cmp	r5, #0
   8886e:	f340 821c 	ble.w	88caa <_dtoa_r+0xb8a>
   88872:	4b51      	ldr	r3, [pc, #324]	; (889b8 <_dtoa_r+0x898>)
   88874:	f005 020f 	and.w	r2, r5, #15
   88878:	eb03 03c2 	add.w	r3, r3, r2, lsl #3
   8887c:	112d      	asrs	r5, r5, #4
   8887e:	e9d3 6700 	ldrd	r6, r7, [r3]
   88882:	06eb      	lsls	r3, r5, #27
   88884:	f140 81cd 	bpl.w	88c22 <_dtoa_r+0xb02>
   88888:	4b4c      	ldr	r3, [pc, #304]	; (889bc <_dtoa_r+0x89c>)
   8888a:	4650      	mov	r0, sl
   8888c:	4659      	mov	r1, fp
   8888e:	e9d3 2308 	ldrd	r2, r3, [r3, #32]
   88892:	f002 f8f1 	bl	8aa78 <__aeabi_ddiv>
   88896:	e9cd 0110 	strd	r0, r1, [sp, #64]	; 0x40
   8889a:	f005 050f 	and.w	r5, r5, #15
   8889e:	f04f 0803 	mov.w	r8, #3
   888a2:	b18d      	cbz	r5, 888c8 <_dtoa_r+0x7a8>
   888a4:	f8df a114 	ldr.w	sl, [pc, #276]	; 889bc <_dtoa_r+0x89c>
   888a8:	4630      	mov	r0, r6
   888aa:	4639      	mov	r1, r7
   888ac:	07ee      	lsls	r6, r5, #31
   888ae:	d505      	bpl.n	888bc <_dtoa_r+0x79c>
   888b0:	e9da 2300 	ldrd	r2, r3, [sl]
   888b4:	f108 0801 	add.w	r8, r8, #1
   888b8:	f001 ffb4 	bl	8a824 <__aeabi_dmul>
   888bc:	106d      	asrs	r5, r5, #1
   888be:	f10a 0a08 	add.w	sl, sl, #8
   888c2:	d1f3      	bne.n	888ac <_dtoa_r+0x78c>
   888c4:	4606      	mov	r6, r0
   888c6:	460f      	mov	r7, r1
   888c8:	e9dd 0110 	ldrd	r0, r1, [sp, #64]	; 0x40
   888cc:	4632      	mov	r2, r6
   888ce:	463b      	mov	r3, r7
   888d0:	f002 f8d2 	bl	8aa78 <__aeabi_ddiv>
   888d4:	4682      	mov	sl, r0
   888d6:	468b      	mov	fp, r1
   888d8:	9d0e      	ldr	r5, [sp, #56]	; 0x38
   888da:	b145      	cbz	r5, 888ee <_dtoa_r+0x7ce>
   888dc:	4650      	mov	r0, sl
   888de:	4659      	mov	r1, fp
   888e0:	2200      	movs	r2, #0
   888e2:	4b37      	ldr	r3, [pc, #220]	; (889c0 <_dtoa_r+0x8a0>)
   888e4:	f002 fa10 	bl	8ad08 <__aeabi_dcmplt>
   888e8:	2800      	cmp	r0, #0
   888ea:	f040 82aa 	bne.w	88e42 <_dtoa_r+0xd22>
   888ee:	4640      	mov	r0, r8
   888f0:	f001 ff32 	bl	8a758 <__aeabi_i2d>
   888f4:	4652      	mov	r2, sl
   888f6:	465b      	mov	r3, fp
   888f8:	f001 ff94 	bl	8a824 <__aeabi_dmul>
   888fc:	2200      	movs	r2, #0
   888fe:	4b31      	ldr	r3, [pc, #196]	; (889c4 <_dtoa_r+0x8a4>)
   88900:	f001 fdde 	bl	8a4c0 <__adddf3>
   88904:	4606      	mov	r6, r0
   88906:	f1a1 7750 	sub.w	r7, r1, #54525952	; 0x3400000
   8890a:	f1b9 0f00 	cmp.w	r9, #0
   8890e:	f000 815a 	beq.w	88bc6 <_dtoa_r+0xaa6>
   88912:	9d07      	ldr	r5, [sp, #28]
   88914:	46c8      	mov	r8, r9
   88916:	9517      	str	r5, [sp, #92]	; 0x5c
   88918:	9d0b      	ldr	r5, [sp, #44]	; 0x2c
   8891a:	2d00      	cmp	r5, #0
   8891c:	f000 8223 	beq.w	88d66 <_dtoa_r+0xc46>
   88920:	4b25      	ldr	r3, [pc, #148]	; (889b8 <_dtoa_r+0x898>)
   88922:	2000      	movs	r0, #0
   88924:	eb03 03c8 	add.w	r3, r3, r8, lsl #3
   88928:	e953 2302 	ldrd	r2, r3, [r3, #-8]
   8892c:	4926      	ldr	r1, [pc, #152]	; (889c8 <_dtoa_r+0x8a8>)
   8892e:	f002 f8a3 	bl	8aa78 <__aeabi_ddiv>
   88932:	4632      	mov	r2, r6
   88934:	463b      	mov	r3, r7
   88936:	f001 fdc1 	bl	8a4bc <__aeabi_dsub>
   8893a:	e9cd 0110 	strd	r0, r1, [sp, #64]	; 0x40
   8893e:	4659      	mov	r1, fp
   88940:	4650      	mov	r0, sl
   88942:	f002 fa09 	bl	8ad58 <__aeabi_d2iz>
   88946:	4605      	mov	r5, r0
   88948:	f001 ff06 	bl	8a758 <__aeabi_i2d>
   8894c:	4602      	mov	r2, r0
   8894e:	460b      	mov	r3, r1
   88950:	4650      	mov	r0, sl
   88952:	4659      	mov	r1, fp
   88954:	f001 fdb2 	bl	8a4bc <__aeabi_dsub>
   88958:	3530      	adds	r5, #48	; 0x30
   8895a:	9e09      	ldr	r6, [sp, #36]	; 0x24
   8895c:	e9cd 0104 	strd	r0, r1, [sp, #16]
   88960:	e9dd 2304 	ldrd	r2, r3, [sp, #16]
   88964:	e9dd 0110 	ldrd	r0, r1, [sp, #64]	; 0x40
   88968:	b2ed      	uxtb	r5, r5
   8896a:	7035      	strb	r5, [r6, #0]
   8896c:	f106 0b01 	add.w	fp, r6, #1
   88970:	f002 f9e8 	bl	8ad44 <__aeabi_dcmpgt>
   88974:	2800      	cmp	r0, #0
   88976:	f040 82ab 	bne.w	88ed0 <_dtoa_r+0xdb0>
   8897a:	e9dd 2304 	ldrd	r2, r3, [sp, #16]
   8897e:	2000      	movs	r0, #0
   88980:	490f      	ldr	r1, [pc, #60]	; (889c0 <_dtoa_r+0x8a0>)
   88982:	f001 fd9b 	bl	8a4bc <__aeabi_dsub>
   88986:	4602      	mov	r2, r0
   88988:	460b      	mov	r3, r1
   8898a:	e9dd 0110 	ldrd	r0, r1, [sp, #64]	; 0x40
   8898e:	f002 f9d9 	bl	8ad44 <__aeabi_dcmpgt>
   88992:	2800      	cmp	r0, #0
   88994:	f040 82a2 	bne.w	88edc <_dtoa_r+0xdbc>
   88998:	f1b8 0f01 	cmp.w	r8, #1
   8899c:	f340 8181 	ble.w	88ca2 <_dtoa_r+0xb82>
   889a0:	44b0      	add	r8, r6
   889a2:	f8cd 9050 	str.w	r9, [sp, #80]	; 0x50
   889a6:	46a2      	mov	sl, r4
   889a8:	46c1      	mov	r9, r8
   889aa:	e9dd 6704 	ldrd	r6, r7, [sp, #16]
   889ae:	e9dd 4510 	ldrd	r4, r5, [sp, #64]	; 0x40
   889b2:	e019      	b.n	889e8 <_dtoa_r+0x8c8>
   889b4:	fffffbee 	.word	0xfffffbee
   889b8:	0008cd98 	.word	0x0008cd98
   889bc:	0008ce60 	.word	0x0008ce60
   889c0:	3ff00000 	.word	0x3ff00000
   889c4:	401c0000 	.word	0x401c0000
   889c8:	3fe00000 	.word	0x3fe00000
   889cc:	2000      	movs	r0, #0
   889ce:	49a8      	ldr	r1, [pc, #672]	; (88c70 <_dtoa_r+0xb50>)
   889d0:	f001 fd74 	bl	8a4bc <__aeabi_dsub>
   889d4:	4622      	mov	r2, r4
   889d6:	462b      	mov	r3, r5
   889d8:	f002 f996 	bl	8ad08 <__aeabi_dcmplt>
   889dc:	2800      	cmp	r0, #0
   889de:	f040 827b 	bne.w	88ed8 <_dtoa_r+0xdb8>
   889e2:	45cb      	cmp	fp, r9
   889e4:	f000 815a 	beq.w	88c9c <_dtoa_r+0xb7c>
   889e8:	4620      	mov	r0, r4
   889ea:	4629      	mov	r1, r5
   889ec:	2200      	movs	r2, #0
   889ee:	4ba1      	ldr	r3, [pc, #644]	; (88c74 <_dtoa_r+0xb54>)
   889f0:	f001 ff18 	bl	8a824 <__aeabi_dmul>
   889f4:	2200      	movs	r2, #0
   889f6:	4b9f      	ldr	r3, [pc, #636]	; (88c74 <_dtoa_r+0xb54>)
   889f8:	4604      	mov	r4, r0
   889fa:	460d      	mov	r5, r1
   889fc:	4630      	mov	r0, r6
   889fe:	4639      	mov	r1, r7
   88a00:	f001 ff10 	bl	8a824 <__aeabi_dmul>
   88a04:	460f      	mov	r7, r1
   88a06:	4606      	mov	r6, r0
   88a08:	f002 f9a6 	bl	8ad58 <__aeabi_d2iz>
   88a0c:	4680      	mov	r8, r0
   88a0e:	f001 fea3 	bl	8a758 <__aeabi_i2d>
   88a12:	4602      	mov	r2, r0
   88a14:	460b      	mov	r3, r1
   88a16:	4630      	mov	r0, r6
   88a18:	4639      	mov	r1, r7
   88a1a:	f001 fd4f 	bl	8a4bc <__aeabi_dsub>
   88a1e:	f108 0830 	add.w	r8, r8, #48	; 0x30
   88a22:	fa5f f888 	uxtb.w	r8, r8
   88a26:	4622      	mov	r2, r4
   88a28:	462b      	mov	r3, r5
   88a2a:	f80b 8b01 	strb.w	r8, [fp], #1
   88a2e:	4606      	mov	r6, r0
   88a30:	460f      	mov	r7, r1
   88a32:	f002 f969 	bl	8ad08 <__aeabi_dcmplt>
   88a36:	4632      	mov	r2, r6
   88a38:	463b      	mov	r3, r7
   88a3a:	2800      	cmp	r0, #0
   88a3c:	d0c6      	beq.n	889cc <_dtoa_r+0x8ac>
   88a3e:	9e17      	ldr	r6, [sp, #92]	; 0x5c
   88a40:	4654      	mov	r4, sl
   88a42:	9607      	str	r6, [sp, #28]
   88a44:	e539      	b.n	884ba <_dtoa_r+0x39a>
   88a46:	2600      	movs	r6, #0
   88a48:	960b      	str	r6, [sp, #44]	; 0x2c
   88a4a:	9825      	ldr	r0, [sp, #148]	; 0x94
   88a4c:	2800      	cmp	r0, #0
   88a4e:	dd3c      	ble.n	88aca <_dtoa_r+0x9aa>
   88a50:	4606      	mov	r6, r0
   88a52:	900f      	str	r0, [sp, #60]	; 0x3c
   88a54:	4681      	mov	r9, r0
   88a56:	e6ec      	b.n	88832 <_dtoa_r+0x712>
   88a58:	2601      	movs	r6, #1
   88a5a:	960b      	str	r6, [sp, #44]	; 0x2c
   88a5c:	e7f5      	b.n	88a4a <_dtoa_r+0x92a>
   88a5e:	f1b9 0f00 	cmp.w	r9, #0
   88a62:	f73f ac7c 	bgt.w	8835e <_dtoa_r+0x23e>
   88a66:	f040 80c6 	bne.w	88bf6 <_dtoa_r+0xad6>
   88a6a:	e9dd 0104 	ldrd	r0, r1, [sp, #16]
   88a6e:	2200      	movs	r2, #0
   88a70:	4b81      	ldr	r3, [pc, #516]	; (88c78 <_dtoa_r+0xb58>)
   88a72:	f001 fed7 	bl	8a824 <__aeabi_dmul>
   88a76:	4652      	mov	r2, sl
   88a78:	465b      	mov	r3, fp
   88a7a:	f002 f959 	bl	8ad30 <__aeabi_dcmpge>
   88a7e:	46c8      	mov	r8, r9
   88a80:	464e      	mov	r6, r9
   88a82:	2800      	cmp	r0, #0
   88a84:	d07c      	beq.n	88b80 <_dtoa_r+0xa60>
   88a86:	9d25      	ldr	r5, [sp, #148]	; 0x94
   88a88:	f8dd b024 	ldr.w	fp, [sp, #36]	; 0x24
   88a8c:	43ed      	mvns	r5, r5
   88a8e:	9507      	str	r5, [sp, #28]
   88a90:	4641      	mov	r1, r8
   88a92:	4620      	mov	r0, r4
   88a94:	f000 ff0c 	bl	898b0 <_Bfree>
   88a98:	2e00      	cmp	r6, #0
   88a9a:	f47f ae06 	bne.w	886aa <_dtoa_r+0x58a>
   88a9e:	e50c      	b.n	884ba <_dtoa_r+0x39a>
   88aa0:	990a      	ldr	r1, [sp, #40]	; 0x28
   88aa2:	4620      	mov	r0, r4
   88aa4:	f001 f84e 	bl	89b44 <__pow5mult>
   88aa8:	900a      	str	r0, [sp, #40]	; 0x28
   88aaa:	e56a      	b.n	88582 <_dtoa_r+0x462>
   88aac:	9d16      	ldr	r5, [sp, #88]	; 0x58
   88aae:	2d00      	cmp	r5, #0
   88ab0:	f000 81b8 	beq.w	88e24 <_dtoa_r+0xd04>
   88ab4:	f203 4333 	addw	r3, r3, #1075	; 0x433
   88ab8:	9f0c      	ldr	r7, [sp, #48]	; 0x30
   88aba:	9d08      	ldr	r5, [sp, #32]
   88abc:	e527      	b.n	8850e <_dtoa_r+0x3ee>
   88abe:	4601      	mov	r1, r0
   88ac0:	4620      	mov	r0, r4
   88ac2:	f000 fef5 	bl	898b0 <_Bfree>
   88ac6:	2201      	movs	r2, #1
   88ac8:	e67a      	b.n	887c0 <_dtoa_r+0x6a0>
   88aca:	2601      	movs	r6, #1
   88acc:	9625      	str	r6, [sp, #148]	; 0x94
   88ace:	960f      	str	r6, [sp, #60]	; 0x3c
   88ad0:	46b1      	mov	r9, r6
   88ad2:	2100      	movs	r1, #0
   88ad4:	6461      	str	r1, [r4, #68]	; 0x44
   88ad6:	e6bb      	b.n	88850 <_dtoa_r+0x730>
   88ad8:	980a      	ldr	r0, [sp, #40]	; 0x28
   88ada:	4641      	mov	r1, r8
   88adc:	f001 f8de 	bl	89c9c <__mcmp>
   88ae0:	2800      	cmp	r0, #0
   88ae2:	f6bf ad8f 	bge.w	88604 <_dtoa_r+0x4e4>
   88ae6:	f8dd e01c 	ldr.w	lr, [sp, #28]
   88aea:	990a      	ldr	r1, [sp, #40]	; 0x28
   88aec:	f10e 3eff 	add.w	lr, lr, #4294967295
   88af0:	4620      	mov	r0, r4
   88af2:	220a      	movs	r2, #10
   88af4:	2300      	movs	r3, #0
   88af6:	f8cd e01c 	str.w	lr, [sp, #28]
   88afa:	f000 fee3 	bl	898c4 <__multadd>
   88afe:	900a      	str	r0, [sp, #40]	; 0x28
   88b00:	980b      	ldr	r0, [sp, #44]	; 0x2c
   88b02:	2800      	cmp	r0, #0
   88b04:	f040 8209 	bne.w	88f1a <_dtoa_r+0xdfa>
   88b08:	f8dd 903c 	ldr.w	r9, [sp, #60]	; 0x3c
   88b0c:	e57a      	b.n	88604 <_dtoa_r+0x4e4>
   88b0e:	f8d8 3010 	ldr.w	r3, [r8, #16]
   88b12:	eb08 0383 	add.w	r3, r8, r3, lsl #2
   88b16:	6918      	ldr	r0, [r3, #16]
   88b18:	f000 ff1e 	bl	89958 <__hi0bits>
   88b1c:	f1c0 0020 	rsb	r0, r0, #32
   88b20:	e547      	b.n	885b2 <_dtoa_r+0x492>
   88b22:	9809      	ldr	r0, [sp, #36]	; 0x24
   88b24:	f7ff bb2c 	b.w	88180 <_dtoa_r+0x60>
   88b28:	f1ba 0f00 	cmp.w	sl, #0
   88b2c:	f47f ad3b 	bne.w	885a6 <_dtoa_r+0x486>
   88b30:	f3cb 0313 	ubfx	r3, fp, #0, #20
   88b34:	2b00      	cmp	r3, #0
   88b36:	f040 817c 	bne.w	88e32 <_dtoa_r+0xd12>
   88b3a:	f02b 4700 	bic.w	r7, fp, #2147483648	; 0x80000000
   88b3e:	0d3f      	lsrs	r7, r7, #20
   88b40:	053f      	lsls	r7, r7, #20
   88b42:	2f00      	cmp	r7, #0
   88b44:	f43f ad30 	beq.w	885a8 <_dtoa_r+0x488>
   88b48:	9a08      	ldr	r2, [sp, #32]
   88b4a:	9b06      	ldr	r3, [sp, #24]
   88b4c:	3201      	adds	r2, #1
   88b4e:	3301      	adds	r3, #1
   88b50:	9208      	str	r2, [sp, #32]
   88b52:	9306      	str	r3, [sp, #24]
   88b54:	2701      	movs	r7, #1
   88b56:	e527      	b.n	885a8 <_dtoa_r+0x488>
   88b58:	9924      	ldr	r1, [sp, #144]	; 0x90
   88b5a:	2902      	cmp	r1, #2
   88b5c:	f77f ad56 	ble.w	8860c <_dtoa_r+0x4ec>
   88b60:	f1b9 0f00 	cmp.w	r9, #0
   88b64:	d18f      	bne.n	88a86 <_dtoa_r+0x966>
   88b66:	4641      	mov	r1, r8
   88b68:	464b      	mov	r3, r9
   88b6a:	2205      	movs	r2, #5
   88b6c:	4620      	mov	r0, r4
   88b6e:	f000 fea9 	bl	898c4 <__multadd>
   88b72:	4680      	mov	r8, r0
   88b74:	4641      	mov	r1, r8
   88b76:	980a      	ldr	r0, [sp, #40]	; 0x28
   88b78:	f001 f890 	bl	89c9c <__mcmp>
   88b7c:	2800      	cmp	r0, #0
   88b7e:	dd82      	ble.n	88a86 <_dtoa_r+0x966>
   88b80:	9d07      	ldr	r5, [sp, #28]
   88b82:	2331      	movs	r3, #49	; 0x31
   88b84:	3501      	adds	r5, #1
   88b86:	9507      	str	r5, [sp, #28]
   88b88:	9d09      	ldr	r5, [sp, #36]	; 0x24
   88b8a:	702b      	strb	r3, [r5, #0]
   88b8c:	f105 0b01 	add.w	fp, r5, #1
   88b90:	e77e      	b.n	88a90 <_dtoa_r+0x970>
   88b92:	9807      	ldr	r0, [sp, #28]
   88b94:	9909      	ldr	r1, [sp, #36]	; 0x24
   88b96:	2331      	movs	r3, #49	; 0x31
   88b98:	3001      	adds	r0, #1
   88b9a:	9007      	str	r0, [sp, #28]
   88b9c:	700b      	strb	r3, [r1, #0]
   88b9e:	e576      	b.n	8868e <_dtoa_r+0x56e>
   88ba0:	46a3      	mov	fp, r4
   88ba2:	9c03      	ldr	r4, [sp, #12]
   88ba4:	e489      	b.n	884ba <_dtoa_r+0x39a>
   88ba6:	4640      	mov	r0, r8
   88ba8:	f001 fdd6 	bl	8a758 <__aeabi_i2d>
   88bac:	4602      	mov	r2, r0
   88bae:	460b      	mov	r3, r1
   88bb0:	4650      	mov	r0, sl
   88bb2:	4659      	mov	r1, fp
   88bb4:	f001 fe36 	bl	8a824 <__aeabi_dmul>
   88bb8:	2200      	movs	r2, #0
   88bba:	4b30      	ldr	r3, [pc, #192]	; (88c7c <_dtoa_r+0xb5c>)
   88bbc:	f001 fc80 	bl	8a4c0 <__adddf3>
   88bc0:	4606      	mov	r6, r0
   88bc2:	f1a1 7750 	sub.w	r7, r1, #54525952	; 0x3400000
   88bc6:	4650      	mov	r0, sl
   88bc8:	4659      	mov	r1, fp
   88bca:	2200      	movs	r2, #0
   88bcc:	4b2a      	ldr	r3, [pc, #168]	; (88c78 <_dtoa_r+0xb58>)
   88bce:	f001 fc75 	bl	8a4bc <__aeabi_dsub>
   88bd2:	4632      	mov	r2, r6
   88bd4:	463b      	mov	r3, r7
   88bd6:	4682      	mov	sl, r0
   88bd8:	468b      	mov	fp, r1
   88bda:	f002 f8b3 	bl	8ad44 <__aeabi_dcmpgt>
   88bde:	2800      	cmp	r0, #0
   88be0:	f040 80bd 	bne.w	88d5e <_dtoa_r+0xc3e>
   88be4:	4632      	mov	r2, r6
   88be6:	f107 4300 	add.w	r3, r7, #2147483648	; 0x80000000
   88bea:	4650      	mov	r0, sl
   88bec:	4659      	mov	r1, fp
   88bee:	f002 f88b 	bl	8ad08 <__aeabi_dcmplt>
   88bf2:	2800      	cmp	r0, #0
   88bf4:	d055      	beq.n	88ca2 <_dtoa_r+0xb82>
   88bf6:	f04f 0800 	mov.w	r8, #0
   88bfa:	4646      	mov	r6, r8
   88bfc:	e743      	b.n	88a86 <_dtoa_r+0x966>
   88bfe:	990a      	ldr	r1, [sp, #40]	; 0x28
   88c00:	9a0c      	ldr	r2, [sp, #48]	; 0x30
   88c02:	4620      	mov	r0, r4
   88c04:	f000 ff9e 	bl	89b44 <__pow5mult>
   88c08:	900a      	str	r0, [sp, #40]	; 0x28
   88c0a:	e4ba      	b.n	88582 <_dtoa_r+0x462>
   88c0c:	2601      	movs	r6, #1
   88c0e:	960b      	str	r6, [sp, #44]	; 0x2c
   88c10:	e602      	b.n	88818 <_dtoa_r+0x6f8>
   88c12:	9d0c      	ldr	r5, [sp, #48]	; 0x30
   88c14:	9e0d      	ldr	r6, [sp, #52]	; 0x34
   88c16:	1b7b      	subs	r3, r7, r5
   88c18:	441e      	add	r6, r3
   88c1a:	970c      	str	r7, [sp, #48]	; 0x30
   88c1c:	960d      	str	r6, [sp, #52]	; 0x34
   88c1e:	2700      	movs	r7, #0
   88c20:	e46f      	b.n	88502 <_dtoa_r+0x3e2>
   88c22:	e9dd 0112 	ldrd	r0, r1, [sp, #72]	; 0x48
   88c26:	f04f 0802 	mov.w	r8, #2
   88c2a:	e9cd 0110 	strd	r0, r1, [sp, #64]	; 0x40
   88c2e:	e638      	b.n	888a2 <_dtoa_r+0x782>
   88c30:	2a00      	cmp	r2, #0
   88c32:	f8cd 9028 	str.w	r9, [sp, #40]	; 0x28
   88c36:	46d9      	mov	r9, fp
   88c38:	dd11      	ble.n	88c5e <_dtoa_r+0xb3e>
   88c3a:	990a      	ldr	r1, [sp, #40]	; 0x28
   88c3c:	2201      	movs	r2, #1
   88c3e:	4620      	mov	r0, r4
   88c40:	f000 ffce 	bl	89be0 <__lshift>
   88c44:	4641      	mov	r1, r8
   88c46:	900a      	str	r0, [sp, #40]	; 0x28
   88c48:	f001 f828 	bl	89c9c <__mcmp>
   88c4c:	2800      	cmp	r0, #0
   88c4e:	f340 815d 	ble.w	88f0c <_dtoa_r+0xdec>
   88c52:	f1ba 0f39 	cmp.w	sl, #57	; 0x39
   88c56:	f000 811b 	beq.w	88e90 <_dtoa_r+0xd70>
   88c5a:	f109 0a31 	add.w	sl, r9, #49	; 0x31
   88c5e:	9b06      	ldr	r3, [sp, #24]
   88c60:	4635      	mov	r5, r6
   88c62:	f883 a000 	strb.w	sl, [r3]
   88c66:	f103 0b01 	add.w	fp, r3, #1
   88c6a:	463e      	mov	r6, r7
   88c6c:	e50f      	b.n	8868e <_dtoa_r+0x56e>
   88c6e:	bf00      	nop
   88c70:	3ff00000 	.word	0x3ff00000
   88c74:	40240000 	.word	0x40240000
   88c78:	40140000 	.word	0x40140000
   88c7c:	401c0000 	.word	0x401c0000
   88c80:	d103      	bne.n	88c8a <_dtoa_r+0xb6a>
   88c82:	f01a 0f01 	tst.w	sl, #1
   88c86:	f47f acf2 	bne.w	8866e <_dtoa_r+0x54e>
   88c8a:	465b      	mov	r3, fp
   88c8c:	f813 2c01 	ldrb.w	r2, [r3, #-1]
   88c90:	469b      	mov	fp, r3
   88c92:	2a30      	cmp	r2, #48	; 0x30
   88c94:	f103 33ff 	add.w	r3, r3, #4294967295
   88c98:	d0f8      	beq.n	88c8c <_dtoa_r+0xb6c>
   88c9a:	e4f8      	b.n	8868e <_dtoa_r+0x56e>
   88c9c:	f8dd 9050 	ldr.w	r9, [sp, #80]	; 0x50
   88ca0:	4654      	mov	r4, sl
   88ca2:	e9dd ab12 	ldrd	sl, fp, [sp, #72]	; 0x48
   88ca6:	f7ff bb47 	b.w	88338 <_dtoa_r+0x218>
   88caa:	9e07      	ldr	r6, [sp, #28]
   88cac:	4275      	negs	r5, r6
   88cae:	2d00      	cmp	r5, #0
   88cb0:	f000 80c2 	beq.w	88e38 <_dtoa_r+0xd18>
   88cb4:	4ba3      	ldr	r3, [pc, #652]	; (88f44 <_dtoa_r+0xe24>)
   88cb6:	f005 020f 	and.w	r2, r5, #15
   88cba:	eb03 03c2 	add.w	r3, r3, r2, lsl #3
   88cbe:	e9d3 2300 	ldrd	r2, r3, [r3]
   88cc2:	e9dd 0112 	ldrd	r0, r1, [sp, #72]	; 0x48
   88cc6:	f001 fdad 	bl	8a824 <__aeabi_dmul>
   88cca:	112d      	asrs	r5, r5, #4
   88ccc:	4682      	mov	sl, r0
   88cce:	468b      	mov	fp, r1
   88cd0:	f000 812e 	beq.w	88f30 <_dtoa_r+0xe10>
   88cd4:	4e9c      	ldr	r6, [pc, #624]	; (88f48 <_dtoa_r+0xe28>)
   88cd6:	f04f 0802 	mov.w	r8, #2
   88cda:	07ea      	lsls	r2, r5, #31
   88cdc:	d505      	bpl.n	88cea <_dtoa_r+0xbca>
   88cde:	e9d6 2300 	ldrd	r2, r3, [r6]
   88ce2:	f108 0801 	add.w	r8, r8, #1
   88ce6:	f001 fd9d 	bl	8a824 <__aeabi_dmul>
   88cea:	106d      	asrs	r5, r5, #1
   88cec:	f106 0608 	add.w	r6, r6, #8
   88cf0:	d1f3      	bne.n	88cda <_dtoa_r+0xbba>
   88cf2:	4682      	mov	sl, r0
   88cf4:	468b      	mov	fp, r1
   88cf6:	e5ef      	b.n	888d8 <_dtoa_r+0x7b8>
   88cf8:	9e07      	ldr	r6, [sp, #28]
   88cfa:	9d09      	ldr	r5, [sp, #36]	; 0x24
   88cfc:	2230      	movs	r2, #48	; 0x30
   88cfe:	702a      	strb	r2, [r5, #0]
   88d00:	3601      	adds	r6, #1
   88d02:	2231      	movs	r2, #49	; 0x31
   88d04:	9607      	str	r6, [sp, #28]
   88d06:	701a      	strb	r2, [r3, #0]
   88d08:	f7ff bbd7 	b.w	884ba <_dtoa_r+0x39a>
   88d0c:	6871      	ldr	r1, [r6, #4]
   88d0e:	4620      	mov	r0, r4
   88d10:	f000 fda8 	bl	89864 <_Balloc>
   88d14:	6933      	ldr	r3, [r6, #16]
   88d16:	4605      	mov	r5, r0
   88d18:	1c9a      	adds	r2, r3, #2
   88d1a:	0092      	lsls	r2, r2, #2
   88d1c:	f106 010c 	add.w	r1, r6, #12
   88d20:	300c      	adds	r0, #12
   88d22:	f7fd fad7 	bl	862d4 <memcpy>
   88d26:	4620      	mov	r0, r4
   88d28:	4629      	mov	r1, r5
   88d2a:	2201      	movs	r2, #1
   88d2c:	f000 ff58 	bl	89be0 <__lshift>
   88d30:	4607      	mov	r7, r0
   88d32:	e503      	b.n	8873c <_dtoa_r+0x61c>
   88d34:	f1ba 0f39 	cmp.w	sl, #57	; 0x39
   88d38:	f8cd 9028 	str.w	r9, [sp, #40]	; 0x28
   88d3c:	f000 80a8 	beq.w	88e90 <_dtoa_r+0xd70>
   88d40:	9d06      	ldr	r5, [sp, #24]
   88d42:	f10a 0301 	add.w	r3, sl, #1
   88d46:	702b      	strb	r3, [r5, #0]
   88d48:	4635      	mov	r5, r6
   88d4a:	9e06      	ldr	r6, [sp, #24]
   88d4c:	f106 0b01 	add.w	fp, r6, #1
   88d50:	463e      	mov	r6, r7
   88d52:	e49c      	b.n	8868e <_dtoa_r+0x56e>
   88d54:	4635      	mov	r5, r6
   88d56:	f8cd 9028 	str.w	r9, [sp, #40]	; 0x28
   88d5a:	463e      	mov	r6, r7
   88d5c:	e47b      	b.n	88656 <_dtoa_r+0x536>
   88d5e:	f04f 0800 	mov.w	r8, #0
   88d62:	4646      	mov	r6, r8
   88d64:	e70c      	b.n	88b80 <_dtoa_r+0xa60>
   88d66:	4977      	ldr	r1, [pc, #476]	; (88f44 <_dtoa_r+0xe24>)
   88d68:	f108 35ff 	add.w	r5, r8, #4294967295
   88d6c:	eb01 01c5 	add.w	r1, r1, r5, lsl #3
   88d70:	4632      	mov	r2, r6
   88d72:	463b      	mov	r3, r7
   88d74:	e9d1 0100 	ldrd	r0, r1, [r1]
   88d78:	9510      	str	r5, [sp, #64]	; 0x40
   88d7a:	f001 fd53 	bl	8a824 <__aeabi_dmul>
   88d7e:	e9cd 0114 	strd	r0, r1, [sp, #80]	; 0x50
   88d82:	4659      	mov	r1, fp
   88d84:	4650      	mov	r0, sl
   88d86:	f001 ffe7 	bl	8ad58 <__aeabi_d2iz>
   88d8a:	4605      	mov	r5, r0
   88d8c:	f001 fce4 	bl	8a758 <__aeabi_i2d>
   88d90:	4602      	mov	r2, r0
   88d92:	460b      	mov	r3, r1
   88d94:	4650      	mov	r0, sl
   88d96:	4659      	mov	r1, fp
   88d98:	f001 fb90 	bl	8a4bc <__aeabi_dsub>
   88d9c:	f8dd e024 	ldr.w	lr, [sp, #36]	; 0x24
   88da0:	3530      	adds	r5, #48	; 0x30
   88da2:	f1b8 0f01 	cmp.w	r8, #1
   88da6:	4606      	mov	r6, r0
   88da8:	460f      	mov	r7, r1
   88daa:	f88e 5000 	strb.w	r5, [lr]
   88dae:	f10e 0b01 	add.w	fp, lr, #1
   88db2:	d01e      	beq.n	88df2 <_dtoa_r+0xcd2>
   88db4:	9d09      	ldr	r5, [sp, #36]	; 0x24
   88db6:	1e6b      	subs	r3, r5, #1
   88db8:	eb03 0a08 	add.w	sl, r3, r8
   88dbc:	2200      	movs	r2, #0
   88dbe:	4b63      	ldr	r3, [pc, #396]	; (88f4c <_dtoa_r+0xe2c>)
   88dc0:	f001 fd30 	bl	8a824 <__aeabi_dmul>
   88dc4:	460f      	mov	r7, r1
   88dc6:	4606      	mov	r6, r0
   88dc8:	f001 ffc6 	bl	8ad58 <__aeabi_d2iz>
   88dcc:	4680      	mov	r8, r0
   88dce:	f001 fcc3 	bl	8a758 <__aeabi_i2d>
   88dd2:	f108 0830 	add.w	r8, r8, #48	; 0x30
   88dd6:	4602      	mov	r2, r0
   88dd8:	460b      	mov	r3, r1
   88dda:	4630      	mov	r0, r6
   88ddc:	4639      	mov	r1, r7
   88dde:	f001 fb6d 	bl	8a4bc <__aeabi_dsub>
   88de2:	f805 8f01 	strb.w	r8, [r5, #1]!
   88de6:	4555      	cmp	r5, sl
   88de8:	d1e8      	bne.n	88dbc <_dtoa_r+0xc9c>
   88dea:	9d10      	ldr	r5, [sp, #64]	; 0x40
   88dec:	4606      	mov	r6, r0
   88dee:	460f      	mov	r7, r1
   88df0:	44ab      	add	fp, r5
   88df2:	2200      	movs	r2, #0
   88df4:	4b56      	ldr	r3, [pc, #344]	; (88f50 <_dtoa_r+0xe30>)
   88df6:	e9dd 0114 	ldrd	r0, r1, [sp, #80]	; 0x50
   88dfa:	f001 fb61 	bl	8a4c0 <__adddf3>
   88dfe:	4632      	mov	r2, r6
   88e00:	463b      	mov	r3, r7
   88e02:	f001 ff81 	bl	8ad08 <__aeabi_dcmplt>
   88e06:	2800      	cmp	r0, #0
   88e08:	d04d      	beq.n	88ea6 <_dtoa_r+0xd86>
   88e0a:	9e17      	ldr	r6, [sp, #92]	; 0x5c
   88e0c:	9a09      	ldr	r2, [sp, #36]	; 0x24
   88e0e:	9607      	str	r6, [sp, #28]
   88e10:	f81b 5c01 	ldrb.w	r5, [fp, #-1]
   88e14:	f7ff bb4a 	b.w	884ac <_dtoa_r+0x38c>
   88e18:	9e08      	ldr	r6, [sp, #32]
   88e1a:	2300      	movs	r3, #0
   88e1c:	ebc9 0506 	rsb	r5, r9, r6
   88e20:	f7ff bb75 	b.w	8850e <_dtoa_r+0x3ee>
   88e24:	9b18      	ldr	r3, [sp, #96]	; 0x60
   88e26:	9f0c      	ldr	r7, [sp, #48]	; 0x30
   88e28:	f1c3 0336 	rsb	r3, r3, #54	; 0x36
   88e2c:	9d08      	ldr	r5, [sp, #32]
   88e2e:	f7ff bb6e 	b.w	8850e <_dtoa_r+0x3ee>
   88e32:	4657      	mov	r7, sl
   88e34:	f7ff bbb8 	b.w	885a8 <_dtoa_r+0x488>
   88e38:	e9dd ab12 	ldrd	sl, fp, [sp, #72]	; 0x48
   88e3c:	f04f 0802 	mov.w	r8, #2
   88e40:	e54a      	b.n	888d8 <_dtoa_r+0x7b8>
   88e42:	f1b9 0f00 	cmp.w	r9, #0
   88e46:	f43f aeae 	beq.w	88ba6 <_dtoa_r+0xa86>
   88e4a:	9e0f      	ldr	r6, [sp, #60]	; 0x3c
   88e4c:	2e00      	cmp	r6, #0
   88e4e:	f77f af28 	ble.w	88ca2 <_dtoa_r+0xb82>
   88e52:	2200      	movs	r2, #0
   88e54:	4b3d      	ldr	r3, [pc, #244]	; (88f4c <_dtoa_r+0xe2c>)
   88e56:	4650      	mov	r0, sl
   88e58:	4659      	mov	r1, fp
   88e5a:	f001 fce3 	bl	8a824 <__aeabi_dmul>
   88e5e:	4682      	mov	sl, r0
   88e60:	f108 0001 	add.w	r0, r8, #1
   88e64:	468b      	mov	fp, r1
   88e66:	f001 fc77 	bl	8a758 <__aeabi_i2d>
   88e6a:	4602      	mov	r2, r0
   88e6c:	460b      	mov	r3, r1
   88e6e:	4650      	mov	r0, sl
   88e70:	4659      	mov	r1, fp
   88e72:	f001 fcd7 	bl	8a824 <__aeabi_dmul>
   88e76:	2200      	movs	r2, #0
   88e78:	4b36      	ldr	r3, [pc, #216]	; (88f54 <_dtoa_r+0xe34>)
   88e7a:	f001 fb21 	bl	8a4c0 <__adddf3>
   88e7e:	9d07      	ldr	r5, [sp, #28]
   88e80:	4606      	mov	r6, r0
   88e82:	3d01      	subs	r5, #1
   88e84:	f1a1 7750 	sub.w	r7, r1, #54525952	; 0x3400000
   88e88:	9517      	str	r5, [sp, #92]	; 0x5c
   88e8a:	f8dd 803c 	ldr.w	r8, [sp, #60]	; 0x3c
   88e8e:	e543      	b.n	88918 <_dtoa_r+0x7f8>
   88e90:	4635      	mov	r5, r6
   88e92:	9b06      	ldr	r3, [sp, #24]
   88e94:	9e06      	ldr	r6, [sp, #24]
   88e96:	2239      	movs	r2, #57	; 0x39
   88e98:	7032      	strb	r2, [r6, #0]
   88e9a:	f103 0b01 	add.w	fp, r3, #1
   88e9e:	463e      	mov	r6, r7
   88ea0:	9909      	ldr	r1, [sp, #36]	; 0x24
   88ea2:	f7ff bbee 	b.w	88682 <_dtoa_r+0x562>
   88ea6:	e9dd 2314 	ldrd	r2, r3, [sp, #80]	; 0x50
   88eaa:	2000      	movs	r0, #0
   88eac:	4928      	ldr	r1, [pc, #160]	; (88f50 <_dtoa_r+0xe30>)
   88eae:	f001 fb05 	bl	8a4bc <__aeabi_dsub>
   88eb2:	4632      	mov	r2, r6
   88eb4:	463b      	mov	r3, r7
   88eb6:	f001 ff45 	bl	8ad44 <__aeabi_dcmpgt>
   88eba:	2800      	cmp	r0, #0
   88ebc:	f43f aef1 	beq.w	88ca2 <_dtoa_r+0xb82>
   88ec0:	465b      	mov	r3, fp
   88ec2:	f813 2c01 	ldrb.w	r2, [r3, #-1]
   88ec6:	469b      	mov	fp, r3
   88ec8:	2a30      	cmp	r2, #48	; 0x30
   88eca:	f103 33ff 	add.w	r3, r3, #4294967295
   88ece:	d0f8      	beq.n	88ec2 <_dtoa_r+0xda2>
   88ed0:	9d17      	ldr	r5, [sp, #92]	; 0x5c
   88ed2:	9507      	str	r5, [sp, #28]
   88ed4:	f7ff baf1 	b.w	884ba <_dtoa_r+0x39a>
   88ed8:	4645      	mov	r5, r8
   88eda:	4654      	mov	r4, sl
   88edc:	9e17      	ldr	r6, [sp, #92]	; 0x5c
   88ede:	9a09      	ldr	r2, [sp, #36]	; 0x24
   88ee0:	9607      	str	r6, [sp, #28]
   88ee2:	f7ff bae3 	b.w	884ac <_dtoa_r+0x38c>
   88ee6:	f1ba 0f39 	cmp.w	sl, #57	; 0x39
   88eea:	f8cd 9028 	str.w	r9, [sp, #40]	; 0x28
   88eee:	d0cf      	beq.n	88e90 <_dtoa_r+0xd70>
   88ef0:	9b03      	ldr	r3, [sp, #12]
   88ef2:	4635      	mov	r5, r6
   88ef4:	2b00      	cmp	r3, #0
   88ef6:	9e06      	ldr	r6, [sp, #24]
   88ef8:	bfc8      	it	gt
   88efa:	f10b 0a31 	addgt.w	sl, fp, #49	; 0x31
   88efe:	f886 a000 	strb.w	sl, [r6]
   88f02:	f106 0b01 	add.w	fp, r6, #1
   88f06:	463e      	mov	r6, r7
   88f08:	f7ff bbc1 	b.w	8868e <_dtoa_r+0x56e>
   88f0c:	f47f aea7 	bne.w	88c5e <_dtoa_r+0xb3e>
   88f10:	f01a 0f01 	tst.w	sl, #1
   88f14:	f43f aea3 	beq.w	88c5e <_dtoa_r+0xb3e>
   88f18:	e69b      	b.n	88c52 <_dtoa_r+0xb32>
   88f1a:	4631      	mov	r1, r6
   88f1c:	4620      	mov	r0, r4
   88f1e:	220a      	movs	r2, #10
   88f20:	2300      	movs	r3, #0
   88f22:	f8dd 903c 	ldr.w	r9, [sp, #60]	; 0x3c
   88f26:	f000 fccd 	bl	898c4 <__multadd>
   88f2a:	4606      	mov	r6, r0
   88f2c:	f7ff bb6a 	b.w	88604 <_dtoa_r+0x4e4>
   88f30:	f04f 0802 	mov.w	r8, #2
   88f34:	e4d0      	b.n	888d8 <_dtoa_r+0x7b8>
   88f36:	f43f ab50 	beq.w	885da <_dtoa_r+0x4ba>
   88f3a:	f1c3 033c 	rsb	r3, r3, #60	; 0x3c
   88f3e:	f7ff bbe0 	b.w	88702 <_dtoa_r+0x5e2>
   88f42:	bf00      	nop
   88f44:	0008cd98 	.word	0x0008cd98
   88f48:	0008ce60 	.word	0x0008ce60
   88f4c:	40240000 	.word	0x40240000
   88f50:	3fe00000 	.word	0x3fe00000
   88f54:	401c0000 	.word	0x401c0000

00088f58 <__libc_fini_array>:
   88f58:	b538      	push	{r3, r4, r5, lr}
   88f5a:	4d09      	ldr	r5, [pc, #36]	; (88f80 <__libc_fini_array+0x28>)
   88f5c:	4c09      	ldr	r4, [pc, #36]	; (88f84 <__libc_fini_array+0x2c>)
   88f5e:	1b64      	subs	r4, r4, r5
   88f60:	10a4      	asrs	r4, r4, #2
   88f62:	bf18      	it	ne
   88f64:	eb05 0584 	addne.w	r5, r5, r4, lsl #2
   88f68:	d005      	beq.n	88f76 <__libc_fini_array+0x1e>
   88f6a:	3c01      	subs	r4, #1
   88f6c:	f855 3d04 	ldr.w	r3, [r5, #-4]!
   88f70:	4798      	blx	r3
   88f72:	2c00      	cmp	r4, #0
   88f74:	d1f9      	bne.n	88f6a <__libc_fini_array+0x12>
   88f76:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
   88f7a:	f003 bf95 	b.w	8cea8 <_fini>
   88f7e:	bf00      	nop
   88f80:	0008ceb4 	.word	0x0008ceb4
   88f84:	0008ceb8 	.word	0x0008ceb8

00088f88 <_malloc_trim_r>:
   88f88:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   88f8a:	4d23      	ldr	r5, [pc, #140]	; (89018 <_malloc_trim_r+0x90>)
   88f8c:	460f      	mov	r7, r1
   88f8e:	4604      	mov	r4, r0
   88f90:	f000 fc64 	bl	8985c <__malloc_lock>
   88f94:	68ab      	ldr	r3, [r5, #8]
   88f96:	685e      	ldr	r6, [r3, #4]
   88f98:	f026 0603 	bic.w	r6, r6, #3
   88f9c:	1bf1      	subs	r1, r6, r7
   88f9e:	f601 71ef 	addw	r1, r1, #4079	; 0xfef
   88fa2:	f421 617f 	bic.w	r1, r1, #4080	; 0xff0
   88fa6:	f021 010f 	bic.w	r1, r1, #15
   88faa:	f5a1 5780 	sub.w	r7, r1, #4096	; 0x1000
   88fae:	f5b7 5f80 	cmp.w	r7, #4096	; 0x1000
   88fb2:	db07      	blt.n	88fc4 <_malloc_trim_r+0x3c>
   88fb4:	4620      	mov	r0, r4
   88fb6:	2100      	movs	r1, #0
   88fb8:	f001 f966 	bl	8a288 <_sbrk_r>
   88fbc:	68ab      	ldr	r3, [r5, #8]
   88fbe:	4433      	add	r3, r6
   88fc0:	4298      	cmp	r0, r3
   88fc2:	d004      	beq.n	88fce <_malloc_trim_r+0x46>
   88fc4:	4620      	mov	r0, r4
   88fc6:	f000 fc4b 	bl	89860 <__malloc_unlock>
   88fca:	2000      	movs	r0, #0
   88fcc:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   88fce:	4620      	mov	r0, r4
   88fd0:	4279      	negs	r1, r7
   88fd2:	f001 f959 	bl	8a288 <_sbrk_r>
   88fd6:	3001      	adds	r0, #1
   88fd8:	d00d      	beq.n	88ff6 <_malloc_trim_r+0x6e>
   88fda:	4b10      	ldr	r3, [pc, #64]	; (8901c <_malloc_trim_r+0x94>)
   88fdc:	68aa      	ldr	r2, [r5, #8]
   88fde:	6819      	ldr	r1, [r3, #0]
   88fe0:	1bf6      	subs	r6, r6, r7
   88fe2:	f046 0601 	orr.w	r6, r6, #1
   88fe6:	4620      	mov	r0, r4
   88fe8:	1bc9      	subs	r1, r1, r7
   88fea:	6056      	str	r6, [r2, #4]
   88fec:	6019      	str	r1, [r3, #0]
   88fee:	f000 fc37 	bl	89860 <__malloc_unlock>
   88ff2:	2001      	movs	r0, #1
   88ff4:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   88ff6:	4620      	mov	r0, r4
   88ff8:	2100      	movs	r1, #0
   88ffa:	f001 f945 	bl	8a288 <_sbrk_r>
   88ffe:	68ab      	ldr	r3, [r5, #8]
   89000:	1ac2      	subs	r2, r0, r3
   89002:	2a0f      	cmp	r2, #15
   89004:	ddde      	ble.n	88fc4 <_malloc_trim_r+0x3c>
   89006:	4d06      	ldr	r5, [pc, #24]	; (89020 <_malloc_trim_r+0x98>)
   89008:	4904      	ldr	r1, [pc, #16]	; (8901c <_malloc_trim_r+0x94>)
   8900a:	682d      	ldr	r5, [r5, #0]
   8900c:	f042 0201 	orr.w	r2, r2, #1
   89010:	1b40      	subs	r0, r0, r5
   89012:	605a      	str	r2, [r3, #4]
   89014:	6008      	str	r0, [r1, #0]
   89016:	e7d5      	b.n	88fc4 <_malloc_trim_r+0x3c>
   89018:	200708d0 	.word	0x200708d0
   8901c:	20075c14 	.word	0x20075c14
   89020:	20070cdc 	.word	0x20070cdc

00089024 <_free_r>:
   89024:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   89028:	460d      	mov	r5, r1
   8902a:	4606      	mov	r6, r0
   8902c:	2900      	cmp	r1, #0
   8902e:	d055      	beq.n	890dc <_free_r+0xb8>
   89030:	f000 fc14 	bl	8985c <__malloc_lock>
   89034:	f855 1c04 	ldr.w	r1, [r5, #-4]
   89038:	f8df c170 	ldr.w	ip, [pc, #368]	; 891ac <_free_r+0x188>
   8903c:	f1a5 0408 	sub.w	r4, r5, #8
   89040:	f021 0301 	bic.w	r3, r1, #1
   89044:	18e2      	adds	r2, r4, r3
   89046:	f8dc 0008 	ldr.w	r0, [ip, #8]
   8904a:	6857      	ldr	r7, [r2, #4]
   8904c:	4290      	cmp	r0, r2
   8904e:	f027 0703 	bic.w	r7, r7, #3
   89052:	d068      	beq.n	89126 <_free_r+0x102>
   89054:	f011 0101 	ands.w	r1, r1, #1
   89058:	6057      	str	r7, [r2, #4]
   8905a:	d032      	beq.n	890c2 <_free_r+0x9e>
   8905c:	2100      	movs	r1, #0
   8905e:	19d0      	adds	r0, r2, r7
   89060:	6840      	ldr	r0, [r0, #4]
   89062:	07c0      	lsls	r0, r0, #31
   89064:	d406      	bmi.n	89074 <_free_r+0x50>
   89066:	443b      	add	r3, r7
   89068:	6890      	ldr	r0, [r2, #8]
   8906a:	2900      	cmp	r1, #0
   8906c:	d04d      	beq.n	8910a <_free_r+0xe6>
   8906e:	68d2      	ldr	r2, [r2, #12]
   89070:	60c2      	str	r2, [r0, #12]
   89072:	6090      	str	r0, [r2, #8]
   89074:	f043 0201 	orr.w	r2, r3, #1
   89078:	6062      	str	r2, [r4, #4]
   8907a:	50e3      	str	r3, [r4, r3]
   8907c:	b9e1      	cbnz	r1, 890b8 <_free_r+0x94>
   8907e:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
   89082:	d32d      	bcc.n	890e0 <_free_r+0xbc>
   89084:	0a5a      	lsrs	r2, r3, #9
   89086:	2a04      	cmp	r2, #4
   89088:	d869      	bhi.n	8915e <_free_r+0x13a>
   8908a:	0998      	lsrs	r0, r3, #6
   8908c:	3038      	adds	r0, #56	; 0x38
   8908e:	0041      	lsls	r1, r0, #1
   89090:	eb0c 0c81 	add.w	ip, ip, r1, lsl #2
   89094:	f8dc 2008 	ldr.w	r2, [ip, #8]
   89098:	4944      	ldr	r1, [pc, #272]	; (891ac <_free_r+0x188>)
   8909a:	4562      	cmp	r2, ip
   8909c:	d065      	beq.n	8916a <_free_r+0x146>
   8909e:	6851      	ldr	r1, [r2, #4]
   890a0:	f021 0103 	bic.w	r1, r1, #3
   890a4:	428b      	cmp	r3, r1
   890a6:	d202      	bcs.n	890ae <_free_r+0x8a>
   890a8:	6892      	ldr	r2, [r2, #8]
   890aa:	4594      	cmp	ip, r2
   890ac:	d1f7      	bne.n	8909e <_free_r+0x7a>
   890ae:	68d3      	ldr	r3, [r2, #12]
   890b0:	60e3      	str	r3, [r4, #12]
   890b2:	60a2      	str	r2, [r4, #8]
   890b4:	609c      	str	r4, [r3, #8]
   890b6:	60d4      	str	r4, [r2, #12]
   890b8:	4630      	mov	r0, r6
   890ba:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
   890be:	f000 bbcf 	b.w	89860 <__malloc_unlock>
   890c2:	f855 5c08 	ldr.w	r5, [r5, #-8]
   890c6:	f10c 0808 	add.w	r8, ip, #8
   890ca:	1b64      	subs	r4, r4, r5
   890cc:	68a0      	ldr	r0, [r4, #8]
   890ce:	442b      	add	r3, r5
   890d0:	4540      	cmp	r0, r8
   890d2:	d042      	beq.n	8915a <_free_r+0x136>
   890d4:	68e5      	ldr	r5, [r4, #12]
   890d6:	60c5      	str	r5, [r0, #12]
   890d8:	60a8      	str	r0, [r5, #8]
   890da:	e7c0      	b.n	8905e <_free_r+0x3a>
   890dc:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   890e0:	08db      	lsrs	r3, r3, #3
   890e2:	109a      	asrs	r2, r3, #2
   890e4:	2001      	movs	r0, #1
   890e6:	4090      	lsls	r0, r2
   890e8:	f8dc 1004 	ldr.w	r1, [ip, #4]
   890ec:	eb0c 03c3 	add.w	r3, ip, r3, lsl #3
   890f0:	689a      	ldr	r2, [r3, #8]
   890f2:	4301      	orrs	r1, r0
   890f4:	60a2      	str	r2, [r4, #8]
   890f6:	60e3      	str	r3, [r4, #12]
   890f8:	f8cc 1004 	str.w	r1, [ip, #4]
   890fc:	4630      	mov	r0, r6
   890fe:	609c      	str	r4, [r3, #8]
   89100:	60d4      	str	r4, [r2, #12]
   89102:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
   89106:	f000 bbab 	b.w	89860 <__malloc_unlock>
   8910a:	4d29      	ldr	r5, [pc, #164]	; (891b0 <_free_r+0x18c>)
   8910c:	42a8      	cmp	r0, r5
   8910e:	d1ae      	bne.n	8906e <_free_r+0x4a>
   89110:	f043 0201 	orr.w	r2, r3, #1
   89114:	f8cc 4014 	str.w	r4, [ip, #20]
   89118:	f8cc 4010 	str.w	r4, [ip, #16]
   8911c:	60e0      	str	r0, [r4, #12]
   8911e:	60a0      	str	r0, [r4, #8]
   89120:	6062      	str	r2, [r4, #4]
   89122:	50e3      	str	r3, [r4, r3]
   89124:	e7c8      	b.n	890b8 <_free_r+0x94>
   89126:	441f      	add	r7, r3
   89128:	07cb      	lsls	r3, r1, #31
   8912a:	d407      	bmi.n	8913c <_free_r+0x118>
   8912c:	f855 1c08 	ldr.w	r1, [r5, #-8]
   89130:	1a64      	subs	r4, r4, r1
   89132:	68e3      	ldr	r3, [r4, #12]
   89134:	68a2      	ldr	r2, [r4, #8]
   89136:	440f      	add	r7, r1
   89138:	60d3      	str	r3, [r2, #12]
   8913a:	609a      	str	r2, [r3, #8]
   8913c:	4b1d      	ldr	r3, [pc, #116]	; (891b4 <_free_r+0x190>)
   8913e:	f047 0201 	orr.w	r2, r7, #1
   89142:	681b      	ldr	r3, [r3, #0]
   89144:	6062      	str	r2, [r4, #4]
   89146:	429f      	cmp	r7, r3
   89148:	f8cc 4008 	str.w	r4, [ip, #8]
   8914c:	d3b4      	bcc.n	890b8 <_free_r+0x94>
   8914e:	4b1a      	ldr	r3, [pc, #104]	; (891b8 <_free_r+0x194>)
   89150:	4630      	mov	r0, r6
   89152:	6819      	ldr	r1, [r3, #0]
   89154:	f7ff ff18 	bl	88f88 <_malloc_trim_r>
   89158:	e7ae      	b.n	890b8 <_free_r+0x94>
   8915a:	2101      	movs	r1, #1
   8915c:	e77f      	b.n	8905e <_free_r+0x3a>
   8915e:	2a14      	cmp	r2, #20
   89160:	d80b      	bhi.n	8917a <_free_r+0x156>
   89162:	f102 005b 	add.w	r0, r2, #91	; 0x5b
   89166:	0041      	lsls	r1, r0, #1
   89168:	e792      	b.n	89090 <_free_r+0x6c>
   8916a:	1080      	asrs	r0, r0, #2
   8916c:	2501      	movs	r5, #1
   8916e:	4085      	lsls	r5, r0
   89170:	6848      	ldr	r0, [r1, #4]
   89172:	4613      	mov	r3, r2
   89174:	4328      	orrs	r0, r5
   89176:	6048      	str	r0, [r1, #4]
   89178:	e79a      	b.n	890b0 <_free_r+0x8c>
   8917a:	2a54      	cmp	r2, #84	; 0x54
   8917c:	d803      	bhi.n	89186 <_free_r+0x162>
   8917e:	0b18      	lsrs	r0, r3, #12
   89180:	306e      	adds	r0, #110	; 0x6e
   89182:	0041      	lsls	r1, r0, #1
   89184:	e784      	b.n	89090 <_free_r+0x6c>
   89186:	f5b2 7faa 	cmp.w	r2, #340	; 0x154
   8918a:	d803      	bhi.n	89194 <_free_r+0x170>
   8918c:	0bd8      	lsrs	r0, r3, #15
   8918e:	3077      	adds	r0, #119	; 0x77
   89190:	0041      	lsls	r1, r0, #1
   89192:	e77d      	b.n	89090 <_free_r+0x6c>
   89194:	f240 5154 	movw	r1, #1364	; 0x554
   89198:	428a      	cmp	r2, r1
   8919a:	d803      	bhi.n	891a4 <_free_r+0x180>
   8919c:	0c98      	lsrs	r0, r3, #18
   8919e:	307c      	adds	r0, #124	; 0x7c
   891a0:	0041      	lsls	r1, r0, #1
   891a2:	e775      	b.n	89090 <_free_r+0x6c>
   891a4:	21fc      	movs	r1, #252	; 0xfc
   891a6:	207e      	movs	r0, #126	; 0x7e
   891a8:	e772      	b.n	89090 <_free_r+0x6c>
   891aa:	bf00      	nop
   891ac:	200708d0 	.word	0x200708d0
   891b0:	200708d8 	.word	0x200708d8
   891b4:	20070cd8 	.word	0x20070cd8
   891b8:	20075c10 	.word	0x20075c10

000891bc <_localeconv_r>:
   891bc:	4800      	ldr	r0, [pc, #0]	; (891c0 <_localeconv_r+0x4>)
   891be:	4770      	bx	lr
   891c0:	20070898 	.word	0x20070898

000891c4 <_malloc_r>:
   891c4:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   891c8:	f101 050b 	add.w	r5, r1, #11
   891cc:	2d16      	cmp	r5, #22
   891ce:	b083      	sub	sp, #12
   891d0:	4606      	mov	r6, r0
   891d2:	d927      	bls.n	89224 <_malloc_r+0x60>
   891d4:	f035 0507 	bics.w	r5, r5, #7
   891d8:	d427      	bmi.n	8922a <_malloc_r+0x66>
   891da:	42a9      	cmp	r1, r5
   891dc:	d825      	bhi.n	8922a <_malloc_r+0x66>
   891de:	4630      	mov	r0, r6
   891e0:	f000 fb3c 	bl	8985c <__malloc_lock>
   891e4:	f5b5 7ffc 	cmp.w	r5, #504	; 0x1f8
   891e8:	d226      	bcs.n	89238 <_malloc_r+0x74>
   891ea:	4fc1      	ldr	r7, [pc, #772]	; (894f0 <_malloc_r+0x32c>)
   891ec:	ea4f 0cd5 	mov.w	ip, r5, lsr #3
   891f0:	eb07 03cc 	add.w	r3, r7, ip, lsl #3
   891f4:	68dc      	ldr	r4, [r3, #12]
   891f6:	429c      	cmp	r4, r3
   891f8:	f000 81d2 	beq.w	895a0 <_malloc_r+0x3dc>
   891fc:	6863      	ldr	r3, [r4, #4]
   891fe:	68e2      	ldr	r2, [r4, #12]
   89200:	f023 0303 	bic.w	r3, r3, #3
   89204:	4423      	add	r3, r4
   89206:	6858      	ldr	r0, [r3, #4]
   89208:	68a1      	ldr	r1, [r4, #8]
   8920a:	f040 0501 	orr.w	r5, r0, #1
   8920e:	60ca      	str	r2, [r1, #12]
   89210:	4630      	mov	r0, r6
   89212:	6091      	str	r1, [r2, #8]
   89214:	605d      	str	r5, [r3, #4]
   89216:	f000 fb23 	bl	89860 <__malloc_unlock>
   8921a:	3408      	adds	r4, #8
   8921c:	4620      	mov	r0, r4
   8921e:	b003      	add	sp, #12
   89220:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   89224:	2510      	movs	r5, #16
   89226:	42a9      	cmp	r1, r5
   89228:	d9d9      	bls.n	891de <_malloc_r+0x1a>
   8922a:	2400      	movs	r4, #0
   8922c:	230c      	movs	r3, #12
   8922e:	4620      	mov	r0, r4
   89230:	6033      	str	r3, [r6, #0]
   89232:	b003      	add	sp, #12
   89234:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   89238:	ea5f 2c55 	movs.w	ip, r5, lsr #9
   8923c:	f000 8089 	beq.w	89352 <_malloc_r+0x18e>
   89240:	f1bc 0f04 	cmp.w	ip, #4
   89244:	f200 8160 	bhi.w	89508 <_malloc_r+0x344>
   89248:	ea4f 1c95 	mov.w	ip, r5, lsr #6
   8924c:	f10c 0c38 	add.w	ip, ip, #56	; 0x38
   89250:	ea4f 014c 	mov.w	r1, ip, lsl #1
   89254:	4fa6      	ldr	r7, [pc, #664]	; (894f0 <_malloc_r+0x32c>)
   89256:	eb07 0181 	add.w	r1, r7, r1, lsl #2
   8925a:	68cc      	ldr	r4, [r1, #12]
   8925c:	42a1      	cmp	r1, r4
   8925e:	d105      	bne.n	8926c <_malloc_r+0xa8>
   89260:	e00c      	b.n	8927c <_malloc_r+0xb8>
   89262:	2b00      	cmp	r3, #0
   89264:	da79      	bge.n	8935a <_malloc_r+0x196>
   89266:	68e4      	ldr	r4, [r4, #12]
   89268:	42a1      	cmp	r1, r4
   8926a:	d007      	beq.n	8927c <_malloc_r+0xb8>
   8926c:	6862      	ldr	r2, [r4, #4]
   8926e:	f022 0203 	bic.w	r2, r2, #3
   89272:	1b53      	subs	r3, r2, r5
   89274:	2b0f      	cmp	r3, #15
   89276:	ddf4      	ble.n	89262 <_malloc_r+0x9e>
   89278:	f10c 3cff 	add.w	ip, ip, #4294967295
   8927c:	f10c 0c01 	add.w	ip, ip, #1
   89280:	4b9b      	ldr	r3, [pc, #620]	; (894f0 <_malloc_r+0x32c>)
   89282:	693c      	ldr	r4, [r7, #16]
   89284:	f103 0e08 	add.w	lr, r3, #8
   89288:	4574      	cmp	r4, lr
   8928a:	f000 817e 	beq.w	8958a <_malloc_r+0x3c6>
   8928e:	6861      	ldr	r1, [r4, #4]
   89290:	f021 0103 	bic.w	r1, r1, #3
   89294:	1b4a      	subs	r2, r1, r5
   89296:	2a0f      	cmp	r2, #15
   89298:	f300 8164 	bgt.w	89564 <_malloc_r+0x3a0>
   8929c:	2a00      	cmp	r2, #0
   8929e:	f8c3 e014 	str.w	lr, [r3, #20]
   892a2:	f8c3 e010 	str.w	lr, [r3, #16]
   892a6:	da69      	bge.n	8937c <_malloc_r+0x1b8>
   892a8:	f5b1 7f00 	cmp.w	r1, #512	; 0x200
   892ac:	f080 813a 	bcs.w	89524 <_malloc_r+0x360>
   892b0:	08c9      	lsrs	r1, r1, #3
   892b2:	108a      	asrs	r2, r1, #2
   892b4:	f04f 0801 	mov.w	r8, #1
   892b8:	fa08 f802 	lsl.w	r8, r8, r2
   892bc:	eb03 01c1 	add.w	r1, r3, r1, lsl #3
   892c0:	685a      	ldr	r2, [r3, #4]
   892c2:	6888      	ldr	r0, [r1, #8]
   892c4:	ea48 0202 	orr.w	r2, r8, r2
   892c8:	60a0      	str	r0, [r4, #8]
   892ca:	60e1      	str	r1, [r4, #12]
   892cc:	605a      	str	r2, [r3, #4]
   892ce:	608c      	str	r4, [r1, #8]
   892d0:	60c4      	str	r4, [r0, #12]
   892d2:	ea4f 03ac 	mov.w	r3, ip, asr #2
   892d6:	2001      	movs	r0, #1
   892d8:	4098      	lsls	r0, r3
   892da:	4290      	cmp	r0, r2
   892dc:	d85b      	bhi.n	89396 <_malloc_r+0x1d2>
   892de:	4202      	tst	r2, r0
   892e0:	d106      	bne.n	892f0 <_malloc_r+0x12c>
   892e2:	f02c 0c03 	bic.w	ip, ip, #3
   892e6:	0040      	lsls	r0, r0, #1
   892e8:	4202      	tst	r2, r0
   892ea:	f10c 0c04 	add.w	ip, ip, #4
   892ee:	d0fa      	beq.n	892e6 <_malloc_r+0x122>
   892f0:	eb07 08cc 	add.w	r8, r7, ip, lsl #3
   892f4:	4644      	mov	r4, r8
   892f6:	46e1      	mov	r9, ip
   892f8:	68e3      	ldr	r3, [r4, #12]
   892fa:	429c      	cmp	r4, r3
   892fc:	d107      	bne.n	8930e <_malloc_r+0x14a>
   892fe:	e146      	b.n	8958e <_malloc_r+0x3ca>
   89300:	2a00      	cmp	r2, #0
   89302:	f280 8157 	bge.w	895b4 <_malloc_r+0x3f0>
   89306:	68db      	ldr	r3, [r3, #12]
   89308:	429c      	cmp	r4, r3
   8930a:	f000 8140 	beq.w	8958e <_malloc_r+0x3ca>
   8930e:	6859      	ldr	r1, [r3, #4]
   89310:	f021 0103 	bic.w	r1, r1, #3
   89314:	1b4a      	subs	r2, r1, r5
   89316:	2a0f      	cmp	r2, #15
   89318:	ddf2      	ble.n	89300 <_malloc_r+0x13c>
   8931a:	461c      	mov	r4, r3
   8931c:	f854 cf08 	ldr.w	ip, [r4, #8]!
   89320:	68d9      	ldr	r1, [r3, #12]
   89322:	f045 0901 	orr.w	r9, r5, #1
   89326:	f042 0801 	orr.w	r8, r2, #1
   8932a:	441d      	add	r5, r3
   8932c:	f8c3 9004 	str.w	r9, [r3, #4]
   89330:	4630      	mov	r0, r6
   89332:	f8cc 100c 	str.w	r1, [ip, #12]
   89336:	f8c1 c008 	str.w	ip, [r1, #8]
   8933a:	617d      	str	r5, [r7, #20]
   8933c:	613d      	str	r5, [r7, #16]
   8933e:	f8c5 e00c 	str.w	lr, [r5, #12]
   89342:	f8c5 e008 	str.w	lr, [r5, #8]
   89346:	f8c5 8004 	str.w	r8, [r5, #4]
   8934a:	50aa      	str	r2, [r5, r2]
   8934c:	f000 fa88 	bl	89860 <__malloc_unlock>
   89350:	e764      	b.n	8921c <_malloc_r+0x58>
   89352:	217e      	movs	r1, #126	; 0x7e
   89354:	f04f 0c3f 	mov.w	ip, #63	; 0x3f
   89358:	e77c      	b.n	89254 <_malloc_r+0x90>
   8935a:	4422      	add	r2, r4
   8935c:	6850      	ldr	r0, [r2, #4]
   8935e:	68e3      	ldr	r3, [r4, #12]
   89360:	68a1      	ldr	r1, [r4, #8]
   89362:	f040 0501 	orr.w	r5, r0, #1
   89366:	60cb      	str	r3, [r1, #12]
   89368:	4630      	mov	r0, r6
   8936a:	6099      	str	r1, [r3, #8]
   8936c:	6055      	str	r5, [r2, #4]
   8936e:	f000 fa77 	bl	89860 <__malloc_unlock>
   89372:	3408      	adds	r4, #8
   89374:	4620      	mov	r0, r4
   89376:	b003      	add	sp, #12
   89378:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   8937c:	4421      	add	r1, r4
   8937e:	684b      	ldr	r3, [r1, #4]
   89380:	4630      	mov	r0, r6
   89382:	f043 0301 	orr.w	r3, r3, #1
   89386:	604b      	str	r3, [r1, #4]
   89388:	f000 fa6a 	bl	89860 <__malloc_unlock>
   8938c:	3408      	adds	r4, #8
   8938e:	4620      	mov	r0, r4
   89390:	b003      	add	sp, #12
   89392:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   89396:	68bc      	ldr	r4, [r7, #8]
   89398:	6863      	ldr	r3, [r4, #4]
   8939a:	f023 0903 	bic.w	r9, r3, #3
   8939e:	45a9      	cmp	r9, r5
   893a0:	d304      	bcc.n	893ac <_malloc_r+0x1e8>
   893a2:	ebc5 0309 	rsb	r3, r5, r9
   893a6:	2b0f      	cmp	r3, #15
   893a8:	f300 8091 	bgt.w	894ce <_malloc_r+0x30a>
   893ac:	4b51      	ldr	r3, [pc, #324]	; (894f4 <_malloc_r+0x330>)
   893ae:	4a52      	ldr	r2, [pc, #328]	; (894f8 <_malloc_r+0x334>)
   893b0:	6819      	ldr	r1, [r3, #0]
   893b2:	6813      	ldr	r3, [r2, #0]
   893b4:	eb05 0a01 	add.w	sl, r5, r1
   893b8:	3301      	adds	r3, #1
   893ba:	eb04 0b09 	add.w	fp, r4, r9
   893be:	f000 8161 	beq.w	89684 <_malloc_r+0x4c0>
   893c2:	f50a 5a80 	add.w	sl, sl, #4096	; 0x1000
   893c6:	f10a 0a0f 	add.w	sl, sl, #15
   893ca:	f42a 6a7f 	bic.w	sl, sl, #4080	; 0xff0
   893ce:	f02a 0a0f 	bic.w	sl, sl, #15
   893d2:	4630      	mov	r0, r6
   893d4:	4651      	mov	r1, sl
   893d6:	9201      	str	r2, [sp, #4]
   893d8:	f000 ff56 	bl	8a288 <_sbrk_r>
   893dc:	f1b0 3fff 	cmp.w	r0, #4294967295
   893e0:	4680      	mov	r8, r0
   893e2:	9a01      	ldr	r2, [sp, #4]
   893e4:	f000 8101 	beq.w	895ea <_malloc_r+0x426>
   893e8:	4583      	cmp	fp, r0
   893ea:	f200 80fb 	bhi.w	895e4 <_malloc_r+0x420>
   893ee:	f8df c114 	ldr.w	ip, [pc, #276]	; 89504 <_malloc_r+0x340>
   893f2:	45c3      	cmp	fp, r8
   893f4:	f8dc 3000 	ldr.w	r3, [ip]
   893f8:	4453      	add	r3, sl
   893fa:	f8cc 3000 	str.w	r3, [ip]
   893fe:	f000 814a 	beq.w	89696 <_malloc_r+0x4d2>
   89402:	6812      	ldr	r2, [r2, #0]
   89404:	493c      	ldr	r1, [pc, #240]	; (894f8 <_malloc_r+0x334>)
   89406:	3201      	adds	r2, #1
   89408:	bf1b      	ittet	ne
   8940a:	ebcb 0b08 	rsbne	fp, fp, r8
   8940e:	445b      	addne	r3, fp
   89410:	f8c1 8000 	streq.w	r8, [r1]
   89414:	f8cc 3000 	strne.w	r3, [ip]
   89418:	f018 0307 	ands.w	r3, r8, #7
   8941c:	f000 8114 	beq.w	89648 <_malloc_r+0x484>
   89420:	f1c3 0208 	rsb	r2, r3, #8
   89424:	f5c3 5380 	rsb	r3, r3, #4096	; 0x1000
   89428:	4490      	add	r8, r2
   8942a:	3308      	adds	r3, #8
   8942c:	44c2      	add	sl, r8
   8942e:	f3ca 0a0b 	ubfx	sl, sl, #0, #12
   89432:	ebca 0a03 	rsb	sl, sl, r3
   89436:	4651      	mov	r1, sl
   89438:	4630      	mov	r0, r6
   8943a:	f8cd c004 	str.w	ip, [sp, #4]
   8943e:	f000 ff23 	bl	8a288 <_sbrk_r>
   89442:	1c43      	adds	r3, r0, #1
   89444:	f8dd c004 	ldr.w	ip, [sp, #4]
   89448:	f000 8135 	beq.w	896b6 <_malloc_r+0x4f2>
   8944c:	ebc8 0200 	rsb	r2, r8, r0
   89450:	4452      	add	r2, sl
   89452:	f042 0201 	orr.w	r2, r2, #1
   89456:	f8dc 3000 	ldr.w	r3, [ip]
   8945a:	42bc      	cmp	r4, r7
   8945c:	4453      	add	r3, sl
   8945e:	f8c7 8008 	str.w	r8, [r7, #8]
   89462:	f8cc 3000 	str.w	r3, [ip]
   89466:	f8c8 2004 	str.w	r2, [r8, #4]
   8946a:	f8df a098 	ldr.w	sl, [pc, #152]	; 89504 <_malloc_r+0x340>
   8946e:	d015      	beq.n	8949c <_malloc_r+0x2d8>
   89470:	f1b9 0f0f 	cmp.w	r9, #15
   89474:	f240 80eb 	bls.w	8964e <_malloc_r+0x48a>
   89478:	6861      	ldr	r1, [r4, #4]
   8947a:	f1a9 020c 	sub.w	r2, r9, #12
   8947e:	f022 0207 	bic.w	r2, r2, #7
   89482:	f001 0101 	and.w	r1, r1, #1
   89486:	ea42 0e01 	orr.w	lr, r2, r1
   8948a:	2005      	movs	r0, #5
   8948c:	18a1      	adds	r1, r4, r2
   8948e:	2a0f      	cmp	r2, #15
   89490:	f8c4 e004 	str.w	lr, [r4, #4]
   89494:	6048      	str	r0, [r1, #4]
   89496:	6088      	str	r0, [r1, #8]
   89498:	f200 8111 	bhi.w	896be <_malloc_r+0x4fa>
   8949c:	4a17      	ldr	r2, [pc, #92]	; (894fc <_malloc_r+0x338>)
   8949e:	68bc      	ldr	r4, [r7, #8]
   894a0:	6811      	ldr	r1, [r2, #0]
   894a2:	428b      	cmp	r3, r1
   894a4:	bf88      	it	hi
   894a6:	6013      	strhi	r3, [r2, #0]
   894a8:	4a15      	ldr	r2, [pc, #84]	; (89500 <_malloc_r+0x33c>)
   894aa:	6811      	ldr	r1, [r2, #0]
   894ac:	428b      	cmp	r3, r1
   894ae:	bf88      	it	hi
   894b0:	6013      	strhi	r3, [r2, #0]
   894b2:	6862      	ldr	r2, [r4, #4]
   894b4:	f022 0203 	bic.w	r2, r2, #3
   894b8:	4295      	cmp	r5, r2
   894ba:	ebc5 0302 	rsb	r3, r5, r2
   894be:	d801      	bhi.n	894c4 <_malloc_r+0x300>
   894c0:	2b0f      	cmp	r3, #15
   894c2:	dc04      	bgt.n	894ce <_malloc_r+0x30a>
   894c4:	4630      	mov	r0, r6
   894c6:	f000 f9cb 	bl	89860 <__malloc_unlock>
   894ca:	2400      	movs	r4, #0
   894cc:	e6a6      	b.n	8921c <_malloc_r+0x58>
   894ce:	f045 0201 	orr.w	r2, r5, #1
   894d2:	f043 0301 	orr.w	r3, r3, #1
   894d6:	4425      	add	r5, r4
   894d8:	6062      	str	r2, [r4, #4]
   894da:	4630      	mov	r0, r6
   894dc:	60bd      	str	r5, [r7, #8]
   894de:	606b      	str	r3, [r5, #4]
   894e0:	f000 f9be 	bl	89860 <__malloc_unlock>
   894e4:	3408      	adds	r4, #8
   894e6:	4620      	mov	r0, r4
   894e8:	b003      	add	sp, #12
   894ea:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   894ee:	bf00      	nop
   894f0:	200708d0 	.word	0x200708d0
   894f4:	20075c10 	.word	0x20075c10
   894f8:	20070cdc 	.word	0x20070cdc
   894fc:	20075c0c 	.word	0x20075c0c
   89500:	20075c08 	.word	0x20075c08
   89504:	20075c14 	.word	0x20075c14
   89508:	f1bc 0f14 	cmp.w	ip, #20
   8950c:	d961      	bls.n	895d2 <_malloc_r+0x40e>
   8950e:	f1bc 0f54 	cmp.w	ip, #84	; 0x54
   89512:	f200 808f 	bhi.w	89634 <_malloc_r+0x470>
   89516:	ea4f 3c15 	mov.w	ip, r5, lsr #12
   8951a:	f10c 0c6e 	add.w	ip, ip, #110	; 0x6e
   8951e:	ea4f 014c 	mov.w	r1, ip, lsl #1
   89522:	e697      	b.n	89254 <_malloc_r+0x90>
   89524:	0a4b      	lsrs	r3, r1, #9
   89526:	2b04      	cmp	r3, #4
   89528:	d958      	bls.n	895dc <_malloc_r+0x418>
   8952a:	2b14      	cmp	r3, #20
   8952c:	f200 80ad 	bhi.w	8968a <_malloc_r+0x4c6>
   89530:	f103 025b 	add.w	r2, r3, #91	; 0x5b
   89534:	0050      	lsls	r0, r2, #1
   89536:	eb07 0080 	add.w	r0, r7, r0, lsl #2
   8953a:	6883      	ldr	r3, [r0, #8]
   8953c:	f8df 81b8 	ldr.w	r8, [pc, #440]	; 896f8 <_malloc_r+0x534>
   89540:	4283      	cmp	r3, r0
   89542:	f000 808a 	beq.w	8965a <_malloc_r+0x496>
   89546:	685a      	ldr	r2, [r3, #4]
   89548:	f022 0203 	bic.w	r2, r2, #3
   8954c:	4291      	cmp	r1, r2
   8954e:	d202      	bcs.n	89556 <_malloc_r+0x392>
   89550:	689b      	ldr	r3, [r3, #8]
   89552:	4298      	cmp	r0, r3
   89554:	d1f7      	bne.n	89546 <_malloc_r+0x382>
   89556:	68d9      	ldr	r1, [r3, #12]
   89558:	687a      	ldr	r2, [r7, #4]
   8955a:	60e1      	str	r1, [r4, #12]
   8955c:	60a3      	str	r3, [r4, #8]
   8955e:	608c      	str	r4, [r1, #8]
   89560:	60dc      	str	r4, [r3, #12]
   89562:	e6b6      	b.n	892d2 <_malloc_r+0x10e>
   89564:	f045 0701 	orr.w	r7, r5, #1
   89568:	f042 0101 	orr.w	r1, r2, #1
   8956c:	4425      	add	r5, r4
   8956e:	6067      	str	r7, [r4, #4]
   89570:	4630      	mov	r0, r6
   89572:	615d      	str	r5, [r3, #20]
   89574:	611d      	str	r5, [r3, #16]
   89576:	f8c5 e00c 	str.w	lr, [r5, #12]
   8957a:	f8c5 e008 	str.w	lr, [r5, #8]
   8957e:	6069      	str	r1, [r5, #4]
   89580:	50aa      	str	r2, [r5, r2]
   89582:	3408      	adds	r4, #8
   89584:	f000 f96c 	bl	89860 <__malloc_unlock>
   89588:	e648      	b.n	8921c <_malloc_r+0x58>
   8958a:	685a      	ldr	r2, [r3, #4]
   8958c:	e6a1      	b.n	892d2 <_malloc_r+0x10e>
   8958e:	f109 0901 	add.w	r9, r9, #1
   89592:	f019 0f03 	tst.w	r9, #3
   89596:	f104 0408 	add.w	r4, r4, #8
   8959a:	f47f aead 	bne.w	892f8 <_malloc_r+0x134>
   8959e:	e02d      	b.n	895fc <_malloc_r+0x438>
   895a0:	f104 0308 	add.w	r3, r4, #8
   895a4:	6964      	ldr	r4, [r4, #20]
   895a6:	42a3      	cmp	r3, r4
   895a8:	bf08      	it	eq
   895aa:	f10c 0c02 	addeq.w	ip, ip, #2
   895ae:	f43f ae67 	beq.w	89280 <_malloc_r+0xbc>
   895b2:	e623      	b.n	891fc <_malloc_r+0x38>
   895b4:	4419      	add	r1, r3
   895b6:	6848      	ldr	r0, [r1, #4]
   895b8:	461c      	mov	r4, r3
   895ba:	f854 2f08 	ldr.w	r2, [r4, #8]!
   895be:	68db      	ldr	r3, [r3, #12]
   895c0:	f040 0501 	orr.w	r5, r0, #1
   895c4:	604d      	str	r5, [r1, #4]
   895c6:	4630      	mov	r0, r6
   895c8:	60d3      	str	r3, [r2, #12]
   895ca:	609a      	str	r2, [r3, #8]
   895cc:	f000 f948 	bl	89860 <__malloc_unlock>
   895d0:	e624      	b.n	8921c <_malloc_r+0x58>
   895d2:	f10c 0c5b 	add.w	ip, ip, #91	; 0x5b
   895d6:	ea4f 014c 	mov.w	r1, ip, lsl #1
   895da:	e63b      	b.n	89254 <_malloc_r+0x90>
   895dc:	098a      	lsrs	r2, r1, #6
   895de:	3238      	adds	r2, #56	; 0x38
   895e0:	0050      	lsls	r0, r2, #1
   895e2:	e7a8      	b.n	89536 <_malloc_r+0x372>
   895e4:	42bc      	cmp	r4, r7
   895e6:	f43f af02 	beq.w	893ee <_malloc_r+0x22a>
   895ea:	68bc      	ldr	r4, [r7, #8]
   895ec:	6862      	ldr	r2, [r4, #4]
   895ee:	f022 0203 	bic.w	r2, r2, #3
   895f2:	e761      	b.n	894b8 <_malloc_r+0x2f4>
   895f4:	f8d8 8000 	ldr.w	r8, [r8]
   895f8:	4598      	cmp	r8, r3
   895fa:	d17a      	bne.n	896f2 <_malloc_r+0x52e>
   895fc:	f01c 0f03 	tst.w	ip, #3
   89600:	f1a8 0308 	sub.w	r3, r8, #8
   89604:	f10c 3cff 	add.w	ip, ip, #4294967295
   89608:	d1f4      	bne.n	895f4 <_malloc_r+0x430>
   8960a:	687b      	ldr	r3, [r7, #4]
   8960c:	ea23 0300 	bic.w	r3, r3, r0
   89610:	607b      	str	r3, [r7, #4]
   89612:	0040      	lsls	r0, r0, #1
   89614:	4298      	cmp	r0, r3
   89616:	f63f aebe 	bhi.w	89396 <_malloc_r+0x1d2>
   8961a:	2800      	cmp	r0, #0
   8961c:	f43f aebb 	beq.w	89396 <_malloc_r+0x1d2>
   89620:	4203      	tst	r3, r0
   89622:	46cc      	mov	ip, r9
   89624:	f47f ae64 	bne.w	892f0 <_malloc_r+0x12c>
   89628:	0040      	lsls	r0, r0, #1
   8962a:	4203      	tst	r3, r0
   8962c:	f10c 0c04 	add.w	ip, ip, #4
   89630:	d0fa      	beq.n	89628 <_malloc_r+0x464>
   89632:	e65d      	b.n	892f0 <_malloc_r+0x12c>
   89634:	f5bc 7faa 	cmp.w	ip, #340	; 0x154
   89638:	d819      	bhi.n	8966e <_malloc_r+0x4aa>
   8963a:	ea4f 3cd5 	mov.w	ip, r5, lsr #15
   8963e:	f10c 0c77 	add.w	ip, ip, #119	; 0x77
   89642:	ea4f 014c 	mov.w	r1, ip, lsl #1
   89646:	e605      	b.n	89254 <_malloc_r+0x90>
   89648:	f44f 5380 	mov.w	r3, #4096	; 0x1000
   8964c:	e6ee      	b.n	8942c <_malloc_r+0x268>
   8964e:	2301      	movs	r3, #1
   89650:	f8c8 3004 	str.w	r3, [r8, #4]
   89654:	4644      	mov	r4, r8
   89656:	2200      	movs	r2, #0
   89658:	e72e      	b.n	894b8 <_malloc_r+0x2f4>
   8965a:	1092      	asrs	r2, r2, #2
   8965c:	2001      	movs	r0, #1
   8965e:	4090      	lsls	r0, r2
   89660:	f8d8 2004 	ldr.w	r2, [r8, #4]
   89664:	4619      	mov	r1, r3
   89666:	4302      	orrs	r2, r0
   89668:	f8c8 2004 	str.w	r2, [r8, #4]
   8966c:	e775      	b.n	8955a <_malloc_r+0x396>
   8966e:	f240 5354 	movw	r3, #1364	; 0x554
   89672:	459c      	cmp	ip, r3
   89674:	d81b      	bhi.n	896ae <_malloc_r+0x4ea>
   89676:	ea4f 4c95 	mov.w	ip, r5, lsr #18
   8967a:	f10c 0c7c 	add.w	ip, ip, #124	; 0x7c
   8967e:	ea4f 014c 	mov.w	r1, ip, lsl #1
   89682:	e5e7      	b.n	89254 <_malloc_r+0x90>
   89684:	f10a 0a10 	add.w	sl, sl, #16
   89688:	e6a3      	b.n	893d2 <_malloc_r+0x20e>
   8968a:	2b54      	cmp	r3, #84	; 0x54
   8968c:	d81f      	bhi.n	896ce <_malloc_r+0x50a>
   8968e:	0b0a      	lsrs	r2, r1, #12
   89690:	326e      	adds	r2, #110	; 0x6e
   89692:	0050      	lsls	r0, r2, #1
   89694:	e74f      	b.n	89536 <_malloc_r+0x372>
   89696:	f3cb 010b 	ubfx	r1, fp, #0, #12
   8969a:	2900      	cmp	r1, #0
   8969c:	f47f aeb1 	bne.w	89402 <_malloc_r+0x23e>
   896a0:	eb0a 0109 	add.w	r1, sl, r9
   896a4:	68ba      	ldr	r2, [r7, #8]
   896a6:	f041 0101 	orr.w	r1, r1, #1
   896aa:	6051      	str	r1, [r2, #4]
   896ac:	e6f6      	b.n	8949c <_malloc_r+0x2d8>
   896ae:	21fc      	movs	r1, #252	; 0xfc
   896b0:	f04f 0c7e 	mov.w	ip, #126	; 0x7e
   896b4:	e5ce      	b.n	89254 <_malloc_r+0x90>
   896b6:	2201      	movs	r2, #1
   896b8:	f04f 0a00 	mov.w	sl, #0
   896bc:	e6cb      	b.n	89456 <_malloc_r+0x292>
   896be:	f104 0108 	add.w	r1, r4, #8
   896c2:	4630      	mov	r0, r6
   896c4:	f7ff fcae 	bl	89024 <_free_r>
   896c8:	f8da 3000 	ldr.w	r3, [sl]
   896cc:	e6e6      	b.n	8949c <_malloc_r+0x2d8>
   896ce:	f5b3 7faa 	cmp.w	r3, #340	; 0x154
   896d2:	d803      	bhi.n	896dc <_malloc_r+0x518>
   896d4:	0bca      	lsrs	r2, r1, #15
   896d6:	3277      	adds	r2, #119	; 0x77
   896d8:	0050      	lsls	r0, r2, #1
   896da:	e72c      	b.n	89536 <_malloc_r+0x372>
   896dc:	f240 5254 	movw	r2, #1364	; 0x554
   896e0:	4293      	cmp	r3, r2
   896e2:	d803      	bhi.n	896ec <_malloc_r+0x528>
   896e4:	0c8a      	lsrs	r2, r1, #18
   896e6:	327c      	adds	r2, #124	; 0x7c
   896e8:	0050      	lsls	r0, r2, #1
   896ea:	e724      	b.n	89536 <_malloc_r+0x372>
   896ec:	20fc      	movs	r0, #252	; 0xfc
   896ee:	227e      	movs	r2, #126	; 0x7e
   896f0:	e721      	b.n	89536 <_malloc_r+0x372>
   896f2:	687b      	ldr	r3, [r7, #4]
   896f4:	e78d      	b.n	89612 <_malloc_r+0x44e>
   896f6:	bf00      	nop
   896f8:	200708d0 	.word	0x200708d0

000896fc <memchr>:
   896fc:	0783      	lsls	r3, r0, #30
   896fe:	b470      	push	{r4, r5, r6}
   89700:	b2c9      	uxtb	r1, r1
   89702:	d040      	beq.n	89786 <memchr+0x8a>
   89704:	1e54      	subs	r4, r2, #1
   89706:	b32a      	cbz	r2, 89754 <memchr+0x58>
   89708:	7803      	ldrb	r3, [r0, #0]
   8970a:	428b      	cmp	r3, r1
   8970c:	d023      	beq.n	89756 <memchr+0x5a>
   8970e:	1c43      	adds	r3, r0, #1
   89710:	e004      	b.n	8971c <memchr+0x20>
   89712:	b1fc      	cbz	r4, 89754 <memchr+0x58>
   89714:	7805      	ldrb	r5, [r0, #0]
   89716:	4614      	mov	r4, r2
   89718:	428d      	cmp	r5, r1
   8971a:	d01c      	beq.n	89756 <memchr+0x5a>
   8971c:	f013 0f03 	tst.w	r3, #3
   89720:	4618      	mov	r0, r3
   89722:	f104 32ff 	add.w	r2, r4, #4294967295
   89726:	f103 0301 	add.w	r3, r3, #1
   8972a:	d1f2      	bne.n	89712 <memchr+0x16>
   8972c:	2c03      	cmp	r4, #3
   8972e:	d814      	bhi.n	8975a <memchr+0x5e>
   89730:	1e65      	subs	r5, r4, #1
   89732:	b354      	cbz	r4, 8978a <memchr+0x8e>
   89734:	7803      	ldrb	r3, [r0, #0]
   89736:	428b      	cmp	r3, r1
   89738:	d00d      	beq.n	89756 <memchr+0x5a>
   8973a:	1c42      	adds	r2, r0, #1
   8973c:	2300      	movs	r3, #0
   8973e:	e002      	b.n	89746 <memchr+0x4a>
   89740:	7804      	ldrb	r4, [r0, #0]
   89742:	428c      	cmp	r4, r1
   89744:	d007      	beq.n	89756 <memchr+0x5a>
   89746:	42ab      	cmp	r3, r5
   89748:	4610      	mov	r0, r2
   8974a:	f103 0301 	add.w	r3, r3, #1
   8974e:	f102 0201 	add.w	r2, r2, #1
   89752:	d1f5      	bne.n	89740 <memchr+0x44>
   89754:	2000      	movs	r0, #0
   89756:	bc70      	pop	{r4, r5, r6}
   89758:	4770      	bx	lr
   8975a:	ea41 2601 	orr.w	r6, r1, r1, lsl #8
   8975e:	4603      	mov	r3, r0
   89760:	ea46 4606 	orr.w	r6, r6, r6, lsl #16
   89764:	681a      	ldr	r2, [r3, #0]
   89766:	4618      	mov	r0, r3
   89768:	4072      	eors	r2, r6
   8976a:	f1a2 3501 	sub.w	r5, r2, #16843009	; 0x1010101
   8976e:	ea25 0202 	bic.w	r2, r5, r2
   89772:	f012 3f80 	tst.w	r2, #2155905152	; 0x80808080
   89776:	f103 0304 	add.w	r3, r3, #4
   8977a:	d1d9      	bne.n	89730 <memchr+0x34>
   8977c:	3c04      	subs	r4, #4
   8977e:	2c03      	cmp	r4, #3
   89780:	4618      	mov	r0, r3
   89782:	d8ef      	bhi.n	89764 <memchr+0x68>
   89784:	e7d4      	b.n	89730 <memchr+0x34>
   89786:	4614      	mov	r4, r2
   89788:	e7d0      	b.n	8972c <memchr+0x30>
   8978a:	4620      	mov	r0, r4
   8978c:	e7e3      	b.n	89756 <memchr+0x5a>
   8978e:	bf00      	nop

00089790 <memmove>:
   89790:	4288      	cmp	r0, r1
   89792:	b4f0      	push	{r4, r5, r6, r7}
   89794:	d910      	bls.n	897b8 <memmove+0x28>
   89796:	188c      	adds	r4, r1, r2
   89798:	42a0      	cmp	r0, r4
   8979a:	d20d      	bcs.n	897b8 <memmove+0x28>
   8979c:	1885      	adds	r5, r0, r2
   8979e:	1e53      	subs	r3, r2, #1
   897a0:	b142      	cbz	r2, 897b4 <memmove+0x24>
   897a2:	4621      	mov	r1, r4
   897a4:	462a      	mov	r2, r5
   897a6:	f811 4d01 	ldrb.w	r4, [r1, #-1]!
   897aa:	3b01      	subs	r3, #1
   897ac:	f802 4d01 	strb.w	r4, [r2, #-1]!
   897b0:	1c5c      	adds	r4, r3, #1
   897b2:	d1f8      	bne.n	897a6 <memmove+0x16>
   897b4:	bcf0      	pop	{r4, r5, r6, r7}
   897b6:	4770      	bx	lr
   897b8:	2a0f      	cmp	r2, #15
   897ba:	d944      	bls.n	89846 <memmove+0xb6>
   897bc:	ea40 0301 	orr.w	r3, r0, r1
   897c0:	079b      	lsls	r3, r3, #30
   897c2:	d144      	bne.n	8984e <memmove+0xbe>
   897c4:	f1a2 0710 	sub.w	r7, r2, #16
   897c8:	093f      	lsrs	r7, r7, #4
   897ca:	eb00 1607 	add.w	r6, r0, r7, lsl #4
   897ce:	3610      	adds	r6, #16
   897d0:	460c      	mov	r4, r1
   897d2:	4603      	mov	r3, r0
   897d4:	6825      	ldr	r5, [r4, #0]
   897d6:	3310      	adds	r3, #16
   897d8:	f843 5c10 	str.w	r5, [r3, #-16]
   897dc:	6865      	ldr	r5, [r4, #4]
   897de:	3410      	adds	r4, #16
   897e0:	f843 5c0c 	str.w	r5, [r3, #-12]
   897e4:	f854 5c08 	ldr.w	r5, [r4, #-8]
   897e8:	f843 5c08 	str.w	r5, [r3, #-8]
   897ec:	f854 5c04 	ldr.w	r5, [r4, #-4]
   897f0:	f843 5c04 	str.w	r5, [r3, #-4]
   897f4:	42b3      	cmp	r3, r6
   897f6:	d1ed      	bne.n	897d4 <memmove+0x44>
   897f8:	1c7b      	adds	r3, r7, #1
   897fa:	f002 0c0f 	and.w	ip, r2, #15
   897fe:	011b      	lsls	r3, r3, #4
   89800:	f1bc 0f03 	cmp.w	ip, #3
   89804:	4419      	add	r1, r3
   89806:	4403      	add	r3, r0
   89808:	d923      	bls.n	89852 <memmove+0xc2>
   8980a:	460e      	mov	r6, r1
   8980c:	461d      	mov	r5, r3
   8980e:	4664      	mov	r4, ip
   89810:	f856 7b04 	ldr.w	r7, [r6], #4
   89814:	3c04      	subs	r4, #4
   89816:	2c03      	cmp	r4, #3
   89818:	f845 7b04 	str.w	r7, [r5], #4
   8981c:	d8f8      	bhi.n	89810 <memmove+0x80>
   8981e:	f1ac 0404 	sub.w	r4, ip, #4
   89822:	f024 0403 	bic.w	r4, r4, #3
   89826:	3404      	adds	r4, #4
   89828:	f002 0203 	and.w	r2, r2, #3
   8982c:	4423      	add	r3, r4
   8982e:	4421      	add	r1, r4
   89830:	2a00      	cmp	r2, #0
   89832:	d0bf      	beq.n	897b4 <memmove+0x24>
   89834:	441a      	add	r2, r3
   89836:	f811 4b01 	ldrb.w	r4, [r1], #1
   8983a:	f803 4b01 	strb.w	r4, [r3], #1
   8983e:	4293      	cmp	r3, r2
   89840:	d1f9      	bne.n	89836 <memmove+0xa6>
   89842:	bcf0      	pop	{r4, r5, r6, r7}
   89844:	4770      	bx	lr
   89846:	4603      	mov	r3, r0
   89848:	2a00      	cmp	r2, #0
   8984a:	d1f3      	bne.n	89834 <memmove+0xa4>
   8984c:	e7b2      	b.n	897b4 <memmove+0x24>
   8984e:	4603      	mov	r3, r0
   89850:	e7f0      	b.n	89834 <memmove+0xa4>
   89852:	4662      	mov	r2, ip
   89854:	2a00      	cmp	r2, #0
   89856:	d1ed      	bne.n	89834 <memmove+0xa4>
   89858:	e7ac      	b.n	897b4 <memmove+0x24>
   8985a:	bf00      	nop

0008985c <__malloc_lock>:
   8985c:	4770      	bx	lr
   8985e:	bf00      	nop

00089860 <__malloc_unlock>:
   89860:	4770      	bx	lr
   89862:	bf00      	nop

00089864 <_Balloc>:
   89864:	6cc2      	ldr	r2, [r0, #76]	; 0x4c
   89866:	b570      	push	{r4, r5, r6, lr}
   89868:	4605      	mov	r5, r0
   8986a:	460c      	mov	r4, r1
   8986c:	b14a      	cbz	r2, 89882 <_Balloc+0x1e>
   8986e:	f852 0024 	ldr.w	r0, [r2, r4, lsl #2]
   89872:	b180      	cbz	r0, 89896 <_Balloc+0x32>
   89874:	6801      	ldr	r1, [r0, #0]
   89876:	f842 1024 	str.w	r1, [r2, r4, lsl #2]
   8987a:	2200      	movs	r2, #0
   8987c:	6102      	str	r2, [r0, #16]
   8987e:	60c2      	str	r2, [r0, #12]
   89880:	bd70      	pop	{r4, r5, r6, pc}
   89882:	2221      	movs	r2, #33	; 0x21
   89884:	2104      	movs	r1, #4
   89886:	f000 fde5 	bl	8a454 <_calloc_r>
   8988a:	64e8      	str	r0, [r5, #76]	; 0x4c
   8988c:	4602      	mov	r2, r0
   8988e:	2800      	cmp	r0, #0
   89890:	d1ed      	bne.n	8986e <_Balloc+0xa>
   89892:	2000      	movs	r0, #0
   89894:	bd70      	pop	{r4, r5, r6, pc}
   89896:	2101      	movs	r1, #1
   89898:	fa01 f604 	lsl.w	r6, r1, r4
   8989c:	1d72      	adds	r2, r6, #5
   8989e:	4628      	mov	r0, r5
   898a0:	0092      	lsls	r2, r2, #2
   898a2:	f000 fdd7 	bl	8a454 <_calloc_r>
   898a6:	2800      	cmp	r0, #0
   898a8:	d0f3      	beq.n	89892 <_Balloc+0x2e>
   898aa:	6044      	str	r4, [r0, #4]
   898ac:	6086      	str	r6, [r0, #8]
   898ae:	e7e4      	b.n	8987a <_Balloc+0x16>

000898b0 <_Bfree>:
   898b0:	b131      	cbz	r1, 898c0 <_Bfree+0x10>
   898b2:	6cc3      	ldr	r3, [r0, #76]	; 0x4c
   898b4:	684a      	ldr	r2, [r1, #4]
   898b6:	f853 0022 	ldr.w	r0, [r3, r2, lsl #2]
   898ba:	6008      	str	r0, [r1, #0]
   898bc:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
   898c0:	4770      	bx	lr
   898c2:	bf00      	nop

000898c4 <__multadd>:
   898c4:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
   898c8:	690f      	ldr	r7, [r1, #16]
   898ca:	b083      	sub	sp, #12
   898cc:	4688      	mov	r8, r1
   898ce:	4681      	mov	r9, r0
   898d0:	f101 0514 	add.w	r5, r1, #20
   898d4:	2400      	movs	r4, #0
   898d6:	682e      	ldr	r6, [r5, #0]
   898d8:	3401      	adds	r4, #1
   898da:	b2b1      	uxth	r1, r6
   898dc:	0c36      	lsrs	r6, r6, #16
   898de:	fb02 3301 	mla	r3, r2, r1, r3
   898e2:	fb02 f606 	mul.w	r6, r2, r6
   898e6:	b299      	uxth	r1, r3
   898e8:	eb06 4313 	add.w	r3, r6, r3, lsr #16
   898ec:	eb01 4103 	add.w	r1, r1, r3, lsl #16
   898f0:	42a7      	cmp	r7, r4
   898f2:	f845 1b04 	str.w	r1, [r5], #4
   898f6:	ea4f 4313 	mov.w	r3, r3, lsr #16
   898fa:	dcec      	bgt.n	898d6 <__multadd+0x12>
   898fc:	b14b      	cbz	r3, 89912 <__multadd+0x4e>
   898fe:	f8d8 2008 	ldr.w	r2, [r8, #8]
   89902:	4297      	cmp	r7, r2
   89904:	da09      	bge.n	8991a <__multadd+0x56>
   89906:	eb08 0287 	add.w	r2, r8, r7, lsl #2
   8990a:	3701      	adds	r7, #1
   8990c:	6153      	str	r3, [r2, #20]
   8990e:	f8c8 7010 	str.w	r7, [r8, #16]
   89912:	4640      	mov	r0, r8
   89914:	b003      	add	sp, #12
   89916:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
   8991a:	f8d8 1004 	ldr.w	r1, [r8, #4]
   8991e:	4648      	mov	r0, r9
   89920:	3101      	adds	r1, #1
   89922:	9301      	str	r3, [sp, #4]
   89924:	f7ff ff9e 	bl	89864 <_Balloc>
   89928:	f8d8 2010 	ldr.w	r2, [r8, #16]
   8992c:	f108 010c 	add.w	r1, r8, #12
   89930:	3202      	adds	r2, #2
   89932:	4604      	mov	r4, r0
   89934:	0092      	lsls	r2, r2, #2
   89936:	300c      	adds	r0, #12
   89938:	f7fc fccc 	bl	862d4 <memcpy>
   8993c:	f8d9 204c 	ldr.w	r2, [r9, #76]	; 0x4c
   89940:	f8d8 1004 	ldr.w	r1, [r8, #4]
   89944:	9b01      	ldr	r3, [sp, #4]
   89946:	f852 0021 	ldr.w	r0, [r2, r1, lsl #2]
   8994a:	f8c8 0000 	str.w	r0, [r8]
   8994e:	f842 8021 	str.w	r8, [r2, r1, lsl #2]
   89952:	46a0      	mov	r8, r4
   89954:	e7d7      	b.n	89906 <__multadd+0x42>
   89956:	bf00      	nop

00089958 <__hi0bits>:
   89958:	0c03      	lsrs	r3, r0, #16
   8995a:	041b      	lsls	r3, r3, #16
   8995c:	b9b3      	cbnz	r3, 8998c <__hi0bits+0x34>
   8995e:	0400      	lsls	r0, r0, #16
   89960:	2310      	movs	r3, #16
   89962:	f010 4f7f 	tst.w	r0, #4278190080	; 0xff000000
   89966:	bf04      	itt	eq
   89968:	0200      	lsleq	r0, r0, #8
   8996a:	3308      	addeq	r3, #8
   8996c:	f010 4f70 	tst.w	r0, #4026531840	; 0xf0000000
   89970:	bf04      	itt	eq
   89972:	0100      	lsleq	r0, r0, #4
   89974:	3304      	addeq	r3, #4
   89976:	f010 4f40 	tst.w	r0, #3221225472	; 0xc0000000
   8997a:	bf04      	itt	eq
   8997c:	0080      	lsleq	r0, r0, #2
   8997e:	3302      	addeq	r3, #2
   89980:	2800      	cmp	r0, #0
   89982:	db07      	blt.n	89994 <__hi0bits+0x3c>
   89984:	0042      	lsls	r2, r0, #1
   89986:	d403      	bmi.n	89990 <__hi0bits+0x38>
   89988:	2020      	movs	r0, #32
   8998a:	4770      	bx	lr
   8998c:	2300      	movs	r3, #0
   8998e:	e7e8      	b.n	89962 <__hi0bits+0xa>
   89990:	1c58      	adds	r0, r3, #1
   89992:	4770      	bx	lr
   89994:	4618      	mov	r0, r3
   89996:	4770      	bx	lr

00089998 <__lo0bits>:
   89998:	6803      	ldr	r3, [r0, #0]
   8999a:	f013 0207 	ands.w	r2, r3, #7
   8999e:	d007      	beq.n	899b0 <__lo0bits+0x18>
   899a0:	07d9      	lsls	r1, r3, #31
   899a2:	d420      	bmi.n	899e6 <__lo0bits+0x4e>
   899a4:	079a      	lsls	r2, r3, #30
   899a6:	d420      	bmi.n	899ea <__lo0bits+0x52>
   899a8:	089b      	lsrs	r3, r3, #2
   899aa:	6003      	str	r3, [r0, #0]
   899ac:	2002      	movs	r0, #2
   899ae:	4770      	bx	lr
   899b0:	b299      	uxth	r1, r3
   899b2:	b909      	cbnz	r1, 899b8 <__lo0bits+0x20>
   899b4:	0c1b      	lsrs	r3, r3, #16
   899b6:	2210      	movs	r2, #16
   899b8:	f013 0fff 	tst.w	r3, #255	; 0xff
   899bc:	bf04      	itt	eq
   899be:	0a1b      	lsreq	r3, r3, #8
   899c0:	3208      	addeq	r2, #8
   899c2:	0719      	lsls	r1, r3, #28
   899c4:	bf04      	itt	eq
   899c6:	091b      	lsreq	r3, r3, #4
   899c8:	3204      	addeq	r2, #4
   899ca:	0799      	lsls	r1, r3, #30
   899cc:	bf04      	itt	eq
   899ce:	089b      	lsreq	r3, r3, #2
   899d0:	3202      	addeq	r2, #2
   899d2:	07d9      	lsls	r1, r3, #31
   899d4:	d404      	bmi.n	899e0 <__lo0bits+0x48>
   899d6:	085b      	lsrs	r3, r3, #1
   899d8:	d101      	bne.n	899de <__lo0bits+0x46>
   899da:	2020      	movs	r0, #32
   899dc:	4770      	bx	lr
   899de:	3201      	adds	r2, #1
   899e0:	6003      	str	r3, [r0, #0]
   899e2:	4610      	mov	r0, r2
   899e4:	4770      	bx	lr
   899e6:	2000      	movs	r0, #0
   899e8:	4770      	bx	lr
   899ea:	085b      	lsrs	r3, r3, #1
   899ec:	6003      	str	r3, [r0, #0]
   899ee:	2001      	movs	r0, #1
   899f0:	4770      	bx	lr
   899f2:	bf00      	nop

000899f4 <__i2b>:
   899f4:	b510      	push	{r4, lr}
   899f6:	460c      	mov	r4, r1
   899f8:	2101      	movs	r1, #1
   899fa:	f7ff ff33 	bl	89864 <_Balloc>
   899fe:	2201      	movs	r2, #1
   89a00:	6144      	str	r4, [r0, #20]
   89a02:	6102      	str	r2, [r0, #16]
   89a04:	bd10      	pop	{r4, pc}
   89a06:	bf00      	nop

00089a08 <__multiply>:
   89a08:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   89a0c:	690d      	ldr	r5, [r1, #16]
   89a0e:	f8d2 9010 	ldr.w	r9, [r2, #16]
   89a12:	b085      	sub	sp, #20
   89a14:	454d      	cmp	r5, r9
   89a16:	460c      	mov	r4, r1
   89a18:	4692      	mov	sl, r2
   89a1a:	da04      	bge.n	89a26 <__multiply+0x1e>
   89a1c:	462a      	mov	r2, r5
   89a1e:	4654      	mov	r4, sl
   89a20:	464d      	mov	r5, r9
   89a22:	468a      	mov	sl, r1
   89a24:	4691      	mov	r9, r2
   89a26:	68a3      	ldr	r3, [r4, #8]
   89a28:	eb05 0709 	add.w	r7, r5, r9
   89a2c:	6861      	ldr	r1, [r4, #4]
   89a2e:	429f      	cmp	r7, r3
   89a30:	bfc8      	it	gt
   89a32:	3101      	addgt	r1, #1
   89a34:	f7ff ff16 	bl	89864 <_Balloc>
   89a38:	f100 0614 	add.w	r6, r0, #20
   89a3c:	eb06 0887 	add.w	r8, r6, r7, lsl #2
   89a40:	4546      	cmp	r6, r8
   89a42:	9001      	str	r0, [sp, #4]
   89a44:	d205      	bcs.n	89a52 <__multiply+0x4a>
   89a46:	4633      	mov	r3, r6
   89a48:	2000      	movs	r0, #0
   89a4a:	f843 0b04 	str.w	r0, [r3], #4
   89a4e:	4598      	cmp	r8, r3
   89a50:	d8fb      	bhi.n	89a4a <__multiply+0x42>
   89a52:	f10a 0c14 	add.w	ip, sl, #20
   89a56:	eb0c 0989 	add.w	r9, ip, r9, lsl #2
   89a5a:	3414      	adds	r4, #20
   89a5c:	45cc      	cmp	ip, r9
   89a5e:	9400      	str	r4, [sp, #0]
   89a60:	eb04 0585 	add.w	r5, r4, r5, lsl #2
   89a64:	d25b      	bcs.n	89b1e <__multiply+0x116>
   89a66:	f8cd 8008 	str.w	r8, [sp, #8]
   89a6a:	9703      	str	r7, [sp, #12]
   89a6c:	46c8      	mov	r8, r9
   89a6e:	f85c 3b04 	ldr.w	r3, [ip], #4
   89a72:	b29c      	uxth	r4, r3
   89a74:	b324      	cbz	r4, 89ac0 <__multiply+0xb8>
   89a76:	9a00      	ldr	r2, [sp, #0]
   89a78:	4633      	mov	r3, r6
   89a7a:	f04f 0900 	mov.w	r9, #0
   89a7e:	e000      	b.n	89a82 <__multiply+0x7a>
   89a80:	460b      	mov	r3, r1
   89a82:	f852 7b04 	ldr.w	r7, [r2], #4
   89a86:	6819      	ldr	r1, [r3, #0]
   89a88:	fa1f fb87 	uxth.w	fp, r7
   89a8c:	fa1f fa81 	uxth.w	sl, r1
   89a90:	0c38      	lsrs	r0, r7, #16
   89a92:	0c09      	lsrs	r1, r1, #16
   89a94:	fb04 aa0b 	mla	sl, r4, fp, sl
   89a98:	fb04 1000 	mla	r0, r4, r0, r1
   89a9c:	44d1      	add	r9, sl
   89a9e:	eb00 4019 	add.w	r0, r0, r9, lsr #16
   89aa2:	fa1f f989 	uxth.w	r9, r9
   89aa6:	ea49 4700 	orr.w	r7, r9, r0, lsl #16
   89aaa:	4619      	mov	r1, r3
   89aac:	4295      	cmp	r5, r2
   89aae:	ea4f 4910 	mov.w	r9, r0, lsr #16
   89ab2:	f841 7b04 	str.w	r7, [r1], #4
   89ab6:	d8e3      	bhi.n	89a80 <__multiply+0x78>
   89ab8:	f8c3 9004 	str.w	r9, [r3, #4]
   89abc:	f85c 3c04 	ldr.w	r3, [ip, #-4]
   89ac0:	ea5f 4913 	movs.w	r9, r3, lsr #16
   89ac4:	d024      	beq.n	89b10 <__multiply+0x108>
   89ac6:	f8d6 a000 	ldr.w	sl, [r6]
   89aca:	9b00      	ldr	r3, [sp, #0]
   89acc:	4650      	mov	r0, sl
   89ace:	4631      	mov	r1, r6
   89ad0:	f04f 0b00 	mov.w	fp, #0
   89ad4:	e000      	b.n	89ad8 <__multiply+0xd0>
   89ad6:	4611      	mov	r1, r2
   89ad8:	881a      	ldrh	r2, [r3, #0]
   89ada:	0c00      	lsrs	r0, r0, #16
   89adc:	fb09 0002 	mla	r0, r9, r2, r0
   89ae0:	fa1f fa8a 	uxth.w	sl, sl
   89ae4:	4483      	add	fp, r0
   89ae6:	ea4a 400b 	orr.w	r0, sl, fp, lsl #16
   89aea:	460a      	mov	r2, r1
   89aec:	f842 0b04 	str.w	r0, [r2], #4
   89af0:	f853 7b04 	ldr.w	r7, [r3], #4
   89af4:	6848      	ldr	r0, [r1, #4]
   89af6:	ea4f 4a17 	mov.w	sl, r7, lsr #16
   89afa:	b284      	uxth	r4, r0
   89afc:	fb09 4a0a 	mla	sl, r9, sl, r4
   89b00:	429d      	cmp	r5, r3
   89b02:	eb0a 4a1b 	add.w	sl, sl, fp, lsr #16
   89b06:	ea4f 4b1a 	mov.w	fp, sl, lsr #16
   89b0a:	d8e4      	bhi.n	89ad6 <__multiply+0xce>
   89b0c:	f8c1 a004 	str.w	sl, [r1, #4]
   89b10:	45e0      	cmp	r8, ip
   89b12:	f106 0604 	add.w	r6, r6, #4
   89b16:	d8aa      	bhi.n	89a6e <__multiply+0x66>
   89b18:	f8dd 8008 	ldr.w	r8, [sp, #8]
   89b1c:	9f03      	ldr	r7, [sp, #12]
   89b1e:	2f00      	cmp	r7, #0
   89b20:	dd0a      	ble.n	89b38 <__multiply+0x130>
   89b22:	f858 3c04 	ldr.w	r3, [r8, #-4]
   89b26:	f1a8 0804 	sub.w	r8, r8, #4
   89b2a:	b11b      	cbz	r3, 89b34 <__multiply+0x12c>
   89b2c:	e004      	b.n	89b38 <__multiply+0x130>
   89b2e:	f858 3d04 	ldr.w	r3, [r8, #-4]!
   89b32:	b90b      	cbnz	r3, 89b38 <__multiply+0x130>
   89b34:	3f01      	subs	r7, #1
   89b36:	d1fa      	bne.n	89b2e <__multiply+0x126>
   89b38:	9b01      	ldr	r3, [sp, #4]
   89b3a:	4618      	mov	r0, r3
   89b3c:	611f      	str	r7, [r3, #16]
   89b3e:	b005      	add	sp, #20
   89b40:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

00089b44 <__pow5mult>:
   89b44:	f012 0303 	ands.w	r3, r2, #3
   89b48:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   89b4c:	4614      	mov	r4, r2
   89b4e:	4607      	mov	r7, r0
   89b50:	460e      	mov	r6, r1
   89b52:	d12c      	bne.n	89bae <__pow5mult+0x6a>
   89b54:	10a4      	asrs	r4, r4, #2
   89b56:	d01c      	beq.n	89b92 <__pow5mult+0x4e>
   89b58:	6cbd      	ldr	r5, [r7, #72]	; 0x48
   89b5a:	2d00      	cmp	r5, #0
   89b5c:	d030      	beq.n	89bc0 <__pow5mult+0x7c>
   89b5e:	f04f 0800 	mov.w	r8, #0
   89b62:	e004      	b.n	89b6e <__pow5mult+0x2a>
   89b64:	1064      	asrs	r4, r4, #1
   89b66:	d014      	beq.n	89b92 <__pow5mult+0x4e>
   89b68:	6828      	ldr	r0, [r5, #0]
   89b6a:	b1a8      	cbz	r0, 89b98 <__pow5mult+0x54>
   89b6c:	4605      	mov	r5, r0
   89b6e:	07e3      	lsls	r3, r4, #31
   89b70:	d5f8      	bpl.n	89b64 <__pow5mult+0x20>
   89b72:	4638      	mov	r0, r7
   89b74:	4631      	mov	r1, r6
   89b76:	462a      	mov	r2, r5
   89b78:	f7ff ff46 	bl	89a08 <__multiply>
   89b7c:	b1ae      	cbz	r6, 89baa <__pow5mult+0x66>
   89b7e:	6872      	ldr	r2, [r6, #4]
   89b80:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
   89b82:	1064      	asrs	r4, r4, #1
   89b84:	f853 1022 	ldr.w	r1, [r3, r2, lsl #2]
   89b88:	6031      	str	r1, [r6, #0]
   89b8a:	f843 6022 	str.w	r6, [r3, r2, lsl #2]
   89b8e:	4606      	mov	r6, r0
   89b90:	d1ea      	bne.n	89b68 <__pow5mult+0x24>
   89b92:	4630      	mov	r0, r6
   89b94:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   89b98:	4638      	mov	r0, r7
   89b9a:	4629      	mov	r1, r5
   89b9c:	462a      	mov	r2, r5
   89b9e:	f7ff ff33 	bl	89a08 <__multiply>
   89ba2:	6028      	str	r0, [r5, #0]
   89ba4:	f8c0 8000 	str.w	r8, [r0]
   89ba8:	e7e0      	b.n	89b6c <__pow5mult+0x28>
   89baa:	4606      	mov	r6, r0
   89bac:	e7da      	b.n	89b64 <__pow5mult+0x20>
   89bae:	4a0b      	ldr	r2, [pc, #44]	; (89bdc <__pow5mult+0x98>)
   89bb0:	3b01      	subs	r3, #1
   89bb2:	f852 2023 	ldr.w	r2, [r2, r3, lsl #2]
   89bb6:	2300      	movs	r3, #0
   89bb8:	f7ff fe84 	bl	898c4 <__multadd>
   89bbc:	4606      	mov	r6, r0
   89bbe:	e7c9      	b.n	89b54 <__pow5mult+0x10>
   89bc0:	2101      	movs	r1, #1
   89bc2:	4638      	mov	r0, r7
   89bc4:	f7ff fe4e 	bl	89864 <_Balloc>
   89bc8:	f240 2171 	movw	r1, #625	; 0x271
   89bcc:	2201      	movs	r2, #1
   89bce:	2300      	movs	r3, #0
   89bd0:	6141      	str	r1, [r0, #20]
   89bd2:	6102      	str	r2, [r0, #16]
   89bd4:	4605      	mov	r5, r0
   89bd6:	64b8      	str	r0, [r7, #72]	; 0x48
   89bd8:	6003      	str	r3, [r0, #0]
   89bda:	e7c0      	b.n	89b5e <__pow5mult+0x1a>
   89bdc:	0008ce88 	.word	0x0008ce88

00089be0 <__lshift>:
   89be0:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
   89be4:	690b      	ldr	r3, [r1, #16]
   89be6:	ea4f 1a62 	mov.w	sl, r2, asr #5
   89bea:	eb0a 0903 	add.w	r9, sl, r3
   89bee:	688b      	ldr	r3, [r1, #8]
   89bf0:	f109 0601 	add.w	r6, r9, #1
   89bf4:	429e      	cmp	r6, r3
   89bf6:	460f      	mov	r7, r1
   89bf8:	4693      	mov	fp, r2
   89bfa:	4680      	mov	r8, r0
   89bfc:	6849      	ldr	r1, [r1, #4]
   89bfe:	dd04      	ble.n	89c0a <__lshift+0x2a>
   89c00:	005b      	lsls	r3, r3, #1
   89c02:	429e      	cmp	r6, r3
   89c04:	f101 0101 	add.w	r1, r1, #1
   89c08:	dcfa      	bgt.n	89c00 <__lshift+0x20>
   89c0a:	4640      	mov	r0, r8
   89c0c:	f7ff fe2a 	bl	89864 <_Balloc>
   89c10:	f1ba 0f00 	cmp.w	sl, #0
   89c14:	f100 0414 	add.w	r4, r0, #20
   89c18:	dd09      	ble.n	89c2e <__lshift+0x4e>
   89c1a:	2300      	movs	r3, #0
   89c1c:	461a      	mov	r2, r3
   89c1e:	4625      	mov	r5, r4
   89c20:	3301      	adds	r3, #1
   89c22:	4553      	cmp	r3, sl
   89c24:	f845 2b04 	str.w	r2, [r5], #4
   89c28:	d1fa      	bne.n	89c20 <__lshift+0x40>
   89c2a:	eb04 0483 	add.w	r4, r4, r3, lsl #2
   89c2e:	693a      	ldr	r2, [r7, #16]
   89c30:	f107 0314 	add.w	r3, r7, #20
   89c34:	f01b 0b1f 	ands.w	fp, fp, #31
   89c38:	eb03 0c82 	add.w	ip, r3, r2, lsl #2
   89c3c:	d021      	beq.n	89c82 <__lshift+0xa2>
   89c3e:	f1cb 0a20 	rsb	sl, fp, #32
   89c42:	2200      	movs	r2, #0
   89c44:	e000      	b.n	89c48 <__lshift+0x68>
   89c46:	462c      	mov	r4, r5
   89c48:	6819      	ldr	r1, [r3, #0]
   89c4a:	4625      	mov	r5, r4
   89c4c:	fa01 f10b 	lsl.w	r1, r1, fp
   89c50:	430a      	orrs	r2, r1
   89c52:	f845 2b04 	str.w	r2, [r5], #4
   89c56:	f853 2b04 	ldr.w	r2, [r3], #4
   89c5a:	4563      	cmp	r3, ip
   89c5c:	fa22 f20a 	lsr.w	r2, r2, sl
   89c60:	d3f1      	bcc.n	89c46 <__lshift+0x66>
   89c62:	6062      	str	r2, [r4, #4]
   89c64:	b10a      	cbz	r2, 89c6a <__lshift+0x8a>
   89c66:	f109 0602 	add.w	r6, r9, #2
   89c6a:	f8d8 304c 	ldr.w	r3, [r8, #76]	; 0x4c
   89c6e:	687a      	ldr	r2, [r7, #4]
   89c70:	3e01      	subs	r6, #1
   89c72:	f853 1022 	ldr.w	r1, [r3, r2, lsl #2]
   89c76:	6106      	str	r6, [r0, #16]
   89c78:	6039      	str	r1, [r7, #0]
   89c7a:	f843 7022 	str.w	r7, [r3, r2, lsl #2]
   89c7e:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
   89c82:	f853 2b04 	ldr.w	r2, [r3], #4
   89c86:	459c      	cmp	ip, r3
   89c88:	f844 2b04 	str.w	r2, [r4], #4
   89c8c:	d9ed      	bls.n	89c6a <__lshift+0x8a>
   89c8e:	f853 2b04 	ldr.w	r2, [r3], #4
   89c92:	459c      	cmp	ip, r3
   89c94:	f844 2b04 	str.w	r2, [r4], #4
   89c98:	d8f3      	bhi.n	89c82 <__lshift+0xa2>
   89c9a:	e7e6      	b.n	89c6a <__lshift+0x8a>

00089c9c <__mcmp>:
   89c9c:	6902      	ldr	r2, [r0, #16]
   89c9e:	690b      	ldr	r3, [r1, #16]
   89ca0:	b410      	push	{r4}
   89ca2:	1ad2      	subs	r2, r2, r3
   89ca4:	d115      	bne.n	89cd2 <__mcmp+0x36>
   89ca6:	009b      	lsls	r3, r3, #2
   89ca8:	3014      	adds	r0, #20
   89caa:	3114      	adds	r1, #20
   89cac:	4419      	add	r1, r3
   89cae:	4403      	add	r3, r0
   89cb0:	e001      	b.n	89cb6 <__mcmp+0x1a>
   89cb2:	4298      	cmp	r0, r3
   89cb4:	d211      	bcs.n	89cda <__mcmp+0x3e>
   89cb6:	f853 2d04 	ldr.w	r2, [r3, #-4]!
   89cba:	f851 4d04 	ldr.w	r4, [r1, #-4]!
   89cbe:	42a2      	cmp	r2, r4
   89cc0:	d0f7      	beq.n	89cb2 <__mcmp+0x16>
   89cc2:	4294      	cmp	r4, r2
   89cc4:	bf94      	ite	ls
   89cc6:	2001      	movls	r0, #1
   89cc8:	f04f 30ff 	movhi.w	r0, #4294967295
   89ccc:	f85d 4b04 	ldr.w	r4, [sp], #4
   89cd0:	4770      	bx	lr
   89cd2:	4610      	mov	r0, r2
   89cd4:	f85d 4b04 	ldr.w	r4, [sp], #4
   89cd8:	4770      	bx	lr
   89cda:	2000      	movs	r0, #0
   89cdc:	f85d 4b04 	ldr.w	r4, [sp], #4
   89ce0:	4770      	bx	lr
   89ce2:	bf00      	nop

00089ce4 <__mdiff>:
   89ce4:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
   89ce8:	460d      	mov	r5, r1
   89cea:	4604      	mov	r4, r0
   89cec:	4611      	mov	r1, r2
   89cee:	4628      	mov	r0, r5
   89cf0:	4616      	mov	r6, r2
   89cf2:	f7ff ffd3 	bl	89c9c <__mcmp>
   89cf6:	1e07      	subs	r7, r0, #0
   89cf8:	d056      	beq.n	89da8 <__mdiff+0xc4>
   89cfa:	db4f      	blt.n	89d9c <__mdiff+0xb8>
   89cfc:	f04f 0900 	mov.w	r9, #0
   89d00:	6869      	ldr	r1, [r5, #4]
   89d02:	4620      	mov	r0, r4
   89d04:	f7ff fdae 	bl	89864 <_Balloc>
   89d08:	692f      	ldr	r7, [r5, #16]
   89d0a:	6932      	ldr	r2, [r6, #16]
   89d0c:	3514      	adds	r5, #20
   89d0e:	3614      	adds	r6, #20
   89d10:	f8c0 900c 	str.w	r9, [r0, #12]
   89d14:	f100 0314 	add.w	r3, r0, #20
   89d18:	eb05 0c87 	add.w	ip, r5, r7, lsl #2
   89d1c:	eb06 0882 	add.w	r8, r6, r2, lsl #2
   89d20:	2100      	movs	r1, #0
   89d22:	f855 4b04 	ldr.w	r4, [r5], #4
   89d26:	f856 2b04 	ldr.w	r2, [r6], #4
   89d2a:	fa1f fa84 	uxth.w	sl, r4
   89d2e:	448a      	add	sl, r1
   89d30:	fa1f f982 	uxth.w	r9, r2
   89d34:	0c11      	lsrs	r1, r2, #16
   89d36:	ebc1 4114 	rsb	r1, r1, r4, lsr #16
   89d3a:	ebc9 020a 	rsb	r2, r9, sl
   89d3e:	eb01 4122 	add.w	r1, r1, r2, asr #16
   89d42:	b292      	uxth	r2, r2
   89d44:	ea42 4201 	orr.w	r2, r2, r1, lsl #16
   89d48:	45b0      	cmp	r8, r6
   89d4a:	f843 2b04 	str.w	r2, [r3], #4
   89d4e:	ea4f 4121 	mov.w	r1, r1, asr #16
   89d52:	462c      	mov	r4, r5
   89d54:	d8e5      	bhi.n	89d22 <__mdiff+0x3e>
   89d56:	45ac      	cmp	ip, r5
   89d58:	4698      	mov	r8, r3
   89d5a:	d915      	bls.n	89d88 <__mdiff+0xa4>
   89d5c:	f854 6b04 	ldr.w	r6, [r4], #4
   89d60:	b2b2      	uxth	r2, r6
   89d62:	4411      	add	r1, r2
   89d64:	0c36      	lsrs	r6, r6, #16
   89d66:	eb06 4621 	add.w	r6, r6, r1, asr #16
   89d6a:	b289      	uxth	r1, r1
   89d6c:	ea41 4206 	orr.w	r2, r1, r6, lsl #16
   89d70:	45a4      	cmp	ip, r4
   89d72:	f843 2b04 	str.w	r2, [r3], #4
   89d76:	ea4f 4126 	mov.w	r1, r6, asr #16
   89d7a:	d8ef      	bhi.n	89d5c <__mdiff+0x78>
   89d7c:	43eb      	mvns	r3, r5
   89d7e:	4463      	add	r3, ip
   89d80:	f023 0303 	bic.w	r3, r3, #3
   89d84:	3304      	adds	r3, #4
   89d86:	4443      	add	r3, r8
   89d88:	3b04      	subs	r3, #4
   89d8a:	b922      	cbnz	r2, 89d96 <__mdiff+0xb2>
   89d8c:	f853 2d04 	ldr.w	r2, [r3, #-4]!
   89d90:	3f01      	subs	r7, #1
   89d92:	2a00      	cmp	r2, #0
   89d94:	d0fa      	beq.n	89d8c <__mdiff+0xa8>
   89d96:	6107      	str	r7, [r0, #16]
   89d98:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
   89d9c:	462b      	mov	r3, r5
   89d9e:	f04f 0901 	mov.w	r9, #1
   89da2:	4635      	mov	r5, r6
   89da4:	461e      	mov	r6, r3
   89da6:	e7ab      	b.n	89d00 <__mdiff+0x1c>
   89da8:	4620      	mov	r0, r4
   89daa:	4639      	mov	r1, r7
   89dac:	f7ff fd5a 	bl	89864 <_Balloc>
   89db0:	2301      	movs	r3, #1
   89db2:	6147      	str	r7, [r0, #20]
   89db4:	6103      	str	r3, [r0, #16]
   89db6:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
   89dba:	bf00      	nop

00089dbc <__d2b>:
   89dbc:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
   89dc0:	2101      	movs	r1, #1
   89dc2:	b083      	sub	sp, #12
   89dc4:	461d      	mov	r5, r3
   89dc6:	f3c3 560a 	ubfx	r6, r3, #20, #11
   89dca:	4614      	mov	r4, r2
   89dcc:	9f0a      	ldr	r7, [sp, #40]	; 0x28
   89dce:	f7ff fd49 	bl	89864 <_Balloc>
   89dd2:	f3c5 0313 	ubfx	r3, r5, #0, #20
   89dd6:	4680      	mov	r8, r0
   89dd8:	b10e      	cbz	r6, 89dde <__d2b+0x22>
   89dda:	f443 1380 	orr.w	r3, r3, #1048576	; 0x100000
   89dde:	9301      	str	r3, [sp, #4]
   89de0:	b324      	cbz	r4, 89e2c <__d2b+0x70>
   89de2:	a802      	add	r0, sp, #8
   89de4:	f840 4d08 	str.w	r4, [r0, #-8]!
   89de8:	4668      	mov	r0, sp
   89dea:	f7ff fdd5 	bl	89998 <__lo0bits>
   89dee:	2800      	cmp	r0, #0
   89df0:	d135      	bne.n	89e5e <__d2b+0xa2>
   89df2:	e89d 000c 	ldmia.w	sp, {r2, r3}
   89df6:	f8c8 2014 	str.w	r2, [r8, #20]
   89dfa:	2b00      	cmp	r3, #0
   89dfc:	bf0c      	ite	eq
   89dfe:	2401      	moveq	r4, #1
   89e00:	2402      	movne	r4, #2
   89e02:	f8c8 3018 	str.w	r3, [r8, #24]
   89e06:	f8c8 4010 	str.w	r4, [r8, #16]
   89e0a:	b9de      	cbnz	r6, 89e44 <__d2b+0x88>
   89e0c:	eb08 0384 	add.w	r3, r8, r4, lsl #2
   89e10:	f2a0 4032 	subw	r0, r0, #1074	; 0x432
   89e14:	6038      	str	r0, [r7, #0]
   89e16:	6918      	ldr	r0, [r3, #16]
   89e18:	f7ff fd9e 	bl	89958 <__hi0bits>
   89e1c:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
   89e1e:	ebc0 1044 	rsb	r0, r0, r4, lsl #5
   89e22:	6018      	str	r0, [r3, #0]
   89e24:	4640      	mov	r0, r8
   89e26:	b003      	add	sp, #12
   89e28:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
   89e2c:	a801      	add	r0, sp, #4
   89e2e:	f7ff fdb3 	bl	89998 <__lo0bits>
   89e32:	9b01      	ldr	r3, [sp, #4]
   89e34:	2401      	movs	r4, #1
   89e36:	3020      	adds	r0, #32
   89e38:	f8c8 3014 	str.w	r3, [r8, #20]
   89e3c:	f8c8 4010 	str.w	r4, [r8, #16]
   89e40:	2e00      	cmp	r6, #0
   89e42:	d0e3      	beq.n	89e0c <__d2b+0x50>
   89e44:	f2a6 4933 	subw	r9, r6, #1075	; 0x433
   89e48:	eb09 0300 	add.w	r3, r9, r0
   89e4c:	603b      	str	r3, [r7, #0]
   89e4e:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
   89e50:	f1c0 0035 	rsb	r0, r0, #53	; 0x35
   89e54:	6018      	str	r0, [r3, #0]
   89e56:	4640      	mov	r0, r8
   89e58:	b003      	add	sp, #12
   89e5a:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
   89e5e:	9b01      	ldr	r3, [sp, #4]
   89e60:	f1c0 0120 	rsb	r1, r0, #32
   89e64:	fa03 f101 	lsl.w	r1, r3, r1
   89e68:	40c3      	lsrs	r3, r0
   89e6a:	9a00      	ldr	r2, [sp, #0]
   89e6c:	9301      	str	r3, [sp, #4]
   89e6e:	430a      	orrs	r2, r1
   89e70:	f8c8 2014 	str.w	r2, [r8, #20]
   89e74:	e7c1      	b.n	89dfa <__d2b+0x3e>
   89e76:	bf00      	nop

00089e78 <_realloc_r>:
   89e78:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   89e7c:	460c      	mov	r4, r1
   89e7e:	b083      	sub	sp, #12
   89e80:	4690      	mov	r8, r2
   89e82:	4681      	mov	r9, r0
   89e84:	2900      	cmp	r1, #0
   89e86:	f000 80ba 	beq.w	89ffe <_realloc_r+0x186>
   89e8a:	f7ff fce7 	bl	8985c <__malloc_lock>
   89e8e:	f108 060b 	add.w	r6, r8, #11
   89e92:	f854 3c04 	ldr.w	r3, [r4, #-4]
   89e96:	2e16      	cmp	r6, #22
   89e98:	f023 0503 	bic.w	r5, r3, #3
   89e9c:	f1a4 0708 	sub.w	r7, r4, #8
   89ea0:	d84b      	bhi.n	89f3a <_realloc_r+0xc2>
   89ea2:	2110      	movs	r1, #16
   89ea4:	460e      	mov	r6, r1
   89ea6:	45b0      	cmp	r8, r6
   89ea8:	d84c      	bhi.n	89f44 <_realloc_r+0xcc>
   89eaa:	428d      	cmp	r5, r1
   89eac:	da51      	bge.n	89f52 <_realloc_r+0xda>
   89eae:	f8df b384 	ldr.w	fp, [pc, #900]	; 8a234 <_realloc_r+0x3bc>
   89eb2:	1978      	adds	r0, r7, r5
   89eb4:	f8db e008 	ldr.w	lr, [fp, #8]
   89eb8:	4586      	cmp	lr, r0
   89eba:	f000 80a6 	beq.w	8a00a <_realloc_r+0x192>
   89ebe:	6842      	ldr	r2, [r0, #4]
   89ec0:	f022 0c01 	bic.w	ip, r2, #1
   89ec4:	4484      	add	ip, r0
   89ec6:	f8dc c004 	ldr.w	ip, [ip, #4]
   89eca:	f01c 0f01 	tst.w	ip, #1
   89ece:	d054      	beq.n	89f7a <_realloc_r+0x102>
   89ed0:	2200      	movs	r2, #0
   89ed2:	4610      	mov	r0, r2
   89ed4:	07db      	lsls	r3, r3, #31
   89ed6:	d46f      	bmi.n	89fb8 <_realloc_r+0x140>
   89ed8:	f854 3c08 	ldr.w	r3, [r4, #-8]
   89edc:	ebc3 0a07 	rsb	sl, r3, r7
   89ee0:	f8da 3004 	ldr.w	r3, [sl, #4]
   89ee4:	f023 0303 	bic.w	r3, r3, #3
   89ee8:	442b      	add	r3, r5
   89eea:	2800      	cmp	r0, #0
   89eec:	d062      	beq.n	89fb4 <_realloc_r+0x13c>
   89eee:	4570      	cmp	r0, lr
   89ef0:	f000 80e9 	beq.w	8a0c6 <_realloc_r+0x24e>
   89ef4:	eb02 0e03 	add.w	lr, r2, r3
   89ef8:	458e      	cmp	lr, r1
   89efa:	db5b      	blt.n	89fb4 <_realloc_r+0x13c>
   89efc:	68c3      	ldr	r3, [r0, #12]
   89efe:	6882      	ldr	r2, [r0, #8]
   89f00:	46d0      	mov	r8, sl
   89f02:	60d3      	str	r3, [r2, #12]
   89f04:	609a      	str	r2, [r3, #8]
   89f06:	f858 1f08 	ldr.w	r1, [r8, #8]!
   89f0a:	f8da 300c 	ldr.w	r3, [sl, #12]
   89f0e:	1f2a      	subs	r2, r5, #4
   89f10:	2a24      	cmp	r2, #36	; 0x24
   89f12:	60cb      	str	r3, [r1, #12]
   89f14:	6099      	str	r1, [r3, #8]
   89f16:	f200 8123 	bhi.w	8a160 <_realloc_r+0x2e8>
   89f1a:	2a13      	cmp	r2, #19
   89f1c:	f240 80b0 	bls.w	8a080 <_realloc_r+0x208>
   89f20:	6823      	ldr	r3, [r4, #0]
   89f22:	2a1b      	cmp	r2, #27
   89f24:	f8ca 3008 	str.w	r3, [sl, #8]
   89f28:	6863      	ldr	r3, [r4, #4]
   89f2a:	f8ca 300c 	str.w	r3, [sl, #12]
   89f2e:	f200 812b 	bhi.w	8a188 <_realloc_r+0x310>
   89f32:	3408      	adds	r4, #8
   89f34:	f10a 0310 	add.w	r3, sl, #16
   89f38:	e0a3      	b.n	8a082 <_realloc_r+0x20a>
   89f3a:	f026 0607 	bic.w	r6, r6, #7
   89f3e:	2e00      	cmp	r6, #0
   89f40:	4631      	mov	r1, r6
   89f42:	dab0      	bge.n	89ea6 <_realloc_r+0x2e>
   89f44:	230c      	movs	r3, #12
   89f46:	2000      	movs	r0, #0
   89f48:	f8c9 3000 	str.w	r3, [r9]
   89f4c:	b003      	add	sp, #12
   89f4e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   89f52:	46a0      	mov	r8, r4
   89f54:	1baa      	subs	r2, r5, r6
   89f56:	2a0f      	cmp	r2, #15
   89f58:	f003 0301 	and.w	r3, r3, #1
   89f5c:	d81a      	bhi.n	89f94 <_realloc_r+0x11c>
   89f5e:	432b      	orrs	r3, r5
   89f60:	607b      	str	r3, [r7, #4]
   89f62:	443d      	add	r5, r7
   89f64:	686b      	ldr	r3, [r5, #4]
   89f66:	f043 0301 	orr.w	r3, r3, #1
   89f6a:	606b      	str	r3, [r5, #4]
   89f6c:	4648      	mov	r0, r9
   89f6e:	f7ff fc77 	bl	89860 <__malloc_unlock>
   89f72:	4640      	mov	r0, r8
   89f74:	b003      	add	sp, #12
   89f76:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   89f7a:	f022 0203 	bic.w	r2, r2, #3
   89f7e:	eb02 0c05 	add.w	ip, r2, r5
   89f82:	458c      	cmp	ip, r1
   89f84:	dba6      	blt.n	89ed4 <_realloc_r+0x5c>
   89f86:	68c2      	ldr	r2, [r0, #12]
   89f88:	6881      	ldr	r1, [r0, #8]
   89f8a:	46a0      	mov	r8, r4
   89f8c:	60ca      	str	r2, [r1, #12]
   89f8e:	4665      	mov	r5, ip
   89f90:	6091      	str	r1, [r2, #8]
   89f92:	e7df      	b.n	89f54 <_realloc_r+0xdc>
   89f94:	19b9      	adds	r1, r7, r6
   89f96:	4333      	orrs	r3, r6
   89f98:	f042 0001 	orr.w	r0, r2, #1
   89f9c:	607b      	str	r3, [r7, #4]
   89f9e:	440a      	add	r2, r1
   89fa0:	6048      	str	r0, [r1, #4]
   89fa2:	6853      	ldr	r3, [r2, #4]
   89fa4:	3108      	adds	r1, #8
   89fa6:	f043 0301 	orr.w	r3, r3, #1
   89faa:	6053      	str	r3, [r2, #4]
   89fac:	4648      	mov	r0, r9
   89fae:	f7ff f839 	bl	89024 <_free_r>
   89fb2:	e7db      	b.n	89f6c <_realloc_r+0xf4>
   89fb4:	428b      	cmp	r3, r1
   89fb6:	da33      	bge.n	8a020 <_realloc_r+0x1a8>
   89fb8:	4641      	mov	r1, r8
   89fba:	4648      	mov	r0, r9
   89fbc:	f7ff f902 	bl	891c4 <_malloc_r>
   89fc0:	4680      	mov	r8, r0
   89fc2:	2800      	cmp	r0, #0
   89fc4:	d0d2      	beq.n	89f6c <_realloc_r+0xf4>
   89fc6:	f854 3c04 	ldr.w	r3, [r4, #-4]
   89fca:	f1a0 0108 	sub.w	r1, r0, #8
   89fce:	f023 0201 	bic.w	r2, r3, #1
   89fd2:	443a      	add	r2, r7
   89fd4:	4291      	cmp	r1, r2
   89fd6:	f000 80bc 	beq.w	8a152 <_realloc_r+0x2da>
   89fda:	1f2a      	subs	r2, r5, #4
   89fdc:	2a24      	cmp	r2, #36	; 0x24
   89fde:	d86e      	bhi.n	8a0be <_realloc_r+0x246>
   89fe0:	2a13      	cmp	r2, #19
   89fe2:	d842      	bhi.n	8a06a <_realloc_r+0x1f2>
   89fe4:	4603      	mov	r3, r0
   89fe6:	4622      	mov	r2, r4
   89fe8:	6811      	ldr	r1, [r2, #0]
   89fea:	6019      	str	r1, [r3, #0]
   89fec:	6851      	ldr	r1, [r2, #4]
   89fee:	6059      	str	r1, [r3, #4]
   89ff0:	6892      	ldr	r2, [r2, #8]
   89ff2:	609a      	str	r2, [r3, #8]
   89ff4:	4621      	mov	r1, r4
   89ff6:	4648      	mov	r0, r9
   89ff8:	f7ff f814 	bl	89024 <_free_r>
   89ffc:	e7b6      	b.n	89f6c <_realloc_r+0xf4>
   89ffe:	4611      	mov	r1, r2
   8a000:	b003      	add	sp, #12
   8a002:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   8a006:	f7ff b8dd 	b.w	891c4 <_malloc_r>
   8a00a:	f8de 2004 	ldr.w	r2, [lr, #4]
   8a00e:	f106 0c10 	add.w	ip, r6, #16
   8a012:	f022 0203 	bic.w	r2, r2, #3
   8a016:	1950      	adds	r0, r2, r5
   8a018:	4560      	cmp	r0, ip
   8a01a:	da3d      	bge.n	8a098 <_realloc_r+0x220>
   8a01c:	4670      	mov	r0, lr
   8a01e:	e759      	b.n	89ed4 <_realloc_r+0x5c>
   8a020:	46d0      	mov	r8, sl
   8a022:	f858 0f08 	ldr.w	r0, [r8, #8]!
   8a026:	f8da 100c 	ldr.w	r1, [sl, #12]
   8a02a:	1f2a      	subs	r2, r5, #4
   8a02c:	2a24      	cmp	r2, #36	; 0x24
   8a02e:	60c1      	str	r1, [r0, #12]
   8a030:	6088      	str	r0, [r1, #8]
   8a032:	f200 80a0 	bhi.w	8a176 <_realloc_r+0x2fe>
   8a036:	2a13      	cmp	r2, #19
   8a038:	f240 809b 	bls.w	8a172 <_realloc_r+0x2fa>
   8a03c:	6821      	ldr	r1, [r4, #0]
   8a03e:	2a1b      	cmp	r2, #27
   8a040:	f8ca 1008 	str.w	r1, [sl, #8]
   8a044:	6861      	ldr	r1, [r4, #4]
   8a046:	f8ca 100c 	str.w	r1, [sl, #12]
   8a04a:	f200 80b2 	bhi.w	8a1b2 <_realloc_r+0x33a>
   8a04e:	3408      	adds	r4, #8
   8a050:	f10a 0210 	add.w	r2, sl, #16
   8a054:	6821      	ldr	r1, [r4, #0]
   8a056:	461d      	mov	r5, r3
   8a058:	6011      	str	r1, [r2, #0]
   8a05a:	6861      	ldr	r1, [r4, #4]
   8a05c:	4657      	mov	r7, sl
   8a05e:	6051      	str	r1, [r2, #4]
   8a060:	68a3      	ldr	r3, [r4, #8]
   8a062:	6093      	str	r3, [r2, #8]
   8a064:	f8da 3004 	ldr.w	r3, [sl, #4]
   8a068:	e774      	b.n	89f54 <_realloc_r+0xdc>
   8a06a:	6823      	ldr	r3, [r4, #0]
   8a06c:	2a1b      	cmp	r2, #27
   8a06e:	6003      	str	r3, [r0, #0]
   8a070:	6863      	ldr	r3, [r4, #4]
   8a072:	6043      	str	r3, [r0, #4]
   8a074:	d862      	bhi.n	8a13c <_realloc_r+0x2c4>
   8a076:	f100 0308 	add.w	r3, r0, #8
   8a07a:	f104 0208 	add.w	r2, r4, #8
   8a07e:	e7b3      	b.n	89fe8 <_realloc_r+0x170>
   8a080:	4643      	mov	r3, r8
   8a082:	6822      	ldr	r2, [r4, #0]
   8a084:	4675      	mov	r5, lr
   8a086:	601a      	str	r2, [r3, #0]
   8a088:	6862      	ldr	r2, [r4, #4]
   8a08a:	4657      	mov	r7, sl
   8a08c:	605a      	str	r2, [r3, #4]
   8a08e:	68a2      	ldr	r2, [r4, #8]
   8a090:	609a      	str	r2, [r3, #8]
   8a092:	f8da 3004 	ldr.w	r3, [sl, #4]
   8a096:	e75d      	b.n	89f54 <_realloc_r+0xdc>
   8a098:	1b83      	subs	r3, r0, r6
   8a09a:	4437      	add	r7, r6
   8a09c:	f043 0301 	orr.w	r3, r3, #1
   8a0a0:	f8cb 7008 	str.w	r7, [fp, #8]
   8a0a4:	607b      	str	r3, [r7, #4]
   8a0a6:	f854 3c04 	ldr.w	r3, [r4, #-4]
   8a0aa:	4648      	mov	r0, r9
   8a0ac:	f003 0301 	and.w	r3, r3, #1
   8a0b0:	431e      	orrs	r6, r3
   8a0b2:	f844 6c04 	str.w	r6, [r4, #-4]
   8a0b6:	f7ff fbd3 	bl	89860 <__malloc_unlock>
   8a0ba:	4620      	mov	r0, r4
   8a0bc:	e75a      	b.n	89f74 <_realloc_r+0xfc>
   8a0be:	4621      	mov	r1, r4
   8a0c0:	f7ff fb66 	bl	89790 <memmove>
   8a0c4:	e796      	b.n	89ff4 <_realloc_r+0x17c>
   8a0c6:	eb02 0c03 	add.w	ip, r2, r3
   8a0ca:	f106 0210 	add.w	r2, r6, #16
   8a0ce:	4594      	cmp	ip, r2
   8a0d0:	f6ff af70 	blt.w	89fb4 <_realloc_r+0x13c>
   8a0d4:	4657      	mov	r7, sl
   8a0d6:	f857 1f08 	ldr.w	r1, [r7, #8]!
   8a0da:	f8da 300c 	ldr.w	r3, [sl, #12]
   8a0de:	1f2a      	subs	r2, r5, #4
   8a0e0:	2a24      	cmp	r2, #36	; 0x24
   8a0e2:	60cb      	str	r3, [r1, #12]
   8a0e4:	6099      	str	r1, [r3, #8]
   8a0e6:	f200 8086 	bhi.w	8a1f6 <_realloc_r+0x37e>
   8a0ea:	2a13      	cmp	r2, #19
   8a0ec:	d977      	bls.n	8a1de <_realloc_r+0x366>
   8a0ee:	6823      	ldr	r3, [r4, #0]
   8a0f0:	2a1b      	cmp	r2, #27
   8a0f2:	f8ca 3008 	str.w	r3, [sl, #8]
   8a0f6:	6863      	ldr	r3, [r4, #4]
   8a0f8:	f8ca 300c 	str.w	r3, [sl, #12]
   8a0fc:	f200 8084 	bhi.w	8a208 <_realloc_r+0x390>
   8a100:	3408      	adds	r4, #8
   8a102:	f10a 0310 	add.w	r3, sl, #16
   8a106:	6822      	ldr	r2, [r4, #0]
   8a108:	601a      	str	r2, [r3, #0]
   8a10a:	6862      	ldr	r2, [r4, #4]
   8a10c:	605a      	str	r2, [r3, #4]
   8a10e:	68a2      	ldr	r2, [r4, #8]
   8a110:	609a      	str	r2, [r3, #8]
   8a112:	ebc6 020c 	rsb	r2, r6, ip
   8a116:	eb0a 0306 	add.w	r3, sl, r6
   8a11a:	f042 0201 	orr.w	r2, r2, #1
   8a11e:	f8cb 3008 	str.w	r3, [fp, #8]
   8a122:	605a      	str	r2, [r3, #4]
   8a124:	f8da 3004 	ldr.w	r3, [sl, #4]
   8a128:	4648      	mov	r0, r9
   8a12a:	f003 0301 	and.w	r3, r3, #1
   8a12e:	431e      	orrs	r6, r3
   8a130:	f8ca 6004 	str.w	r6, [sl, #4]
   8a134:	f7ff fb94 	bl	89860 <__malloc_unlock>
   8a138:	4638      	mov	r0, r7
   8a13a:	e71b      	b.n	89f74 <_realloc_r+0xfc>
   8a13c:	68a3      	ldr	r3, [r4, #8]
   8a13e:	2a24      	cmp	r2, #36	; 0x24
   8a140:	6083      	str	r3, [r0, #8]
   8a142:	68e3      	ldr	r3, [r4, #12]
   8a144:	60c3      	str	r3, [r0, #12]
   8a146:	d02b      	beq.n	8a1a0 <_realloc_r+0x328>
   8a148:	f100 0310 	add.w	r3, r0, #16
   8a14c:	f104 0210 	add.w	r2, r4, #16
   8a150:	e74a      	b.n	89fe8 <_realloc_r+0x170>
   8a152:	f850 2c04 	ldr.w	r2, [r0, #-4]
   8a156:	46a0      	mov	r8, r4
   8a158:	f022 0203 	bic.w	r2, r2, #3
   8a15c:	4415      	add	r5, r2
   8a15e:	e6f9      	b.n	89f54 <_realloc_r+0xdc>
   8a160:	4621      	mov	r1, r4
   8a162:	4640      	mov	r0, r8
   8a164:	4675      	mov	r5, lr
   8a166:	4657      	mov	r7, sl
   8a168:	f7ff fb12 	bl	89790 <memmove>
   8a16c:	f8da 3004 	ldr.w	r3, [sl, #4]
   8a170:	e6f0      	b.n	89f54 <_realloc_r+0xdc>
   8a172:	4642      	mov	r2, r8
   8a174:	e76e      	b.n	8a054 <_realloc_r+0x1dc>
   8a176:	4621      	mov	r1, r4
   8a178:	4640      	mov	r0, r8
   8a17a:	461d      	mov	r5, r3
   8a17c:	4657      	mov	r7, sl
   8a17e:	f7ff fb07 	bl	89790 <memmove>
   8a182:	f8da 3004 	ldr.w	r3, [sl, #4]
   8a186:	e6e5      	b.n	89f54 <_realloc_r+0xdc>
   8a188:	68a3      	ldr	r3, [r4, #8]
   8a18a:	2a24      	cmp	r2, #36	; 0x24
   8a18c:	f8ca 3010 	str.w	r3, [sl, #16]
   8a190:	68e3      	ldr	r3, [r4, #12]
   8a192:	f8ca 3014 	str.w	r3, [sl, #20]
   8a196:	d018      	beq.n	8a1ca <_realloc_r+0x352>
   8a198:	3410      	adds	r4, #16
   8a19a:	f10a 0318 	add.w	r3, sl, #24
   8a19e:	e770      	b.n	8a082 <_realloc_r+0x20a>
   8a1a0:	6922      	ldr	r2, [r4, #16]
   8a1a2:	f100 0318 	add.w	r3, r0, #24
   8a1a6:	6102      	str	r2, [r0, #16]
   8a1a8:	6961      	ldr	r1, [r4, #20]
   8a1aa:	f104 0218 	add.w	r2, r4, #24
   8a1ae:	6141      	str	r1, [r0, #20]
   8a1b0:	e71a      	b.n	89fe8 <_realloc_r+0x170>
   8a1b2:	68a1      	ldr	r1, [r4, #8]
   8a1b4:	2a24      	cmp	r2, #36	; 0x24
   8a1b6:	f8ca 1010 	str.w	r1, [sl, #16]
   8a1ba:	68e1      	ldr	r1, [r4, #12]
   8a1bc:	f8ca 1014 	str.w	r1, [sl, #20]
   8a1c0:	d00f      	beq.n	8a1e2 <_realloc_r+0x36a>
   8a1c2:	3410      	adds	r4, #16
   8a1c4:	f10a 0218 	add.w	r2, sl, #24
   8a1c8:	e744      	b.n	8a054 <_realloc_r+0x1dc>
   8a1ca:	6922      	ldr	r2, [r4, #16]
   8a1cc:	f10a 0320 	add.w	r3, sl, #32
   8a1d0:	f8ca 2018 	str.w	r2, [sl, #24]
   8a1d4:	6962      	ldr	r2, [r4, #20]
   8a1d6:	3418      	adds	r4, #24
   8a1d8:	f8ca 201c 	str.w	r2, [sl, #28]
   8a1dc:	e751      	b.n	8a082 <_realloc_r+0x20a>
   8a1de:	463b      	mov	r3, r7
   8a1e0:	e791      	b.n	8a106 <_realloc_r+0x28e>
   8a1e2:	6921      	ldr	r1, [r4, #16]
   8a1e4:	f10a 0220 	add.w	r2, sl, #32
   8a1e8:	f8ca 1018 	str.w	r1, [sl, #24]
   8a1ec:	6961      	ldr	r1, [r4, #20]
   8a1ee:	3418      	adds	r4, #24
   8a1f0:	f8ca 101c 	str.w	r1, [sl, #28]
   8a1f4:	e72e      	b.n	8a054 <_realloc_r+0x1dc>
   8a1f6:	4621      	mov	r1, r4
   8a1f8:	4638      	mov	r0, r7
   8a1fa:	f8cd c004 	str.w	ip, [sp, #4]
   8a1fe:	f7ff fac7 	bl	89790 <memmove>
   8a202:	f8dd c004 	ldr.w	ip, [sp, #4]
   8a206:	e784      	b.n	8a112 <_realloc_r+0x29a>
   8a208:	68a3      	ldr	r3, [r4, #8]
   8a20a:	2a24      	cmp	r2, #36	; 0x24
   8a20c:	f8ca 3010 	str.w	r3, [sl, #16]
   8a210:	68e3      	ldr	r3, [r4, #12]
   8a212:	f8ca 3014 	str.w	r3, [sl, #20]
   8a216:	d003      	beq.n	8a220 <_realloc_r+0x3a8>
   8a218:	3410      	adds	r4, #16
   8a21a:	f10a 0318 	add.w	r3, sl, #24
   8a21e:	e772      	b.n	8a106 <_realloc_r+0x28e>
   8a220:	6922      	ldr	r2, [r4, #16]
   8a222:	f10a 0320 	add.w	r3, sl, #32
   8a226:	f8ca 2018 	str.w	r2, [sl, #24]
   8a22a:	6962      	ldr	r2, [r4, #20]
   8a22c:	3418      	adds	r4, #24
   8a22e:	f8ca 201c 	str.w	r2, [sl, #28]
   8a232:	e768      	b.n	8a106 <_realloc_r+0x28e>
   8a234:	200708d0 	.word	0x200708d0

0008a238 <__fpclassifyd>:
   8a238:	f031 4300 	bics.w	r3, r1, #2147483648	; 0x80000000
   8a23c:	b410      	push	{r4}
   8a23e:	d008      	beq.n	8a252 <__fpclassifyd+0x1a>
   8a240:	4a0f      	ldr	r2, [pc, #60]	; (8a280 <__fpclassifyd+0x48>)
   8a242:	f5a3 1480 	sub.w	r4, r3, #1048576	; 0x100000
   8a246:	4294      	cmp	r4, r2
   8a248:	d80a      	bhi.n	8a260 <__fpclassifyd+0x28>
   8a24a:	2004      	movs	r0, #4
   8a24c:	f85d 4b04 	ldr.w	r4, [sp], #4
   8a250:	4770      	bx	lr
   8a252:	2800      	cmp	r0, #0
   8a254:	bf0c      	ite	eq
   8a256:	2002      	moveq	r0, #2
   8a258:	2003      	movne	r0, #3
   8a25a:	f85d 4b04 	ldr.w	r4, [sp], #4
   8a25e:	4770      	bx	lr
   8a260:	f5b3 1f80 	cmp.w	r3, #1048576	; 0x100000
   8a264:	d201      	bcs.n	8a26a <__fpclassifyd+0x32>
   8a266:	2003      	movs	r0, #3
   8a268:	e7f7      	b.n	8a25a <__fpclassifyd+0x22>
   8a26a:	4a06      	ldr	r2, [pc, #24]	; (8a284 <__fpclassifyd+0x4c>)
   8a26c:	4293      	cmp	r3, r2
   8a26e:	d001      	beq.n	8a274 <__fpclassifyd+0x3c>
   8a270:	2000      	movs	r0, #0
   8a272:	e7f2      	b.n	8a25a <__fpclassifyd+0x22>
   8a274:	f1d0 0001 	rsbs	r0, r0, #1
   8a278:	bf38      	it	cc
   8a27a:	2000      	movcc	r0, #0
   8a27c:	e7ed      	b.n	8a25a <__fpclassifyd+0x22>
   8a27e:	bf00      	nop
   8a280:	7fdfffff 	.word	0x7fdfffff
   8a284:	7ff00000 	.word	0x7ff00000

0008a288 <_sbrk_r>:
   8a288:	b538      	push	{r3, r4, r5, lr}
   8a28a:	4c07      	ldr	r4, [pc, #28]	; (8a2a8 <_sbrk_r+0x20>)
   8a28c:	2300      	movs	r3, #0
   8a28e:	4605      	mov	r5, r0
   8a290:	4608      	mov	r0, r1
   8a292:	6023      	str	r3, [r4, #0]
   8a294:	f7f9 fb38 	bl	83908 <_sbrk>
   8a298:	1c43      	adds	r3, r0, #1
   8a29a:	d000      	beq.n	8a29e <_sbrk_r+0x16>
   8a29c:	bd38      	pop	{r3, r4, r5, pc}
   8a29e:	6823      	ldr	r3, [r4, #0]
   8a2a0:	2b00      	cmp	r3, #0
   8a2a2:	d0fb      	beq.n	8a29c <_sbrk_r+0x14>
   8a2a4:	602b      	str	r3, [r5, #0]
   8a2a6:	bd38      	pop	{r3, r4, r5, pc}
   8a2a8:	20075c5c 	.word	0x20075c5c

0008a2ac <__ssprint_r>:
   8a2ac:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   8a2b0:	6894      	ldr	r4, [r2, #8]
   8a2b2:	b083      	sub	sp, #12
   8a2b4:	4692      	mov	sl, r2
   8a2b6:	4680      	mov	r8, r0
   8a2b8:	460d      	mov	r5, r1
   8a2ba:	6816      	ldr	r6, [r2, #0]
   8a2bc:	2c00      	cmp	r4, #0
   8a2be:	d06f      	beq.n	8a3a0 <__ssprint_r+0xf4>
   8a2c0:	f04f 0b00 	mov.w	fp, #0
   8a2c4:	6808      	ldr	r0, [r1, #0]
   8a2c6:	688b      	ldr	r3, [r1, #8]
   8a2c8:	465c      	mov	r4, fp
   8a2ca:	2c00      	cmp	r4, #0
   8a2cc:	d043      	beq.n	8a356 <__ssprint_r+0xaa>
   8a2ce:	429c      	cmp	r4, r3
   8a2d0:	461f      	mov	r7, r3
   8a2d2:	d345      	bcc.n	8a360 <__ssprint_r+0xb4>
   8a2d4:	89ab      	ldrh	r3, [r5, #12]
   8a2d6:	f413 6f90 	tst.w	r3, #1152	; 0x480
   8a2da:	d044      	beq.n	8a366 <__ssprint_r+0xba>
   8a2dc:	696f      	ldr	r7, [r5, #20]
   8a2de:	6929      	ldr	r1, [r5, #16]
   8a2e0:	eb07 0747 	add.w	r7, r7, r7, lsl #1
   8a2e4:	eb07 77d7 	add.w	r7, r7, r7, lsr #31
   8a2e8:	ebc1 0900 	rsb	r9, r1, r0
   8a2ec:	1c62      	adds	r2, r4, #1
   8a2ee:	107f      	asrs	r7, r7, #1
   8a2f0:	444a      	add	r2, r9
   8a2f2:	4297      	cmp	r7, r2
   8a2f4:	bf34      	ite	cc
   8a2f6:	4617      	movcc	r7, r2
   8a2f8:	463a      	movcs	r2, r7
   8a2fa:	055b      	lsls	r3, r3, #21
   8a2fc:	d535      	bpl.n	8a36a <__ssprint_r+0xbe>
   8a2fe:	4611      	mov	r1, r2
   8a300:	4640      	mov	r0, r8
   8a302:	f7fe ff5f 	bl	891c4 <_malloc_r>
   8a306:	2800      	cmp	r0, #0
   8a308:	d039      	beq.n	8a37e <__ssprint_r+0xd2>
   8a30a:	6929      	ldr	r1, [r5, #16]
   8a30c:	464a      	mov	r2, r9
   8a30e:	9001      	str	r0, [sp, #4]
   8a310:	f7fb ffe0 	bl	862d4 <memcpy>
   8a314:	89aa      	ldrh	r2, [r5, #12]
   8a316:	9b01      	ldr	r3, [sp, #4]
   8a318:	f422 6290 	bic.w	r2, r2, #1152	; 0x480
   8a31c:	f042 0280 	orr.w	r2, r2, #128	; 0x80
   8a320:	81aa      	strh	r2, [r5, #12]
   8a322:	ebc9 0207 	rsb	r2, r9, r7
   8a326:	eb03 0009 	add.w	r0, r3, r9
   8a32a:	616f      	str	r7, [r5, #20]
   8a32c:	612b      	str	r3, [r5, #16]
   8a32e:	6028      	str	r0, [r5, #0]
   8a330:	60aa      	str	r2, [r5, #8]
   8a332:	4627      	mov	r7, r4
   8a334:	46a1      	mov	r9, r4
   8a336:	464a      	mov	r2, r9
   8a338:	4659      	mov	r1, fp
   8a33a:	f7ff fa29 	bl	89790 <memmove>
   8a33e:	f8da 2008 	ldr.w	r2, [sl, #8]
   8a342:	68ab      	ldr	r3, [r5, #8]
   8a344:	6828      	ldr	r0, [r5, #0]
   8a346:	1bdb      	subs	r3, r3, r7
   8a348:	4448      	add	r0, r9
   8a34a:	1b14      	subs	r4, r2, r4
   8a34c:	60ab      	str	r3, [r5, #8]
   8a34e:	6028      	str	r0, [r5, #0]
   8a350:	f8ca 4008 	str.w	r4, [sl, #8]
   8a354:	b324      	cbz	r4, 8a3a0 <__ssprint_r+0xf4>
   8a356:	f8d6 b000 	ldr.w	fp, [r6]
   8a35a:	6874      	ldr	r4, [r6, #4]
   8a35c:	3608      	adds	r6, #8
   8a35e:	e7b4      	b.n	8a2ca <__ssprint_r+0x1e>
   8a360:	4627      	mov	r7, r4
   8a362:	46a1      	mov	r9, r4
   8a364:	e7e7      	b.n	8a336 <__ssprint_r+0x8a>
   8a366:	46b9      	mov	r9, r7
   8a368:	e7e5      	b.n	8a336 <__ssprint_r+0x8a>
   8a36a:	4640      	mov	r0, r8
   8a36c:	f7ff fd84 	bl	89e78 <_realloc_r>
   8a370:	4603      	mov	r3, r0
   8a372:	2800      	cmp	r0, #0
   8a374:	d1d5      	bne.n	8a322 <__ssprint_r+0x76>
   8a376:	4640      	mov	r0, r8
   8a378:	6929      	ldr	r1, [r5, #16]
   8a37a:	f7fe fe53 	bl	89024 <_free_r>
   8a37e:	89aa      	ldrh	r2, [r5, #12]
   8a380:	230c      	movs	r3, #12
   8a382:	f8c8 3000 	str.w	r3, [r8]
   8a386:	f042 0240 	orr.w	r2, r2, #64	; 0x40
   8a38a:	2300      	movs	r3, #0
   8a38c:	f04f 30ff 	mov.w	r0, #4294967295
   8a390:	81aa      	strh	r2, [r5, #12]
   8a392:	f8ca 3008 	str.w	r3, [sl, #8]
   8a396:	f8ca 3004 	str.w	r3, [sl, #4]
   8a39a:	b003      	add	sp, #12
   8a39c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   8a3a0:	4620      	mov	r0, r4
   8a3a2:	f8ca 4004 	str.w	r4, [sl, #4]
   8a3a6:	b003      	add	sp, #12
   8a3a8:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

0008a3ac <__register_exitproc>:
   8a3ac:	b5f0      	push	{r4, r5, r6, r7, lr}
   8a3ae:	4c27      	ldr	r4, [pc, #156]	; (8a44c <__register_exitproc+0xa0>)
   8a3b0:	b085      	sub	sp, #20
   8a3b2:	6826      	ldr	r6, [r4, #0]
   8a3b4:	4607      	mov	r7, r0
   8a3b6:	f8d6 4148 	ldr.w	r4, [r6, #328]	; 0x148
   8a3ba:	2c00      	cmp	r4, #0
   8a3bc:	d040      	beq.n	8a440 <__register_exitproc+0x94>
   8a3be:	6865      	ldr	r5, [r4, #4]
   8a3c0:	2d1f      	cmp	r5, #31
   8a3c2:	dd1e      	ble.n	8a402 <__register_exitproc+0x56>
   8a3c4:	4822      	ldr	r0, [pc, #136]	; (8a450 <__register_exitproc+0xa4>)
   8a3c6:	b918      	cbnz	r0, 8a3d0 <__register_exitproc+0x24>
   8a3c8:	f04f 30ff 	mov.w	r0, #4294967295
   8a3cc:	b005      	add	sp, #20
   8a3ce:	bdf0      	pop	{r4, r5, r6, r7, pc}
   8a3d0:	f44f 70c8 	mov.w	r0, #400	; 0x190
   8a3d4:	9103      	str	r1, [sp, #12]
   8a3d6:	9202      	str	r2, [sp, #8]
   8a3d8:	9301      	str	r3, [sp, #4]
   8a3da:	f3af 8000 	nop.w
   8a3de:	9903      	ldr	r1, [sp, #12]
   8a3e0:	4604      	mov	r4, r0
   8a3e2:	9a02      	ldr	r2, [sp, #8]
   8a3e4:	9b01      	ldr	r3, [sp, #4]
   8a3e6:	2800      	cmp	r0, #0
   8a3e8:	d0ee      	beq.n	8a3c8 <__register_exitproc+0x1c>
   8a3ea:	f8d6 5148 	ldr.w	r5, [r6, #328]	; 0x148
   8a3ee:	2000      	movs	r0, #0
   8a3f0:	6025      	str	r5, [r4, #0]
   8a3f2:	6060      	str	r0, [r4, #4]
   8a3f4:	4605      	mov	r5, r0
   8a3f6:	f8c6 4148 	str.w	r4, [r6, #328]	; 0x148
   8a3fa:	f8c4 0188 	str.w	r0, [r4, #392]	; 0x188
   8a3fe:	f8c4 018c 	str.w	r0, [r4, #396]	; 0x18c
   8a402:	b93f      	cbnz	r7, 8a414 <__register_exitproc+0x68>
   8a404:	1c6b      	adds	r3, r5, #1
   8a406:	2000      	movs	r0, #0
   8a408:	3502      	adds	r5, #2
   8a40a:	6063      	str	r3, [r4, #4]
   8a40c:	f844 1025 	str.w	r1, [r4, r5, lsl #2]
   8a410:	b005      	add	sp, #20
   8a412:	bdf0      	pop	{r4, r5, r6, r7, pc}
   8a414:	2601      	movs	r6, #1
   8a416:	40ae      	lsls	r6, r5
   8a418:	eb04 0085 	add.w	r0, r4, r5, lsl #2
   8a41c:	f8c0 2088 	str.w	r2, [r0, #136]	; 0x88
   8a420:	f8d4 2188 	ldr.w	r2, [r4, #392]	; 0x188
   8a424:	2f02      	cmp	r7, #2
   8a426:	ea42 0206 	orr.w	r2, r2, r6
   8a42a:	f8c4 2188 	str.w	r2, [r4, #392]	; 0x188
   8a42e:	f8c0 3108 	str.w	r3, [r0, #264]	; 0x108
   8a432:	d1e7      	bne.n	8a404 <__register_exitproc+0x58>
   8a434:	f8d4 318c 	ldr.w	r3, [r4, #396]	; 0x18c
   8a438:	431e      	orrs	r6, r3
   8a43a:	f8c4 618c 	str.w	r6, [r4, #396]	; 0x18c
   8a43e:	e7e1      	b.n	8a404 <__register_exitproc+0x58>
   8a440:	f506 74a6 	add.w	r4, r6, #332	; 0x14c
   8a444:	f8c6 4148 	str.w	r4, [r6, #328]	; 0x148
   8a448:	e7b9      	b.n	8a3be <__register_exitproc+0x12>
   8a44a:	bf00      	nop
   8a44c:	0008cc10 	.word	0x0008cc10
   8a450:	00000000 	.word	0x00000000

0008a454 <_calloc_r>:
   8a454:	b510      	push	{r4, lr}
   8a456:	fb02 f101 	mul.w	r1, r2, r1
   8a45a:	f7fe feb3 	bl	891c4 <_malloc_r>
   8a45e:	4604      	mov	r4, r0
   8a460:	b168      	cbz	r0, 8a47e <_calloc_r+0x2a>
   8a462:	f850 2c04 	ldr.w	r2, [r0, #-4]
   8a466:	f022 0203 	bic.w	r2, r2, #3
   8a46a:	3a04      	subs	r2, #4
   8a46c:	2a24      	cmp	r2, #36	; 0x24
   8a46e:	d818      	bhi.n	8a4a2 <_calloc_r+0x4e>
   8a470:	2a13      	cmp	r2, #19
   8a472:	d806      	bhi.n	8a482 <_calloc_r+0x2e>
   8a474:	4603      	mov	r3, r0
   8a476:	2200      	movs	r2, #0
   8a478:	601a      	str	r2, [r3, #0]
   8a47a:	605a      	str	r2, [r3, #4]
   8a47c:	609a      	str	r2, [r3, #8]
   8a47e:	4620      	mov	r0, r4
   8a480:	bd10      	pop	{r4, pc}
   8a482:	2300      	movs	r3, #0
   8a484:	2a1b      	cmp	r2, #27
   8a486:	6003      	str	r3, [r0, #0]
   8a488:	6043      	str	r3, [r0, #4]
   8a48a:	d90f      	bls.n	8a4ac <_calloc_r+0x58>
   8a48c:	2a24      	cmp	r2, #36	; 0x24
   8a48e:	6083      	str	r3, [r0, #8]
   8a490:	60c3      	str	r3, [r0, #12]
   8a492:	bf05      	ittet	eq
   8a494:	6103      	streq	r3, [r0, #16]
   8a496:	6143      	streq	r3, [r0, #20]
   8a498:	f100 0310 	addne.w	r3, r0, #16
   8a49c:	f100 0318 	addeq.w	r3, r0, #24
   8a4a0:	e7e9      	b.n	8a476 <_calloc_r+0x22>
   8a4a2:	2100      	movs	r1, #0
   8a4a4:	f7fb ff8c 	bl	863c0 <memset>
   8a4a8:	4620      	mov	r0, r4
   8a4aa:	bd10      	pop	{r4, pc}
   8a4ac:	f100 0308 	add.w	r3, r0, #8
   8a4b0:	e7e1      	b.n	8a476 <_calloc_r+0x22>
   8a4b2:	bf00      	nop

0008a4b4 <__aeabi_drsub>:
   8a4b4:	f081 4100 	eor.w	r1, r1, #2147483648	; 0x80000000
   8a4b8:	e002      	b.n	8a4c0 <__adddf3>
   8a4ba:	bf00      	nop

0008a4bc <__aeabi_dsub>:
   8a4bc:	f083 4300 	eor.w	r3, r3, #2147483648	; 0x80000000

0008a4c0 <__adddf3>:
   8a4c0:	b530      	push	{r4, r5, lr}
   8a4c2:	ea4f 0441 	mov.w	r4, r1, lsl #1
   8a4c6:	ea4f 0543 	mov.w	r5, r3, lsl #1
   8a4ca:	ea94 0f05 	teq	r4, r5
   8a4ce:	bf08      	it	eq
   8a4d0:	ea90 0f02 	teqeq	r0, r2
   8a4d4:	bf1f      	itttt	ne
   8a4d6:	ea54 0c00 	orrsne.w	ip, r4, r0
   8a4da:	ea55 0c02 	orrsne.w	ip, r5, r2
   8a4de:	ea7f 5c64 	mvnsne.w	ip, r4, asr #21
   8a4e2:	ea7f 5c65 	mvnsne.w	ip, r5, asr #21
   8a4e6:	f000 80e2 	beq.w	8a6ae <__adddf3+0x1ee>
   8a4ea:	ea4f 5454 	mov.w	r4, r4, lsr #21
   8a4ee:	ebd4 5555 	rsbs	r5, r4, r5, lsr #21
   8a4f2:	bfb8      	it	lt
   8a4f4:	426d      	neglt	r5, r5
   8a4f6:	dd0c      	ble.n	8a512 <__adddf3+0x52>
   8a4f8:	442c      	add	r4, r5
   8a4fa:	ea80 0202 	eor.w	r2, r0, r2
   8a4fe:	ea81 0303 	eor.w	r3, r1, r3
   8a502:	ea82 0000 	eor.w	r0, r2, r0
   8a506:	ea83 0101 	eor.w	r1, r3, r1
   8a50a:	ea80 0202 	eor.w	r2, r0, r2
   8a50e:	ea81 0303 	eor.w	r3, r1, r3
   8a512:	2d36      	cmp	r5, #54	; 0x36
   8a514:	bf88      	it	hi
   8a516:	bd30      	pophi	{r4, r5, pc}
   8a518:	f011 4f00 	tst.w	r1, #2147483648	; 0x80000000
   8a51c:	ea4f 3101 	mov.w	r1, r1, lsl #12
   8a520:	f44f 1c80 	mov.w	ip, #1048576	; 0x100000
   8a524:	ea4c 3111 	orr.w	r1, ip, r1, lsr #12
   8a528:	d002      	beq.n	8a530 <__adddf3+0x70>
   8a52a:	4240      	negs	r0, r0
   8a52c:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
   8a530:	f013 4f00 	tst.w	r3, #2147483648	; 0x80000000
   8a534:	ea4f 3303 	mov.w	r3, r3, lsl #12
   8a538:	ea4c 3313 	orr.w	r3, ip, r3, lsr #12
   8a53c:	d002      	beq.n	8a544 <__adddf3+0x84>
   8a53e:	4252      	negs	r2, r2
   8a540:	eb63 0343 	sbc.w	r3, r3, r3, lsl #1
   8a544:	ea94 0f05 	teq	r4, r5
   8a548:	f000 80a7 	beq.w	8a69a <__adddf3+0x1da>
   8a54c:	f1a4 0401 	sub.w	r4, r4, #1
   8a550:	f1d5 0e20 	rsbs	lr, r5, #32
   8a554:	db0d      	blt.n	8a572 <__adddf3+0xb2>
   8a556:	fa02 fc0e 	lsl.w	ip, r2, lr
   8a55a:	fa22 f205 	lsr.w	r2, r2, r5
   8a55e:	1880      	adds	r0, r0, r2
   8a560:	f141 0100 	adc.w	r1, r1, #0
   8a564:	fa03 f20e 	lsl.w	r2, r3, lr
   8a568:	1880      	adds	r0, r0, r2
   8a56a:	fa43 f305 	asr.w	r3, r3, r5
   8a56e:	4159      	adcs	r1, r3
   8a570:	e00e      	b.n	8a590 <__adddf3+0xd0>
   8a572:	f1a5 0520 	sub.w	r5, r5, #32
   8a576:	f10e 0e20 	add.w	lr, lr, #32
   8a57a:	2a01      	cmp	r2, #1
   8a57c:	fa03 fc0e 	lsl.w	ip, r3, lr
   8a580:	bf28      	it	cs
   8a582:	f04c 0c02 	orrcs.w	ip, ip, #2
   8a586:	fa43 f305 	asr.w	r3, r3, r5
   8a58a:	18c0      	adds	r0, r0, r3
   8a58c:	eb51 71e3 	adcs.w	r1, r1, r3, asr #31
   8a590:	f001 4500 	and.w	r5, r1, #2147483648	; 0x80000000
   8a594:	d507      	bpl.n	8a5a6 <__adddf3+0xe6>
   8a596:	f04f 0e00 	mov.w	lr, #0
   8a59a:	f1dc 0c00 	rsbs	ip, ip, #0
   8a59e:	eb7e 0000 	sbcs.w	r0, lr, r0
   8a5a2:	eb6e 0101 	sbc.w	r1, lr, r1
   8a5a6:	f5b1 1f80 	cmp.w	r1, #1048576	; 0x100000
   8a5aa:	d31b      	bcc.n	8a5e4 <__adddf3+0x124>
   8a5ac:	f5b1 1f00 	cmp.w	r1, #2097152	; 0x200000
   8a5b0:	d30c      	bcc.n	8a5cc <__adddf3+0x10c>
   8a5b2:	0849      	lsrs	r1, r1, #1
   8a5b4:	ea5f 0030 	movs.w	r0, r0, rrx
   8a5b8:	ea4f 0c3c 	mov.w	ip, ip, rrx
   8a5bc:	f104 0401 	add.w	r4, r4, #1
   8a5c0:	ea4f 5244 	mov.w	r2, r4, lsl #21
   8a5c4:	f512 0f80 	cmn.w	r2, #4194304	; 0x400000
   8a5c8:	f080 809a 	bcs.w	8a700 <__adddf3+0x240>
   8a5cc:	f1bc 4f00 	cmp.w	ip, #2147483648	; 0x80000000
   8a5d0:	bf08      	it	eq
   8a5d2:	ea5f 0c50 	movseq.w	ip, r0, lsr #1
   8a5d6:	f150 0000 	adcs.w	r0, r0, #0
   8a5da:	eb41 5104 	adc.w	r1, r1, r4, lsl #20
   8a5de:	ea41 0105 	orr.w	r1, r1, r5
   8a5e2:	bd30      	pop	{r4, r5, pc}
   8a5e4:	ea5f 0c4c 	movs.w	ip, ip, lsl #1
   8a5e8:	4140      	adcs	r0, r0
   8a5ea:	eb41 0101 	adc.w	r1, r1, r1
   8a5ee:	f411 1f80 	tst.w	r1, #1048576	; 0x100000
   8a5f2:	f1a4 0401 	sub.w	r4, r4, #1
   8a5f6:	d1e9      	bne.n	8a5cc <__adddf3+0x10c>
   8a5f8:	f091 0f00 	teq	r1, #0
   8a5fc:	bf04      	itt	eq
   8a5fe:	4601      	moveq	r1, r0
   8a600:	2000      	moveq	r0, #0
   8a602:	fab1 f381 	clz	r3, r1
   8a606:	bf08      	it	eq
   8a608:	3320      	addeq	r3, #32
   8a60a:	f1a3 030b 	sub.w	r3, r3, #11
   8a60e:	f1b3 0220 	subs.w	r2, r3, #32
   8a612:	da0c      	bge.n	8a62e <__adddf3+0x16e>
   8a614:	320c      	adds	r2, #12
   8a616:	dd08      	ble.n	8a62a <__adddf3+0x16a>
   8a618:	f102 0c14 	add.w	ip, r2, #20
   8a61c:	f1c2 020c 	rsb	r2, r2, #12
   8a620:	fa01 f00c 	lsl.w	r0, r1, ip
   8a624:	fa21 f102 	lsr.w	r1, r1, r2
   8a628:	e00c      	b.n	8a644 <__adddf3+0x184>
   8a62a:	f102 0214 	add.w	r2, r2, #20
   8a62e:	bfd8      	it	le
   8a630:	f1c2 0c20 	rsble	ip, r2, #32
   8a634:	fa01 f102 	lsl.w	r1, r1, r2
   8a638:	fa20 fc0c 	lsr.w	ip, r0, ip
   8a63c:	bfdc      	itt	le
   8a63e:	ea41 010c 	orrle.w	r1, r1, ip
   8a642:	4090      	lslle	r0, r2
   8a644:	1ae4      	subs	r4, r4, r3
   8a646:	bfa2      	ittt	ge
   8a648:	eb01 5104 	addge.w	r1, r1, r4, lsl #20
   8a64c:	4329      	orrge	r1, r5
   8a64e:	bd30      	popge	{r4, r5, pc}
   8a650:	ea6f 0404 	mvn.w	r4, r4
   8a654:	3c1f      	subs	r4, #31
   8a656:	da1c      	bge.n	8a692 <__adddf3+0x1d2>
   8a658:	340c      	adds	r4, #12
   8a65a:	dc0e      	bgt.n	8a67a <__adddf3+0x1ba>
   8a65c:	f104 0414 	add.w	r4, r4, #20
   8a660:	f1c4 0220 	rsb	r2, r4, #32
   8a664:	fa20 f004 	lsr.w	r0, r0, r4
   8a668:	fa01 f302 	lsl.w	r3, r1, r2
   8a66c:	ea40 0003 	orr.w	r0, r0, r3
   8a670:	fa21 f304 	lsr.w	r3, r1, r4
   8a674:	ea45 0103 	orr.w	r1, r5, r3
   8a678:	bd30      	pop	{r4, r5, pc}
   8a67a:	f1c4 040c 	rsb	r4, r4, #12
   8a67e:	f1c4 0220 	rsb	r2, r4, #32
   8a682:	fa20 f002 	lsr.w	r0, r0, r2
   8a686:	fa01 f304 	lsl.w	r3, r1, r4
   8a68a:	ea40 0003 	orr.w	r0, r0, r3
   8a68e:	4629      	mov	r1, r5
   8a690:	bd30      	pop	{r4, r5, pc}
   8a692:	fa21 f004 	lsr.w	r0, r1, r4
   8a696:	4629      	mov	r1, r5
   8a698:	bd30      	pop	{r4, r5, pc}
   8a69a:	f094 0f00 	teq	r4, #0
   8a69e:	f483 1380 	eor.w	r3, r3, #1048576	; 0x100000
   8a6a2:	bf06      	itte	eq
   8a6a4:	f481 1180 	eoreq.w	r1, r1, #1048576	; 0x100000
   8a6a8:	3401      	addeq	r4, #1
   8a6aa:	3d01      	subne	r5, #1
   8a6ac:	e74e      	b.n	8a54c <__adddf3+0x8c>
   8a6ae:	ea7f 5c64 	mvns.w	ip, r4, asr #21
   8a6b2:	bf18      	it	ne
   8a6b4:	ea7f 5c65 	mvnsne.w	ip, r5, asr #21
   8a6b8:	d029      	beq.n	8a70e <__adddf3+0x24e>
   8a6ba:	ea94 0f05 	teq	r4, r5
   8a6be:	bf08      	it	eq
   8a6c0:	ea90 0f02 	teqeq	r0, r2
   8a6c4:	d005      	beq.n	8a6d2 <__adddf3+0x212>
   8a6c6:	ea54 0c00 	orrs.w	ip, r4, r0
   8a6ca:	bf04      	itt	eq
   8a6cc:	4619      	moveq	r1, r3
   8a6ce:	4610      	moveq	r0, r2
   8a6d0:	bd30      	pop	{r4, r5, pc}
   8a6d2:	ea91 0f03 	teq	r1, r3
   8a6d6:	bf1e      	ittt	ne
   8a6d8:	2100      	movne	r1, #0
   8a6da:	2000      	movne	r0, #0
   8a6dc:	bd30      	popne	{r4, r5, pc}
   8a6de:	ea5f 5c54 	movs.w	ip, r4, lsr #21
   8a6e2:	d105      	bne.n	8a6f0 <__adddf3+0x230>
   8a6e4:	0040      	lsls	r0, r0, #1
   8a6e6:	4149      	adcs	r1, r1
   8a6e8:	bf28      	it	cs
   8a6ea:	f041 4100 	orrcs.w	r1, r1, #2147483648	; 0x80000000
   8a6ee:	bd30      	pop	{r4, r5, pc}
   8a6f0:	f514 0480 	adds.w	r4, r4, #4194304	; 0x400000
   8a6f4:	bf3c      	itt	cc
   8a6f6:	f501 1180 	addcc.w	r1, r1, #1048576	; 0x100000
   8a6fa:	bd30      	popcc	{r4, r5, pc}
   8a6fc:	f001 4500 	and.w	r5, r1, #2147483648	; 0x80000000
   8a700:	f045 41fe 	orr.w	r1, r5, #2130706432	; 0x7f000000
   8a704:	f441 0170 	orr.w	r1, r1, #15728640	; 0xf00000
   8a708:	f04f 0000 	mov.w	r0, #0
   8a70c:	bd30      	pop	{r4, r5, pc}
   8a70e:	ea7f 5c64 	mvns.w	ip, r4, asr #21
   8a712:	bf1a      	itte	ne
   8a714:	4619      	movne	r1, r3
   8a716:	4610      	movne	r0, r2
   8a718:	ea7f 5c65 	mvnseq.w	ip, r5, asr #21
   8a71c:	bf1c      	itt	ne
   8a71e:	460b      	movne	r3, r1
   8a720:	4602      	movne	r2, r0
   8a722:	ea50 3401 	orrs.w	r4, r0, r1, lsl #12
   8a726:	bf06      	itte	eq
   8a728:	ea52 3503 	orrseq.w	r5, r2, r3, lsl #12
   8a72c:	ea91 0f03 	teqeq	r1, r3
   8a730:	f441 2100 	orrne.w	r1, r1, #524288	; 0x80000
   8a734:	bd30      	pop	{r4, r5, pc}
   8a736:	bf00      	nop

0008a738 <__aeabi_ui2d>:
   8a738:	f090 0f00 	teq	r0, #0
   8a73c:	bf04      	itt	eq
   8a73e:	2100      	moveq	r1, #0
   8a740:	4770      	bxeq	lr
   8a742:	b530      	push	{r4, r5, lr}
   8a744:	f44f 6480 	mov.w	r4, #1024	; 0x400
   8a748:	f104 0432 	add.w	r4, r4, #50	; 0x32
   8a74c:	f04f 0500 	mov.w	r5, #0
   8a750:	f04f 0100 	mov.w	r1, #0
   8a754:	e750      	b.n	8a5f8 <__adddf3+0x138>
   8a756:	bf00      	nop

0008a758 <__aeabi_i2d>:
   8a758:	f090 0f00 	teq	r0, #0
   8a75c:	bf04      	itt	eq
   8a75e:	2100      	moveq	r1, #0
   8a760:	4770      	bxeq	lr
   8a762:	b530      	push	{r4, r5, lr}
   8a764:	f44f 6480 	mov.w	r4, #1024	; 0x400
   8a768:	f104 0432 	add.w	r4, r4, #50	; 0x32
   8a76c:	f010 4500 	ands.w	r5, r0, #2147483648	; 0x80000000
   8a770:	bf48      	it	mi
   8a772:	4240      	negmi	r0, r0
   8a774:	f04f 0100 	mov.w	r1, #0
   8a778:	e73e      	b.n	8a5f8 <__adddf3+0x138>
   8a77a:	bf00      	nop

0008a77c <__aeabi_f2d>:
   8a77c:	0042      	lsls	r2, r0, #1
   8a77e:	ea4f 01e2 	mov.w	r1, r2, asr #3
   8a782:	ea4f 0131 	mov.w	r1, r1, rrx
   8a786:	ea4f 7002 	mov.w	r0, r2, lsl #28
   8a78a:	bf1f      	itttt	ne
   8a78c:	f012 437f 	andsne.w	r3, r2, #4278190080	; 0xff000000
   8a790:	f093 4f7f 	teqne	r3, #4278190080	; 0xff000000
   8a794:	f081 5160 	eorne.w	r1, r1, #939524096	; 0x38000000
   8a798:	4770      	bxne	lr
   8a79a:	f092 0f00 	teq	r2, #0
   8a79e:	bf14      	ite	ne
   8a7a0:	f093 4f7f 	teqne	r3, #4278190080	; 0xff000000
   8a7a4:	4770      	bxeq	lr
   8a7a6:	b530      	push	{r4, r5, lr}
   8a7a8:	f44f 7460 	mov.w	r4, #896	; 0x380
   8a7ac:	f001 4500 	and.w	r5, r1, #2147483648	; 0x80000000
   8a7b0:	f021 4100 	bic.w	r1, r1, #2147483648	; 0x80000000
   8a7b4:	e720      	b.n	8a5f8 <__adddf3+0x138>
   8a7b6:	bf00      	nop

0008a7b8 <__aeabi_ul2d>:
   8a7b8:	ea50 0201 	orrs.w	r2, r0, r1
   8a7bc:	bf08      	it	eq
   8a7be:	4770      	bxeq	lr
   8a7c0:	b530      	push	{r4, r5, lr}
   8a7c2:	f04f 0500 	mov.w	r5, #0
   8a7c6:	e00a      	b.n	8a7de <__aeabi_l2d+0x16>

0008a7c8 <__aeabi_l2d>:
   8a7c8:	ea50 0201 	orrs.w	r2, r0, r1
   8a7cc:	bf08      	it	eq
   8a7ce:	4770      	bxeq	lr
   8a7d0:	b530      	push	{r4, r5, lr}
   8a7d2:	f011 4500 	ands.w	r5, r1, #2147483648	; 0x80000000
   8a7d6:	d502      	bpl.n	8a7de <__aeabi_l2d+0x16>
   8a7d8:	4240      	negs	r0, r0
   8a7da:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
   8a7de:	f44f 6480 	mov.w	r4, #1024	; 0x400
   8a7e2:	f104 0432 	add.w	r4, r4, #50	; 0x32
   8a7e6:	ea5f 5c91 	movs.w	ip, r1, lsr #22
   8a7ea:	f43f aedc 	beq.w	8a5a6 <__adddf3+0xe6>
   8a7ee:	f04f 0203 	mov.w	r2, #3
   8a7f2:	ea5f 0cdc 	movs.w	ip, ip, lsr #3
   8a7f6:	bf18      	it	ne
   8a7f8:	3203      	addne	r2, #3
   8a7fa:	ea5f 0cdc 	movs.w	ip, ip, lsr #3
   8a7fe:	bf18      	it	ne
   8a800:	3203      	addne	r2, #3
   8a802:	eb02 02dc 	add.w	r2, r2, ip, lsr #3
   8a806:	f1c2 0320 	rsb	r3, r2, #32
   8a80a:	fa00 fc03 	lsl.w	ip, r0, r3
   8a80e:	fa20 f002 	lsr.w	r0, r0, r2
   8a812:	fa01 fe03 	lsl.w	lr, r1, r3
   8a816:	ea40 000e 	orr.w	r0, r0, lr
   8a81a:	fa21 f102 	lsr.w	r1, r1, r2
   8a81e:	4414      	add	r4, r2
   8a820:	e6c1      	b.n	8a5a6 <__adddf3+0xe6>
   8a822:	bf00      	nop

0008a824 <__aeabi_dmul>:
   8a824:	b570      	push	{r4, r5, r6, lr}
   8a826:	f04f 0cff 	mov.w	ip, #255	; 0xff
   8a82a:	f44c 6ce0 	orr.w	ip, ip, #1792	; 0x700
   8a82e:	ea1c 5411 	ands.w	r4, ip, r1, lsr #20
   8a832:	bf1d      	ittte	ne
   8a834:	ea1c 5513 	andsne.w	r5, ip, r3, lsr #20
   8a838:	ea94 0f0c 	teqne	r4, ip
   8a83c:	ea95 0f0c 	teqne	r5, ip
   8a840:	f000 f8de 	bleq	8aa00 <__aeabi_dmul+0x1dc>
   8a844:	442c      	add	r4, r5
   8a846:	ea81 0603 	eor.w	r6, r1, r3
   8a84a:	ea21 514c 	bic.w	r1, r1, ip, lsl #21
   8a84e:	ea23 534c 	bic.w	r3, r3, ip, lsl #21
   8a852:	ea50 3501 	orrs.w	r5, r0, r1, lsl #12
   8a856:	bf18      	it	ne
   8a858:	ea52 3503 	orrsne.w	r5, r2, r3, lsl #12
   8a85c:	f441 1180 	orr.w	r1, r1, #1048576	; 0x100000
   8a860:	f443 1380 	orr.w	r3, r3, #1048576	; 0x100000
   8a864:	d038      	beq.n	8a8d8 <__aeabi_dmul+0xb4>
   8a866:	fba0 ce02 	umull	ip, lr, r0, r2
   8a86a:	f04f 0500 	mov.w	r5, #0
   8a86e:	fbe1 e502 	umlal	lr, r5, r1, r2
   8a872:	f006 4200 	and.w	r2, r6, #2147483648	; 0x80000000
   8a876:	fbe0 e503 	umlal	lr, r5, r0, r3
   8a87a:	f04f 0600 	mov.w	r6, #0
   8a87e:	fbe1 5603 	umlal	r5, r6, r1, r3
   8a882:	f09c 0f00 	teq	ip, #0
   8a886:	bf18      	it	ne
   8a888:	f04e 0e01 	orrne.w	lr, lr, #1
   8a88c:	f1a4 04ff 	sub.w	r4, r4, #255	; 0xff
   8a890:	f5b6 7f00 	cmp.w	r6, #512	; 0x200
   8a894:	f564 7440 	sbc.w	r4, r4, #768	; 0x300
   8a898:	d204      	bcs.n	8a8a4 <__aeabi_dmul+0x80>
   8a89a:	ea5f 0e4e 	movs.w	lr, lr, lsl #1
   8a89e:	416d      	adcs	r5, r5
   8a8a0:	eb46 0606 	adc.w	r6, r6, r6
   8a8a4:	ea42 21c6 	orr.w	r1, r2, r6, lsl #11
   8a8a8:	ea41 5155 	orr.w	r1, r1, r5, lsr #21
   8a8ac:	ea4f 20c5 	mov.w	r0, r5, lsl #11
   8a8b0:	ea40 505e 	orr.w	r0, r0, lr, lsr #21
   8a8b4:	ea4f 2ece 	mov.w	lr, lr, lsl #11
   8a8b8:	f1b4 0cfd 	subs.w	ip, r4, #253	; 0xfd
   8a8bc:	bf88      	it	hi
   8a8be:	f5bc 6fe0 	cmphi.w	ip, #1792	; 0x700
   8a8c2:	d81e      	bhi.n	8a902 <__aeabi_dmul+0xde>
   8a8c4:	f1be 4f00 	cmp.w	lr, #2147483648	; 0x80000000
   8a8c8:	bf08      	it	eq
   8a8ca:	ea5f 0e50 	movseq.w	lr, r0, lsr #1
   8a8ce:	f150 0000 	adcs.w	r0, r0, #0
   8a8d2:	eb41 5104 	adc.w	r1, r1, r4, lsl #20
   8a8d6:	bd70      	pop	{r4, r5, r6, pc}
   8a8d8:	f006 4600 	and.w	r6, r6, #2147483648	; 0x80000000
   8a8dc:	ea46 0101 	orr.w	r1, r6, r1
   8a8e0:	ea40 0002 	orr.w	r0, r0, r2
   8a8e4:	ea81 0103 	eor.w	r1, r1, r3
   8a8e8:	ebb4 045c 	subs.w	r4, r4, ip, lsr #1
   8a8ec:	bfc2      	ittt	gt
   8a8ee:	ebd4 050c 	rsbsgt	r5, r4, ip
   8a8f2:	ea41 5104 	orrgt.w	r1, r1, r4, lsl #20
   8a8f6:	bd70      	popgt	{r4, r5, r6, pc}
   8a8f8:	f441 1180 	orr.w	r1, r1, #1048576	; 0x100000
   8a8fc:	f04f 0e00 	mov.w	lr, #0
   8a900:	3c01      	subs	r4, #1
   8a902:	f300 80ab 	bgt.w	8aa5c <__aeabi_dmul+0x238>
   8a906:	f114 0f36 	cmn.w	r4, #54	; 0x36
   8a90a:	bfde      	ittt	le
   8a90c:	2000      	movle	r0, #0
   8a90e:	f001 4100 	andle.w	r1, r1, #2147483648	; 0x80000000
   8a912:	bd70      	pople	{r4, r5, r6, pc}
   8a914:	f1c4 0400 	rsb	r4, r4, #0
   8a918:	3c20      	subs	r4, #32
   8a91a:	da35      	bge.n	8a988 <__aeabi_dmul+0x164>
   8a91c:	340c      	adds	r4, #12
   8a91e:	dc1b      	bgt.n	8a958 <__aeabi_dmul+0x134>
   8a920:	f104 0414 	add.w	r4, r4, #20
   8a924:	f1c4 0520 	rsb	r5, r4, #32
   8a928:	fa00 f305 	lsl.w	r3, r0, r5
   8a92c:	fa20 f004 	lsr.w	r0, r0, r4
   8a930:	fa01 f205 	lsl.w	r2, r1, r5
   8a934:	ea40 0002 	orr.w	r0, r0, r2
   8a938:	f001 4200 	and.w	r2, r1, #2147483648	; 0x80000000
   8a93c:	f021 4100 	bic.w	r1, r1, #2147483648	; 0x80000000
   8a940:	eb10 70d3 	adds.w	r0, r0, r3, lsr #31
   8a944:	fa21 f604 	lsr.w	r6, r1, r4
   8a948:	eb42 0106 	adc.w	r1, r2, r6
   8a94c:	ea5e 0e43 	orrs.w	lr, lr, r3, lsl #1
   8a950:	bf08      	it	eq
   8a952:	ea20 70d3 	biceq.w	r0, r0, r3, lsr #31
   8a956:	bd70      	pop	{r4, r5, r6, pc}
   8a958:	f1c4 040c 	rsb	r4, r4, #12
   8a95c:	f1c4 0520 	rsb	r5, r4, #32
   8a960:	fa00 f304 	lsl.w	r3, r0, r4
   8a964:	fa20 f005 	lsr.w	r0, r0, r5
   8a968:	fa01 f204 	lsl.w	r2, r1, r4
   8a96c:	ea40 0002 	orr.w	r0, r0, r2
   8a970:	f001 4100 	and.w	r1, r1, #2147483648	; 0x80000000
   8a974:	eb10 70d3 	adds.w	r0, r0, r3, lsr #31
   8a978:	f141 0100 	adc.w	r1, r1, #0
   8a97c:	ea5e 0e43 	orrs.w	lr, lr, r3, lsl #1
   8a980:	bf08      	it	eq
   8a982:	ea20 70d3 	biceq.w	r0, r0, r3, lsr #31
   8a986:	bd70      	pop	{r4, r5, r6, pc}
   8a988:	f1c4 0520 	rsb	r5, r4, #32
   8a98c:	fa00 f205 	lsl.w	r2, r0, r5
   8a990:	ea4e 0e02 	orr.w	lr, lr, r2
   8a994:	fa20 f304 	lsr.w	r3, r0, r4
   8a998:	fa01 f205 	lsl.w	r2, r1, r5
   8a99c:	ea43 0302 	orr.w	r3, r3, r2
   8a9a0:	fa21 f004 	lsr.w	r0, r1, r4
   8a9a4:	f001 4100 	and.w	r1, r1, #2147483648	; 0x80000000
   8a9a8:	fa21 f204 	lsr.w	r2, r1, r4
   8a9ac:	ea20 0002 	bic.w	r0, r0, r2
   8a9b0:	eb00 70d3 	add.w	r0, r0, r3, lsr #31
   8a9b4:	ea5e 0e43 	orrs.w	lr, lr, r3, lsl #1
   8a9b8:	bf08      	it	eq
   8a9ba:	ea20 70d3 	biceq.w	r0, r0, r3, lsr #31
   8a9be:	bd70      	pop	{r4, r5, r6, pc}
   8a9c0:	f094 0f00 	teq	r4, #0
   8a9c4:	d10f      	bne.n	8a9e6 <__aeabi_dmul+0x1c2>
   8a9c6:	f001 4600 	and.w	r6, r1, #2147483648	; 0x80000000
   8a9ca:	0040      	lsls	r0, r0, #1
   8a9cc:	eb41 0101 	adc.w	r1, r1, r1
   8a9d0:	f411 1f80 	tst.w	r1, #1048576	; 0x100000
   8a9d4:	bf08      	it	eq
   8a9d6:	3c01      	subeq	r4, #1
   8a9d8:	d0f7      	beq.n	8a9ca <__aeabi_dmul+0x1a6>
   8a9da:	ea41 0106 	orr.w	r1, r1, r6
   8a9de:	f095 0f00 	teq	r5, #0
   8a9e2:	bf18      	it	ne
   8a9e4:	4770      	bxne	lr
   8a9e6:	f003 4600 	and.w	r6, r3, #2147483648	; 0x80000000
   8a9ea:	0052      	lsls	r2, r2, #1
   8a9ec:	eb43 0303 	adc.w	r3, r3, r3
   8a9f0:	f413 1f80 	tst.w	r3, #1048576	; 0x100000
   8a9f4:	bf08      	it	eq
   8a9f6:	3d01      	subeq	r5, #1
   8a9f8:	d0f7      	beq.n	8a9ea <__aeabi_dmul+0x1c6>
   8a9fa:	ea43 0306 	orr.w	r3, r3, r6
   8a9fe:	4770      	bx	lr
   8aa00:	ea94 0f0c 	teq	r4, ip
   8aa04:	ea0c 5513 	and.w	r5, ip, r3, lsr #20
   8aa08:	bf18      	it	ne
   8aa0a:	ea95 0f0c 	teqne	r5, ip
   8aa0e:	d00c      	beq.n	8aa2a <__aeabi_dmul+0x206>
   8aa10:	ea50 0641 	orrs.w	r6, r0, r1, lsl #1
   8aa14:	bf18      	it	ne
   8aa16:	ea52 0643 	orrsne.w	r6, r2, r3, lsl #1
   8aa1a:	d1d1      	bne.n	8a9c0 <__aeabi_dmul+0x19c>
   8aa1c:	ea81 0103 	eor.w	r1, r1, r3
   8aa20:	f001 4100 	and.w	r1, r1, #2147483648	; 0x80000000
   8aa24:	f04f 0000 	mov.w	r0, #0
   8aa28:	bd70      	pop	{r4, r5, r6, pc}
   8aa2a:	ea50 0641 	orrs.w	r6, r0, r1, lsl #1
   8aa2e:	bf06      	itte	eq
   8aa30:	4610      	moveq	r0, r2
   8aa32:	4619      	moveq	r1, r3
   8aa34:	ea52 0643 	orrsne.w	r6, r2, r3, lsl #1
   8aa38:	d019      	beq.n	8aa6e <__aeabi_dmul+0x24a>
   8aa3a:	ea94 0f0c 	teq	r4, ip
   8aa3e:	d102      	bne.n	8aa46 <__aeabi_dmul+0x222>
   8aa40:	ea50 3601 	orrs.w	r6, r0, r1, lsl #12
   8aa44:	d113      	bne.n	8aa6e <__aeabi_dmul+0x24a>
   8aa46:	ea95 0f0c 	teq	r5, ip
   8aa4a:	d105      	bne.n	8aa58 <__aeabi_dmul+0x234>
   8aa4c:	ea52 3603 	orrs.w	r6, r2, r3, lsl #12
   8aa50:	bf1c      	itt	ne
   8aa52:	4610      	movne	r0, r2
   8aa54:	4619      	movne	r1, r3
   8aa56:	d10a      	bne.n	8aa6e <__aeabi_dmul+0x24a>
   8aa58:	ea81 0103 	eor.w	r1, r1, r3
   8aa5c:	f001 4100 	and.w	r1, r1, #2147483648	; 0x80000000
   8aa60:	f041 41fe 	orr.w	r1, r1, #2130706432	; 0x7f000000
   8aa64:	f441 0170 	orr.w	r1, r1, #15728640	; 0xf00000
   8aa68:	f04f 0000 	mov.w	r0, #0
   8aa6c:	bd70      	pop	{r4, r5, r6, pc}
   8aa6e:	f041 41fe 	orr.w	r1, r1, #2130706432	; 0x7f000000
   8aa72:	f441 0178 	orr.w	r1, r1, #16252928	; 0xf80000
   8aa76:	bd70      	pop	{r4, r5, r6, pc}

0008aa78 <__aeabi_ddiv>:
   8aa78:	b570      	push	{r4, r5, r6, lr}
   8aa7a:	f04f 0cff 	mov.w	ip, #255	; 0xff
   8aa7e:	f44c 6ce0 	orr.w	ip, ip, #1792	; 0x700
   8aa82:	ea1c 5411 	ands.w	r4, ip, r1, lsr #20
   8aa86:	bf1d      	ittte	ne
   8aa88:	ea1c 5513 	andsne.w	r5, ip, r3, lsr #20
   8aa8c:	ea94 0f0c 	teqne	r4, ip
   8aa90:	ea95 0f0c 	teqne	r5, ip
   8aa94:	f000 f8a7 	bleq	8abe6 <__aeabi_ddiv+0x16e>
   8aa98:	eba4 0405 	sub.w	r4, r4, r5
   8aa9c:	ea81 0e03 	eor.w	lr, r1, r3
   8aaa0:	ea52 3503 	orrs.w	r5, r2, r3, lsl #12
   8aaa4:	ea4f 3101 	mov.w	r1, r1, lsl #12
   8aaa8:	f000 8088 	beq.w	8abbc <__aeabi_ddiv+0x144>
   8aaac:	ea4f 3303 	mov.w	r3, r3, lsl #12
   8aab0:	f04f 5580 	mov.w	r5, #268435456	; 0x10000000
   8aab4:	ea45 1313 	orr.w	r3, r5, r3, lsr #4
   8aab8:	ea43 6312 	orr.w	r3, r3, r2, lsr #24
   8aabc:	ea4f 2202 	mov.w	r2, r2, lsl #8
   8aac0:	ea45 1511 	orr.w	r5, r5, r1, lsr #4
   8aac4:	ea45 6510 	orr.w	r5, r5, r0, lsr #24
   8aac8:	ea4f 2600 	mov.w	r6, r0, lsl #8
   8aacc:	f00e 4100 	and.w	r1, lr, #2147483648	; 0x80000000
   8aad0:	429d      	cmp	r5, r3
   8aad2:	bf08      	it	eq
   8aad4:	4296      	cmpeq	r6, r2
   8aad6:	f144 04fd 	adc.w	r4, r4, #253	; 0xfd
   8aada:	f504 7440 	add.w	r4, r4, #768	; 0x300
   8aade:	d202      	bcs.n	8aae6 <__aeabi_ddiv+0x6e>
   8aae0:	085b      	lsrs	r3, r3, #1
   8aae2:	ea4f 0232 	mov.w	r2, r2, rrx
   8aae6:	1ab6      	subs	r6, r6, r2
   8aae8:	eb65 0503 	sbc.w	r5, r5, r3
   8aaec:	085b      	lsrs	r3, r3, #1
   8aaee:	ea4f 0232 	mov.w	r2, r2, rrx
   8aaf2:	f44f 1080 	mov.w	r0, #1048576	; 0x100000
   8aaf6:	f44f 2c00 	mov.w	ip, #524288	; 0x80000
   8aafa:	ebb6 0e02 	subs.w	lr, r6, r2
   8aafe:	eb75 0e03 	sbcs.w	lr, r5, r3
   8ab02:	bf22      	ittt	cs
   8ab04:	1ab6      	subcs	r6, r6, r2
   8ab06:	4675      	movcs	r5, lr
   8ab08:	ea40 000c 	orrcs.w	r0, r0, ip
   8ab0c:	085b      	lsrs	r3, r3, #1
   8ab0e:	ea4f 0232 	mov.w	r2, r2, rrx
   8ab12:	ebb6 0e02 	subs.w	lr, r6, r2
   8ab16:	eb75 0e03 	sbcs.w	lr, r5, r3
   8ab1a:	bf22      	ittt	cs
   8ab1c:	1ab6      	subcs	r6, r6, r2
   8ab1e:	4675      	movcs	r5, lr
   8ab20:	ea40 005c 	orrcs.w	r0, r0, ip, lsr #1
   8ab24:	085b      	lsrs	r3, r3, #1
   8ab26:	ea4f 0232 	mov.w	r2, r2, rrx
   8ab2a:	ebb6 0e02 	subs.w	lr, r6, r2
   8ab2e:	eb75 0e03 	sbcs.w	lr, r5, r3
   8ab32:	bf22      	ittt	cs
   8ab34:	1ab6      	subcs	r6, r6, r2
   8ab36:	4675      	movcs	r5, lr
   8ab38:	ea40 009c 	orrcs.w	r0, r0, ip, lsr #2
   8ab3c:	085b      	lsrs	r3, r3, #1
   8ab3e:	ea4f 0232 	mov.w	r2, r2, rrx
   8ab42:	ebb6 0e02 	subs.w	lr, r6, r2
   8ab46:	eb75 0e03 	sbcs.w	lr, r5, r3
   8ab4a:	bf22      	ittt	cs
   8ab4c:	1ab6      	subcs	r6, r6, r2
   8ab4e:	4675      	movcs	r5, lr
   8ab50:	ea40 00dc 	orrcs.w	r0, r0, ip, lsr #3
   8ab54:	ea55 0e06 	orrs.w	lr, r5, r6
   8ab58:	d018      	beq.n	8ab8c <__aeabi_ddiv+0x114>
   8ab5a:	ea4f 1505 	mov.w	r5, r5, lsl #4
   8ab5e:	ea45 7516 	orr.w	r5, r5, r6, lsr #28
   8ab62:	ea4f 1606 	mov.w	r6, r6, lsl #4
   8ab66:	ea4f 03c3 	mov.w	r3, r3, lsl #3
   8ab6a:	ea43 7352 	orr.w	r3, r3, r2, lsr #29
   8ab6e:	ea4f 02c2 	mov.w	r2, r2, lsl #3
   8ab72:	ea5f 1c1c 	movs.w	ip, ip, lsr #4
   8ab76:	d1c0      	bne.n	8aafa <__aeabi_ddiv+0x82>
   8ab78:	f411 1f80 	tst.w	r1, #1048576	; 0x100000
   8ab7c:	d10b      	bne.n	8ab96 <__aeabi_ddiv+0x11e>
   8ab7e:	ea41 0100 	orr.w	r1, r1, r0
   8ab82:	f04f 0000 	mov.w	r0, #0
   8ab86:	f04f 4c00 	mov.w	ip, #2147483648	; 0x80000000
   8ab8a:	e7b6      	b.n	8aafa <__aeabi_ddiv+0x82>
   8ab8c:	f411 1f80 	tst.w	r1, #1048576	; 0x100000
   8ab90:	bf04      	itt	eq
   8ab92:	4301      	orreq	r1, r0
   8ab94:	2000      	moveq	r0, #0
   8ab96:	f1b4 0cfd 	subs.w	ip, r4, #253	; 0xfd
   8ab9a:	bf88      	it	hi
   8ab9c:	f5bc 6fe0 	cmphi.w	ip, #1792	; 0x700
   8aba0:	f63f aeaf 	bhi.w	8a902 <__aeabi_dmul+0xde>
   8aba4:	ebb5 0c03 	subs.w	ip, r5, r3
   8aba8:	bf04      	itt	eq
   8abaa:	ebb6 0c02 	subseq.w	ip, r6, r2
   8abae:	ea5f 0c50 	movseq.w	ip, r0, lsr #1
   8abb2:	f150 0000 	adcs.w	r0, r0, #0
   8abb6:	eb41 5104 	adc.w	r1, r1, r4, lsl #20
   8abba:	bd70      	pop	{r4, r5, r6, pc}
   8abbc:	f00e 4e00 	and.w	lr, lr, #2147483648	; 0x80000000
   8abc0:	ea4e 3111 	orr.w	r1, lr, r1, lsr #12
   8abc4:	eb14 045c 	adds.w	r4, r4, ip, lsr #1
   8abc8:	bfc2      	ittt	gt
   8abca:	ebd4 050c 	rsbsgt	r5, r4, ip
   8abce:	ea41 5104 	orrgt.w	r1, r1, r4, lsl #20
   8abd2:	bd70      	popgt	{r4, r5, r6, pc}
   8abd4:	f441 1180 	orr.w	r1, r1, #1048576	; 0x100000
   8abd8:	f04f 0e00 	mov.w	lr, #0
   8abdc:	3c01      	subs	r4, #1
   8abde:	e690      	b.n	8a902 <__aeabi_dmul+0xde>
   8abe0:	ea45 0e06 	orr.w	lr, r5, r6
   8abe4:	e68d      	b.n	8a902 <__aeabi_dmul+0xde>
   8abe6:	ea0c 5513 	and.w	r5, ip, r3, lsr #20
   8abea:	ea94 0f0c 	teq	r4, ip
   8abee:	bf08      	it	eq
   8abf0:	ea95 0f0c 	teqeq	r5, ip
   8abf4:	f43f af3b 	beq.w	8aa6e <__aeabi_dmul+0x24a>
   8abf8:	ea94 0f0c 	teq	r4, ip
   8abfc:	d10a      	bne.n	8ac14 <__aeabi_ddiv+0x19c>
   8abfe:	ea50 3401 	orrs.w	r4, r0, r1, lsl #12
   8ac02:	f47f af34 	bne.w	8aa6e <__aeabi_dmul+0x24a>
   8ac06:	ea95 0f0c 	teq	r5, ip
   8ac0a:	f47f af25 	bne.w	8aa58 <__aeabi_dmul+0x234>
   8ac0e:	4610      	mov	r0, r2
   8ac10:	4619      	mov	r1, r3
   8ac12:	e72c      	b.n	8aa6e <__aeabi_dmul+0x24a>
   8ac14:	ea95 0f0c 	teq	r5, ip
   8ac18:	d106      	bne.n	8ac28 <__aeabi_ddiv+0x1b0>
   8ac1a:	ea52 3503 	orrs.w	r5, r2, r3, lsl #12
   8ac1e:	f43f aefd 	beq.w	8aa1c <__aeabi_dmul+0x1f8>
   8ac22:	4610      	mov	r0, r2
   8ac24:	4619      	mov	r1, r3
   8ac26:	e722      	b.n	8aa6e <__aeabi_dmul+0x24a>
   8ac28:	ea50 0641 	orrs.w	r6, r0, r1, lsl #1
   8ac2c:	bf18      	it	ne
   8ac2e:	ea52 0643 	orrsne.w	r6, r2, r3, lsl #1
   8ac32:	f47f aec5 	bne.w	8a9c0 <__aeabi_dmul+0x19c>
   8ac36:	ea50 0441 	orrs.w	r4, r0, r1, lsl #1
   8ac3a:	f47f af0d 	bne.w	8aa58 <__aeabi_dmul+0x234>
   8ac3e:	ea52 0543 	orrs.w	r5, r2, r3, lsl #1
   8ac42:	f47f aeeb 	bne.w	8aa1c <__aeabi_dmul+0x1f8>
   8ac46:	e712      	b.n	8aa6e <__aeabi_dmul+0x24a>

0008ac48 <__gedf2>:
   8ac48:	f04f 3cff 	mov.w	ip, #4294967295
   8ac4c:	e006      	b.n	8ac5c <__cmpdf2+0x4>
   8ac4e:	bf00      	nop

0008ac50 <__ledf2>:
   8ac50:	f04f 0c01 	mov.w	ip, #1
   8ac54:	e002      	b.n	8ac5c <__cmpdf2+0x4>
   8ac56:	bf00      	nop

0008ac58 <__cmpdf2>:
   8ac58:	f04f 0c01 	mov.w	ip, #1
   8ac5c:	f84d cd04 	str.w	ip, [sp, #-4]!
   8ac60:	ea4f 0c41 	mov.w	ip, r1, lsl #1
   8ac64:	ea7f 5c6c 	mvns.w	ip, ip, asr #21
   8ac68:	ea4f 0c43 	mov.w	ip, r3, lsl #1
   8ac6c:	bf18      	it	ne
   8ac6e:	ea7f 5c6c 	mvnsne.w	ip, ip, asr #21
   8ac72:	d01b      	beq.n	8acac <__cmpdf2+0x54>
   8ac74:	b001      	add	sp, #4
   8ac76:	ea50 0c41 	orrs.w	ip, r0, r1, lsl #1
   8ac7a:	bf0c      	ite	eq
   8ac7c:	ea52 0c43 	orrseq.w	ip, r2, r3, lsl #1
   8ac80:	ea91 0f03 	teqne	r1, r3
   8ac84:	bf02      	ittt	eq
   8ac86:	ea90 0f02 	teqeq	r0, r2
   8ac8a:	2000      	moveq	r0, #0
   8ac8c:	4770      	bxeq	lr
   8ac8e:	f110 0f00 	cmn.w	r0, #0
   8ac92:	ea91 0f03 	teq	r1, r3
   8ac96:	bf58      	it	pl
   8ac98:	4299      	cmppl	r1, r3
   8ac9a:	bf08      	it	eq
   8ac9c:	4290      	cmpeq	r0, r2
   8ac9e:	bf2c      	ite	cs
   8aca0:	17d8      	asrcs	r0, r3, #31
   8aca2:	ea6f 70e3 	mvncc.w	r0, r3, asr #31
   8aca6:	f040 0001 	orr.w	r0, r0, #1
   8acaa:	4770      	bx	lr
   8acac:	ea4f 0c41 	mov.w	ip, r1, lsl #1
   8acb0:	ea7f 5c6c 	mvns.w	ip, ip, asr #21
   8acb4:	d102      	bne.n	8acbc <__cmpdf2+0x64>
   8acb6:	ea50 3c01 	orrs.w	ip, r0, r1, lsl #12
   8acba:	d107      	bne.n	8accc <__cmpdf2+0x74>
   8acbc:	ea4f 0c43 	mov.w	ip, r3, lsl #1
   8acc0:	ea7f 5c6c 	mvns.w	ip, ip, asr #21
   8acc4:	d1d6      	bne.n	8ac74 <__cmpdf2+0x1c>
   8acc6:	ea52 3c03 	orrs.w	ip, r2, r3, lsl #12
   8acca:	d0d3      	beq.n	8ac74 <__cmpdf2+0x1c>
   8accc:	f85d 0b04 	ldr.w	r0, [sp], #4
   8acd0:	4770      	bx	lr
   8acd2:	bf00      	nop

0008acd4 <__aeabi_cdrcmple>:
   8acd4:	4684      	mov	ip, r0
   8acd6:	4610      	mov	r0, r2
   8acd8:	4662      	mov	r2, ip
   8acda:	468c      	mov	ip, r1
   8acdc:	4619      	mov	r1, r3
   8acde:	4663      	mov	r3, ip
   8ace0:	e000      	b.n	8ace4 <__aeabi_cdcmpeq>
   8ace2:	bf00      	nop

0008ace4 <__aeabi_cdcmpeq>:
   8ace4:	b501      	push	{r0, lr}
   8ace6:	f7ff ffb7 	bl	8ac58 <__cmpdf2>
   8acea:	2800      	cmp	r0, #0
   8acec:	bf48      	it	mi
   8acee:	f110 0f00 	cmnmi.w	r0, #0
   8acf2:	bd01      	pop	{r0, pc}

0008acf4 <__aeabi_dcmpeq>:
   8acf4:	f84d ed08 	str.w	lr, [sp, #-8]!
   8acf8:	f7ff fff4 	bl	8ace4 <__aeabi_cdcmpeq>
   8acfc:	bf0c      	ite	eq
   8acfe:	2001      	moveq	r0, #1
   8ad00:	2000      	movne	r0, #0
   8ad02:	f85d fb08 	ldr.w	pc, [sp], #8
   8ad06:	bf00      	nop

0008ad08 <__aeabi_dcmplt>:
   8ad08:	f84d ed08 	str.w	lr, [sp, #-8]!
   8ad0c:	f7ff ffea 	bl	8ace4 <__aeabi_cdcmpeq>
   8ad10:	bf34      	ite	cc
   8ad12:	2001      	movcc	r0, #1
   8ad14:	2000      	movcs	r0, #0
   8ad16:	f85d fb08 	ldr.w	pc, [sp], #8
   8ad1a:	bf00      	nop

0008ad1c <__aeabi_dcmple>:
   8ad1c:	f84d ed08 	str.w	lr, [sp, #-8]!
   8ad20:	f7ff ffe0 	bl	8ace4 <__aeabi_cdcmpeq>
   8ad24:	bf94      	ite	ls
   8ad26:	2001      	movls	r0, #1
   8ad28:	2000      	movhi	r0, #0
   8ad2a:	f85d fb08 	ldr.w	pc, [sp], #8
   8ad2e:	bf00      	nop

0008ad30 <__aeabi_dcmpge>:
   8ad30:	f84d ed08 	str.w	lr, [sp, #-8]!
   8ad34:	f7ff ffce 	bl	8acd4 <__aeabi_cdrcmple>
   8ad38:	bf94      	ite	ls
   8ad3a:	2001      	movls	r0, #1
   8ad3c:	2000      	movhi	r0, #0
   8ad3e:	f85d fb08 	ldr.w	pc, [sp], #8
   8ad42:	bf00      	nop

0008ad44 <__aeabi_dcmpgt>:
   8ad44:	f84d ed08 	str.w	lr, [sp, #-8]!
   8ad48:	f7ff ffc4 	bl	8acd4 <__aeabi_cdrcmple>
   8ad4c:	bf34      	ite	cc
   8ad4e:	2001      	movcc	r0, #1
   8ad50:	2000      	movcs	r0, #0
   8ad52:	f85d fb08 	ldr.w	pc, [sp], #8
   8ad56:	bf00      	nop

0008ad58 <__aeabi_d2iz>:
   8ad58:	ea4f 0241 	mov.w	r2, r1, lsl #1
   8ad5c:	f512 1200 	adds.w	r2, r2, #2097152	; 0x200000
   8ad60:	d215      	bcs.n	8ad8e <__aeabi_d2iz+0x36>
   8ad62:	d511      	bpl.n	8ad88 <__aeabi_d2iz+0x30>
   8ad64:	f46f 7378 	mvn.w	r3, #992	; 0x3e0
   8ad68:	ebb3 5262 	subs.w	r2, r3, r2, asr #21
   8ad6c:	d912      	bls.n	8ad94 <__aeabi_d2iz+0x3c>
   8ad6e:	ea4f 23c1 	mov.w	r3, r1, lsl #11
   8ad72:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
   8ad76:	ea43 5350 	orr.w	r3, r3, r0, lsr #21
   8ad7a:	f011 4f00 	tst.w	r1, #2147483648	; 0x80000000
   8ad7e:	fa23 f002 	lsr.w	r0, r3, r2
   8ad82:	bf18      	it	ne
   8ad84:	4240      	negne	r0, r0
   8ad86:	4770      	bx	lr
   8ad88:	f04f 0000 	mov.w	r0, #0
   8ad8c:	4770      	bx	lr
   8ad8e:	ea50 3001 	orrs.w	r0, r0, r1, lsl #12
   8ad92:	d105      	bne.n	8ada0 <__aeabi_d2iz+0x48>
   8ad94:	f011 4000 	ands.w	r0, r1, #2147483648	; 0x80000000
   8ad98:	bf08      	it	eq
   8ad9a:	f06f 4000 	mvneq.w	r0, #2147483648	; 0x80000000
   8ad9e:	4770      	bx	lr
   8ada0:	f04f 0000 	mov.w	r0, #0
   8ada4:	4770      	bx	lr
   8ada6:	bf00      	nop

0008ada8 <__aeabi_uldivmod>:
   8ada8:	b94b      	cbnz	r3, 8adbe <__aeabi_uldivmod+0x16>
   8adaa:	b942      	cbnz	r2, 8adbe <__aeabi_uldivmod+0x16>
   8adac:	2900      	cmp	r1, #0
   8adae:	bf08      	it	eq
   8adb0:	2800      	cmpeq	r0, #0
   8adb2:	d002      	beq.n	8adba <__aeabi_uldivmod+0x12>
   8adb4:	f04f 31ff 	mov.w	r1, #4294967295
   8adb8:	4608      	mov	r0, r1
   8adba:	f000 b83b 	b.w	8ae34 <__aeabi_idiv0>
   8adbe:	b082      	sub	sp, #8
   8adc0:	46ec      	mov	ip, sp
   8adc2:	e92d 5000 	stmdb	sp!, {ip, lr}
   8adc6:	f000 f81d 	bl	8ae04 <__gnu_uldivmod_helper>
   8adca:	f8dd e004 	ldr.w	lr, [sp, #4]
   8adce:	b002      	add	sp, #8
   8add0:	bc0c      	pop	{r2, r3}
   8add2:	4770      	bx	lr

0008add4 <__gnu_ldivmod_helper>:
   8add4:	e92d 4f70 	stmdb	sp!, {r4, r5, r6, r8, r9, sl, fp, lr}
   8add8:	9e08      	ldr	r6, [sp, #32]
   8adda:	4614      	mov	r4, r2
   8addc:	461d      	mov	r5, r3
   8adde:	4680      	mov	r8, r0
   8ade0:	4689      	mov	r9, r1
   8ade2:	f000 f829 	bl	8ae38 <__divdi3>
   8ade6:	fb04 f301 	mul.w	r3, r4, r1
   8adea:	fba4 ab00 	umull	sl, fp, r4, r0
   8adee:	fb00 3205 	mla	r2, r0, r5, r3
   8adf2:	4493      	add	fp, r2
   8adf4:	ebb8 080a 	subs.w	r8, r8, sl
   8adf8:	eb69 090b 	sbc.w	r9, r9, fp
   8adfc:	e9c6 8900 	strd	r8, r9, [r6]
   8ae00:	e8bd 8f70 	ldmia.w	sp!, {r4, r5, r6, r8, r9, sl, fp, pc}

0008ae04 <__gnu_uldivmod_helper>:
   8ae04:	e92d 4f70 	stmdb	sp!, {r4, r5, r6, r8, r9, sl, fp, lr}
   8ae08:	9e08      	ldr	r6, [sp, #32]
   8ae0a:	4614      	mov	r4, r2
   8ae0c:	461d      	mov	r5, r3
   8ae0e:	4680      	mov	r8, r0
   8ae10:	4689      	mov	r9, r1
   8ae12:	f000 f961 	bl	8b0d8 <__udivdi3>
   8ae16:	fb00 f505 	mul.w	r5, r0, r5
   8ae1a:	fba0 ab04 	umull	sl, fp, r0, r4
   8ae1e:	fb04 5401 	mla	r4, r4, r1, r5
   8ae22:	44a3      	add	fp, r4
   8ae24:	ebb8 080a 	subs.w	r8, r8, sl
   8ae28:	eb69 090b 	sbc.w	r9, r9, fp
   8ae2c:	e9c6 8900 	strd	r8, r9, [r6]
   8ae30:	e8bd 8f70 	ldmia.w	sp!, {r4, r5, r6, r8, r9, sl, fp, pc}

0008ae34 <__aeabi_idiv0>:
   8ae34:	4770      	bx	lr
   8ae36:	bf00      	nop

0008ae38 <__divdi3>:
   8ae38:	2900      	cmp	r1, #0
   8ae3a:	e92d 0ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp}
   8ae3e:	f2c0 80a1 	blt.w	8af84 <__divdi3+0x14c>
   8ae42:	2400      	movs	r4, #0
   8ae44:	2b00      	cmp	r3, #0
   8ae46:	f2c0 8098 	blt.w	8af7a <__divdi3+0x142>
   8ae4a:	4615      	mov	r5, r2
   8ae4c:	4606      	mov	r6, r0
   8ae4e:	460f      	mov	r7, r1
   8ae50:	2b00      	cmp	r3, #0
   8ae52:	d13f      	bne.n	8aed4 <__divdi3+0x9c>
   8ae54:	428a      	cmp	r2, r1
   8ae56:	d958      	bls.n	8af0a <__divdi3+0xd2>
   8ae58:	fab2 f382 	clz	r3, r2
   8ae5c:	b14b      	cbz	r3, 8ae72 <__divdi3+0x3a>
   8ae5e:	f1c3 0220 	rsb	r2, r3, #32
   8ae62:	fa01 f703 	lsl.w	r7, r1, r3
   8ae66:	fa20 f202 	lsr.w	r2, r0, r2
   8ae6a:	409d      	lsls	r5, r3
   8ae6c:	fa00 f603 	lsl.w	r6, r0, r3
   8ae70:	4317      	orrs	r7, r2
   8ae72:	0c29      	lsrs	r1, r5, #16
   8ae74:	fbb7 f2f1 	udiv	r2, r7, r1
   8ae78:	fb01 7712 	mls	r7, r1, r2, r7
   8ae7c:	b2a8      	uxth	r0, r5
   8ae7e:	fb00 f302 	mul.w	r3, r0, r2
   8ae82:	ea4f 4c16 	mov.w	ip, r6, lsr #16
   8ae86:	ea4c 4707 	orr.w	r7, ip, r7, lsl #16
   8ae8a:	42bb      	cmp	r3, r7
   8ae8c:	d909      	bls.n	8aea2 <__divdi3+0x6a>
   8ae8e:	197f      	adds	r7, r7, r5
   8ae90:	f102 3cff 	add.w	ip, r2, #4294967295
   8ae94:	f080 8105 	bcs.w	8b0a2 <__divdi3+0x26a>
   8ae98:	42bb      	cmp	r3, r7
   8ae9a:	f240 8102 	bls.w	8b0a2 <__divdi3+0x26a>
   8ae9e:	3a02      	subs	r2, #2
   8aea0:	442f      	add	r7, r5
   8aea2:	1aff      	subs	r7, r7, r3
   8aea4:	fbb7 f3f1 	udiv	r3, r7, r1
   8aea8:	fb01 7113 	mls	r1, r1, r3, r7
   8aeac:	fb00 f003 	mul.w	r0, r0, r3
   8aeb0:	b2b6      	uxth	r6, r6
   8aeb2:	ea46 4101 	orr.w	r1, r6, r1, lsl #16
   8aeb6:	4288      	cmp	r0, r1
   8aeb8:	d908      	bls.n	8aecc <__divdi3+0x94>
   8aeba:	1949      	adds	r1, r1, r5
   8aebc:	f103 37ff 	add.w	r7, r3, #4294967295
   8aec0:	f080 80f1 	bcs.w	8b0a6 <__divdi3+0x26e>
   8aec4:	4288      	cmp	r0, r1
   8aec6:	f240 80ee 	bls.w	8b0a6 <__divdi3+0x26e>
   8aeca:	3b02      	subs	r3, #2
   8aecc:	ea43 4202 	orr.w	r2, r3, r2, lsl #16
   8aed0:	2300      	movs	r3, #0
   8aed2:	e003      	b.n	8aedc <__divdi3+0xa4>
   8aed4:	428b      	cmp	r3, r1
   8aed6:	d90a      	bls.n	8aeee <__divdi3+0xb6>
   8aed8:	2300      	movs	r3, #0
   8aeda:	461a      	mov	r2, r3
   8aedc:	4610      	mov	r0, r2
   8aede:	4619      	mov	r1, r3
   8aee0:	b114      	cbz	r4, 8aee8 <__divdi3+0xb0>
   8aee2:	4240      	negs	r0, r0
   8aee4:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
   8aee8:	e8bd 0ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp}
   8aeec:	4770      	bx	lr
   8aeee:	fab3 f883 	clz	r8, r3
   8aef2:	f1b8 0f00 	cmp.w	r8, #0
   8aef6:	f040 8088 	bne.w	8b00a <__divdi3+0x1d2>
   8aefa:	428b      	cmp	r3, r1
   8aefc:	d302      	bcc.n	8af04 <__divdi3+0xcc>
   8aefe:	4282      	cmp	r2, r0
   8af00:	f200 80e2 	bhi.w	8b0c8 <__divdi3+0x290>
   8af04:	2300      	movs	r3, #0
   8af06:	2201      	movs	r2, #1
   8af08:	e7e8      	b.n	8aedc <__divdi3+0xa4>
   8af0a:	b912      	cbnz	r2, 8af12 <__divdi3+0xda>
   8af0c:	2301      	movs	r3, #1
   8af0e:	fbb3 f5f2 	udiv	r5, r3, r2
   8af12:	fab5 f285 	clz	r2, r5
   8af16:	2a00      	cmp	r2, #0
   8af18:	d13a      	bne.n	8af90 <__divdi3+0x158>
   8af1a:	1b7f      	subs	r7, r7, r5
   8af1c:	0c28      	lsrs	r0, r5, #16
   8af1e:	fa1f fc85 	uxth.w	ip, r5
   8af22:	2301      	movs	r3, #1
   8af24:	fbb7 f1f0 	udiv	r1, r7, r0
   8af28:	fb00 7711 	mls	r7, r0, r1, r7
   8af2c:	fb0c f201 	mul.w	r2, ip, r1
   8af30:	ea4f 4816 	mov.w	r8, r6, lsr #16
   8af34:	ea48 4707 	orr.w	r7, r8, r7, lsl #16
   8af38:	42ba      	cmp	r2, r7
   8af3a:	d907      	bls.n	8af4c <__divdi3+0x114>
   8af3c:	197f      	adds	r7, r7, r5
   8af3e:	f101 38ff 	add.w	r8, r1, #4294967295
   8af42:	d202      	bcs.n	8af4a <__divdi3+0x112>
   8af44:	42ba      	cmp	r2, r7
   8af46:	f200 80c4 	bhi.w	8b0d2 <__divdi3+0x29a>
   8af4a:	4641      	mov	r1, r8
   8af4c:	1abf      	subs	r7, r7, r2
   8af4e:	fbb7 f2f0 	udiv	r2, r7, r0
   8af52:	fb00 7012 	mls	r0, r0, r2, r7
   8af56:	fb0c fc02 	mul.w	ip, ip, r2
   8af5a:	b2b6      	uxth	r6, r6
   8af5c:	ea46 4000 	orr.w	r0, r6, r0, lsl #16
   8af60:	4584      	cmp	ip, r0
   8af62:	d907      	bls.n	8af74 <__divdi3+0x13c>
   8af64:	1940      	adds	r0, r0, r5
   8af66:	f102 37ff 	add.w	r7, r2, #4294967295
   8af6a:	d202      	bcs.n	8af72 <__divdi3+0x13a>
   8af6c:	4584      	cmp	ip, r0
   8af6e:	f200 80ae 	bhi.w	8b0ce <__divdi3+0x296>
   8af72:	463a      	mov	r2, r7
   8af74:	ea42 4201 	orr.w	r2, r2, r1, lsl #16
   8af78:	e7b0      	b.n	8aedc <__divdi3+0xa4>
   8af7a:	43e4      	mvns	r4, r4
   8af7c:	4252      	negs	r2, r2
   8af7e:	eb63 0343 	sbc.w	r3, r3, r3, lsl #1
   8af82:	e762      	b.n	8ae4a <__divdi3+0x12>
   8af84:	4240      	negs	r0, r0
   8af86:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
   8af8a:	f04f 34ff 	mov.w	r4, #4294967295
   8af8e:	e759      	b.n	8ae44 <__divdi3+0xc>
   8af90:	4095      	lsls	r5, r2
   8af92:	f1c2 0920 	rsb	r9, r2, #32
   8af96:	fa27 f109 	lsr.w	r1, r7, r9
   8af9a:	fa26 f909 	lsr.w	r9, r6, r9
   8af9e:	4097      	lsls	r7, r2
   8afa0:	0c28      	lsrs	r0, r5, #16
   8afa2:	fbb1 f8f0 	udiv	r8, r1, r0
   8afa6:	fb00 1118 	mls	r1, r0, r8, r1
   8afaa:	fa1f fc85 	uxth.w	ip, r5
   8afae:	fb0c f308 	mul.w	r3, ip, r8
   8afb2:	ea49 0907 	orr.w	r9, r9, r7
   8afb6:	ea4f 4719 	mov.w	r7, r9, lsr #16
   8afba:	ea47 4101 	orr.w	r1, r7, r1, lsl #16
   8afbe:	428b      	cmp	r3, r1
   8afc0:	fa06 f602 	lsl.w	r6, r6, r2
   8afc4:	d908      	bls.n	8afd8 <__divdi3+0x1a0>
   8afc6:	1949      	adds	r1, r1, r5
   8afc8:	f108 32ff 	add.w	r2, r8, #4294967295
   8afcc:	d27a      	bcs.n	8b0c4 <__divdi3+0x28c>
   8afce:	428b      	cmp	r3, r1
   8afd0:	d978      	bls.n	8b0c4 <__divdi3+0x28c>
   8afd2:	f1a8 0802 	sub.w	r8, r8, #2
   8afd6:	4429      	add	r1, r5
   8afd8:	1ac9      	subs	r1, r1, r3
   8afda:	fbb1 f3f0 	udiv	r3, r1, r0
   8afde:	fb00 1713 	mls	r7, r0, r3, r1
   8afe2:	fb0c f203 	mul.w	r2, ip, r3
   8afe6:	fa1f f989 	uxth.w	r9, r9
   8afea:	ea49 4707 	orr.w	r7, r9, r7, lsl #16
   8afee:	42ba      	cmp	r2, r7
   8aff0:	d907      	bls.n	8b002 <__divdi3+0x1ca>
   8aff2:	197f      	adds	r7, r7, r5
   8aff4:	f103 31ff 	add.w	r1, r3, #4294967295
   8aff8:	d260      	bcs.n	8b0bc <__divdi3+0x284>
   8affa:	42ba      	cmp	r2, r7
   8affc:	d95e      	bls.n	8b0bc <__divdi3+0x284>
   8affe:	3b02      	subs	r3, #2
   8b000:	442f      	add	r7, r5
   8b002:	1abf      	subs	r7, r7, r2
   8b004:	ea43 4308 	orr.w	r3, r3, r8, lsl #16
   8b008:	e78c      	b.n	8af24 <__divdi3+0xec>
   8b00a:	f1c8 0220 	rsb	r2, r8, #32
   8b00e:	fa25 f102 	lsr.w	r1, r5, r2
   8b012:	fa03 fc08 	lsl.w	ip, r3, r8
   8b016:	fa27 f302 	lsr.w	r3, r7, r2
   8b01a:	fa20 f202 	lsr.w	r2, r0, r2
   8b01e:	fa07 f708 	lsl.w	r7, r7, r8
   8b022:	ea41 0c0c 	orr.w	ip, r1, ip
   8b026:	ea4f 491c 	mov.w	r9, ip, lsr #16
   8b02a:	fbb3 f1f9 	udiv	r1, r3, r9
   8b02e:	fb09 3311 	mls	r3, r9, r1, r3
   8b032:	fa1f fa8c 	uxth.w	sl, ip
   8b036:	fb0a fb01 	mul.w	fp, sl, r1
   8b03a:	4317      	orrs	r7, r2
   8b03c:	0c3a      	lsrs	r2, r7, #16
   8b03e:	ea42 4303 	orr.w	r3, r2, r3, lsl #16
   8b042:	459b      	cmp	fp, r3
   8b044:	fa05 f008 	lsl.w	r0, r5, r8
   8b048:	d908      	bls.n	8b05c <__divdi3+0x224>
   8b04a:	eb13 030c 	adds.w	r3, r3, ip
   8b04e:	f101 32ff 	add.w	r2, r1, #4294967295
   8b052:	d235      	bcs.n	8b0c0 <__divdi3+0x288>
   8b054:	459b      	cmp	fp, r3
   8b056:	d933      	bls.n	8b0c0 <__divdi3+0x288>
   8b058:	3902      	subs	r1, #2
   8b05a:	4463      	add	r3, ip
   8b05c:	ebcb 0303 	rsb	r3, fp, r3
   8b060:	fbb3 f2f9 	udiv	r2, r3, r9
   8b064:	fb09 3312 	mls	r3, r9, r2, r3
   8b068:	fb0a fa02 	mul.w	sl, sl, r2
   8b06c:	b2bf      	uxth	r7, r7
   8b06e:	ea47 4703 	orr.w	r7, r7, r3, lsl #16
   8b072:	45ba      	cmp	sl, r7
   8b074:	d908      	bls.n	8b088 <__divdi3+0x250>
   8b076:	eb17 070c 	adds.w	r7, r7, ip
   8b07a:	f102 33ff 	add.w	r3, r2, #4294967295
   8b07e:	d21b      	bcs.n	8b0b8 <__divdi3+0x280>
   8b080:	45ba      	cmp	sl, r7
   8b082:	d919      	bls.n	8b0b8 <__divdi3+0x280>
   8b084:	3a02      	subs	r2, #2
   8b086:	4467      	add	r7, ip
   8b088:	ea42 4501 	orr.w	r5, r2, r1, lsl #16
   8b08c:	fba5 0100 	umull	r0, r1, r5, r0
   8b090:	ebca 0707 	rsb	r7, sl, r7
   8b094:	428f      	cmp	r7, r1
   8b096:	f04f 0300 	mov.w	r3, #0
   8b09a:	d30a      	bcc.n	8b0b2 <__divdi3+0x27a>
   8b09c:	d005      	beq.n	8b0aa <__divdi3+0x272>
   8b09e:	462a      	mov	r2, r5
   8b0a0:	e71c      	b.n	8aedc <__divdi3+0xa4>
   8b0a2:	4662      	mov	r2, ip
   8b0a4:	e6fd      	b.n	8aea2 <__divdi3+0x6a>
   8b0a6:	463b      	mov	r3, r7
   8b0a8:	e710      	b.n	8aecc <__divdi3+0x94>
   8b0aa:	fa06 f608 	lsl.w	r6, r6, r8
   8b0ae:	4286      	cmp	r6, r0
   8b0b0:	d2f5      	bcs.n	8b09e <__divdi3+0x266>
   8b0b2:	1e6a      	subs	r2, r5, #1
   8b0b4:	2300      	movs	r3, #0
   8b0b6:	e711      	b.n	8aedc <__divdi3+0xa4>
   8b0b8:	461a      	mov	r2, r3
   8b0ba:	e7e5      	b.n	8b088 <__divdi3+0x250>
   8b0bc:	460b      	mov	r3, r1
   8b0be:	e7a0      	b.n	8b002 <__divdi3+0x1ca>
   8b0c0:	4611      	mov	r1, r2
   8b0c2:	e7cb      	b.n	8b05c <__divdi3+0x224>
   8b0c4:	4690      	mov	r8, r2
   8b0c6:	e787      	b.n	8afd8 <__divdi3+0x1a0>
   8b0c8:	4643      	mov	r3, r8
   8b0ca:	4642      	mov	r2, r8
   8b0cc:	e706      	b.n	8aedc <__divdi3+0xa4>
   8b0ce:	3a02      	subs	r2, #2
   8b0d0:	e750      	b.n	8af74 <__divdi3+0x13c>
   8b0d2:	3902      	subs	r1, #2
   8b0d4:	442f      	add	r7, r5
   8b0d6:	e739      	b.n	8af4c <__divdi3+0x114>

0008b0d8 <__udivdi3>:
   8b0d8:	e92d 0ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp}
   8b0dc:	4614      	mov	r4, r2
   8b0de:	4605      	mov	r5, r0
   8b0e0:	460e      	mov	r6, r1
   8b0e2:	2b00      	cmp	r3, #0
   8b0e4:	d143      	bne.n	8b16e <__udivdi3+0x96>
   8b0e6:	428a      	cmp	r2, r1
   8b0e8:	d953      	bls.n	8b192 <__udivdi3+0xba>
   8b0ea:	fab2 f782 	clz	r7, r2
   8b0ee:	b157      	cbz	r7, 8b106 <__udivdi3+0x2e>
   8b0f0:	f1c7 0620 	rsb	r6, r7, #32
   8b0f4:	fa20 f606 	lsr.w	r6, r0, r6
   8b0f8:	fa01 f307 	lsl.w	r3, r1, r7
   8b0fc:	fa02 f407 	lsl.w	r4, r2, r7
   8b100:	fa00 f507 	lsl.w	r5, r0, r7
   8b104:	431e      	orrs	r6, r3
   8b106:	0c21      	lsrs	r1, r4, #16
   8b108:	fbb6 f2f1 	udiv	r2, r6, r1
   8b10c:	fb01 6612 	mls	r6, r1, r2, r6
   8b110:	b2a0      	uxth	r0, r4
   8b112:	fb00 f302 	mul.w	r3, r0, r2
   8b116:	0c2f      	lsrs	r7, r5, #16
   8b118:	ea47 4606 	orr.w	r6, r7, r6, lsl #16
   8b11c:	42b3      	cmp	r3, r6
   8b11e:	d909      	bls.n	8b134 <__udivdi3+0x5c>
   8b120:	1936      	adds	r6, r6, r4
   8b122:	f102 37ff 	add.w	r7, r2, #4294967295
   8b126:	f080 80fd 	bcs.w	8b324 <__udivdi3+0x24c>
   8b12a:	42b3      	cmp	r3, r6
   8b12c:	f240 80fa 	bls.w	8b324 <__udivdi3+0x24c>
   8b130:	3a02      	subs	r2, #2
   8b132:	4426      	add	r6, r4
   8b134:	1af6      	subs	r6, r6, r3
   8b136:	fbb6 f3f1 	udiv	r3, r6, r1
   8b13a:	fb01 6113 	mls	r1, r1, r3, r6
   8b13e:	fb00 f003 	mul.w	r0, r0, r3
   8b142:	b2ad      	uxth	r5, r5
   8b144:	ea45 4101 	orr.w	r1, r5, r1, lsl #16
   8b148:	4288      	cmp	r0, r1
   8b14a:	d908      	bls.n	8b15e <__udivdi3+0x86>
   8b14c:	1909      	adds	r1, r1, r4
   8b14e:	f103 36ff 	add.w	r6, r3, #4294967295
   8b152:	f080 80e9 	bcs.w	8b328 <__udivdi3+0x250>
   8b156:	4288      	cmp	r0, r1
   8b158:	f240 80e6 	bls.w	8b328 <__udivdi3+0x250>
   8b15c:	3b02      	subs	r3, #2
   8b15e:	ea43 4202 	orr.w	r2, r3, r2, lsl #16
   8b162:	2300      	movs	r3, #0
   8b164:	4610      	mov	r0, r2
   8b166:	4619      	mov	r1, r3
   8b168:	e8bd 0ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp}
   8b16c:	4770      	bx	lr
   8b16e:	428b      	cmp	r3, r1
   8b170:	d84c      	bhi.n	8b20c <__udivdi3+0x134>
   8b172:	fab3 f683 	clz	r6, r3
   8b176:	2e00      	cmp	r6, #0
   8b178:	d14f      	bne.n	8b21a <__udivdi3+0x142>
   8b17a:	428b      	cmp	r3, r1
   8b17c:	d302      	bcc.n	8b184 <__udivdi3+0xac>
   8b17e:	4282      	cmp	r2, r0
   8b180:	f200 80dd 	bhi.w	8b33e <__udivdi3+0x266>
   8b184:	e8bd 0ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp}
   8b188:	2300      	movs	r3, #0
   8b18a:	2201      	movs	r2, #1
   8b18c:	4610      	mov	r0, r2
   8b18e:	4619      	mov	r1, r3
   8b190:	4770      	bx	lr
   8b192:	b912      	cbnz	r2, 8b19a <__udivdi3+0xc2>
   8b194:	2401      	movs	r4, #1
   8b196:	fbb4 f4f2 	udiv	r4, r4, r2
   8b19a:	fab4 f284 	clz	r2, r4
   8b19e:	2a00      	cmp	r2, #0
   8b1a0:	f040 8082 	bne.w	8b2a8 <__udivdi3+0x1d0>
   8b1a4:	1b09      	subs	r1, r1, r4
   8b1a6:	0c26      	lsrs	r6, r4, #16
   8b1a8:	b2a7      	uxth	r7, r4
   8b1aa:	2301      	movs	r3, #1
   8b1ac:	fbb1 f0f6 	udiv	r0, r1, r6
   8b1b0:	fb06 1110 	mls	r1, r6, r0, r1
   8b1b4:	fb07 f200 	mul.w	r2, r7, r0
   8b1b8:	ea4f 4c15 	mov.w	ip, r5, lsr #16
   8b1bc:	ea4c 4101 	orr.w	r1, ip, r1, lsl #16
   8b1c0:	428a      	cmp	r2, r1
   8b1c2:	d907      	bls.n	8b1d4 <__udivdi3+0xfc>
   8b1c4:	1909      	adds	r1, r1, r4
   8b1c6:	f100 3cff 	add.w	ip, r0, #4294967295
   8b1ca:	d202      	bcs.n	8b1d2 <__udivdi3+0xfa>
   8b1cc:	428a      	cmp	r2, r1
   8b1ce:	f200 80c8 	bhi.w	8b362 <__udivdi3+0x28a>
   8b1d2:	4660      	mov	r0, ip
   8b1d4:	1a89      	subs	r1, r1, r2
   8b1d6:	fbb1 f2f6 	udiv	r2, r1, r6
   8b1da:	fb06 1112 	mls	r1, r6, r2, r1
   8b1de:	fb07 f702 	mul.w	r7, r7, r2
   8b1e2:	b2ad      	uxth	r5, r5
   8b1e4:	ea45 4501 	orr.w	r5, r5, r1, lsl #16
   8b1e8:	42af      	cmp	r7, r5
   8b1ea:	d908      	bls.n	8b1fe <__udivdi3+0x126>
   8b1ec:	192c      	adds	r4, r5, r4
   8b1ee:	f102 31ff 	add.w	r1, r2, #4294967295
   8b1f2:	f080 809b 	bcs.w	8b32c <__udivdi3+0x254>
   8b1f6:	42a7      	cmp	r7, r4
   8b1f8:	f240 8098 	bls.w	8b32c <__udivdi3+0x254>
   8b1fc:	3a02      	subs	r2, #2
   8b1fe:	ea42 4200 	orr.w	r2, r2, r0, lsl #16
   8b202:	4610      	mov	r0, r2
   8b204:	4619      	mov	r1, r3
   8b206:	e8bd 0ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp}
   8b20a:	4770      	bx	lr
   8b20c:	2300      	movs	r3, #0
   8b20e:	461a      	mov	r2, r3
   8b210:	4610      	mov	r0, r2
   8b212:	4619      	mov	r1, r3
   8b214:	e8bd 0ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp}
   8b218:	4770      	bx	lr
   8b21a:	f1c6 0520 	rsb	r5, r6, #32
   8b21e:	fa22 f705 	lsr.w	r7, r2, r5
   8b222:	fa03 f406 	lsl.w	r4, r3, r6
   8b226:	fa21 f305 	lsr.w	r3, r1, r5
   8b22a:	fa01 fb06 	lsl.w	fp, r1, r6
   8b22e:	fa20 f505 	lsr.w	r5, r0, r5
   8b232:	433c      	orrs	r4, r7
   8b234:	ea4f 4814 	mov.w	r8, r4, lsr #16
   8b238:	fbb3 fcf8 	udiv	ip, r3, r8
   8b23c:	fb08 331c 	mls	r3, r8, ip, r3
   8b240:	fa1f f984 	uxth.w	r9, r4
   8b244:	fb09 fa0c 	mul.w	sl, r9, ip
   8b248:	ea45 0b0b 	orr.w	fp, r5, fp
   8b24c:	ea4f 451b 	mov.w	r5, fp, lsr #16
   8b250:	ea45 4303 	orr.w	r3, r5, r3, lsl #16
   8b254:	459a      	cmp	sl, r3
   8b256:	fa02 f206 	lsl.w	r2, r2, r6
   8b25a:	d904      	bls.n	8b266 <__udivdi3+0x18e>
   8b25c:	191b      	adds	r3, r3, r4
   8b25e:	f10c 35ff 	add.w	r5, ip, #4294967295
   8b262:	d36f      	bcc.n	8b344 <__udivdi3+0x26c>
   8b264:	46ac      	mov	ip, r5
   8b266:	ebca 0303 	rsb	r3, sl, r3
   8b26a:	fbb3 f5f8 	udiv	r5, r3, r8
   8b26e:	fb08 3315 	mls	r3, r8, r5, r3
   8b272:	fb09 f905 	mul.w	r9, r9, r5
   8b276:	fa1f fb8b 	uxth.w	fp, fp
   8b27a:	ea4b 4703 	orr.w	r7, fp, r3, lsl #16
   8b27e:	45b9      	cmp	r9, r7
   8b280:	d904      	bls.n	8b28c <__udivdi3+0x1b4>
   8b282:	193f      	adds	r7, r7, r4
   8b284:	f105 33ff 	add.w	r3, r5, #4294967295
   8b288:	d362      	bcc.n	8b350 <__udivdi3+0x278>
   8b28a:	461d      	mov	r5, r3
   8b28c:	ea45 4c0c 	orr.w	ip, r5, ip, lsl #16
   8b290:	fbac 2302 	umull	r2, r3, ip, r2
   8b294:	ebc9 0707 	rsb	r7, r9, r7
   8b298:	429f      	cmp	r7, r3
   8b29a:	f04f 0500 	mov.w	r5, #0
   8b29e:	d34a      	bcc.n	8b336 <__udivdi3+0x25e>
   8b2a0:	d046      	beq.n	8b330 <__udivdi3+0x258>
   8b2a2:	4662      	mov	r2, ip
   8b2a4:	462b      	mov	r3, r5
   8b2a6:	e75d      	b.n	8b164 <__udivdi3+0x8c>
   8b2a8:	4094      	lsls	r4, r2
   8b2aa:	f1c2 0920 	rsb	r9, r2, #32
   8b2ae:	fa21 fc09 	lsr.w	ip, r1, r9
   8b2b2:	4091      	lsls	r1, r2
   8b2b4:	fa20 f909 	lsr.w	r9, r0, r9
   8b2b8:	0c26      	lsrs	r6, r4, #16
   8b2ba:	fbbc f8f6 	udiv	r8, ip, r6
   8b2be:	fb06 cc18 	mls	ip, r6, r8, ip
   8b2c2:	b2a7      	uxth	r7, r4
   8b2c4:	fb07 f308 	mul.w	r3, r7, r8
   8b2c8:	ea49 0901 	orr.w	r9, r9, r1
   8b2cc:	ea4f 4119 	mov.w	r1, r9, lsr #16
   8b2d0:	ea41 4c0c 	orr.w	ip, r1, ip, lsl #16
   8b2d4:	4563      	cmp	r3, ip
   8b2d6:	fa00 f502 	lsl.w	r5, r0, r2
   8b2da:	d909      	bls.n	8b2f0 <__udivdi3+0x218>
   8b2dc:	eb1c 0c04 	adds.w	ip, ip, r4
   8b2e0:	f108 32ff 	add.w	r2, r8, #4294967295
   8b2e4:	d23b      	bcs.n	8b35e <__udivdi3+0x286>
   8b2e6:	4563      	cmp	r3, ip
   8b2e8:	d939      	bls.n	8b35e <__udivdi3+0x286>
   8b2ea:	f1a8 0802 	sub.w	r8, r8, #2
   8b2ee:	44a4      	add	ip, r4
   8b2f0:	ebc3 0c0c 	rsb	ip, r3, ip
   8b2f4:	fbbc f3f6 	udiv	r3, ip, r6
   8b2f8:	fb06 c113 	mls	r1, r6, r3, ip
   8b2fc:	fb07 f203 	mul.w	r2, r7, r3
   8b300:	fa1f f989 	uxth.w	r9, r9
   8b304:	ea49 4101 	orr.w	r1, r9, r1, lsl #16
   8b308:	428a      	cmp	r2, r1
   8b30a:	d907      	bls.n	8b31c <__udivdi3+0x244>
   8b30c:	1909      	adds	r1, r1, r4
   8b30e:	f103 30ff 	add.w	r0, r3, #4294967295
   8b312:	d222      	bcs.n	8b35a <__udivdi3+0x282>
   8b314:	428a      	cmp	r2, r1
   8b316:	d920      	bls.n	8b35a <__udivdi3+0x282>
   8b318:	3b02      	subs	r3, #2
   8b31a:	4421      	add	r1, r4
   8b31c:	1a89      	subs	r1, r1, r2
   8b31e:	ea43 4308 	orr.w	r3, r3, r8, lsl #16
   8b322:	e743      	b.n	8b1ac <__udivdi3+0xd4>
   8b324:	463a      	mov	r2, r7
   8b326:	e705      	b.n	8b134 <__udivdi3+0x5c>
   8b328:	4633      	mov	r3, r6
   8b32a:	e718      	b.n	8b15e <__udivdi3+0x86>
   8b32c:	460a      	mov	r2, r1
   8b32e:	e766      	b.n	8b1fe <__udivdi3+0x126>
   8b330:	40b0      	lsls	r0, r6
   8b332:	4290      	cmp	r0, r2
   8b334:	d2b5      	bcs.n	8b2a2 <__udivdi3+0x1ca>
   8b336:	f10c 32ff 	add.w	r2, ip, #4294967295
   8b33a:	2300      	movs	r3, #0
   8b33c:	e712      	b.n	8b164 <__udivdi3+0x8c>
   8b33e:	4633      	mov	r3, r6
   8b340:	4632      	mov	r2, r6
   8b342:	e70f      	b.n	8b164 <__udivdi3+0x8c>
   8b344:	459a      	cmp	sl, r3
   8b346:	d98d      	bls.n	8b264 <__udivdi3+0x18c>
   8b348:	f1ac 0c02 	sub.w	ip, ip, #2
   8b34c:	4423      	add	r3, r4
   8b34e:	e78a      	b.n	8b266 <__udivdi3+0x18e>
   8b350:	45b9      	cmp	r9, r7
   8b352:	d99a      	bls.n	8b28a <__udivdi3+0x1b2>
   8b354:	3d02      	subs	r5, #2
   8b356:	4427      	add	r7, r4
   8b358:	e798      	b.n	8b28c <__udivdi3+0x1b4>
   8b35a:	4603      	mov	r3, r0
   8b35c:	e7de      	b.n	8b31c <__udivdi3+0x244>
   8b35e:	4690      	mov	r8, r2
   8b360:	e7c6      	b.n	8b2f0 <__udivdi3+0x218>
   8b362:	3802      	subs	r0, #2
   8b364:	4421      	add	r1, r4
   8b366:	e735      	b.n	8b1d4 <__udivdi3+0xfc>
   8b368:	732f2e2e 	.word	0x732f2e2e
   8b36c:	412f6372 	.word	0x412f6372
   8b370:	632f4653 	.word	0x632f4653
   8b374:	6f6d6d6f 	.word	0x6f6d6d6f
   8b378:	65732f6e 	.word	0x65732f6e
   8b37c:	63697672 	.word	0x63697672
   8b380:	662f7365 	.word	0x662f7365
   8b384:	72656572 	.word	0x72656572
   8b388:	2f736f74 	.word	0x2f736f74
   8b38c:	2f6d6173 	.word	0x2f6d6173
   8b390:	65657266 	.word	0x65657266
   8b394:	736f7472 	.word	0x736f7472
   8b398:	7265705f 	.word	0x7265705f
   8b39c:	65687069 	.word	0x65687069
   8b3a0:	5f6c6172 	.word	0x5f6c6172
   8b3a4:	746e6f63 	.word	0x746e6f63
   8b3a8:	2e6c6f72 	.word	0x2e6c6f72
   8b3ac:	00000063 	.word	0x00000063

0008b3b0 <all_twi_definitions>:
   8b3b0:	4008c000 4008c100 00000016 00000016     ...@...@........
   8b3c0:	40090000 40090100 00000017 00000017     ...@...@........
   8b3d0:	732f2e2e 412f6372 632f4653 6f6d6d6f     ../src/ASF/commo
   8b3e0:	65732f6e 63697672 662f7365 72656572     n/services/freer
   8b3f0:	2f736f74 2f6d6173 65657266 736f7472     tos/sam/freertos
   8b400:	7261755f 65735f74 6c616972 0000632e     _uart_serial.c..

0008b410 <all_uart_definitions>:
   8b410:	400e0800 400e0900 00000008 00000008     ...@...@........
   8b420:	732f2e2e 412f6372 632f4653 6f6d6d6f     ../src/ASF/commo
   8b430:	65732f6e 63697672 662f7365 72656572     n/services/freer
   8b440:	2f736f74 2f6d6173 65657266 736f7472     tos/sam/freertos
   8b450:	6173755f 735f7472 61697265 00632e6c     _usart_serial.c.

0008b460 <all_usart_definitions>:
   8b460:	40098000 40098100 00000011 00000011     ...@...@........
   8b470:	4009c000 4009c100 00000012 00000012     ...@...@........
   8b480:	400a0000 400a0100 00000013 00000013     ...@...@........
   8b490:	400a4000 400a4100 00000014 00000014     .@.@.A.@........
	...
   8b4a8:	aaaaaa00 aaaaaaaa eeeeeeaa eeeeeeee     ................
   8b4b8:	fffffeee ffffffff ffffffff dfbf7fff     ................
   8b4c8:	fdfbf7ef dfbf7efc fdfbf7ef 0000007e     .....~......~...
   8b4d8:	20071768 0000004f 0000000a 00000300     h.. O...........
   8b4e8:	0001c200 000000c0 00000800 00000000     ................
	...
   8b500:	732f2e2e 412f6372 742f4653 64726968     ../src/ASF/third
   8b510:	74726170 72662f79 74726565 642f736f     party/freertos/d
   8b520:	2f6f6d65 69726570 72656870 635f6c61     emo/peripheral_c
   8b530:	72746e6f 642f6c6f 2d6f6d65 6b736174     ontrol/demo-task
   8b540:	53552f73 2d545241 6f686365 7361742d     s/USART-echo-tas
   8b550:	632e736b 00000000 00007854 00007852     ks.c....Tx..Rx..
   8b560:	65646362 69686766 6d6c6b6a 71706f6e     bcdefghijklmnopq
   8b570:	75747372 79787776 3332317a 37363534     rstuvwxyz1234567
   8b580:	41303938 45444342 49484746 4d4c4b4a     890ABCDEFGHIJKLM
   8b590:	51504f4e 55545352 57585756 3332315a     NOPQRSTUVWXWZ123
   8b5a0:	37363534 5b303938 23273b5d 00002b3d     4567890[];'#=+..
   8b5b0:	00000061 00000062 00000064 00000065     a...b...d...e...
   8b5c0:	00000067 00000068 00000069 0000006b     g...h...i...k...
   8b5d0:	0000006c 0000006d 0000006f 00000070     l...m...o...p...
   8b5e0:	00000071 00000074 00000075 00000077     q...t...u...w...
   8b5f0:	00000078 00006261 00636261 65646362     x...ab..abc.bcde
   8b600:	00000000 65646362 00000066 65646362     ....bcdef...bcde
   8b610:	00006766 65646362 00686766 65646362     fg..bcdefgh.bcde
   8b620:	69686766 00000000 65646362 69686766     fghi....bcdefghi
   8b630:	0000006a 65646362 69686766 00006b6a     j...bcdefghijk..
   8b640:	65646362 69686766 006c6b6a 65646362     bcdefghijkl.bcde
   8b650:	69686766 6d6c6b6a 00000000 65646362     fghijklm....bcde
   8b660:	69686766 6d6c6b6a 0000006e 65646362     fghijklmn...bcde
   8b670:	69686766 6d6c6b6a 00006f6e 65646362     fghijklmno..bcde
   8b680:	69686766 6d6c6b6a 00706f6e 65646362     fghijklmnop.bcde
   8b690:	69686766 6d6c6b6a 71706f6e 00000000     fghijklmnopq....
   8b6a0:	65646362 69686766 6d6c6b6a 71706f6e     bcdefghijklmnopq
   8b6b0:	00000072 65646362 69686766 6d6c6b6a     r...bcdefghijklm
   8b6c0:	71706f6e 00007372 65646362 69686766     nopqrs..bcdefghi
   8b6d0:	6d6c6b6a 71706f6e 00747372 65646362     jklmnopqrst.bcde
   8b6e0:	69686766 6d6c6b6a 71706f6e 75747372     fghijklmnopqrstu
   8b6f0:	00000000 65646362 69686766 6d6c6b6a     ....bcdefghijklm
   8b700:	71706f6e 75747372 00000076 65646362     nopqrstuv...bcde
   8b710:	69686766 6d6c6b6a 71706f6e 75747372     fghijklmnopqrstu
   8b720:	00007776 65646362 69686766 6d6c6b6a     vw..bcdefghijklm
   8b730:	71706f6e 75747372 00787776 65646362     nopqrstuvwx.bcde
   8b740:	69686766 6d6c6b6a 71706f6e 75747372     fghijklmnopqrstu
   8b750:	79787776 00000000 65646362 69686766     vwxy....bcdefghi
   8b760:	6d6c6b6a 71706f6e 75747372 79787776     jklmnopqrstuvwxy
   8b770:	0000007a 65646362 69686766 6d6c6b6a     z...bcdefghijklm
   8b780:	71706f6e 75747372 79787776 0000317a     nopqrstuvwxyz1..
   8b790:	65646362 69686766 6d6c6b6a 71706f6e     bcdefghijklmnopq
   8b7a0:	75747372 79787776 0032317a 65646362     rstuvwxyz12.bcde
   8b7b0:	69686766 6d6c6b6a 71706f6e 75747372     fghijklmnopqrstu
   8b7c0:	79787776 3332317a 00000000 65646362     vwxyz123....bcde
   8b7d0:	69686766 6d6c6b6a 71706f6e 75747372     fghijklmnopqrstu
   8b7e0:	79787776 3332317a 00000034 65646362     vwxyz1234...bcde
   8b7f0:	69686766 6d6c6b6a 71706f6e 75747372     fghijklmnopqrstu
   8b800:	79787776 3332317a 00003534 65646362     vwxyz12345..bcde
   8b810:	69686766 6d6c6b6a 71706f6e 75747372     fghijklmnopqrstu
   8b820:	79787776 3332317a 00363534 65646362     vwxyz123456.bcde
   8b830:	69686766 6d6c6b6a 71706f6e 75747372     fghijklmnopqrstu
   8b840:	79787776 3332317a 37363534 00000000     vwxyz1234567....
   8b850:	65646362 69686766 6d6c6b6a 71706f6e     bcdefghijklmnopq
   8b860:	75747372 79787776 3332317a 37363534     rstuvwxyz1234567
   8b870:	00000038 65646362 69686766 6d6c6b6a     8...bcdefghijklm
   8b880:	71706f6e 75747372 79787776 3332317a     nopqrstuvwxyz123
   8b890:	37363534 00003938 65646362 69686766     456789..bcdefghi
   8b8a0:	6d6c6b6a 71706f6e 75747372 79787776     jklmnopqrstuvwxy
   8b8b0:	3332317a 37363534 00303938 65646362     z1234567890.bcde
   8b8c0:	69686766 6d6c6b6a 71706f6e 75747372     fghijklmnopqrstu
   8b8d0:	79787776 3332317a 37363534 41303938     vwxyz1234567890A
   8b8e0:	00000000 65646362 69686766 6d6c6b6a     ....bcdefghijklm
   8b8f0:	71706f6e 75747372 79787776 3332317a     nopqrstuvwxyz123
   8b900:	37363534 41303938 00000042 65646362     4567890AB...bcde
   8b910:	69686766 6d6c6b6a 71706f6e 75747372     fghijklmnopqrstu
   8b920:	79787776 3332317a 37363534 41303938     vwxyz1234567890A
   8b930:	00004342 65646362 69686766 6d6c6b6a     BC..bcdefghijklm
   8b940:	71706f6e 75747372 79787776 3332317a     nopqrstuvwxyz123
   8b950:	37363534 41303938 00444342 65646362     4567890ABCD.bcde
   8b960:	69686766 6d6c6b6a 71706f6e 75747372     fghijklmnopqrstu
   8b970:	79787776 3332317a 37363534 41303938     vwxyz1234567890A
   8b980:	45444342 00000000 65646362 69686766     BCDE....bcdefghi
   8b990:	6d6c6b6a 71706f6e 75747372 79787776     jklmnopqrstuvwxy
   8b9a0:	3332317a 37363534 41303938 45444342     z1234567890ABCDE
   8b9b0:	00000046 65646362 69686766 6d6c6b6a     F...bcdefghijklm
   8b9c0:	71706f6e 75747372 79787776 3332317a     nopqrstuvwxyz123
   8b9d0:	37363534 41303938 45444342 00004746     4567890ABCDEFG..
   8b9e0:	65646362 69686766 6d6c6b6a 71706f6e     bcdefghijklmnopq
   8b9f0:	75747372 79787776 3332317a 37363534     rstuvwxyz1234567
   8ba00:	41303938 45444342 00484746 65646362     890ABCDEFGH.bcde
   8ba10:	69686766 6d6c6b6a 71706f6e 75747372     fghijklmnopqrstu
   8ba20:	79787776 3332317a 37363534 41303938     vwxyz1234567890A
   8ba30:	45444342 49484746 00000000 65646362     BCDEFGHI....bcde
   8ba40:	69686766 6d6c6b6a 71706f6e 75747372     fghijklmnopqrstu
   8ba50:	79787776 3332317a 37363534 41303938     vwxyz1234567890A
   8ba60:	45444342 49484746 0000004a 65646362     BCDEFGHIJ...bcde
   8ba70:	69686766 6d6c6b6a 71706f6e 75747372     fghijklmnopqrstu
   8ba80:	79787776 3332317a 37363534 41303938     vwxyz1234567890A
   8ba90:	45444342 49484746 00004b4a 65646362     BCDEFGHIJK..bcde
   8baa0:	69686766 6d6c6b6a 71706f6e 75747372     fghijklmnopqrstu
   8bab0:	79787776 3332317a 37363534 41303938     vwxyz1234567890A
   8bac0:	45444342 49484746 004c4b4a 65646362     BCDEFGHIJKL.bcde
   8bad0:	69686766 6d6c6b6a 71706f6e 75747372     fghijklmnopqrstu
   8bae0:	79787776 3332317a 37363534 41303938     vwxyz1234567890A
   8baf0:	45444342 49484746 4d4c4b4a 00000000     BCDEFGHIJKLM....
   8bb00:	65646362 69686766 6d6c6b6a 71706f6e     bcdefghijklmnopq
   8bb10:	75747372 79787776 3332317a 37363534     rstuvwxyz1234567
   8bb20:	41303938 45444342 49484746 4d4c4b4a     890ABCDEFGHIJKLM
   8bb30:	0000004e 65646362 69686766 6d6c6b6a     N...bcdefghijklm
   8bb40:	71706f6e 75747372 79787776 3332317a     nopqrstuvwxyz123
   8bb50:	37363534 41303938 45444342 49484746     4567890ABCDEFGHI
   8bb60:	4d4c4b4a 00004f4e 65646362 69686766     JKLMNO..bcdefghi
   8bb70:	6d6c6b6a 71706f6e 75747372 79787776     jklmnopqrstuvwxy
   8bb80:	3332317a 37363534 41303938 45444342     z1234567890ABCDE
   8bb90:	49484746 4d4c4b4a 00504f4e 65646362     FGHIJKLMNOP.bcde
   8bba0:	69686766 6d6c6b6a 71706f6e 75747372     fghijklmnopqrstu
   8bbb0:	79787776 3332317a 37363534 41303938     vwxyz1234567890A
   8bbc0:	45444342 49484746 4d4c4b4a 51504f4e     BCDEFGHIJKLMNOPQ
   8bbd0:	00000000 65646362 69686766 6d6c6b6a     ....bcdefghijklm
   8bbe0:	71706f6e 75747372 79787776 3332317a     nopqrstuvwxyz123
   8bbf0:	37363534 41303938 45444342 49484746     4567890ABCDEFGHI
   8bc00:	4d4c4b4a 51504f4e 00000052 65646362     JKLMNOPQR...bcde
   8bc10:	69686766 6d6c6b6a 71706f6e 75747372     fghijklmnopqrstu
   8bc20:	79787776 3332317a 37363534 41303938     vwxyz1234567890A
   8bc30:	45444342 49484746 4d4c4b4a 51504f4e     BCDEFGHIJKLMNOPQ
   8bc40:	00005352 65646362 69686766 6d6c6b6a     RS..bcdefghijklm
   8bc50:	71706f6e 75747372 79787776 3332317a     nopqrstuvwxyz123
   8bc60:	37363534 41303938 45444342 49484746     4567890ABCDEFGHI
   8bc70:	4d4c4b4a 51504f4e 00545352 65646362     JKLMNOPQRST.bcde
   8bc80:	69686766 6d6c6b6a 71706f6e 75747372     fghijklmnopqrstu
   8bc90:	79787776 3332317a 37363534 41303938     vwxyz1234567890A
   8bca0:	45444342 49484746 4d4c4b4a 51504f4e     BCDEFGHIJKLMNOPQ
   8bcb0:	55545352 00000000 65646362 69686766     RSTU....bcdefghi
   8bcc0:	6d6c6b6a 71706f6e 75747372 79787776     jklmnopqrstuvwxy
   8bcd0:	3332317a 37363534 41303938 45444342     z1234567890ABCDE
   8bce0:	49484746 4d4c4b4a 51504f4e 55545352     FGHIJKLMNOPQRSTU
   8bcf0:	00000056 65646362 69686766 6d6c6b6a     V...bcdefghijklm
   8bd00:	71706f6e 75747372 79787776 3332317a     nopqrstuvwxyz123
   8bd10:	37363534 41303938 45444342 49484746     4567890ABCDEFGHI
   8bd20:	4d4c4b4a 51504f4e 55545352 00005756     JKLMNOPQRSTUVW..
   8bd30:	65646362 69686766 6d6c6b6a 71706f6e     bcdefghijklmnopq
   8bd40:	75747372 79787776 3332317a 37363534     rstuvwxyz1234567
   8bd50:	41303938 45444342 49484746 4d4c4b4a     890ABCDEFGHIJKLM
   8bd60:	51504f4e 55545352 00585756 65646362     NOPQRSTUVWX.bcde
   8bd70:	69686766 6d6c6b6a 71706f6e 75747372     fghijklmnopqrstu
   8bd80:	79787776 3332317a 37363534 41303938     vwxyz1234567890A
   8bd90:	45444342 49484746 4d4c4b4a 51504f4e     BCDEFGHIJKLMNOPQ
   8bda0:	55545352 57585756 00000000 65646362     RSTUVWXW....bcde
   8bdb0:	69686766 6d6c6b6a 71706f6e 75747372     fghijklmnopqrstu
   8bdc0:	79787776 3332317a 37363534 41303938     vwxyz1234567890A
   8bdd0:	45444342 49484746 4d4c4b4a 51504f4e     BCDEFGHIJKLMNOPQ
   8bde0:	55545352 57585756 0000005a 65646362     RSTUVWXWZ...bcde
   8bdf0:	69686766 6d6c6b6a 71706f6e 75747372     fghijklmnopqrstu
   8be00:	79787776 3332317a 37363534 41303938     vwxyz1234567890A
   8be10:	45444342 49484746 4d4c4b4a 51504f4e     BCDEFGHIJKLMNOPQ
   8be20:	55545352 57585756 0000315a 65646362     RSTUVWXWZ1..bcde
   8be30:	69686766 6d6c6b6a 71706f6e 75747372     fghijklmnopqrstu
   8be40:	79787776 3332317a 37363534 41303938     vwxyz1234567890A
   8be50:	45444342 49484746 4d4c4b4a 51504f4e     BCDEFGHIJKLMNOPQ
   8be60:	55545352 57585756 0032315a 65646362     RSTUVWXWZ12.bcde
   8be70:	69686766 6d6c6b6a 71706f6e 75747372     fghijklmnopqrstu
   8be80:	79787776 3332317a 37363534 41303938     vwxyz1234567890A
   8be90:	45444342 49484746 4d4c4b4a 51504f4e     BCDEFGHIJKLMNOPQ
   8bea0:	55545352 57585756 3332315a 00000000     RSTUVWXWZ123....
   8beb0:	65646362 69686766 6d6c6b6a 71706f6e     bcdefghijklmnopq
   8bec0:	75747372 79787776 3332317a 37363534     rstuvwxyz1234567
   8bed0:	41303938 45444342 49484746 4d4c4b4a     890ABCDEFGHIJKLM
   8bee0:	51504f4e 55545352 57585756 3332315a     NOPQRSTUVWXWZ123
   8bef0:	00000034 65646362 69686766 6d6c6b6a     4...bcdefghijklm
   8bf00:	71706f6e 75747372 79787776 3332317a     nopqrstuvwxyz123
   8bf10:	37363534 41303938 45444342 49484746     4567890ABCDEFGHI
   8bf20:	4d4c4b4a 51504f4e 55545352 57585756     JKLMNOPQRSTUVWXW
   8bf30:	3332315a 00003534 65646362 69686766     Z12345..bcdefghi
   8bf40:	6d6c6b6a 71706f6e 75747372 79787776     jklmnopqrstuvwxy
   8bf50:	3332317a 37363534 41303938 45444342     z1234567890ABCDE
   8bf60:	49484746 4d4c4b4a 51504f4e 55545352     FGHIJKLMNOPQRSTU
   8bf70:	57585756 3332315a 00363534 65646362     VWXWZ123456.bcde
   8bf80:	69686766 6d6c6b6a 71706f6e 75747372     fghijklmnopqrstu
   8bf90:	79787776 3332317a 37363534 41303938     vwxyz1234567890A
   8bfa0:	45444342 49484746 4d4c4b4a 51504f4e     BCDEFGHIJKLMNOPQ
   8bfb0:	55545352 57585756 3332315a 37363534     RSTUVWXWZ1234567
   8bfc0:	00000000 65646362 69686766 6d6c6b6a     ....bcdefghijklm
   8bfd0:	71706f6e 75747372 79787776 3332317a     nopqrstuvwxyz123
   8bfe0:	37363534 41303938 45444342 49484746     4567890ABCDEFGHI
   8bff0:	4d4c4b4a 51504f4e 55545352 57585756     JKLMNOPQRSTUVWXW
   8c000:	3332315a 37363534 00000038 65646362     Z12345678...bcde
   8c010:	69686766 6d6c6b6a 71706f6e 75747372     fghijklmnopqrstu
   8c020:	79787776 3332317a 37363534 41303938     vwxyz1234567890A
   8c030:	45444342 49484746 4d4c4b4a 51504f4e     BCDEFGHIJKLMNOPQ
   8c040:	55545352 57585756 3332315a 37363534     RSTUVWXWZ1234567
   8c050:	00003938 65646362 69686766 6d6c6b6a     89..bcdefghijklm
   8c060:	71706f6e 75747372 79787776 3332317a     nopqrstuvwxyz123
   8c070:	37363534 41303938 45444342 49484746     4567890ABCDEFGHI
   8c080:	4d4c4b4a 51504f4e 55545352 57585756     JKLMNOPQRSTUVWXW
   8c090:	3332315a 37363534 00303938 65646362     Z1234567890.bcde
   8c0a0:	69686766 6d6c6b6a 71706f6e 75747372     fghijklmnopqrstu
   8c0b0:	79787776 3332317a 37363534 41303938     vwxyz1234567890A
   8c0c0:	45444342 49484746 4d4c4b4a 51504f4e     BCDEFGHIJKLMNOPQ
   8c0d0:	55545352 57585756 3332315a 37363534     RSTUVWXWZ1234567
   8c0e0:	5b303938 00000000 65646362 69686766     890[....bcdefghi
   8c0f0:	6d6c6b6a 71706f6e 75747372 79787776     jklmnopqrstuvwxy
   8c100:	3332317a 37363534 41303938 45444342     z1234567890ABCDE
   8c110:	49484746 4d4c4b4a 51504f4e 55545352     FGHIJKLMNOPQRSTU
   8c120:	57585756 3332315a 37363534 5b303938     VWXWZ1234567890[
   8c130:	0000005d 65646362 69686766 6d6c6b6a     ]...bcdefghijklm
   8c140:	71706f6e 75747372 79787776 3332317a     nopqrstuvwxyz123
   8c150:	37363534 41303938 45444342 49484746     4567890ABCDEFGHI
   8c160:	4d4c4b4a 51504f4e 55545352 57585756     JKLMNOPQRSTUVWXW
   8c170:	3332315a 37363534 5b303938 00003b5d     Z1234567890[];..
   8c180:	65646362 69686766 6d6c6b6a 71706f6e     bcdefghijklmnopq
   8c190:	75747372 79787776 3332317a 37363534     rstuvwxyz1234567
   8c1a0:	41303938 45444342 49484746 4d4c4b4a     890ABCDEFGHIJKLM
   8c1b0:	51504f4e 55545352 57585756 3332315a     NOPQRSTUVWXWZ123
   8c1c0:	37363534 5b303938 00273b5d 65646362     4567890[];'.bcde
   8c1d0:	69686766 6d6c6b6a 71706f6e 75747372     fghijklmnopqrstu
   8c1e0:	79787776 3332317a 37363534 41303938     vwxyz1234567890A
   8c1f0:	45444342 49484746 4d4c4b4a 51504f4e     BCDEFGHIJKLMNOPQ
   8c200:	55545352 57585756 3332315a 37363534     RSTUVWXWZ1234567
   8c210:	5b303938 23273b5d 00000000 65646362     890[];'#....bcde
   8c220:	69686766 6d6c6b6a 71706f6e 75747372     fghijklmnopqrstu
   8c230:	79787776 3332317a 37363534 41303938     vwxyz1234567890A
   8c240:	45444342 49484746 4d4c4b4a 51504f4e     BCDEFGHIJKLMNOPQ
   8c250:	55545352 57585756 3332315a 37363534     RSTUVWXWZ1234567
   8c260:	5b303938 23273b5d 0000003d 6564635f     890[];'#=..._cde
   8c270:	69686766 6d6c6b6a 71706f6e 75747372     fghijklmnopqrstu
   8c280:	79787776 3332317a 37363534 41303938     vwxyz1234567890A
   8c290:	45444342 49484746 4d4c4b4a 51504f4e     BCDEFGHIJKLMNOPQ
   8c2a0:	55545352 57585756 3332315a 37363534     RSTUVWXWZ1234567
   8c2b0:	5b303938 23273b5d 00002b3d 65645f5f     890[];'#=+..__de
   8c2c0:	69686766 6d6c6b6a 71706f6e 75747372     fghijklmnopqrstu
   8c2d0:	79787776 3332317a 37363534 41303938     vwxyz1234567890A
   8c2e0:	45444342 49484746 4d4c4b4a 51504f4e     BCDEFGHIJKLMNOPQ
   8c2f0:	55545352 57585756 3332315a 37363534     RSTUVWXWZ1234567
   8c300:	5b303938 23273b5d 00002b3d 655f5f5f     890[];'#=+..___e
   8c310:	69686766 6d6c6b6a 71706f6e 75747372     fghijklmnopqrstu
   8c320:	79787776 3332317a 37363534 41303938     vwxyz1234567890A
   8c330:	45444342 49484746 4d4c4b4a 51504f4e     BCDEFGHIJKLMNOPQ
   8c340:	55545352 57585756 3332315a 37363534     RSTUVWXWZ1234567
   8c350:	5b303938 23273b5d 00002b3d 5f5f5f5f     890[];'#=+..____
   8c360:	69686766 6d6c6b6a 71706f6e 75747372     fghijklmnopqrstu
   8c370:	79787776 3332317a 37363534 41303938     vwxyz1234567890A
   8c380:	45444342 49484746 4d4c4b4a 51504f4e     BCDEFGHIJKLMNOPQ
   8c390:	55545352 57585756 3332315a 37363534     RSTUVWXWZ1234567
   8c3a0:	5b303938 23273b5d 00002b3d 5f5f5f5f     890[];'#=+..____
   8c3b0:	6968675f 6d6c6b6a 71706f6e 75747372     _ghijklmnopqrstu
   8c3c0:	79787776 3332317a 37363534 41303938     vwxyz1234567890A
   8c3d0:	45444342 49484746 4d4c4b4a 51504f4e     BCDEFGHIJKLMNOPQ
   8c3e0:	55545352 57585756 3332315a 37363534     RSTUVWXWZ1234567
   8c3f0:	5b303938 23273b5d 00002b3d 505b0a0d     890[];'#=+....[P
   8c400:	73736572 544e4520 74205245 7865206f     ress ENTER to ex
   8c410:	74756365 68742065 72702065 6f697665     ecute the previo
   8c420:	63207375 616d6d6f 6120646e 6e696167     us command again
   8c430:	3e0a0d5d 00000000 732f2e2e 412f6372     ]..>....../src/A
   8c440:	742f4653 64726968 74726170 72662f79     SF/thirdparty/fr
   8c450:	74726565 642f736f 2f6f6d65 69726570     eertos/demo/peri
   8c460:	72656870 635f6c61 72746e6f 642f6c6f     pheral_control/d
   8c470:	2d6f6d65 6b736174 53552f73 44432d42     emo-tasks/USB-CD
   8c480:	4c432d43 61742d49 632e6b73 00000000     C-CLI-task.c....
   8c490:	5f434443 00494c43                       CDC_CLI.

0008c498 <xHelpCommand>:
   8c498:	0008c594 0008c59c 00083e29 00000000     ........)>......
   8c4a8:	732f2e2e 412f6372 742f4653 64726968     ../src/ASF/third
   8c4b8:	74726170 72662f79 74726565 662f736f     party/freertos/f
   8c4c8:	72656572 2d736f74 2e332e37 6f732f30     reertos-7.3.0/so
   8c4d8:	65637275 6572462f 4f545265 4c435f53     urce/FreeRTOS_CL
   8c4e8:	00632e49 6f636e49 63657272 6f632074     I.c.Incorrect co
   8c4f8:	6e616d6d 61702064 656d6172 28726574     mmand parameter(
   8c508:	202e2973 746e4520 22207265 706c6568     s).  Enter "help
   8c518:	6f742022 65697620 20612077 7473696c     " to view a list
   8c528:	20666f20 69617661 6c62616c 6f632065      of available co
   8c538:	6e616d6d 0d2e7364 000a0d0a 6d6d6f43     mmands......Comm
   8c548:	20646e61 20746f6e 6f636572 73696e67     and not recognis
   8c558:	202e6465 746e4520 22207265 706c6568     ed.  Enter "help
   8c568:	6f742022 65697620 20612077 7473696c     " to view a list
   8c578:	20666f20 69617661 6c62616c 6f632065      of available co
   8c588:	6e616d6d 0d2e7364 000a0d0a 706c6568     mmands......help
   8c598:	00000000 65680a0d 0d3a706c 694c200a     ......help:.. Li
   8c5a8:	20737473 206c6c61 20656874 69676572     sts all the regi
   8c5b8:	72657473 63206465 616d6d6f 0d73646e     stered commands.
   8c5c8:	000a0d0a 732f2e2e 412f6372 742f4653     ....../src/ASF/t
   8c5d8:	64726968 74726170 72662f79 74726565     hirdparty/freert
   8c5e8:	662f736f 72656572 2d736f74 2e332e37     os/freertos-7.3.
   8c5f8:	6f732f30 65637275 6575712f 632e6575     0/source/queue.c
   8c608:	00000000 09097325 25096325 75250975     ....%s..%c.%u.%u
   8c618:	0d752509 0000000a 09097325 30090930     .%u.....%s..0..0
   8c628:	0a0d2525 00000000 09097325 09097525     %%......%s..%u..
   8c638:	25257525 00000a0d 09097325 09097525     %u%%....%s..%u..
   8c648:	2525313c 00000a0d 732f2e2e 412f6372     <1%%....../src/A
   8c658:	742f4653 64726968 74726170 72662f79     SF/thirdparty/fr
   8c668:	74726565 662f736f 72656572 2d736f74     eertos/freertos-
   8c678:	2e332e37 6f732f30 65637275 7361742f     7.3.0/source/tas
   8c688:	632e736b 00000000 454c4449 00000000     ks.c....IDLE....

0008c698 <ucExpectedStackBytes.5975>:
   8c698:	a5a5a5a5 a5a5a5a5 a5a5a5a5 a5a5a5a5     ................
   8c6a8:	a5a5a5a5 20726d54 00637653 732f2e2e     ....Tmr Svc.../s
   8c6b8:	412f6372 742f4653 64726968 74726170     rc/ASF/thirdpart
   8c6c8:	72662f79 74726565 662f736f 72656572     y/freertos/freer
   8c6d8:	2d736f74 2e332e37 6f732f30 65637275     tos-7.3.0/source
   8c6e8:	6d69742f 2e737265 00000063              /timers.c...

0008c6f4 <create_task_command_definition>:
   8c6f4:	0008c99c 0008c9a8 00085c25 00000001     ........%\......

0008c704 <multi_parameter_echo_command_definition>:
   8c704:	0008ca10 0008ca20 00085cd5 000000ff     .... ....\......

0008c714 <delete_task_command_definition>:
   8c714:	0008c948 0008c954 00085bc5 00000000     H...T....[......

0008c724 <run_time_stats_command_definition>:
   8c724:	0008cb44 0008cb54 00085e59 00000000     D...T...Y^......
   8c734:	732f2e2e 642f6372 2d6f6d65 6b736174     ../src/demo-task
   8c744:	4c432f73 6f632d49 6e616d6d 632e7364     s/CLI-commands.c
   8c754:	00000000 6b736154 6c656420 64657465     ....Task deleted
   8c764:	00000a0d 20656854 6b736174 73617720     ....The task was
   8c774:	746f6e20 6e757220 676e696e 4520202e      not running.  E
   8c784:	75636578 74206574 63206568 74616572     xecute the creat
   8c794:	61742d65 63206b73 616d6d6f 6620646e     e-task command f
   8c7a4:	74737269 000a0d2e 20656854 6b736174     irst....The task
   8c7b4:	73616820 726c6120 79646165 65656220      has already bee
   8c7c4:	7263206e 65746165 45202e64 75636578     n created. Execu
   8c7d4:	74206574 64206568 74656c65 61742d65     te the delete-ta
   8c7e4:	63206b73 616d6d6f 6620646e 74737269     sk command first
   8c7f4:	000a0d2e 61657243 00646574 6b736154     ....Created.Task
   8c804:	65726320 64657461 00000a0d 6b736154      created....Task
   8c814:	746f6e20 65726320 64657461 00000a0d      not created....
   8c824:	20656854 61726170 6574656d 77207372     The parameters w
   8c834:	3a657265 00000a0d 3a646c25 00000020     ere:....%ld: ...
   8c844:	20656854 65726874 61702065 656d6172     The three parame
   8c854:	73726574 72657720 0a0d3a65 00000000     ters were:......
   8c864:	6b736154 20202020 20202020 20202020     Task            
   8c874:	20736241 656d6954 20202020 20252020     Abs Time      % 
   8c884:	656d6954 2a2a0a0d 2a2a2a2a 2a2a2a2a     Time..**********
   8c894:	2a2a2a2a 2a2a2a2a 2a2a2a2a 2a2a2a2a     ****************
   8c8a4:	2a2a2a2a 2a2a2a2a 2a2a2a2a 0a0d2a2a     **************..
   8c8b4:	00000000 6b736154 20202020 20202020     ....Task        
   8c8c4:	74532020 20657461 69725020 7469726f       State  Priorit
   8c8d4:	53202079 6b636174 0a0d2309 2a2a2a2a     y  Stack.#..****
   8c8e4:	2a2a2a2a 2a2a2a2a 2a2a2a2a 2a2a2a2a     ****************
   8c8f4:	2a2a2a2a 2a2a2a2a 2a2a2a2a 2a2a2a2a     ****************
   8c904:	2a2a2a2a 2a2a2a2a 2a2a2a2a 00000a0d     ************....
   8c914:	61657243 20646574 6b736174 6e757220     Created task run
   8c924:	676e696e 5220202e 69656365 20646576     ning.  Received 
   8c934:	61726170 6574656d 6c252072 0d0a0d64     parameter %ld...
   8c944:	0000000a 656c6564 742d6574 006b7361     ....delete-task.
   8c954:	656c6564 742d6574 3a6b7361 44200a0d     delete-task:.. D
   8c964:	74656c65 74207365 74206568 206b7361     eletes the task 
   8c974:	61657263 20646574 74207962 63206568     created by the c
   8c984:	74616572 61742d65 63206b73 616d6d6f     reate-task comma
   8c994:	0a0d646e 00000a0d 61657263 742d6574     nd......create-t
   8c9a4:	006b7361 61657263 742d6574 206b7361     ask.create-task 
   8c9b4:	7261703c 3a3e6d61 43200a0d 74616572     <param>:.. Creat
   8c9c4:	61207365 77656e20 73617420 6874206b     es a new task th
   8c9d4:	70207461 6f697265 61636964 20796c6c     at periodically 
   8c9e4:	74697277 74207365 70206568 6d617261     writes the param
   8c9f4:	72657465 206f7420 20656874 20494c43     eter to the CLI 
   8ca04:	7074756f 0a0d7475 00000a0d 6f686365     output......echo
   8ca14:	7261702d 74656d61 00737265 6f686365     -parameters.echo
   8ca24:	7261702d 74656d61 20737265 2e2e2e3c     -parameters <...
   8ca34:	0a0d3a3e 6b615420 61762065 62616972     >:.. Take variab
   8ca44:	6e20656c 65626d75 666f2072 72617020     le number of par
   8ca54:	74656d61 2c737265 68636520 6520736f     ameters, echos e
   8ca64:	20686361 74206e69 0d6e7275 000a0d0a     ach in turn.....
   8ca74:	6f686365 702d332d 6d617261 72657465     echo-3-parameter
   8ca84:	00000073 6f686365 702d332d 6d617261     s...echo-3-param
   8ca94:	72657465 703c2073 6d617261 3c203e31     eters <param1> <
   8caa4:	61726170 203e326d 7261703c 3e336d61     param2> <param3>
   8cab4:	200a0d3a 65707845 20737463 65726874     :.. Expects thre
   8cac4:	61702065 656d6172 73726574 6365202c     e parameters, ec
   8cad4:	20736f68 68636165 206e6920 6e727574     hos each in turn
   8cae4:	0a0d0a0d 00000000 6b736174 6174732d     ........task-sta
   8caf4:	00007374 6b736174 6174732d 0d3a7374     ts..task-stats:.
   8cb04:	6944200a 616c7073 61207379 62617420     . Displays a tab
   8cb14:	7320656c 69776f68 7420676e 73206568     le showing the s
   8cb24:	65746174 20666f20 68636165 65724620     tate of each Fre
   8cb34:	4f545265 61742053 0a0d6b73 00000a0d     eRTOS task......
   8cb44:	2d6e7572 656d6974 6174732d 00007374     run-time-stats..
   8cb54:	2d6e7572 656d6974 6174732d 0d3a7374     run-time-stats:.
   8cb64:	6944200a 616c7073 61207379 62617420     . Displays a tab
   8cb74:	7320656c 69776f68 6820676e 6d20776f     le showing how m
   8cb84:	20686375 636f7270 69737365 7420676e     uch processing t
   8cb94:	20656d69 68636165 65724620 4f545265     ime each FreeRTO
   8cba4:	61742053 68206b73 75207361 0d646573     S task has used.
   8cbb4:	000a0d0a                                ....

0008cbb8 <task_stats_command_definition>:
   8cbb8:	0008caec 0008caf8 00085e91 00000000     .........^......

0008cbc8 <three_parameter_echo_command_definition>:
   8cbc8:	0008ca74 0008ca88 00085d91 00000003     t........]......
   8cbd8:	2044454c 656d6974 00000072 732f2e2e     LED timer...../s
   8cbe8:	6d2f6372 2e6e6961 00000063              rc/main.c...

0008cbf4 <xActiveStates>:
	...

0008cc00 <ulLED>:
   8cc00:	0000003b 00000055 00000056 00000043     ;...U...V...C...

0008cc10 <_global_impure_ptr>:
   8cc10:	20070468                                h.. 

0008cc14 <zeroes.6763>:
   8cc14:	30303030 30303030 30303030 30303030     0000000000000000
   8cc24:	00464e49 00666e69 004e414e 006e616e     INF.inf.NAN.nan.
   8cc34:	33323130 37363534 42413938 46454443     0123456789ABCDEF
   8cc44:	00000000 33323130 37363534 62613938     ....0123456789ab
   8cc54:	66656463 00000000 6c756e28 0000296c     cdef....(null)..
   8cc64:	00000030                                0...

0008cc68 <blanks.6762>:
   8cc68:	20202020 20202020 20202020 20202020                     

0008cc78 <_ctype_>:
   8cc78:	20202000 20202020 28282020 20282828     .         ((((( 
   8cc88:	20202020 20202020 20202020 20202020                     
   8cc98:	10108820 10101010 10101010 10101010      ...............
   8cca8:	04040410 04040404 10040404 10101010     ................
   8ccb8:	41411010 41414141 01010101 01010101     ..AAAAAA........
   8ccc8:	01010101 01010101 01010101 10101010     ................
   8ccd8:	42421010 42424242 02020202 02020202     ..BBBBBB........
   8cce8:	02020202 02020202 02020202 10101010     ................
   8ccf8:	00000020 00000000 00000000 00000000      ...............
	...
   8cd7c:	69666e49 7974696e 00000000 004e614e     Infinity....NaN.
   8cd8c:	49534f50 00000058 0000002e              POSIX.......

0008cd98 <__mprec_tens>:
   8cd98:	00000000 3ff00000 00000000 40240000     .......?......$@
   8cda8:	00000000 40590000 00000000 408f4000     ......Y@.....@.@
   8cdb8:	00000000 40c38800 00000000 40f86a00     .......@.....j.@
   8cdc8:	00000000 412e8480 00000000 416312d0     .......A......cA
   8cdd8:	00000000 4197d784 00000000 41cdcd65     .......A....e..A
   8cde8:	20000000 4202a05f e8000000 42374876     ... _..B....vH7B
   8cdf8:	a2000000 426d1a94 e5400000 42a2309c     ......mB..@..0.B
   8ce08:	1e900000 42d6bcc4 26340000 430c6bf5     .......B..4&.k.C
   8ce18:	37e08000 4341c379 85d8a000 43763457     ...7y.AC....W4vC
   8ce28:	674ec800 43abc16d 60913d00 43e158e4     ..Ngm..C.=.`.X.C
   8ce38:	78b58c40 4415af1d d6e2ef50 444b1ae4     @..x...DP.....KD
   8ce48:	064dd592 4480f0cf c7e14af6 44b52d02     ..M....D.J...-.D
   8ce58:	79d99db4 44ea7843                       ...yCx.D

0008ce60 <__mprec_bigtens>:
   8ce60:	37e08000 4341c379 b5056e17 4693b8b5     ...7y.AC.n.....F
   8ce70:	e93ff9f5 4d384f03 f9301d32 5a827748     ..?..O8M2.0.Hw.Z
   8ce80:	7f73bf3c 75154fdd                       <.s..O.u

0008ce88 <p05.5269>:
   8ce88:	00000005 00000019 0000007d              ........}...

0008ce94 <_init>:
   8ce94:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   8ce96:	bf00      	nop
   8ce98:	bcf8      	pop	{r3, r4, r5, r6, r7}
   8ce9a:	bc08      	pop	{r3}
   8ce9c:	469e      	mov	lr, r3
   8ce9e:	4770      	bx	lr

0008cea0 <__init_array_start>:
   8cea0:	00087fcd 	.word	0x00087fcd

0008cea4 <__frame_dummy_init_array_entry>:
   8cea4:	00080119                                ....

0008cea8 <_fini>:
   8cea8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   8ceaa:	bf00      	nop
   8ceac:	bcf8      	pop	{r3, r4, r5, r6, r7}
   8ceae:	bc08      	pop	{r3}
   8ceb0:	469e      	mov	lr, r3
   8ceb2:	4770      	bx	lr

0008ceb4 <__fini_array_start>:
   8ceb4:	000800f5 	.word	0x000800f5

Disassembly of section .relocate:

20070000 <SystemInit>:
__no_inline
RAMFUNC
void SystemInit(void)
{
	/* Set FWS according to SYS_BOARD_MCKR configuration */
	EFC0->EEFC_FMR = EEFC_FMR_FWS(4);
20070000:	f44f 6380 	mov.w	r3, #1024	; 0x400
20070004:	4a20      	ldr	r2, [pc, #128]	; (20070088 <SystemInit+0x88>)
20070006:	6013      	str	r3, [r2, #0]
	EFC1->EEFC_FMR = EEFC_FMR_FWS(4);
20070008:	f502 7200 	add.w	r2, r2, #512	; 0x200
2007000c:	6013      	str	r3, [r2, #0]

	/* Initialize main oscillator */
	if (!(PMC->CKGR_MOR & CKGR_MOR_MOSCSEL)) {
2007000e:	4b1f      	ldr	r3, [pc, #124]	; (2007008c <SystemInit+0x8c>)
20070010:	6a1b      	ldr	r3, [r3, #32]
20070012:	f013 7f80 	tst.w	r3, #16777216	; 0x1000000
20070016:	d107      	bne.n	20070028 <SystemInit+0x28>
		PMC->CKGR_MOR = SYS_CKGR_MOR_KEY_VALUE | SYS_BOARD_OSCOUNT | 
20070018:	4a1d      	ldr	r2, [pc, #116]	; (20070090 <SystemInit+0x90>)
2007001a:	4b1c      	ldr	r3, [pc, #112]	; (2007008c <SystemInit+0x8c>)
2007001c:	621a      	str	r2, [r3, #32]
			                     CKGR_MOR_MOSCRCEN | CKGR_MOR_MOSCXTEN;
		while (!(PMC->PMC_SR & PMC_SR_MOSCXTS)) {
2007001e:	461a      	mov	r2, r3
20070020:	6e93      	ldr	r3, [r2, #104]	; 0x68
20070022:	f013 0f01 	tst.w	r3, #1
20070026:	d0fb      	beq.n	20070020 <SystemInit+0x20>
		}
	}

	/* Switch to 3-20MHz Xtal oscillator */
	PMC->CKGR_MOR = SYS_CKGR_MOR_KEY_VALUE | SYS_BOARD_OSCOUNT | 
20070028:	4a1a      	ldr	r2, [pc, #104]	; (20070094 <SystemInit+0x94>)
2007002a:	4b18      	ldr	r3, [pc, #96]	; (2007008c <SystemInit+0x8c>)
2007002c:	621a      	str	r2, [r3, #32]
	                           CKGR_MOR_MOSCRCEN | CKGR_MOR_MOSCXTEN | CKGR_MOR_MOSCSEL;

	while (!(PMC->PMC_SR & PMC_SR_MOSCSELS)) {
2007002e:	461a      	mov	r2, r3
20070030:	6e93      	ldr	r3, [r2, #104]	; 0x68
20070032:	f413 3f80 	tst.w	r3, #65536	; 0x10000
20070036:	d0fb      	beq.n	20070030 <SystemInit+0x30>
	}
 	PMC->PMC_MCKR = (PMC->PMC_MCKR & ~(uint32_t)PMC_MCKR_CSS_Msk) | 
20070038:	4b14      	ldr	r3, [pc, #80]	; (2007008c <SystemInit+0x8c>)
2007003a:	6b1a      	ldr	r2, [r3, #48]	; 0x30
2007003c:	f022 0203 	bic.w	r2, r2, #3
20070040:	f042 0201 	orr.w	r2, r2, #1
20070044:	631a      	str	r2, [r3, #48]	; 0x30
		                     PMC_MCKR_CSS_MAIN_CLK;
	while (!(PMC->PMC_SR & PMC_SR_MCKRDY)) {
20070046:	461a      	mov	r2, r3
20070048:	6e93      	ldr	r3, [r2, #104]	; 0x68
2007004a:	f013 0f08 	tst.w	r3, #8
2007004e:	d0fb      	beq.n	20070048 <SystemInit+0x48>
	}

	/* Initialize PLLA */
	PMC->CKGR_PLLAR = SYS_BOARD_PLLAR;
20070050:	4a11      	ldr	r2, [pc, #68]	; (20070098 <SystemInit+0x98>)
20070052:	4b0e      	ldr	r3, [pc, #56]	; (2007008c <SystemInit+0x8c>)
20070054:	629a      	str	r2, [r3, #40]	; 0x28
	while (!(PMC->PMC_SR & PMC_SR_LOCKA)) {
20070056:	461a      	mov	r2, r3
20070058:	6e93      	ldr	r3, [r2, #104]	; 0x68
2007005a:	f013 0f02 	tst.w	r3, #2
2007005e:	d0fb      	beq.n	20070058 <SystemInit+0x58>
	}

	/* Switch to main clock */
	PMC->PMC_MCKR = (SYS_BOARD_MCKR & ~PMC_MCKR_CSS_Msk) | PMC_MCKR_CSS_MAIN_CLK;
20070060:	2211      	movs	r2, #17
20070062:	4b0a      	ldr	r3, [pc, #40]	; (2007008c <SystemInit+0x8c>)
20070064:	631a      	str	r2, [r3, #48]	; 0x30
	while (!(PMC->PMC_SR & PMC_SR_MCKRDY)) {
20070066:	461a      	mov	r2, r3
20070068:	6e93      	ldr	r3, [r2, #104]	; 0x68
2007006a:	f013 0f08 	tst.w	r3, #8
2007006e:	d0fb      	beq.n	20070068 <SystemInit+0x68>
	}

	/* Switch to PLLA */
	PMC->PMC_MCKR = SYS_BOARD_MCKR;
20070070:	2212      	movs	r2, #18
20070072:	4b06      	ldr	r3, [pc, #24]	; (2007008c <SystemInit+0x8c>)
20070074:	631a      	str	r2, [r3, #48]	; 0x30
	while (!(PMC->PMC_SR & PMC_SR_MCKRDY)) {
20070076:	461a      	mov	r2, r3
20070078:	6e93      	ldr	r3, [r2, #104]	; 0x68
2007007a:	f013 0f08 	tst.w	r3, #8
2007007e:	d0fb      	beq.n	20070078 <SystemInit+0x78>
	}

	SystemCoreClock = CHIP_FREQ_CPU_MAX;
20070080:	4a06      	ldr	r2, [pc, #24]	; (2007009c <SystemInit+0x9c>)
20070082:	4b07      	ldr	r3, [pc, #28]	; (200700a0 <SystemInit+0xa0>)
20070084:	601a      	str	r2, [r3, #0]
20070086:	4770      	bx	lr
20070088:	400e0a00 	.word	0x400e0a00
2007008c:	400e0600 	.word	0x400e0600
20070090:	00370809 	.word	0x00370809
20070094:	01370809 	.word	0x01370809
20070098:	200d3f01 	.word	0x200d3f01
2007009c:	0501bd00 	.word	0x0501bd00
200700a0:	20070274 	.word	0x20070274

200700a4 <system_init_flash>:
__no_inline
RAMFUNC
void system_init_flash(uint32_t ul_clk)
{
	/* Set FWS for embedded Flash access according to operating frequency */
	if (ul_clk < CHIP_FREQ_FWS_0) {
200700a4:	4b1b      	ldr	r3, [pc, #108]	; (20070114 <system_init_flash+0x70>)
200700a6:	4298      	cmp	r0, r3
200700a8:	d806      	bhi.n	200700b8 <system_init_flash+0x14>
		EFC0->EEFC_FMR = EEFC_FMR_FWS(0);
200700aa:	2300      	movs	r3, #0
200700ac:	4a1a      	ldr	r2, [pc, #104]	; (20070118 <system_init_flash+0x74>)
200700ae:	6013      	str	r3, [r2, #0]
		EFC1->EEFC_FMR = EEFC_FMR_FWS(0);
200700b0:	f502 7200 	add.w	r2, r2, #512	; 0x200
200700b4:	6013      	str	r3, [r2, #0]
200700b6:	4770      	bx	lr
	} else if (ul_clk < CHIP_FREQ_FWS_1) {
200700b8:	4b18      	ldr	r3, [pc, #96]	; (2007011c <system_init_flash+0x78>)
200700ba:	4298      	cmp	r0, r3
200700bc:	d807      	bhi.n	200700ce <system_init_flash+0x2a>
		EFC0->EEFC_FMR = EEFC_FMR_FWS(1);
200700be:	f44f 7380 	mov.w	r3, #256	; 0x100
200700c2:	4a15      	ldr	r2, [pc, #84]	; (20070118 <system_init_flash+0x74>)
200700c4:	6013      	str	r3, [r2, #0]
		EFC1->EEFC_FMR = EEFC_FMR_FWS(1);
200700c6:	f502 7200 	add.w	r2, r2, #512	; 0x200
200700ca:	6013      	str	r3, [r2, #0]
200700cc:	4770      	bx	lr
	} else if (ul_clk < CHIP_FREQ_FWS_2) {
200700ce:	4b14      	ldr	r3, [pc, #80]	; (20070120 <system_init_flash+0x7c>)
200700d0:	4298      	cmp	r0, r3
200700d2:	d807      	bhi.n	200700e4 <system_init_flash+0x40>
		EFC0->EEFC_FMR = EEFC_FMR_FWS(2);
200700d4:	f44f 7300 	mov.w	r3, #512	; 0x200
200700d8:	4a0f      	ldr	r2, [pc, #60]	; (20070118 <system_init_flash+0x74>)
200700da:	6013      	str	r3, [r2, #0]
		EFC1->EEFC_FMR = EEFC_FMR_FWS(2);
200700dc:	f502 7200 	add.w	r2, r2, #512	; 0x200
200700e0:	6013      	str	r3, [r2, #0]
200700e2:	4770      	bx	lr
	} else if (ul_clk < CHIP_FREQ_FWS_3) {
200700e4:	4b0f      	ldr	r3, [pc, #60]	; (20070124 <system_init_flash+0x80>)
200700e6:	4298      	cmp	r0, r3
200700e8:	d807      	bhi.n	200700fa <system_init_flash+0x56>
		EFC0->EEFC_FMR = EEFC_FMR_FWS(3);
200700ea:	f44f 7340 	mov.w	r3, #768	; 0x300
200700ee:	4a0a      	ldr	r2, [pc, #40]	; (20070118 <system_init_flash+0x74>)
200700f0:	6013      	str	r3, [r2, #0]
		EFC1->EEFC_FMR = EEFC_FMR_FWS(3);
200700f2:	f502 7200 	add.w	r2, r2, #512	; 0x200
200700f6:	6013      	str	r3, [r2, #0]
200700f8:	4770      	bx	lr
	} else if (ul_clk < CHIP_FREQ_FWS_4) {
200700fa:	4b0b      	ldr	r3, [pc, #44]	; (20070128 <system_init_flash+0x84>)
200700fc:	4298      	cmp	r0, r3
		EFC0->EEFC_FMR = EEFC_FMR_FWS(4);
200700fe:	bf94      	ite	ls
20070100:	f44f 6380 	movls.w	r3, #1024	; 0x400
		EFC1->EEFC_FMR = EEFC_FMR_FWS(4);	
	} else {
		EFC0->EEFC_FMR = EEFC_FMR_FWS(5);
20070104:	f44f 63a0 	movhi.w	r3, #1280	; 0x500
20070108:	4a03      	ldr	r2, [pc, #12]	; (20070118 <system_init_flash+0x74>)
2007010a:	6013      	str	r3, [r2, #0]
		EFC1->EEFC_FMR = EEFC_FMR_FWS(5);
2007010c:	f502 7200 	add.w	r2, r2, #512	; 0x200
20070110:	6013      	str	r3, [r2, #0]
20070112:	4770      	bx	lr
20070114:	0121eabf 	.word	0x0121eabf
20070118:	400e0a00 	.word	0x400e0a00
2007011c:	02faf07f 	.word	0x02faf07f
20070120:	03d08fff 	.word	0x03d08fff
20070124:	04c4b3ff 	.word	0x04c4b3ff
20070128:	055d4a7f 	.word	0x055d4a7f

2007012c <udi_api_cdc_data>:
2007012c:	00081261 00081111 00080e91 00080e95     a...............
2007013c:	00081101                                ....

20070140 <udi_api_cdc_comm>:
20070140:	00080f21 00080e81 00080e99 00080e95     !...............
20070150:	00000000                                ....

20070154 <udc_config_hs>:
20070154:	2007015c 200701c4                       \.. ... 

2007015c <udc_desc_hs>:
2007015c:	00430209 c0000102 00040932 02020100     ..C.....2.......
2007016c:	24050001 04011000 05020224 01000624     ...$....$...$...
2007017c:	03012405 83050701 10004003 00010409     .$.......@......
2007018c:	00000a02 81050700 00020002 02020507     ................
2007019c:	00000200                                ....

200701a0 <udc_config>:
200701a0:	200701d4 200701cc 200701d4 200701b8     ... ... ... ... 
200701b0:	20070154 00000000                       T.. ....

200701b8 <udc_device_qual>:
200701b8:	0200060a 40000002 00000001              .......@....

200701c4 <udi_apis>:
200701c4:	20070140 2007012c                       @.. ,.. 

200701cc <udc_config_fs>:
200701cc:	200701e8 200701c4                       ... ... 

200701d4 <udc_device_desc>:
200701d4:	02000112 40000002 240403eb 02010100     .......@...$....
200701e4:	00000100                                ....

200701e8 <udc_desc_fs>:
200701e8:	00430209 c0000102 00040932 02020100     ..C.....2.......
200701f8:	24050001 04011000 05020224 01000624     ...$....$...$...
20070208:	03012405 83050701 10004003 00010409     .$.......@......
20070218:	00000a02 81050700 00004002 02020507     .........@......
20070228:	00000040                                @...

2007022c <udc_string_product_name>:
2007022c:	6c6c6942 6f422079 75422062 6e6f7474     Billy Bob Button
2007023c:	00000073                                s...

20070240 <udc_string_manufacturer_name>:
20070240:	656d7441 0000006c                       Atmel...

20070248 <udc_string_desc>:
20070248:	00000300 00000000 00000000 00000000     ................
	...

2007026c <udc_string_desc_languageid>:
2007026c:	04090304                                ....

20070270 <g_interrupt_enabled>:
20070270:	00000001                                ....

20070274 <SystemCoreClock>:
20070274:	003d0900                                ..=.

20070278 <echo_strings>:
20070278:	0008b560 0008b5b0 0008b560 0008b5b4     `.......`.......
20070288:	0008b560 0008b3ac 0008b560 0008b5b8     `.......`.......
20070298:	0008b560 0008b5bc 0008b560 0008b608     `.......`.......
200702a8:	0008b560 0008b5c0 0008b560 0008b5c4     `.......`.......
200702b8:	0008b560 0008b5c8 0008b630 0008b5cc     `.......0.......
200702c8:	0008b5d0 0008b5d4 0008b668 0008b5d8     ........h.......
200702d8:	0008b5dc 0008b5e0 0008cbe0 0008ca84     ................
200702e8:	0008b5e4 0008b5e8 0008b708 0008b5ec     ................
200702f8:	0008b5f0 0008b5ec 0008b770 0008b5f4     ........p.......
20070308:	0008b5f8 0008b5fc 0008b604 0008b60c     ................
20070318:	0008b614 0008b61c 0008b628 0008b634     ........(...4...
20070328:	0008b640 0008b64c 0008b65c 0008b66c     @...L...\...l...
20070338:	0008b67c 0008b68c 0008b6a0 0008b6b4     |...............
20070348:	0008b6c8 0008b6dc 0008b6f4 0008b70c     ................
20070358:	0008b724 0008b73c 0008b758 0008b774     $...<...X...t...
20070368:	0008b790 0008b7ac 0008b7cc 0008b7ec     ................
20070378:	0008b80c 0008b82c 0008b850 0008b874     ....,...P...t...
20070388:	0008b898 0008b8bc 0008b8e4 0008b90c     ................
20070398:	0008b934 0008b95c 0008b988 0008b9b4     4...\...........
200703a8:	0008b9e0 0008ba0c 0008ba3c 0008ba6c     ........<...l...
200703b8:	0008ba9c 0008bacc 0008bb00 0008bb34     ............4...
200703c8:	0008bb68 0008bb9c 0008bbd4 0008bc0c     h...............
200703d8:	0008bc44 0008bc7c 0008bcb8 0008bcf4     D...|...........
200703e8:	0008bd30 0008bd6c 0008bdac 0008bdec     0...l...........
200703f8:	0008be2c 0008be6c 0008beb0 0008bef4     ,...l...........
20070408:	0008bf38 0008bf7c 0008bfc4 0008c00c     8...|...........
20070418:	0008c054 0008c09c 0008c0e8 0008c134     T...........4...
20070428:	0008c180 0008c1cc 0008c21c 0008b560     ............`...
20070438:	0008c26c 0008c2bc 0008c30c 0008c35c     l...........\...
20070448:	0008c3ac                                ....

2007044c <pxLastCommandInList.4673>:
2007044c:	20070450                                P.. 

20070450 <xRegisteredCommands>:
20070450:	0008c498 00000000                       ........

20070458 <uxCriticalNesting>:
20070458:	aaaaaaaa                                ....

2007045c <xFreeBytesRemaining>:
2007045c:	00004000                                .@..

20070460 <xNextTaskUnblockTime>:
20070460:	ffffffff 00000000                       ........

20070468 <impure_data>:
20070468:	00000000 20070754 200707bc 20070824     ....T.. ... $.. 
	...
2007049c:	0008cc0c 00000000 00000000 00000000     ................
	...
20070510:	00000001 00000000 abcd330e e66d1234     .........3..4.m.
20070520:	0005deec 0000000b 00000000 00000000     ................
	...

20070890 <_impure_ptr>:
20070890:	20070468                                h.. 

20070894 <__ctype_ptr__>:
20070894:	0008cc78                                x...

20070898 <lconv>:
20070898:	0008cd94 0008cae8 0008cae8 0008cae8     ................
200708a8:	0008cae8 0008cae8 0008cae8 0008cae8     ................
200708b8:	0008cae8 0008cae8 ffffffff ffffffff     ................
200708c8:	ffffffff 0000ffff                       ........

200708d0 <__malloc_av_>:
	...
200708d8:	200708d0 200708d0 200708d8 200708d8     ... ... ... ... 
200708e8:	200708e0 200708e0 200708e8 200708e8     ... ... ... ... 
200708f8:	200708f0 200708f0 200708f8 200708f8     ... ... ... ... 
20070908:	20070900 20070900 20070908 20070908     ... ... ... ... 
20070918:	20070910 20070910 20070918 20070918     ... ... ... ... 
20070928:	20070920 20070920 20070928 20070928      ..  .. (.. (.. 
20070938:	20070930 20070930 20070938 20070938     0.. 0.. 8.. 8.. 
20070948:	20070940 20070940 20070948 20070948     @.. @.. H.. H.. 
20070958:	20070950 20070950 20070958 20070958     P.. P.. X.. X.. 
20070968:	20070960 20070960 20070968 20070968     `.. `.. h.. h.. 
20070978:	20070970 20070970 20070978 20070978     p.. p.. x.. x.. 
20070988:	20070980 20070980 20070988 20070988     ... ... ... ... 
20070998:	20070990 20070990 20070998 20070998     ... ... ... ... 
200709a8:	200709a0 200709a0 200709a8 200709a8     ... ... ... ... 
200709b8:	200709b0 200709b0 200709b8 200709b8     ... ... ... ... 
200709c8:	200709c0 200709c0 200709c8 200709c8     ... ... ... ... 
200709d8:	200709d0 200709d0 200709d8 200709d8     ... ... ... ... 
200709e8:	200709e0 200709e0 200709e8 200709e8     ... ... ... ... 
200709f8:	200709f0 200709f0 200709f8 200709f8     ... ... ... ... 
20070a08:	20070a00 20070a00 20070a08 20070a08     ... ... ... ... 
20070a18:	20070a10 20070a10 20070a18 20070a18     ... ... ... ... 
20070a28:	20070a20 20070a20 20070a28 20070a28      ..  .. (.. (.. 
20070a38:	20070a30 20070a30 20070a38 20070a38     0.. 0.. 8.. 8.. 
20070a48:	20070a40 20070a40 20070a48 20070a48     @.. @.. H.. H.. 
20070a58:	20070a50 20070a50 20070a58 20070a58     P.. P.. X.. X.. 
20070a68:	20070a60 20070a60 20070a68 20070a68     `.. `.. h.. h.. 
20070a78:	20070a70 20070a70 20070a78 20070a78     p.. p.. x.. x.. 
20070a88:	20070a80 20070a80 20070a88 20070a88     ... ... ... ... 
20070a98:	20070a90 20070a90 20070a98 20070a98     ... ... ... ... 
20070aa8:	20070aa0 20070aa0 20070aa8 20070aa8     ... ... ... ... 
20070ab8:	20070ab0 20070ab0 20070ab8 20070ab8     ... ... ... ... 
20070ac8:	20070ac0 20070ac0 20070ac8 20070ac8     ... ... ... ... 
20070ad8:	20070ad0 20070ad0 20070ad8 20070ad8     ... ... ... ... 
20070ae8:	20070ae0 20070ae0 20070ae8 20070ae8     ... ... ... ... 
20070af8:	20070af0 20070af0 20070af8 20070af8     ... ... ... ... 
20070b08:	20070b00 20070b00 20070b08 20070b08     ... ... ... ... 
20070b18:	20070b10 20070b10 20070b18 20070b18     ... ... ... ... 
20070b28:	20070b20 20070b20 20070b28 20070b28      ..  .. (.. (.. 
20070b38:	20070b30 20070b30 20070b38 20070b38     0.. 0.. 8.. 8.. 
20070b48:	20070b40 20070b40 20070b48 20070b48     @.. @.. H.. H.. 
20070b58:	20070b50 20070b50 20070b58 20070b58     P.. P.. X.. X.. 
20070b68:	20070b60 20070b60 20070b68 20070b68     `.. `.. h.. h.. 
20070b78:	20070b70 20070b70 20070b78 20070b78     p.. p.. x.. x.. 
20070b88:	20070b80 20070b80 20070b88 20070b88     ... ... ... ... 
20070b98:	20070b90 20070b90 20070b98 20070b98     ... ... ... ... 
20070ba8:	20070ba0 20070ba0 20070ba8 20070ba8     ... ... ... ... 
20070bb8:	20070bb0 20070bb0 20070bb8 20070bb8     ... ... ... ... 
20070bc8:	20070bc0 20070bc0 20070bc8 20070bc8     ... ... ... ... 
20070bd8:	20070bd0 20070bd0 20070bd8 20070bd8     ... ... ... ... 
20070be8:	20070be0 20070be0 20070be8 20070be8     ... ... ... ... 
20070bf8:	20070bf0 20070bf0 20070bf8 20070bf8     ... ... ... ... 
20070c08:	20070c00 20070c00 20070c08 20070c08     ... ... ... ... 
20070c18:	20070c10 20070c10 20070c18 20070c18     ... ... ... ... 
20070c28:	20070c20 20070c20 20070c28 20070c28      ..  .. (.. (.. 
20070c38:	20070c30 20070c30 20070c38 20070c38     0.. 0.. 8.. 8.. 
20070c48:	20070c40 20070c40 20070c48 20070c48     @.. @.. H.. H.. 
20070c58:	20070c50 20070c50 20070c58 20070c58     P.. P.. X.. X.. 
20070c68:	20070c60 20070c60 20070c68 20070c68     `.. `.. h.. h.. 
20070c78:	20070c70 20070c70 20070c78 20070c78     p.. p.. x.. x.. 
20070c88:	20070c80 20070c80 20070c88 20070c88     ... ... ... ... 
20070c98:	20070c90 20070c90 20070c98 20070c98     ... ... ... ... 
20070ca8:	20070ca0 20070ca0 20070ca8 20070ca8     ... ... ... ... 
20070cb8:	20070cb0 20070cb0 20070cb8 20070cb8     ... ... ... ... 
20070cc8:	20070cc0 20070cc0 20070cc8 20070cc8     ... ... ... ... 

20070cd8 <__malloc_trim_threshold>:
20070cd8:	00020000                                ....

20070cdc <__malloc_sbrk_base>:
20070cdc:	ffffffff                                ....
